<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mydcwfy&#39;s Blog</title>
  
  
  <link href="https://mydcwfy.github.io/atom.xml" rel="self"/>
  
  <link href="https://mydcwfy.github.io/"/>
  <updated>2022-09-13T09:23:18.827Z</updated>
  <id>https://mydcwfy.github.io/</id>
  
  <author>
    <name>mydcwfy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Luogu P8541 「Wdoi-2」死亡之后愈发愉悦</title>
    <link href="https://mydcwfy.github.io/2022/09/13/Luogu-P8541/"/>
    <id>https://mydcwfy.github.io/2022/09/13/Luogu-P8541/</id>
    <published>2022-09-13T09:01:35.000Z</published>
    <updated>2022-09-13T09:23:18.827Z</updated>
    
    <content type="html"><![CDATA[<p>题意：交互题。定义 $f(x)$ 为严格大于 $x$ 的最小完全平方数，$g(x)$ 为小于等于 $x$ 的最大完全平方数。你需要猜一个 $\in[1, 10 ^ {12}]$ 中的一个数 $a$，用少于 64 次的询问得到答案，单次你给出 $t(t\in [0, 10 ^ 9])$，会返回 $a + t$ 是否满足 $x - g(x) &lt; f(x) - x$。$T(T\leq 2\times 10 ^ 3)$ 组数据，2s。</p><span id="more"></span><p>首先发现 $[i ^ 2, (i + 1) ^ 2)$ 中恰好有 $i + 1$ 个满足条件的数，$i$ 个不满足条件的数，分界线为 $i(i + 1)$（该数满足）。</p><p>然后考虑找到第一个不和 $a$ 性质相同的位置。如何找到呢？注意到我们其实并不知道上界，但是我们有一个关键的性质：如果 $a$ 和 $a + t$ 在同一段，那么 $a + 2t$ 和 $a$ 中间最多只有一个分界线。具体证明可以考虑段长不降的性质。于是我们可以靠这个进行倍增，找到最小的 $b$ 使得 $a + 2 ^ b$ 和 $a + 2 ^ {b + 1}$ 性质不同。这中间显然只有一个分界线，于是我们直接在这个区间进行二分即可。</p><p>如果我们找到这个分界线的位置，显然就可以求出 $a$ 了。根据上面的结论，我们可以类似地找到下一个分界线的位置即可，这样就可以询问 $4\log \sqrt a$ 次得到答案，需要 $\approx 80$ 次，还差一点。</p><p>注意到我们已经得到了最小的 $b$，也就是说这一段的长度肯定 $&gt; 2 ^ b$，我们没必要又从 1 开始倍增，直接从 $2 ^ b$ 即可。当然也可以使用上一段的长度倍增来寻找这一段的长度，参考代码是这种写法。容易发现这两个都只需要询问 $3\log \sqrt a$ 次，恰好通过。</p><p>实现的时候比较繁琐，可以用 <code>5, 7, 16, 30</code> 等几个数据调试，似乎能卡掉大部分 corner case。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mp.<span class="built_in">count</span>(x)) <span class="keyword">return</span> mp[x];</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; x &lt;&lt; std::endl, std::cin &gt;&gt; t;</span><br><span class="line"><span class="built_in">assert</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= (<span class="type">int</span>) <span class="number">1e9</span>);</span><br><span class="line"><span class="keyword">if</span> (!~t) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> mp[x] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mp.<span class="built_in">clear</span>();</span><br><span class="line"><span class="type">bool</span> st = <span class="built_in">query</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> mid, l, r, j1, j2, bit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">query</span>(<span class="number">1</span>) ^ st) j1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">query</span>(<span class="number">1</span> &lt;&lt; bit) == st) bit ++;</span><br><span class="line">l = <span class="number">1</span> &lt;&lt; (bit - <span class="number">1</span>), r = (<span class="number">1</span> &lt;&lt; bit) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">query</span>(mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ^ st) r = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid;</span><br><span class="line">&#125;</span><br><span class="line">j1 = l;</span><br><span class="line">&#125;</span><br><span class="line">j1 ++;</span><br><span class="line">bit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">query</span>((j1 &lt;&lt; bit) + j1) ^ st) bit ++;</span><br><span class="line">l = (bit == <span class="number">0</span> ? <span class="number">0</span> : (j1 &lt;&lt; (bit - <span class="number">1</span>))) + j1, r = (j1 &lt;&lt; bit) + j1 - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">query</span>(mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ^ st) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">j2 = l - j1 + <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;! &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (!st) -- j2, std::cout &lt;&lt; (LL) j2 * j2 - j1 &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">else</span> std::cout &lt;&lt; j2 * (j2 + <span class="number">1LL</span>) - j1 + <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：交互题。定义 $f(x)$ 为严格大于 $x$ 的最小完全平方数，$g(x)$ 为小于等于 $x$ 的最大完全平方数。你需要猜一个 $\in[1, 10 ^ {12}]$ 中的一个数 $a$，用少于 64 次的询问得到答案，单次你给出 $t(t\in [0, 10 ^ 9])$，会返回 $a + t$ 是否满足 $x - g(x) &amp;lt; f(x) - x$。$T(T\leq 2\times 10 ^ 3)$ 组数据，2s。&lt;/p&gt;</summary>
    
    
    
    
    <category term="倍增" scheme="https://mydcwfy.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
    <category term="二分" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>ARC148E ≥K</title>
    <link href="https://mydcwfy.github.io/2022/09/13/ARC148E/"/>
    <id>https://mydcwfy.github.io/2022/09/13/ARC148E/</id>
    <published>2022-09-13T08:09:57.000Z</published>
    <updated>2022-09-13T08:58:52.753Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一个长度为 $n$ 的序列，问有多少个重排序列的方案使得相邻两个数的和都 $\geq k$。$n\leq 2\times 10 ^ 5$，$a_i, k\leq 10 ^ 9$。</p><span id="more"></span><p>神仙构造 + 组合数学，只能复述题解了。</p><p>首先考虑如何生成这样的一个合法序列。考虑对序列排序，给定两个指针 $l, r$，使得 $[l, r]$ 里面的数都没有填入新的序列 $B$，其他的已经填入了。</p><p>我们分两种情况：如果 $A_l + A_r &lt; k$，就将 $A_l$ 插入 $B$，否则 $A_r$ 插入 $B$。两边的指针相应移动。</p><p>首先容易发现的结论是 $A_l &lt; \dfrac k2, A_r\geq \dfrac k2$。</p><p>假设 $A_l + A_r &lt; k$ 即插入 $l$ 的话，我们需要考虑哪些位置可以插入。假设满足 $\max\{B_{i}, B_{i + 1}\} + A_l\geq k$ 的位置有 $s$ 个。</p><blockquote><p>结论 1：满足 $\max\{B_i, B_{i + 1}\} + A_r\geq k$ 的数也恰好有 $s$ 个。</p><p>证明：假设 $A_l = \dfrac k2 - d(d &gt; 0)$，那么 $A_r \geq \dfrac k2 + d$（注意我们现在需要插入 $r$，一定满足 $A_l + A_r\geq k$），如果 $B_i$ 和 $B_{i + 1}$ 中间存在一个数 $&lt; \dfrac k2 - d$，那么不可能满足 $B_i + A_l \geq k$，同时也不满足 $B_i + A_r\geq k$（注意 $B_i$ 不可能等于 $A_l$，因为在插入第一个 $A_l$ 之前一定会先插入 $A_r$）。满足 $B_i + A_l\geq k$ 的一定满足 $B_i + A_r\geq k$，这个显然。</p></blockquote><p>那么我们就证明到了不管是 $A_l$ 还是 $A_r$ 插入，都恰好有 $s$ 个可插入的位置。</p><blockquote><p>结论 2：插入 $A_l$ 后会导致可插入位置 -1，插入 $A_r$ 后会导致可插入位置 +1。</p><p>首先证明除了插入位置外，其他位置的可插入性是不改变的。容易发现 $l$ 增加的话，一定是 $A_l + A_r &lt; k$ 了，那么原来合法的一定还合法，由于不合法的时候一定存在一个 $B_i$ 使得 $B_i \leq A_l$，因为 $A_l + A_r &lt; k$，所以不会再合法了。而如果 $r$ 减少的话，一定是满足 $A_l + A_r\geq k$，原来合法的一定还合法，原来不合法的一定满足 $B_i + A_r &lt; k$，所以也永远不合法。</p><p>现在考虑插入位置附近。容易发现 $A_l$ 插入后两边不能再插入，因为 $A_l + A_r &lt; k$ 了。而 $A_r$ 插入后两边都可以再插入，因为 $A_l + A_r \geq k$。</p></blockquote><p>有了上面的结论，我们很容易写出第一部分代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = n, c = <span class="number">1</span>; i &lt;= j;)</span><br><span class="line"><span class="keyword">if</span> (a[i] + a[j] &lt; lim) res = (LL) res * c -- % Mod, i ++;</span><br><span class="line"><span class="keyword">else</span> res = (LL) res * c ++ % Mod, j --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来考虑和原问题的对应关系。</p><p>注意到我们现在相当于求的是整个 $B$ 的生成过程有多少种。我们暂且把它称为三角阵。现在我们需要知道的就是一个三角阵会对应多少个 $B$。</p><p>我们考虑从一个合法的序列 $B$ 删除来得到三角阵。容易发现我们只需要找到距离 $\dfrac k2$ 最近的值删除一个即可（如果存在两个值距离相同，显然选大的）。注意到这和三角阵的生成过程恰好是逆序的。</p><p>注意到一个合法的 $B$ 每次删除值的时候值都是一定的，主要在于删除哪一个值。显然单次会删除 $cnt$ 个中的一个，然后 <code>cnt --</code>。</p><p>那么我们就是需要将刚刚得到的答案除以所有数字出现次数的逆元即可。时间复杂度 $O(n\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; lim;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = n, c = <span class="number">1</span>; i &lt;= j;)</span><br><span class="line"><span class="keyword">if</span> (a[i] + a[j] &lt; lim) res = (LL) res * c -- % Mod, i ++;</span><br><span class="line"><span class="keyword">else</span> res = (LL) res * c ++ % Mod, j --;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, ls = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (a[i] != a[i - <span class="number">1</span>]) res = (LL) res * infact[i - ls] % Mod, ls = i;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一个长度为 $n$ 的序列，问有多少个重排序列的方案使得相邻两个数的和都 $\geq k$。$n\leq 2\times 10 ^ 5$，$a_i, k\leq 10 ^ 9$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="结论" scheme="https://mydcwfy.github.io/tags/%E7%BB%93%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>ARC Round#148</title>
    <link href="https://mydcwfy.github.io/2022/09/13/ARC-Round-148/"/>
    <id>https://mydcwfy.github.io/2022/09/13/ARC-Round-148/</id>
    <published>2022-09-13T06:11:26.000Z</published>
    <updated>2022-09-13T08:09:26.920Z</updated>
    
    <content type="html"><![CDATA[<p>靠着 D 猜到结论好不容易上分了，第三次上黄（</p><p>赛后改题：All Accepted。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定 $n$ 个数，要你选择一个模数 $M$，问每个数 $\bmod M$ 过后不同的数最少都多少个，$M$ 不能选择 1。</p><p>容易发现当 $M = 2$ 的时候答案不超过 2。这是一个关键入口。</p><p>判断答案能不能为 1 是好判断的，差分数组的 $\gcd$ 不为 1 的话就存在。</p><p>否则答案一定为 2。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定一个长度为 $n$ 的只包含 <code>dp</code> 的字符串，你可以选择一个区间 $[l, r]$ 将该子串翻转。翻转的定义是 <code>d</code> 变 <code>p</code>，<code>p</code> 变 <code>d</code>，然后 <code>std::reverse</code>。问翻转后字典序最小是哪个串。$n\leq 5000$。</p><p>容易发现我们的翻转起始点就是第一个 <code>p</code> 的位置，我们将他变为 <code>d</code>，这样肯定比不变化该位置更优。另外我们把起始点设在该 <code>p</code> 前面的话，那么翻转区间的最后一定是一堆 <code>p</code>，否则不优。如果是一堆 <code>p</code> 的话，两端相当于没有交换，其实还是从 <code>p</code> 开始的。</p><p>这样可能的串就只有 $O(n)$ 个了，找到最小的即可，时间复杂度 $O(n ^ 2)$。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定一棵 $n$ 个点的无边权有根树，根为 1，每个点有一个正反面的硬币，翻转一个硬币会导致子树内的硬币都会翻转，代价为 1。$q$ 次询问，每次给定一个大小为 $m$ 的点集，求将集合内的硬币都翻转而不改变其他点状态的最小代价。$n, q, \sum m\leq 2\times 10 ^ 5$。</p><p>据说数据很水，最坏 $O(nq)$ 的直接过了（</p><p>容易发现一个点最多只会产生 1 的代价（注意这个点可能不在给定点集里）。</p><p>假设先不考虑上面的结论，我们直接翻转，假设集合只有 1 个点的话，我们需要对他本身和他的所有儿子都翻转一次，答案为 $1 + son(x)$。而多个点相较于 1 个点的差别在于如果一个集合内的点的父亲也在集合内的话，那么这个点原来应该翻转 2 次，现在不再需要翻转了，就可以减 2。</p><p>于是题目转化成了一个给定点集求父子关系对数。枚举儿子查父亲即可。时间复杂度 $O(n + \sum m)$ 或 $O(n + \sum m\log m)$。</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定 $2n$ 个数，Alice 和 Bob 分别任取其中的一个数，如果最后 Alice 取的数的和和 Bob 的和在 $\bmod m$ 意义下相同的话，Bob 胜，否则 Alice 胜。问最优情况下谁会胜利。$n\leq 2\times 10 ^ 5$。</p><p>先不考虑模意义，如果是和相同怎么做。容易发现每个数出现的次数必须是偶数，这样 Bob 才能获胜，否则 Alice 获胜。考虑证明，由于 Alice 取的时候，至少有两个数没有配对，Alice 取走一个过后，剩下的就和 Bob 取配对游戏，最后 Bob 一定会取到另外一个没有配对的数。这样两人的和并不同，Alice 胜。</p><p>现在我们需要考虑增加了模意义有什么变化。如果每个数出现次数是偶数的话，仍然还是 Bob 胜，但剩下的情况不太对劲。我们先给出一个 Hack：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 6</span><br><span class="line">1 4 2 5</span><br></pre></td></tr></table></figure><p>手玩一下，容易发现这个时候一定会是 Bob 胜利。</p><p>为什么呢？因为在 $\bmod m$ 意义下，$m$ 如果是偶数的话，并且 $\geq \dfrac m2$ 的数是偶数个的话，两个人最后拿到 $\geq \dfrac m2$ 的个数的奇偶性一定是相同的，而这就代表着只考虑 $\dfrac M2$ 的话两个人 $\bmod m$ 是相同的。这样我们就不能 $\bmod m$ 意义下了，而应该在$\bmod \dfrac m2$ 意义下做上面的结论了。</p><p>剩下的没有其他的情况需要特判了，简单的证一下。</p><ol><li>$m$ 是奇数：容易发现这时 Alice 最后一次选择的时候一定剩 2 个不同的数，选择一个数后会产生一个差值 $d$，而反过来选择差值就是 $m - d$。$d$ 和 $m - d$ 不相同，那么不可能两个数都是满足加上后变成 0 的，于是此时 Alice 胜。</li><li>$\geq \dfrac m2$ 有奇数个：让所有 $\geq \dfrac m2$ 的数都减去 $\dfrac m2$，我们只需要让 Alice 和 Bob 在 $\bmod m$ 意义下差值 $&lt; \dfrac m2$ 即可。这显然是容易办到的，而两个人选择的 $\geq \dfrac m2$ 的数的奇偶性不同，所以 Alice 一定胜利。</li></ol><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>咕咕咕。</p><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：提交答案题。给定一个计算器，有 26 个 <code>unsigned long long</code> 的存储功能，标号为 <code>A</code> 到  <code>Z</code>。满足的功能有 $a + b\to c$，$a\times b\to c$，$a\bmod 998244353\to c$。注意这里面的 $a, b$ 可以为给定常数。现在有两个数分别存储在 <code>A</code> 和 <code>B</code>，要求给定命令使得最后 <code>C</code> 存储的是 $a\times b\bmod 10 ^ 9 + 7$。</p><p>复述题解。</p><p>这个是完全不懂了，先给出一个 AT 的官方链接 <a href="https://en.wikipedia.org/wiki/Montgomery_modular_multiplication">Montgomery multiplication (Wikipedia)</a>。</p><p>令 $P_1 = 998244353, P_2 = 10 ^ 9 + 7$。</p><p>直接使用这个算法，我们相当于是可以在 $\bmod 2 ^ {64}$ 和 $\bmod P_1$ 下做乘法运算，现在需要求 $\bmod P_2$ 下的乘法。</p><p>直接给出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ULL = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P1 = <span class="number">998244353</span>, P2 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> _MP = P1 - <span class="built_in">qpow</span>(P2, P1 - <span class="number">2</span>, P1), M2 = (ULL) P1 * P1 % P2;</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">reduce</span><span class="params">(ULL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ULL ret = (x + (x % P1 * _MP % P1) * N) / P1;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= P2) x -= P2;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">mul</span><span class="params">(ULL a, ULL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = <span class="built_in">reduce</span>(a * M2), b = <span class="built_in">reduce</span>(b * M2);</span><br><span class="line">ULL c = a * b;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reduce</span>(<span class="built_in">reduce</span>(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_MP</code> 记为 $P_m$，满足 $P_mP_2\equiv -1\pmod {P_1}$，<code>M2</code> 满足 $M_2 = P_1 ^ 2\bmod P_2$。</p><p>原理不清楚，目前所知就是 <code>reduce(x)</code> 会返回 $xP_1 ^ {-1}\bmod P_2$，反正是这样了呢。现在考虑如何使用这段代码。</p><p>难点主要有两个：一是如何实现 $x / P_1$，二是如何实现 <code>if</code> 语句。</p><h4 id="实现-x-P-1"><a href="#实现-x-P-1" class="headerlink" title="实现 $x / P_1$"></a>实现 $x / P_1$</h4><p>假设我们把 <code>x + (x % P1 * _MP % P1) * P2</code> 在 $\bmod P_1$ 意义下，我们容易发现这个 $\bmod P_1$ 余 0 的。那么相当于就是直接除，而直接除可以使用乘 $P_1$ 在 $2 ^ {64}$ 的逆元完成。</p><h4 id="实现-if-语句"><a href="#实现-if-语句" class="headerlink" title="实现 if 语句"></a>实现 <code>if</code> 语句</h4><p>这个是难实现的，但是我们发现（？）执行该语句的次数很少，而且肯定不超过 $2N$。这样的话可以证明不超过 2 次执行 <code>reduce</code> 就可以代替该 <code>if</code> 语句了。</p><p>于是整个的就可以写作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">reduce</span>(a * M2), b = <span class="built_in">reduce</span>(b * M2);</span><br><span class="line">c = <span class="built_in">reduce</span>(<span class="built_in">reduce</span>(c));</span><br><span class="line">c *= M2, c = <span class="built_in">reduce</span>(<span class="built_in">reduce</span>(c));</span><br></pre></td></tr></table></figure><p>改成给的语言即可。代码附调试功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ULL = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> s128 = <span class="type">__int128_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Mod1 = <span class="number">998244353</span>, Mod2 = <span class="number">1e9</span> + <span class="number">7</span>, _MP = <span class="number">4915446</span>, M2 = <span class="number">320946142</span>;</span><br><span class="line"><span class="type">const</span> ULL Mul = <span class="number">996491785301655553ULL</span>;</span><br><span class="line">ULL a[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExGcd</span><span class="params">(s128 a, s128 b, s128 &amp;x, s128 &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, <span class="built_in">void</span>();</span><br><span class="line"><span class="built_in">ExGcd</span>(b, a % b, y, x), y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reduce</span><span class="params">(<span class="type">char</span> t)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*ULL ret = (t + (t % Mod1 * _MP % Mod1) * Mod2) / Mod1;</span></span><br><span class="line"><span class="comment">// if (ret &gt;= Mod2) ret -= Mod2;</span></span><br><span class="line"><span class="comment">t = ret;*/</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;rem Z &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[<span class="number">25</span>] = a[t - <span class="string">&#x27;A&#x27;</span>] % Mod1;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mul Z Z &quot;</span> &lt;&lt; _MP &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[<span class="number">25</span>] = a[<span class="number">25</span>] * _MP % Mod1;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;rem Z Z\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mul Z Z &quot;</span> &lt;&lt; Mod2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[<span class="number">25</span>] = a[<span class="number">25</span>] * Mod2;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;add Z Z &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[<span class="number">25</span>] += a[t - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mul &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot; Z &quot;</span> &lt;&lt; Mul &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[t - <span class="string">&#x27;A&#x27;</span>] = a[<span class="number">25</span>] * Mul;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; a[<span class="number">0</span>] &gt;&gt; a[<span class="number">1</span>];</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;40\nmul A A &quot;</span> &lt;&lt; M2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; <span class="string">&quot;mul B B &quot;</span> &lt;&lt; M2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[<span class="number">0</span>] *= M2, a[<span class="number">1</span>] *= M2;</span><br><span class="line"><span class="built_in">reduce</span>(<span class="string">&#x27;A&#x27;</span>), <span class="built_in">reduce</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mul C A B\n&quot;</span>;</span><br><span class="line">a[<span class="number">2</span>] = a[<span class="number">0</span>] * a[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">reduce</span>(<span class="string">&#x27;C&#x27;</span>), <span class="built_in">reduce</span>(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mul C C &quot;</span> &lt;&lt; M2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[<span class="number">2</span>] *= M2;</span><br><span class="line"><span class="built_in">reduce</span>(<span class="string">&#x27;C&#x27;</span>), <span class="built_in">reduce</span>(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">std::cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;靠着 D 猜到结论好不容易上分了，第三次上黄（&lt;/p&gt;
&lt;p&gt;赛后改题：All Accepted。&lt;/p&gt;</summary>
    
    
    
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>LOJ3276 「JOISC 2020 Day2」遗迹</title>
    <link href="https://mydcwfy.github.io/2022/09/13/LOJ3276/"/>
    <id>https://mydcwfy.github.io/2022/09/13/LOJ3276/</id>
    <published>2022-09-13T03:06:32.000Z</published>
    <updated>2022-09-13T04:29:22.787Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一个长度为 $2n$ 的序列，其中 $[1, n]$ 各出现 2 次，对序列一直操作直到不再变化：从前向后操作每一个数，如果这个数不为 0 并且在其后面存在一个和其相等的数，则将这个数减 1。可以证明最后存在 $n$ 个数不为 0。先给出这 $n$ 个位置，求有多少个序列满足操作后剩这些位置。$n\leq 600$。</p><span id="more"></span><p>这个的性质并不是很优美，我们考虑直接暴力 DP。</p><p>把这个序列 reverse 一下。</p><p>记 $f(i, j)$ 表示处理了前 $i$ 个，且前面 $[1, j]$ 在操作后已经存在的方案数（暗示 $j + 1$ 操作后不会存在）。注意到我们无法对 $[j + 2, n]$ 的出现情况压进状态，所以我们考虑如果出现了 $[j + 2, n]$ 的数，我们先视而不见，后面需要用到的时候再将其加入，因为他还用不到。</p><p>考虑转移，如果这一位最后剩的 0，那么这个数开始必须是 $[1, j]$。考虑计算 $[1, j]$ 中有多少个。注意一个问题是我们现在不好区分这个是第一还是第二，那么我们考虑<strong>对于所有相同的数假设不相同，最后再除以阶乘</strong>。假设前面有 $c$ 个位置最后不剩 0（包含 $i$），那么所有 $2j$ 个数已经被占领了 $i - 1 - c$，剩下的就都可以选择。</p><p>如果最后剩的 1，那么考虑两个情况：</p><ol><li>这个数最后剩的不是 $j + 1$。按照前面的理论，我们先不计算他的贡献。</li><li>最后剩的是 $j + 1$。假设现在变成了 $[1, j + k]$，那么 $[j + 2, j + k]$ 的所有数都需要在前面完成，并且 $i$ 位置最后必须剩 $j + 1$。注意到我们需要从剩下的 $c - j - 1$ 个数中选取 $k - 1$ 个数，并且让他最后覆盖 $[j + 2, j + k]$。容易发现这个式子只与 $k - 1$ 有关，假设为 $add_{k - 1, k - 1}$。剩下的 $i$ 位置，只能填 $[j + 1, k]$ 的数，我们可以从剩下的 $2k - (k - 1) = k + 1$ 个数中选择。于是可以得到转移方程为：</li></ol><p>$$<br>dp_{i - 1, j}\times \binom{c - j - 1}{k - 1} add_{k - 1, k - 1}(k + 1) \to dp_{i, j + k}<br>$$</p><p>最后一个问题就是如何计算 $add_{k, k}$。首先发现这个等价于计算 $k$ 个数，任意满足 $\in [i, k]$ 的数都 $\geq k - i + 1$，也就是满足 $[1, i]$ 的数都 $\leq i$。注意到一个数只能选择两次，考虑直接 DP。$add_{i, j}(j\leq i)$ 表示选择了 $[1, i]$ 的数，并且选了 $j$ 个的序列数。枚举 $i$ 是选择了 0、1、2 个容易得到转移方程：<br>$$<br>add_{i, j} = add_{i - 1, j} + 2j\times add_{i - 1, j - 1} + j(j - 1)\times add_{i - 1, j - 2}<br>$$<br>该部分复杂度 $O(n ^ 2)$。</p><p>主 DP 复杂度 $O(n ^ 3)$，总复杂度即为 $O(n ^ 3)$。注意我们开始把任意两个相同的数当作不同了，于是需要除以 $2 ^ n$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> x, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), key[<span class="number">2</span> * n - x + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">add[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = add[i][<span class="number">0</span>] = <span class="number">1</span>; j &lt;= i; ++ j) &#123;</span><br><span class="line">add[i][j] = (add[i - <span class="number">1</span>][j] + add[i - <span class="number">1</span>][j - <span class="number">1</span>] * <span class="number">2LL</span> * j) % Mod;</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">1</span>) add[i][j] = (add[i][j] + add[i - <span class="number">1</span>][j - <span class="number">2</span>] * (j - <span class="number">1LL</span>) * j) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (key[i]) &#123;</span><br><span class="line">++ cnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; ++ j) <span class="keyword">if</span> (f[i - <span class="number">1</span>][j])</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> nxt = <span class="number">1</span>; nxt + j &lt;= cnt; ++ nxt)</span><br><span class="line">f[i][j + nxt] = (f[i][j + nxt] + (LL) f[i - <span class="number">1</span>][j] * C[cnt - j - <span class="number">1</span>][nxt - <span class="number">1</span>] % Mod</span><br><span class="line">* add[nxt - <span class="number">1</span>][nxt - <span class="number">1</span>] % Mod * (nxt + <span class="number">1</span>)) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; ++ j)</span><br><span class="line"><span class="built_in">adj</span>(f[i][j] += f[i - <span class="number">1</span>][j] - Mod);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= cnt; ++ j)</span><br><span class="line">f[i][j] = (LL) f[i - <span class="number">1</span>][j] * (j - (i - <span class="number">1</span> - cnt)) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; (LL) f[<span class="number">2</span> * n][n] * <span class="built_in">qpow</span>(<span class="number">2</span>, Mod - <span class="number">1</span> - n) % Mod &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一个长度为 $2n$ 的序列，其中 $[1, n]$ 各出现 2 次，对序列一直操作直到不再变化：从前向后操作每一个数，如果这个数不为 0 并且在其后面存在一个和其相等的数，则将这个数减 1。可以证明最后存在 $n$ 个数不为 0。先给出这 $n$ 个位置，求有多少个序列满足操作后剩这些位置。$n\leq 600$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>UOJ710 【北大集训2021】魔塔 OL</title>
    <link href="https://mydcwfy.github.io/2022/08/30/UOJ710/"/>
    <id>https://mydcwfy.github.io/2022/08/30/UOJ710/</id>
    <published>2022-08-30T12:45:09.000Z</published>
    <updated>2022-08-30T13:16:18.568Z</updated>
    
    <content type="html"><![CDATA[<p>按序给出 $m$ 次操作或询问：</p><ol><li>新增元素 $(x, y, z)$，新给一个编号，获得他需要消耗 $a$ 点血量，获得他后可以获得 $b$ 点血量。</li><li>编号为 $k$ 的元素被删除了。保证不会重复利用或重复删除编号。</li><li>给定三元组 $(x, y, z)$，问要获得所有严格小于等于 $(x, y, z)$ 的元素需要开始时有多少血量才不会出现血量 $&lt; 0$ 的情况。</li></ol><p>元素和询问次数都不超过 $50000$，$x, y, z\leq 10000$，$a, b\leq 10 ^ 9$，2s。</p><span id="more"></span><p>首先我们需要考虑的问题是如果已经给出了所有严格小于等于的元素，如何排布使得开始的血量最少。</p><p>直接对这些元素排序，考虑微调来判断谁在前面，因为微调不会影响其他元素。假设当前 $(a_1, b_1)$ 和 $(a_2, b_2)$ 需要比较，那么假设 $a_1$ 在前，最少血量就是 $\max(a_1, a_1 + a_2 - b_1)$，$a_2$ 在前也是一样。比较这两个就可以了。</p><p>注意到这个判断先后顺序的是满足 <code>std::sort</code> 的要求（严格弱序）。我们可以观察到如果 $a_1 &lt; b_1$ 和 $a_2 &lt; b_2$ 不相同的话，是可以严格排序的（显然 $a &lt; b$ 的在前面）。而如果都是 $a &lt; b$ 的话，那么就是比较 $a_1$ 和 $a_2$。如果都是 $a \geq b$ 的话，就是比 $a_1 + a_2 - b_1$ 和 $a_1 + a_2 - b_2$ 也就是 $b_1$ 和 $b_2$。容易发现都是严格弱序的。</p><p>这样我们就解决了第一个问题，如何找到最小的方案。那么现在我们将所有元素按照该排序方式排序，离线询问，现在需要解决的问题就是如何找到所有满足严格小于等于的存在的元素。注意到存在其实也是时间轴上的偏序，于是就是解决偏序问题。</p><p>高维偏序问题，显然的 <code>std::bitset</code> 解法，复杂度 $O(\dfrac {n ^ 2}w)$ 也很对，但是注意到我们还是需要把每个元素取出来然后选择他，这样复杂度可能退化。考虑分块，我们每 $B$ 个一块，然后对一块所有可能的选择情况都预处理出来。然后再对于所有询问，这样就可以直接使用了。</p><p>假设 $n, m$ 同阶，复杂度显然是 $O(\dfrac {n2 ^ B}B + \dfrac{n ^ 2}B)$，取 $B = O(\log n)$ 即可得到复杂度为 $O(\dfrac{n ^ 2}{\log n})$。复杂度虽然比较奇怪，但事实是这算法能过。</p><p><strong>所有偏序需要一个一个加入统计答案的可以使用分块做到 $O(\dfrac{n ^ 2}{\log n})$。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> high(x) (31 - __builtin_clz(x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">LL nd, sum;</span><br><span class="line">Node <span class="keyword">operator</span> +(Node t) <span class="type">const</span> &#123;</span><br><span class="line">LL ret = std::<span class="built_in">max</span>(nd, nd - sum + t.nd);</span><br><span class="line"><span class="keyword">return</span> &#123;ret, ret + t.sum + sum - nd - t.nd&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Monster</span> &#123;</span><br><span class="line"><span class="type">int</span> st, ed, x, y, z;</span><br><span class="line">Node add;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(Monster t) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">min</span>(-add.nd, -add.nd + add.sum - t.add.nd)</span><br><span class="line">&gt; std::<span class="built_in">min</span>(-t.add.nd, -t.add.nd + t.add.sum - add.nd);</span><br><span class="line">&#125;</span><br><span class="line">&#125; mon[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y, z, at;</span><br><span class="line">Node res;</span><br><span class="line">&#125; q[N];</span><br><span class="line"><span class="type">int</span> m, n, Q, havx[S], havy[S], havz[S];</span><br><span class="line">Node ans[<span class="number">1</span> &lt;&lt; B | <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; len); ++ i)</span><br><span class="line">ans[i] = ans[i ^ (<span class="number">1</span> &lt;&lt; <span class="built_in">high</span>(i))] + mon[<span class="built_in">high</span>(i) + l].add;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; ++ i) havx[i] = havy[i] = havz[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l, id; i &lt;= r; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">havx[mon[i].x] |= <span class="number">1</span> &lt;&lt; (id = i - l);</span><br><span class="line">havy[mon[i].y] |= <span class="number">1</span> &lt;&lt; id, havz[mon[i].z] |= <span class="number">1</span> &lt;&lt; id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; S; ++ i)</span><br><span class="line">havx[i] |= havx[i - <span class="number">1</span>], havy[i] |= havy[i - <span class="number">1</span>], havz[i] |= havz[i - <span class="number">1</span>];</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">id1</span><span class="params">(r - l + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++ i) id1[i - l] = i;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">id2</span><span class="params">(id1)</span></span>;</span><br><span class="line">std::<span class="built_in">sort</span>(id1.<span class="built_in">begin</span>(), id1.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> mon[x].st &lt; mon[y].st; &#125;);</span><br><span class="line">std::<span class="built_in">sort</span>(id2.<span class="built_in">begin</span>(), id2.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> mon[x].ed &lt; mon[y].ed; &#125;);</span><br><span class="line"><span class="keyword">auto</span> iter1 = id1.<span class="built_in">begin</span>(), iter2 = id2.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, hav = <span class="number">0</span>; i &lt;= Q; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (iter1 != id1.<span class="built_in">end</span>() &amp;&amp; mon[*iter1].st &lt;= q[i].at) hav ^= <span class="number">1</span> &lt;&lt; (*(iter1 ++) - l);</span><br><span class="line"><span class="keyword">while</span> (iter2 != id2.<span class="built_in">end</span>() &amp;&amp; mon[*iter2].ed &lt;= q[i].at) hav ^= <span class="number">1</span> &lt;&lt; (*(iter2 ++) - l);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; (hav &amp; havx[q[i].x] &amp; havy[q[i].y] &amp; havz[q[i].z]) &lt;&lt; &#x27; &#x27; &lt;&lt; hav &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">q[i].res = q[i].res + ans[hav &amp; havx[q[i].x] &amp; havy[q[i].y] &amp; havz[q[i].z]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; m;</span><br><span class="line"><span class="type">char</span> op[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, id, t = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line"><span class="keyword">if</span> (*op == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">++ n, <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %lld %lld&quot;</span>, &amp;mon[n].x, &amp;mon[n].y, &amp;mon[n].z, &amp;mon[n].add.nd, &amp;mon[n].add.sum), mon[n].st = ++ t;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*op == <span class="string">&#x27;-&#x27;</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;id), mon[id].ed = ++ t;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*op == <span class="string">&#x27;?&#x27;</span>) ++ Q, <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;q[Q].x, &amp;q[Q].y, &amp;q[Q].z), q[Q].at = t;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!mon[i].ed) mon[i].ed = m + <span class="number">1</span>;</span><br><span class="line">std::<span class="built_in">sort</span>(mon + <span class="number">1</span>, mon + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) <span class="built_in">solve</span>(l, r = std::<span class="built_in">min</span>(n, l + B - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, q[i].res.nd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;按序给出 $m$ 次操作或询问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新增元素 $(x, y, z)$，新给一个编号，获得他需要消耗 $a$ 点血量，获得他后可以获得 $b$ 点血量。&lt;/li&gt;
&lt;li&gt;编号为 $k$ 的元素被删除了。保证不会重复利用或重复删除编号。&lt;/li&gt;
&lt;li&gt;给定三元组 $(x, y, z)$，问要获得所有严格小于等于 $(x, y, z)$ 的元素需要开始时有多少血量才不会出现血量 $&amp;lt; 0$ 的情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;元素和询问次数都不超过 $50000$，$x, y, z\leq 10000$，$a, b\leq 10 ^ 9$，2s。&lt;/p&gt;</summary>
    
    
    
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="分块" scheme="https://mydcwfy.github.io/tags/%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P5605 小A与两位神仙</title>
    <link href="https://mydcwfy.github.io/2022/08/29/Luogu-P5605/"/>
    <id>https://mydcwfy.github.io/2022/08/29/Luogu-P5605/</id>
    <published>2022-08-29T13:15:00.000Z</published>
    <updated>2022-08-30T12:42:17.058Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定模数 $m$ 和 $T$ 次询问，每次询问给定 $x, y$，问是否 $z$ 满足存在 $x ^ z\equiv y\pmod m$。$m\leq 10 ^ {18}, T\leq 2\times 10 ^ 4$，保证 $m$ 是奇质数的次幂，$\gcd(x, m) = \gcd(y, m) = 1$，3s。</p><span id="more"></span><p>首先考虑如何判断。仍然使用原根，令 $x = g ^ a$，$y = g ^ b$，那么就是问是否存在 $z$ 满足 $az\equiv b\pmod {\varphi(m)}$。那么显然合法的条件是 $b\bmod \gcd(a, \varphi(m)) = 0$。这样你就可以在单次 $O(\sqrt m)$ 的时间（？）求出，容易发现显然寄了。</p><p>注意到我们其实并不需要知道 $a, b$，我们其实只需要知道 $\gcd(a, \varphi(m))$ 和 $\gcd(b, \varphi(m))$ 即可。这个和什么有关呢？注意到 $x ^ {\frac m{\gcd(a, \varphi(m))}}$ 一定是 1，而且是最小的循环节。这样就是阶啊！显然我们需要使得 $\gcd(b, \varphi(m)) \bmod \gcd(a, \varphi(m)) = 0$，那么就是 $\dfrac m{\gcd(a, \varphi(m))} \bmod \dfrac m{\gcd(b, \varphi(m))} = 0$，也就是 $y$ 的阶整除 $x$ 的阶即可，记作 $\text{ord}(y) | \text{ord}(x)$。</p><p>现在问题转化为求阶了。一个显然的办法是枚举所有因数，看是否满足条件。这之前需要我们算出 $\varphi(m)$ 和他的分解。这个都需要使用 Pollard-Rho 算法，单次求解还是问题不大。然后枚举所有因数，复杂度为 $O(T\omega(n)\log n)$（检验需要快速幂），无法通过。</p><p>注意到一个数满足 $x ^ a\equiv 1\pmod m$，那么 $a$ 的所有倍数都满足。我们就可以每次试除每一个质因数即可，时间复杂度 $O(T\log ^ 2 n)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;LL&gt; <span class="title">Pollard_Rho</span><span class="params">(LL n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL m, T, p, ti = <span class="number">0</span>, tmp, x, y;</span><br><span class="line">std::cin &gt;&gt; m &gt;&gt; T;</span><br><span class="line">p = <span class="built_in">Pollard_Rho</span>(m).<span class="built_in">front</span>();</span><br><span class="line">tmp = m;</span><br><span class="line"><span class="keyword">while</span> (tmp % p == <span class="number">0</span>) tmp /= p, ti ++;</span><br><span class="line"><span class="keyword">if</span> (ti) pr.<span class="built_in">push_back</span>(&#123;p, ti - <span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">auto</span> vec = <span class="built_in">Pollard_Rho</span>(p - <span class="number">1</span>);</span><br><span class="line">tmp = p - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (LL &amp;x : vec)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (tmp % x == <span class="number">0</span>) t ++, tmp /= x;</span><br><span class="line">pr.<span class="built_in">push_back</span>(&#123;x, t&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> getord = [&amp;](LL x) &#123;</span><br><span class="line">LL ans = m / p * (p - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [p, cnt] : pr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (t &lt; cnt &amp;&amp; <span class="built_in">qpow</span>(x, ans / p, m) == <span class="number">1</span>) ++ t, ans /= p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">while</span> (T --) <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;x, &amp;y), <span class="built_in">puts</span>(<span class="built_in">getord</span>(x) % <span class="built_in">getord</span>(y) ? <span class="string">&quot;No&quot;</span> : <span class="string">&quot;Yes&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定模数 $m$ 和 $T$ 次询问，每次询问给定 $x, y$，问是否 $z$ 满足存在 $x ^ z\equiv y\pmod m$。$m\leq 10 ^ {18}, T\leq 2\times 10 ^ 4$，保证 $m$ 是奇质数的次幂，$\gcd(x, m) = \gcd(y, m) = 1$，3s。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="结论" scheme="https://mydcwfy.github.io/tags/%E7%BB%93%E8%AE%BA/"/>
    
    <category term="离散对数" scheme="https://mydcwfy.github.io/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF103102H AND = OR</title>
    <link href="https://mydcwfy.github.io/2022/08/29/CF103102H/"/>
    <id>https://mydcwfy.github.io/2022/08/29/CF103102H/</id>
    <published>2022-08-29T12:41:05.000Z</published>
    <updated>2022-08-29T13:08:10.640Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一个长度为 $n$ 的序列，$q$ 次给出 $l, r$，问 $[l, r]$ 区间能否拆成两个集合使得第一个集合的 OR 是第二个集合的 AND。$n, q\leq 10 ^ 5$，$0\leq a_i &lt; 2 ^ {30}$，3s，1GB。</p><span id="more"></span><p>首先考虑一个结论：</p><blockquote><p>如果合法，假设两个集合 OR/AND 的值 $mid$ 满足 $|mid| = x$，则一定存在一种方案，使得 $|v| &lt; x$ 的所有 $v$（$|v|$ 表示 $v$ 中 1 的个数）都放在 OR 里面，$|v| &gt; x$ 的所有 $v$ 都放在 AND 里面。</p><p>证明：容易发现如果 $|v| &gt; x$ 的放在 OR 里面，那么 OR 的结果一定 满足 $|v| &gt; x$，就不可能合法。$|v| &lt; x$ 放在 AND 同理。</p></blockquote><p>那么对于每次询问，考虑枚举 $x$，那么按照该方式，所有 $|v|&lt; x$ 的都放在 OR 里面。求出这些所有的 OR 可以把每个数按照 $|v|$ 放入对应的线段树，然后查一下前缀即可。AND 同理。</p><p>最后注意一下细节即可。一个可能的合法方案是枚举 $x$，$|v| &lt; x$ 的 OR 和 $|v| \geq x$ 的 AND 相同。另外一种方案是 $|v|\leq x$ 的 OR 和 $|v|\geq x$ 的 AND 相同，并且 $|v| = x$ 的个数不少于两个。容易发现如果满足前面的条件，所有满足 $|v| = x$ 的 $v$ 都相同。于是上面这个是对的。</p><p>用线段树维护一下即可。时间复杂度 $O(n\log ^ 2n + q\log ^ 2 n)$，空间复杂度 $O(n\log n)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> le[<span class="number">31</span>], ri[<span class="number">31</span>], prehav[<span class="number">31</span>], sufhav[<span class="number">31</span>], hav[<span class="number">31</span>];</span><br><span class="line">le[<span class="number">0</span>] = orseg[<span class="number">0</span>].<span class="built_in">query</span>(l, r), prehav[<span class="number">0</span>] = havseg[<span class="number">0</span>].<span class="built_in">query</span>(l, r);</span><br><span class="line">ri[<span class="number">30</span>] = andseg[<span class="number">30</span>].<span class="built_in">query</span>(l, r), sufhav[<span class="number">30</span>] = havseg[<span class="number">30</span>].<span class="built_in">query</span>(l, r);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++ i)</span><br><span class="line">le[i] = le[i - <span class="number">1</span>] | orseg[i].<span class="built_in">query</span>(l, r), prehav[i] = prehav[i - <span class="number">1</span>] | (hav[i] = havseg[i].<span class="built_in">query</span>(l, r));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">29</span>; ~i; -- i)</span><br><span class="line">ri[i] = ri[i + <span class="number">1</span>] &amp; andseg[i].<span class="built_in">query</span>(l, r), sufhav[i] = sufhav[i + <span class="number">1</span>] | hav[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &amp;&amp; prehav[i - <span class="number">1</span>] &amp;&amp; sufhav[i] &amp;&amp; le[i - <span class="number">1</span>] == ri[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">auto</span> iter = std::<span class="built_in">lower_bound</span>(app[i].<span class="built_in">begin</span>(), app[i].<span class="built_in">end</span>(), l);</span><br><span class="line"><span class="keyword">if</span> (iter == app[i].<span class="built_in">end</span>() || *iter &gt; r || nxt[i][iter - app[i].<span class="built_in">begin</span>()] &lt;= r) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> ccnt = std::<span class="built_in">upper_bound</span>(app[i].<span class="built_in">begin</span>(), app[i].<span class="built_in">end</span>(), r) - iter;</span><br><span class="line"><span class="keyword">if</span> (le[i] == ri[i] &amp;&amp; ccnt &gt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cerr &lt;&lt; std::<span class="built_in">abs</span>(&amp;mem1 - &amp;mem2) / <span class="number">1048576.</span> &lt;&lt; <span class="string">&quot; MB\n&quot;</span>;</span><br><span class="line"><span class="type">int</span> q, l = <span class="number">2</span>, r = n - <span class="number">1</span>;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) app[__builtin_popcount(a[i])].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++ i) &#123;</span><br><span class="line">nxt[i].<span class="built_in">resize</span>(app[i].<span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">if</span> (!app[i].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">nxt[i].<span class="built_in">back</span>() = n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = app[i].<span class="built_in">size</span>() - <span class="number">2</span>; ~j; -- j)</span><br><span class="line"><span class="keyword">if</span> (a[app[i][j]] != a[app[i][j + <span class="number">1</span>]]) nxt[i][j] = app[i][j + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> nxt[i][j] = nxt[i][j + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++ i) orseg[i].<span class="built_in">build</span>(n), andseg[i].<span class="built_in">build</span>(n), havseg[i].<span class="built_in">build</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;x : app[i]) orseg[i].<span class="built_in">modify</span>(x, a[x]), andseg[i].<span class="built_in">modify</span>(x, a[x]), havseg[i].<span class="built_in">modify</span>(x, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line"><span class="built_in">puts</span>(<span class="built_in">query</span>(l, r) ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一个长度为 $n$ 的序列，$q$ 次给出 $l, r$，问 $[l, r]$ 区间能否拆成两个集合使得第一个集合的 OR 是第二个集合的 AND。$n, q\leq 10 ^ 5$，$0\leq a_i &amp;lt; 2 ^ {30}$，3s，1GB。&lt;/p&gt;</summary>
    
    
    
    
    <category term="结论" scheme="https://mydcwfy.github.io/tags/%E7%BB%93%E8%AE%BA/"/>
    
    <category term="线段树" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2219 数论之神</title>
    <link href="https://mydcwfy.github.io/2022/08/29/BZOJ2219/"/>
    <id>https://mydcwfy.github.io/2022/08/29/BZOJ2219/</id>
    <published>2022-08-29T11:27:18.000Z</published>
    <updated>2022-08-29T12:36:54.645Z</updated>
    
    <content type="html"><![CDATA[<p>题意：求 $x ^ a \equiv b\pmod p$ 的解数，$a, b, p$ 给定。$a, b, p\leq 10 ^ 9 + 1$，$p$ 是奇数，$T(T\leq 1000)$ 组数据。</p><span id="more"></span><p>容易发现单纯的 $p$ 不好做，于是显然根据中国剩余定理拆成 $p ^ k(p\in P)$ 做，然后直接把各部分的答案乘起来即可。</p><p>下面直接讨论 $x ^ a\equiv b\pmod {p ^ k}$ 的解数。</p><h4 id="Case-1：-b-0"><a href="#Case-1：-b-0" class="headerlink" title="Case 1：$b = 0$"></a>Case 1：$b = 0$</h4><p>容易发现只要 $x$ 在 $p$ 的次幂至少是 $\left\lceil\dfrac ka \right\rceil$ 即可。于是此时的贡献就是 $p ^ {k - \lceil\frac ka\rceil}$。</p><h4 id="Case-2：-b-bmod-p-0-land-b-not-0"><a href="#Case-2：-b-bmod-p-0-land-b-not-0" class="headerlink" title="Case 2：$b\bmod p = 0\land b\not= 0$"></a>Case 2：$b\bmod p = 0\land b\not= 0$</h4><p>此时假设 $b = c \times p ^ t$，那么此时 $x$ 在 $p$ 的次幂一定是 $\dfrac ta$（注意一定整除，否则无解），然后可以对两边同时除以 $p ^ t$，那么方程就变为了 $x ^ a\equiv c\pmod {p ^ {k - t}}$。注意到 $\bmod p ^ {k - t}$ 映射到 $\bmod p ^ k$ 时，由于需要乘上 $p ^ {\frac ta}$，所以剩下的 $k - (k - t) - \dfrac ta = t - \dfrac ta$ 次幂是完全定义域扩大的，所以需要乘上 $p ^ {t - \frac ta}$。剩下的是第三种情况，就可以解决这个问题了。</p><h4 id="Case-3：-b-bmod-p-not-0"><a href="#Case-3：-b-bmod-p-not-0" class="headerlink" title="Case 3：$b\bmod p \not= 0$"></a>Case 3：$b\bmod p \not= 0$</h4><p>这个可以使用离散对数（知道奇数的作用了吗？），假设 $b = g ^ t$，那么就是 $x ^ a \equiv g ^ t \pmod {p ^ k}$，容易发现如果 $t\bmod \gcd(\varphi(p ^ k), a)\not= 0$，说明不可能凑出 $t$，这样的话就返回 0。</p><p>然后考虑有解的情况有多少个。假设 $x = g ^ y$，那么就是 $ay\equiv t\pmod {\varphi(p ^ k)}$。容易发现此时当找到一个解时，$+\dfrac{\text{lcm}(\varphi(p ^ k), a)}{a}$ 也是一个解，而且是最小周期。除一下，一共就有 $\gcd(\varphi(p ^ k), a)$ 个解。</p><p>把所有的乘起来即可。时间复杂度 $O(\sqrt p\log p)$ 或 $O(\sqrt p)$，瓶颈在求离散对数的 BSGS 上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BSGS</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> Mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">1</span> || Mod == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; H;</span><br><span class="line"><span class="type">int</span> cur = b, K = std::<span class="built_in">sqrt</span>(Mod) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; K; ++ i, cur = (LL) cur * a % Mod) H[cur] = i;</span><br><span class="line"><span class="type">int</span> ak = cur = <span class="built_in">qpow</span>(a, K, Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= K; ++ i, cur = (LL) cur * ak % Mod)</span><br><span class="line"><span class="keyword">if</span> (H.<span class="built_in">count</span>(cur)) <span class="keyword">return</span> i * K - H[cur];</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findrt</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> pk = <span class="built_in">qpow</span>(p, k);</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; fac;</span><br><span class="line"><span class="type">int</span> n = pk - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; ++ i)</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">fac.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n ^ <span class="number">1</span>) fac.<span class="built_in">push_back</span>(n);</span><br><span class="line"><span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> g) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : fac)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">qpow</span>(g, pk / p * (p - <span class="number">1</span>) / x, pk) == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; pk; ++ i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(i)) <span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> pk = <span class="built_in">qpow</span>(p, k);</span><br><span class="line">b %= pk;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; a &lt;&lt; &#x27; &#x27; &lt;&lt; b &lt;&lt; &#x27; &#x27; &lt;&lt; p &lt;&lt; &#x27; &#x27; &lt;&lt; k &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">qpow</span>(p, k - (k + a - <span class="number">1</span>) / a);</span><br><span class="line"><span class="keyword">if</span> (b % p == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b % p == <span class="number">0</span>) b /= p, ++ t;</span><br><span class="line"><span class="keyword">if</span> (t % a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">solve</span>(a, b, p, k - t) * <span class="built_in">qpow</span>(p, t - t / a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> g = <span class="built_in">findrt</span>(p, k), _b = <span class="built_in">BSGS</span>(g, b, pk);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; pk &lt;&lt; &#x27; &#x27; &lt;&lt; g &lt;&lt; &#x27; &#x27; &lt;&lt; b &lt;&lt; &#x27; &#x27; &lt;&lt; _b &lt;&lt; &#x27; &#x27; &lt;&lt; Gcd(a, pk / p * (p - 1)) &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">if</span> (_b % <span class="built_in">Gcd</span>(a, pk / p * (p - <span class="number">1</span>))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Gcd</span>(a, pk / p * (p - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a, b, p, res = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;p), p = <span class="number">2</span> * p + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= p / i; ++ i)</span><br><span class="line"><span class="keyword">if</span> (p % i == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p % i == <span class="number">0</span>) ++ t, p /= i;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;Solve &quot; &lt;&lt; a &lt;&lt; &#x27; &#x27; &lt;&lt; b &lt;&lt; &#x27; &#x27; &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; t &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">res *= <span class="built_in">solve</span>(a, b, i, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p ^ <span class="number">1</span>) res *= <span class="built_in">solve</span>(a, b, p, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：求 $x ^ a \equiv b\pmod p$ 的解数，$a, b, p$ 给定。$a, b, p\leq 10 ^ 9 + 1$，$p$ 是奇数，$T(T\leq 1000)$ 组数据。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="离散对数" scheme="https://mydcwfy.github.io/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>TopCoder12004 SetAndSet</title>
    <link href="https://mydcwfy.github.io/2022/08/29/TopCoder12004/"/>
    <id>https://mydcwfy.github.io/2022/08/29/TopCoder12004/</id>
    <published>2022-08-29T10:58:53.000Z</published>
    <updated>2022-08-29T11:16:44.402Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定 $n$ 个数，要求把他们分成红蓝两组，要求都不为空，使得红组的 AND 和蓝组的 AND 相同，求划分方案。$n\leq 50, a &lt; 2 ^ {20}$。</p><span id="more"></span><p>容易发现不管怎么 DP 都是至少 $O(a ^ 2n)$ 的，不可接受。</p><p>考虑朴素容斥，假设某一位不相同，那么所有该位为 1 的数都应该在同一组，容斥这一位不相同，那么将所有该位为 1 的数同并查集合并，然后最后看有几组，答案就是 $2 ^ {cnt} - 2$。</p><p>注意如果一个位置一个该位为 1 的数都没有，那么不能对该位进行容斥。用个 dfs 搜一搜即可。复杂度 $O(na)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SetAndSet</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; f;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; all[<span class="number">20</span>];</span><br><span class="line">LL res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">find</span>(f[x]); &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(u) == <span class="built_in">find</span>(v)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> f[<span class="built_in">find</span>(v)] = <span class="built_in">find</span>(u), <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> bit, <span class="type">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bit == <span class="number">20</span>) &#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) cnt += f[i] == i;</span><br><span class="line">res += op * ((<span class="number">1LL</span> &lt;&lt; cnt) - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(bit + <span class="number">1</span>, op);</span><br><span class="line"><span class="keyword">if</span> (all[bit].<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> bac = f;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="type">int</span>) all[bit].<span class="built_in">size</span>(); ++ i)</span><br><span class="line"><span class="built_in">merge</span>(all[bit][i], all[bit][<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">dfs</span>(bit + <span class="number">1</span>, -op);</span><br><span class="line">f = bac;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">LL <span class="title">countandset</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n = a.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">f.<span class="built_in">resize</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) f[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> bit = <span class="number">0</span>; bit &lt; <span class="number">20</span>; ++ bit)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!(a[i] &gt;&gt; bit &amp; <span class="number">1</span>)) all[bit].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">1</span>), res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定 $n$ 个数，要求把他们分成红蓝两组，要求都不为空，使得红组的 AND 和蓝组的 AND 相同，求划分方案。$n\leq 50, a &amp;lt; 2 ^ {20}$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>NOI2022 游记</title>
    <link href="https://mydcwfy.github.io/2022/08/28/NOI-2022/"/>
    <id>https://mydcwfy.github.io/2022/08/28/NOI-2022/</id>
    <published>2022-08-28T10:31:58.000Z</published>
    <updated>2022-08-29T13:01:13.219Z</updated>
    
    <content type="html"><![CDATA[<p>挂 18pts 送走 Au，rk65 Ag。</p><span id="more"></span><p>现在来写，感觉很多有意义的细节已经忘记的差不多了，只能记得一个大概的框架了，所以游记总是看起来干巴巴的。由于我又没有赛时写游记的习惯，看来以后得先记录一点有意义的事情了。</p><p>以 8.23 为 Day 1。</p><h3 id="Day-10（8-12）"><a href="#Day-10（8-12）" class="headerlink" title="Day -10（8.12）"></a>Day -10（8.12）</h3><p>突然听说要提前 7 天到苏州，吓了一跳，赶忙飞去上海然后高铁到昆山。没住在 CCF 建议的酒店，说找一个安静点的地方。熟悉了一下环境，结果碰上了成外的（</p><p>和 CSYZ 一起训练，他们明天才来，所以模拟赛没来，于是可以光明正大的颓，结果被教练评价为“效率怎么这么低下啊”。</p><p>条件还行，手机电脑被收后，晚上看点奇怪的电视剧，不知不觉就睡着了。</p><h3 id="Day-9（8-13）-Day-3（8-19）"><a href="#Day-9（8-13）-Day-3（8-19）" class="headerlink" title="Day -9（8.13）- Day -3（8.19）"></a>Day -9（8.13）- Day -3（8.19）</h3><p>CSYZ 的来了，模拟赛也来了（悲</p><p>天天在酒店里颓，但是还是被强制做模拟赛。结果几场模拟赛一次排名比一次低，是不是 NOI 就要垫底了 /ll</p><p>地方特别偏，想找一点能吃的菜简直不太可能，就连外卖的 5km 以内都没有几家，一周显然就都吃遍了，然后就没得吃了（</p><p>8.14 晚上 AGC 直接自闭，啥题不会，最后在 170 min 的时候终于过了 A /kk，不过排名没变化，还是掉大分。第二天发现自己的 B 和正解一模一样，不知道为什么赛时没过样例呢？当时又把 B 的代码删了，更不知道哪里错了，于是又重码了一遍赛时写的，就过了 /fn</p><p>8.16 晚上 CF Div1，A 一直猜贪心，WA 了两发才发现哪里没对，结果是一个 sb DP，做了半个小时。B 没想到有一个唯一分解（其实推式子的过程中证明到了，但是没写）用了一个奇奇怪怪的东西，写了半个小时多，WA 了两发，终于过了。C 一个一眼题，直接维护所有因数的答案即可，突然感觉过不去，把因数换为质因数就好了，又写了半个小时，罚时一车，不过还是上分了。</p><h3 id="Day-2（8-20）"><a href="#Day-2（8-20）" class="headerlink" title="Day -2（8.20）"></a>Day -2（8.20）</h3><p>进校力！（不过教练因为没报名字上去，进不了 /kk，比较离谱）</p><p>发现是一个 nb 学校，感觉非常宽敞，所有建筑都是西式风格的，在我们那地很少见。被分到了一个两人间的宿舍，居然没有上下铺，一人一弹簧床、一个书桌，独立洗手间、洗漱台，感觉是星级酒店而不是一个学校的宿舍欸。不过听说到这里的学费，实在是震惊到了，但是这学费也值啊，天天住宾馆，实在是条件不错 /se</p><p>由于不认识几个人，跟着多头去逛了一圈，在签名墙上写下了自己的 id（诶话说这么大个签名墙，写个 id 真有人能看到吗），然后就溜回寝室颓了。</p><p>午饭也是全自助，挺好吃的 /se</p><p>一直颓颓颓，无事可干捏。由于我们教练进不来 /ll，只好像探监一样把我们叫过去，问一下近期的情况，自然是应付一下，不过确实也不知道自己状态到底如何，只好开摆。</p><p>晚上颓。</p><h3 id="Day-1（8-21）"><a href="#Day-1（8-21）" class="headerlink" title="Day -1（8.21）"></a>Day -1（8.21）</h3><p>早上去领胸牌，结果要去 4 个地方按顺序排队，第二个位置特别慢，导致那个位置的人特别多，其他位置几乎人都没有，让我清楚的认识到了水桶效应（一开始差点由于人多直接排第二个位置了）。我不清楚为啥不在那里多安排几个人呢？看到几个志愿者议论了半天，结果也没人去帮忙。另外为什么不集中到一个地方直接同意统一领呢？表示问号。不过反正排队也是颓，也没太在意。</p><p>拿到徽章后和多头换了一个，又去领了背包，感觉良好。遇到了 CSYZ 的几个，换了徽章，然后回寝室了。</p><p>据说 ZJ 和 CQ 都在 D4，晚上和 RuSun 去面了 dX 和 feecle6418，结果都只有 1 个徽章了 /kk，不过我们两个还是都给他们了（）</p><p>晚上斗地主 / 看别人斗地主。</p><h3 id="Day-0（8-22）"><a href="#Day-0（8-22）" class="headerlink" title="Day 0（8.22）"></a>Day 0（8.22）</h3><p>下午要笔试了，早上只好开始复习，不过看不进去，因为这个笔试有 whk 的感觉。过了几遍感觉差不多就行了，然后开始颓。</p><p>下午笔试，先发了一个去年 NOIp 的题目，就写了一下练练手，结果发现 T3 还是不会，T4 还是只会暴力。如果叫我现在去考去年的 NOIp，能不能考到我当时的分数还是问题呢 /kk。随便写了 T1 和 T2，幸运的是没怎么调试就对了，本想开始写 T3 的退火，结果发现 14:58 了，遂弃。</p><p>笔试竟然是内网提交答案，和我想象的方式（写成程序提交）不太像，不过这样就不会题号错误，还是不错。结果第五个就不太确定（记不到题目是什么了），中间要好一些，然后 46 47 连着两个全选，47 能不能登陆系统把我给不会了，但是转念一想，不是不能碰键盘吗？不碰键盘怎么登陆？差点就变成 bot  了，哈哈。</p><p>据说以前考完就出成绩了，不过今年的系统考完后 15:31 就关了。那多久出成绩呢？表示问号。</p><p>本想接着写 NOIp T3 的，但是发现旁边的人走了一大半，于是果断弃掉跑路。</p><h3 id="Day-1（8-23）"><a href="#Day-1（8-23）" class="headerlink" title="Day 1（8.23）"></a>Day 1（8.23）</h3><p>早上本身没改原来 7：00 的闹钟，但是同宿舍 CDQZ 的 6：40 就起来了，于是我也起来了（</p><p>先吃饭，后洗漱，虽然有些奇怪，但是教练要求的，不管了。差不多 7：40 进去的，结果只带了一个士力架，感觉亏大了 /ll。不过还发了一些吃的，于是进场了。</p><p>8：00 准时开题，看到 T1 是一个 sb 摩尔投票，因为当时做 CF 好像做到一个，所以记忆比较深刻。感觉 T1 简单，一会来写，又看 T2。T2 的题目很简洁，但是感觉性质很不优美，开始看成了操作一是每次恰好减少两个，发现完全不可做。过了一会发现是至少减少两个，然后发现还是不可做（，于是去看 T3。T3 “这是一道交互题”和 6 页的题面，已经难懂的定义让人想起了 lxl 欸，不过好像是 zx 出的（。看了一圈，大概半个小时才看懂题，发现连 $O(n ^ 2)-O(1)$ 都不会，只会一个链的猫树分治 10pts。不过 T3 一脸不可做，也没人写更多分吧（</p><p>回过头去写 T1，发现需要维护原序列以及摩尔投票的结果，开始觉得只需要线段树合并就可以了，于是写了，发现没法删除最后一个，想了半天发现可以平衡树合并维护序列（我怎么没想到启发式呢？），不需要线段树合并，差点把线段树合并删了，不过还是忍住了放在 backup。果然过了一会写完平衡树合并后才发现没法判断一个数是否真的是绝对众数，于是又想起了线段树（，然后复制过来，前前后后 1.5h 过去了，写了 200 行的代码总算过了大样例。这常数能过就离谱了，不过我当时没想到更好的办法，于是跳了。</p><p>懒得写对拍，9：45 开 T2，我不相信 3h 拿不下 T2，毕竟每年 D1 队线都是 200+。但赛后看来我的思路就是错的，因为我一直想找到一个比较优美的结论来表示。但事实是这个题需要 DP 刻画合法性。赛时想到了 DP，但是发现每个区间的操作次数复杂度上天，于是弃掉了。其实当时如果认真想还是可做的，只不过我被“有一个优美的结论”的思维禁锢住了，没有仔细思考。</p><p>这样前前后后到了 11:40，我连 $k = 0, l_i = r_i$ 都不会做，心里有点慌了，于是写了爆搜 15pts 跳 T3。T3 下发了 grader.o 和 checker.o 是我第一次见识，还是挺 nb 的。能用就是了，主要是没有 checker 源码，不知道为啥错，猫树分治都调了半个多小时，总算调出来了。想了想暴力怎么写，结果搞了很久，想了多个算法，全部假了。</p><p>回过头来看 T2，还是一点不会。遂弃掉，慢悠悠的检查了三个题能不能编译通过，于是罚坐 15min，结束了。</p><p>出来听说估分 125pts 的人很多，但是 125pts 以上的比较少，只要不挂分，应该还是可以翻盘的。不过盘是什么？我也不知道。</p><p>吃了饭睡了午觉过去查成绩，发现没挂，$100 + 15 + 10 = 125$。CSYZ 的似乎都有多多少少的挂分，惨惨。据说队线在 130-140之间，心态稳健，多头 T2 直接场切，我直接 orz。</p><p>下午和 XJ 的学生聊，他 D1 130（不过好像 D2 爆炸了，Ag 走人了，惨），他把题看成了操作区间长度 $\geq 2$，这个比原问题 $\geq 3$ 可做一些，但是他写了很久，直到最后一个小时才发现，然后就寄了。不过至少还是会并能写完 $k = 0, l_i = r_i$ 的部分。他讲了一遍 T3 的暴力，可我还是没怎么听懂（</p><p>晚上讲课大概听懂了 T2，发现是一个神秘 DP 套 DP，瞎搜一下可达的状态救就可以了，T3 神仙数据结构，暴力都好阴间 /kk。回去斗地主。</p><h3 id="Day-2（8-24）"><a href="#Day-2（8-24）" class="headerlink" title="Day 2（8.24）"></a>Day 2（8.24）</h3><p>说好的社会活动呢？</p><p>好像有一个什么猜谜游戏，不过听说比较专业，就没参加。上午无事可干，想看几道题，结果 ABC 都不会（，心态爆炸，于是不看了，开始颓。</p><p>下午开幕式，印象最深的当属 dzd 的讲话和无人机表演。无人机的背景音乐是 AW 的 <code>Hello World</code>，有点寓意阿。</p><p>晚上颓。</p><h3 id="Day-3（8-25）"><a href="#Day-3（8-25）" class="headerlink" title="Day 3（8.25）"></a>Day 3（8.25）</h3><p>其实应该是 D2（</p><p>8：00 开题，一眼觉得 T2 是 Itst 出的（赛后发现他出的是 D2T3），部分分比较良心，争取多拿点（总所周知 D2T2 不可做）。T1 树哈希，题面明摆着不会特意卡，那随便搞搞，感觉比较简单。T3 神仙题，显然不会，但不知道爆搜多少分。</p><p>T1 想了一会可以直接暴力枚举哈希值不同的如何匹配，复杂度上界是 $O(k! \times n)$，看样子可以过，于是直接开写，细节还行，差不多 9：30 过大样例，然后随便造了几组 <code>Yes</code> 的数据（似乎不好写对拍），发现是对的，于是跑路。</p><p>9：45 开 T2，先做 A 发现有一个显然的 $O(n ^ 3)$ DP，想了一想转移方程可以使用单调队列优化到 $O(n ^ 2)$（自始至终没有想过贪心 /kk），先不忙写，又开 B 性质，盲猜一下没填的是不降的，于是又可以 $O(n ^ 2)$ DP，想了一下会证明了，感觉 C 也是这么做的。大概 10：20 开始写，单调队列比较难写，主要是不断平移比较麻烦（赛后发现好像可以记录 0 的个数而不是 1 的个数就不需要平移了 /jy），写了半个多小时才过样例。B 好写一些，发现这个过不了 C，于是摆，然后又胡了个爆搜，应该 56 pts。</p><p>11：45 左右开 T3，$k = 3$ 容易贪心选 2 即可，很好做；$k = 4$ 不太会，又写了个爆搜，想尽奇奇怪怪的方法优化，但是 $n = 50$ 根本过不了，于是期望 27 pts 跑路。感觉这么多分 + D1 的 125 应该够队线了吧，就没有继续想其他部分分了（伏笔）。简单的检查了一下就结束了。</p><p>一出来就听到有人会 T2，难道 D2T2 比 D1T2 简单？表示问号。不过出来就听到 CSYZ 的教练给我们说马上回去，不是还有两天吗？一查，苏州一个无症状感染者，没必要这么紧张呗。不过还是回去把东西收好了。</p><p>下午 2：30 就看到一车人去查分，也去一看，$100 + 48 + 17 = 165$，挂了 18 pts。</p><p>先看 T2，发现是暴力挂了 8pts，反倒是 A、B 两个难写的性质都对了。想起了当时我需要在一段区间的右端点判断一段区间的最小值是否是给定的时候，我为了运行效率，把一个右端点的限制按照左端点排序，然后指针扫过去。结果排序的时候把 $n$ 写成 $m$ 了 /kk，然后暴力挂了一半。当时想过要不要这样，因为数据不好检查写对没有，结果一想应该没问题，就略过了，然后就挂了 /ll</p><p>然后看 T3，发现 $k = 3$ 的点全挂了，10pts，仔细一看，多测不清空，爆零两行泪。怎么过的 $k = 3$ 的大样例呢？小编也觉得很惊讶，但事实就是这样。</p><p>出来几乎没有讨论就出校了，路上和教练讨论了一会。一路上有各种奇奇怪怪的队线，不知道该听谁的。</p><p>似乎确实是一个不完整的 NOI 欸。</p><h3 id="Day-4（8-26）"><a href="#Day-4（8-26）" class="headerlink" title="Day 4（8.26）"></a>Day 4（8.26）</h3><p>出总分和排名了，$100 + 100 + 15 + 10 + 100 + 48 + 17 + 0 = 390$，rk65 Ag。</p><p>回收伏笔，确实当时估计的 $100 + 125 + 183 = 408$ 也可以进队的，不过挂分了。不过确实实力不够呗，这直接导致容错的区间太小了，我一旦任何一个地方挂了，都不可能进队。一旦多会 20pts，这样的话，挂一点分还是可接受的。现在确实一点不能挂，但谁能保证总计 10h 的 NOI 一分不挂呢？显然是一件难事啊。</p><p>没进队有遗憾啊，不然我写这游记的时候心情也就完全不一样了，就可能是 feecle6418 和 dottle 的心情了。不过好像还是可以参加 CTT/se</p><p>接下来的一年，除需要提升实力外，这些挂分我们需要一些总结，比如将可能挂分的方式写在代码里，过完样例后逐一检查。这些问题可能是易避免的，也有可能是难发现的。检查出样例无法检查到的错误可能也是实力的一部分吧！</p><p>来年再战！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;挂 18pts 送走 Au，rk65 Ag。&lt;/p&gt;</summary>
    
    
    
    
    <category term="游记" scheme="https://mydcwfy.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF1707E Replace</title>
    <link href="https://mydcwfy.github.io/2022/08/09/CF1707E/"/>
    <id>https://mydcwfy.github.io/2022/08/09/CF1707E/</id>
    <published>2022-08-09T11:08:48.000Z</published>
    <updated>2022-08-10T00:28:06.954Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一个序列 $a$，定义 $f(\{l, r\}) = \{\min(a_{l\dots r}), \max(a_{l\dots r}) \}$，$q$ 次给定 $l, r$，问 $\{l, r\}$ 经过多少次 $f$ 函数后会变为 $\{1, n\}$，或者报告不可能。$n, q\leq 10 ^ 5$，1.5s，1024 MB。</p><span id="more"></span><p>首先看这个多少次，也许可以想到倍增，但是当前的 $(l, r)$ 一共有 $O(n ^ 2)$ 个，无法计算。</p><p>后面的表示可能不够严谨，可以认为 $f(l, r)$ 表示上面的函数，会返回一个区间。</p><p>下面给出一个结论：</p><blockquote><p>$f(l, r) = f(l, l + 1) \cup f(l + 1, l + 2) \cup \dots \cup f(r - 1, r)$。</p><p>证明：设右边的为 $g(l, r)$。首先证明 $g(l, r)\subseteq f(l, r)$。容易发现每一个的 $f(i, i + 1)$ 都是 $\subseteq f(l, r)$ 的，所以 $g(l, r)\subseteq f(l, r)$。然后考虑证明 $f(l, r)\subseteq g(l, r)$。容易发现在最大值和最小值之间的区间，跨度是连续的，也就是每一个 $i\in [l, r]$ 都可以在这段区间中找到一个位置 $p$ 使得 $i\in f(p, p + 1)$，那么 $f(l, r)\subseteq g(l, r)$。综上，$f(l, r) = g(l, r)$。</p></blockquote><p>有了上面的结论，我们就可以发现只需要记录所有的 $f(l, l + 1)$ 即可。</p><p>然后考虑倍增，记录所有的 $f ^ {2 ^ i} (l, l + 1)$ 的答案，那么当 $f ^ {2 ^ i}$ 转向 $f ^ {2 ^ {i + 1}}$ 时，我们相当于是求 $f ^ {2 ^ i} (f ^ {2 ^ i}(\{l, l + 1\}))$。里面一层的我们已经知道了，现在要求外面一层的，那么就需要把 $f ^ {2 ^ i}(\{l, r\})$ 区间内部的所有区间都并起来，这个可以使用线段树 / ST 表实现，预处理时间复杂度 $O(n \log ^ 2n)$。</p><p>现在开始询问。考虑如何判断 $\{l, r\}$可不可以变成 $\{1, n\}$。容易发现如果超过 $O(n ^ 2)$ 个都还没有出现 $\{1, n\}$ 的话，肯定出现了循环节，但是一出现 $\{1, n\}$ 就一定一直是 $\{1, n\}$ 了（最开始是 $\{1, n\}$ 除外），既然没有出现 $\{1, n\}$，那么就不可能出现 $\{1, n\}$ 了。剩下的直接倍增查找即可，时间复杂度 $O(n \log ^ 2 n + q\log n)$（ST 表，空间复杂度 $O(n\log ^ 2n)$）或者 $O((n + q)\log ^ 2 n)$（线段树，空间复杂度 $O(n\log n)$）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">prework</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++ i)</span><br><span class="line">st[id][i][j] = st[id][i][j - <span class="number">1</span>] | st[id][i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Segment <span class="title">query</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"><span class="type">int</span> k = lg[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> st[id][l][k] | st[id][r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) pw[<span class="number">0</span>][i] = &#123;std::<span class="built_in">min</span>(a[i], a[i + <span class="number">1</span>]), std::<span class="built_in">max</span>(a[i], a[i + <span class="number">1</span>])&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; L - <span class="number">1</span>; ++ k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) st[k][i][<span class="number">0</span>] = pw[k][i];</span><br><span class="line"><span class="built_in">prework</span>(k);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">pw[k + <span class="number">1</span>][i] = <span class="built_in">query</span>(k, pw[k][i].l, pw[k][i].r - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line"><span class="keyword">while</span> (Q --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line"><span class="keyword">if</span> (l == <span class="number">1</span> &amp;&amp; r == n) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">query</span>(L - <span class="number">2</span>, l, r - <span class="number">1</span>) != <span class="built_in">Segment</span>(<span class="number">1</span>, n)) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="function">Segment <span class="title">cur</span><span class="params">(l, r)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = L - <span class="number">2</span>; ~i; -- i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">query</span>(i, cur.l, cur.r - <span class="number">1</span>) != <span class="built_in">Segment</span>(<span class="number">1</span>, n)) res |= <span class="number">1LL</span> &lt;&lt; i, cur = <span class="built_in">query</span>(i, cur.l, cur.r - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一个序列 $a$，定义 $f(\{l, r\}) = \{\min(a_{l\dots r}), \max(a_{l\dots r}) \}$，$q$ 次给定 $l, r$，问 $\{l, r\}$ 经过多少次 $f$ 函数后会变为 $\{1, n\}$，或者报告不可能。$n, q\leq 10 ^ 5$，1.5s，1024 MB。&lt;/p&gt;</summary>
    
    
    
    
    <category term="倍增" scheme="https://mydcwfy.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>CF102586L Yosupo&#39;s Algorithm</title>
    <link href="https://mydcwfy.github.io/2022/08/09/CF102586L/"/>
    <id>https://mydcwfy.github.io/2022/08/09/CF102586L/</id>
    <published>2022-08-09T00:11:27.000Z</published>
    <updated>2022-08-09T10:41:15.266Z</updated>
    
    <content type="html"><![CDATA[<p>二维平面上有 $n$ 个红点和 $n$ 个蓝点，每个点有一个权值 $vr_i/vb_i$，$q$ 次询问，每次给定 $L, R$，求满足 $[xr_i&lt;L] = [xb_j &gt; R]$ 并且 $[yr_i &lt; yb_j]$ 的 $(i, j)$ 中 $vr_i + vb_j$ 的最大值。$n\leq 10 ^ 5$，$q\leq 5\times 10 ^ 5$。</p><span id="more"></span><p>对于这种 $yr_i &lt; yb_j$ 限制比较明显的，可以考虑<strong>一维分治，一维扫描线</strong>计算二维符合情况的答案。</p><p>首先容易发现 $y$ 的用处就是比较 $yr_i$ 和 $yb_j$，于是考虑对 $y$ 分治。假设当前 $y$ 的区间是 $[l, r]$，我们强制要求 $yr_i\leq mid$，$yb_i &gt; mid$，然后向两边递归即可。容易发现如果我们可以做到线性扫所有 $yr_i$ 和 $yb_j$，那么时间复杂度就是正确的 $O(n\log n)$，那么得到的二元组也是 $O(n\log n)$ 的。</p><p>现在问题在于如何线性得到所有可能是最优解的方案。一个可以发现的贪心思想是我们一定会选择满足 $yr_i\leq mid$ 中权值最大的点和 $yb_j &gt; mid$ 中权值最大的点。容易发现如果两个都没有被选择的话，我们一定可以替换一个变成这两个点中的一个。这样我们只需要把两边最大的点选进去即可。这样备选的二元组是 $O(n\log n)$ 组。</p><p>剩下的就是一个二维数点，扫描线 + 线段树即可，时间复杂度 $O(n\log ^ 2 n + q\log n)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment_Tree</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> l, r, mx;</span><br><span class="line">&#125; tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; tr[x].mx = std::<span class="built_in">max</span>(tr[x &lt;&lt; <span class="number">1</span>].mx, tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[x] = &#123;l, r, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> pos, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">chkmax</span>(tr[x].mx, c);</span><br><span class="line"><span class="keyword">if</span> (tr[x].l ^ tr[x].r) <span class="built_in">modify</span>(pos &lt;= (tr[x].l + tr[x].r) &gt;&gt; <span class="number">1</span> ? x &lt;&lt; <span class="number">1</span> : x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, pos, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt; r || tr[x].r &lt; l) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> tr[x].mx;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">max</span>(<span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span>, l, r), <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line">&#125;</span><br><span class="line">&#125; seg;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> yl, <span class="type">int</span> yr, std::vector&lt;<span class="type">int</span>&gt; rid, std::vector&lt;<span class="type">int</span>&gt; bid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rid.<span class="built_in">empty</span>() || bid.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mxid = <span class="number">0</span>, mid = (yl + yr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;x : rid)</span><br><span class="line"><span class="keyword">if</span> (r[x].y &lt;= mid &amp;&amp; r[x].v &gt; r[mxid].v) mxid = x;</span><br><span class="line"><span class="keyword">if</span> (mxid)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;x : bid)</span><br><span class="line"><span class="keyword">if</span> (b[x].y &gt; mid) vd.<span class="built_in">push_back</span>(&#123;mxid, x&#125;);</span><br><span class="line">mxid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;x : bid)</span><br><span class="line"><span class="keyword">if</span> (b[x].y &gt; mid &amp;&amp; b[x].v &gt; b[mxid].v) mxid = x;</span><br><span class="line"><span class="keyword">if</span> (mxid)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;x : rid)</span><br><span class="line"><span class="keyword">if</span> (r[x].y &lt;= mid) vd.<span class="built_in">push_back</span>(&#123;x, mxid&#125;);</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; r1, r2, b1, b2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;x : rid)</span><br><span class="line"><span class="keyword">if</span> (r[x].y &lt;= mid) r1.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="keyword">else</span> r2.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;x : bid)</span><br><span class="line"><span class="keyword">if</span> (b[x].y &lt;= mid) b1.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="keyword">else</span> b2.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="built_in">solve</span>(yl, mid, r1, b1), <span class="built_in">solve</span>(mid + <span class="number">1</span>, yr, r2, b2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;r[i].x, &amp;r[i].y, &amp;r[i].v);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;b[i].x, &amp;b[i].y, &amp;b[i].v);</span><br><span class="line">std::cin &gt;&gt; Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;q[i].l, &amp;q[i].r), q[i].id = i, q[i].res = <span class="number">-1</span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">allid</span><span class="params">(n)</span>, <span class="title">ws</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) allid[i] = i + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">solve</span>(<span class="number">1</span>, <span class="number">1e9</span>, allid, allid);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> loc = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">lower_bound</span>(ws.<span class="built_in">begin</span>(), ws.<span class="built_in">end</span>(), x) - ws.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) ws[i] = b[i + <span class="number">1</span>].x;</span><br><span class="line">std::<span class="built_in">sort</span>(ws.<span class="built_in">begin</span>(), ws.<span class="built_in">end</span>());</span><br><span class="line">seg.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">std::<span class="built_in">sort</span>(vd.<span class="built_in">begin</span>(), vd.<span class="built_in">end</span>(), [&amp;](PII &amp;x, PII &amp;y) &#123;</span><br><span class="line"><span class="keyword">return</span> r[x.first].x &lt; r[y.first].x;</span><br><span class="line">&#125;);</span><br><span class="line">std::<span class="built_in">sort</span>(q + <span class="number">1</span>, q + Q + <span class="number">1</span>, [&amp;](Query &amp;q1, Query &amp;q2) &#123;</span><br><span class="line"><span class="keyword">return</span> q1.l &lt; q2.l;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">int</span> it = <span class="number">0</span>, ed = vd.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (it &lt; ed &amp;&amp; r[vd[it].first].x &lt;= q[i].l)</span><br><span class="line">seg.<span class="built_in">modify</span>(<span class="number">1</span>, <span class="built_in">loc</span>(b[vd[it].second].x), r[vd[it].first].v + b[vd[it].second].v), it ++;</span><br><span class="line"><span class="built_in">chkmax</span>(q[i].res, seg.<span class="built_in">query</span>(<span class="number">1</span>, <span class="built_in">loc</span>(q[i].r), n));</span><br><span class="line">&#125;</span><br><span class="line">seg.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">it = vd.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = Q; i; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (it &gt;= <span class="number">0</span> &amp;&amp; r[vd[it].first].x &gt;= q[i].l)</span><br><span class="line">seg.<span class="built_in">modify</span>(<span class="number">1</span>, <span class="built_in">loc</span>(b[vd[it].second].x), r[vd[it].first].v + b[vd[it].second].v), it --;</span><br><span class="line"><span class="built_in">chkmax</span>(q[i].res, seg.<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="built_in">loc</span>(q[i].r) - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(q + <span class="number">1</span>, q + Q + <span class="number">1</span>, [&amp;](Query &amp;q1, Query &amp;q2) &#123;</span><br><span class="line"><span class="keyword">return</span> q1.id &lt; q2.id;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q[i].res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;二维平面上有 $n$ 个红点和 $n$ 个蓝点，每个点有一个权值 $vr_i/vb_i$，$q$ 次询问，每次给定 $L, R$，求满足 $[xr_i&amp;lt;L] = [xb_j &amp;gt; R]$ 并且 $[yr_i &amp;lt; yb_j]$ 的 $(i, j)$ 中 $vr_i + vb_j$ 的最大值。$n\leq 10 ^ 5$，$q\leq 5\times 10 ^ 5$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分治" scheme="https://mydcwfy.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="线段树" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>HDU5382 GCD?LCM!</title>
    <link href="https://mydcwfy.github.io/2022/08/08/HDU5382/"/>
    <id>https://mydcwfy.github.io/2022/08/08/HDU5382/</id>
    <published>2022-08-08T13:04:45.000Z</published>
    <updated>2022-08-09T00:09:21.387Z</updated>
    
    <content type="html"><![CDATA[<p>题意：令 $f(n) = \displaystyle \sum_{i = 1} ^ n \sum_{j = 1} ^ n [\text{lcm}(i, j) + \gcd(i, j)\geq n]$，求 $f(n)$ 的前缀和。$T(T\leq 10 ^ 5)$ 组数据，$n\leq 10 ^ 5$。</p><span id="more"></span><p>看着 $\text{lcm}(i, j) + \gcd(i, j) \geq n$ 有点奇怪，可以考虑递推，从 $f(n - 1)$ 递推到 $f(n)$。</p><p>容易发现多出来的部分是 $(n, x)$ 和 $(x, n)$ 的二元组，直接合法，答案加上 $2 * n - 1$。但是注意到原来的 $[\text{lcm}(i, j) + \gcd(i, j) = n - 1]$ 的二元组变得不合法了，所以我们只需要记 $\displaystyle g(n) = \sum_{i = 1} ^ n\sum_{j = 1} ^ n [\text{lcm}(i, j) + \gcd(i, j) = n]$ 即可递推得到 $f(n) = f(n - 1) - g(n - 1) + 2n - 1$。</p><p>然后看到 $=$ 就比较好做了，直接考虑莫比乌斯反演：<br>$$<br>\begin{aligned}<br>g(n) =&amp; \sum_{i = 1} ^ n \sum_{j = 1} ^ n [\text{lcm}(i, j) + \gcd(i, j) = n]\\<br>=&amp; \sum_{i = 1} ^ n \sum_{j = 1} ^ n \sum_{d = 1} ^ n [\gcd(i, j) = d] [\dfrac{ij}d + d = n]\\<br>=&amp; \sum_{d = 1} ^ n \sum_{i = 1} ^ {\frac nd} \sum_{j = 1} ^ {\frac nd} [\gcd(i, j) = 1] [d(ij + 1) = n]\\<br>=&amp; \sum_{d | n} \sum_{i = 1} ^ {\frac nd} \sum_{j = 1} ^ {\frac nd} [\gcd(i, j) = 1] [ij = \dfrac nd - 1]<br>\end{aligned}<br>$$<br>容易发现最后的 $i, j$ 的上界是没有意义的，我们可以直接设定为无穷大。那么考虑设 $h(n) = \sum_{i = 1} \sum_{j = 1} [\gcd(i, j) = 1][ij = n]$，那么我们可以表示 $g(n)$ 了：<br>$$<br>g(n) = \sum_{d | n} h(\dfrac nd - 1)<br>$$<br>容易发现我们假设知道 $h(n)$ 了，可以在 $O(n\log n)$ 的时间内得到 $g(n)$，这样也可以递推得到 $f(n)$ 了。</p><p>如何计算所有的 $h(n)$ 呢？容易发现满足 $ij\leq n$ 的二元组只有 $O(n\log n)$ 个，直接暴力枚举判断合法性就可以得到 $h(1\dots n)$，时间复杂度 $O(n\log ^ 2 n)$。</p><p>询问直接 $O(1)$ 回答。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; i * j &lt; N; ++ j)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Gcd</span>(i, j) == <span class="number">1</span>) f[i * j] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * i &lt; N; ++ j)</span><br><span class="line"><span class="built_in">adj</span>(g[i * j] += f[i - <span class="number">1</span>] - Mod);</span><br><span class="line">f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line"><span class="built_in">adj</span>(<span class="built_in">adj</span>(f[i] = f[i - <span class="number">1</span>] - g[i - <span class="number">1</span>]) += <span class="number">2</span> * i - <span class="number">1</span> - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; ++ i) <span class="built_in">adj</span>(f[i] += f[i - <span class="number">1</span>] - Mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：令 $f(n) = \displaystyle \sum_{i = 1} ^ n \sum_{j = 1} ^ n [\text{lcm}(i, j) + \gcd(i, j)\geq n]$，求 $f(n)$ 的前缀和。$T(T\leq 10 ^ 5)$ 组数据，$n\leq 10 ^ 5$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="莫比乌斯反演" scheme="https://mydcwfy.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>UOJ715 【北大集训 2021】小明的树</title>
    <link href="https://mydcwfy.github.io/2022/08/07/UOJ715/"/>
    <id>https://mydcwfy.github.io/2022/08/07/UOJ715/</id>
    <published>2022-08-07T07:33:59.000Z</published>
    <updated>2022-08-08T11:33:22.638Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一棵 $n$ 个点的以 1 为根的树和一个删除序列，每次删除一个 $[2, n]$ 之类的点，当对于任意一个删除的点都有其所有子树的点都被删除时，答案加上删除点的连通块个数。一棵树的价值为最后删除完的答案。动态修改树，删除一条边，加上一条边，保证还是树。实时维护答案。$n, q\leq 5\times 10 ^ 5$。</p><span id="more"></span><p><strong>诈骗结论：树的连通块个数是点数减去边数</strong>。容易发现这个结论是显然的，不过在统计连通块个数的时候非常有用。</p><p>容易发现这个条件其实就是删除的点的连通块个数恰好为 1。考虑对时间轴维护连通块个数，然后对于所有未删点的连通块个数为 1 的时间点，维护删除的点的连通块个数并求和。容易发现这个在树动态的时候也很好维护，直接区间加减即可。</p><p>最后一个问题就是如何维护连通块个数为 1 的时间点的删除点的连通块个数和。容易发现连通块个数最少是 1，于是可以用线段树维护区间的最小值和最小值对应位置的权值和。注意因为要区间加权值，还需要维护区间最小值个数。</p><p>注意开 <code>long long</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment_Tree</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line"><span class="type">int</span> mn, cnt, mntag, valtag;</span><br><span class="line">LL val;</span><br><span class="line">&#125; tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> &amp;rt = tr[x], &amp;nl = tr[x &lt;&lt; <span class="number">1</span>], &amp;nr = tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (nl.mn &lt; nr.mn) rt.mn = nl.mn, rt.val = nl.val, rt.cnt = nl.cnt;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nl.mn &gt; nr.mn) rt.mn = nr.mn, rt.val = nr.val, rt.cnt = nr.cnt;</span><br><span class="line"><span class="keyword">else</span> rt.mn = nl.mn, rt.val = nl.val + nr.val, rt.cnt = nl.cnt + nr.cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[x] = &#123;l, r, <span class="number">0</span>, r - l + <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_key</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span> </span>&#123; tr[x].mn += c, tr[x].mntag += c; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_val</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span> </span>&#123; tr[x].val += (LL) c * tr[x].cnt, tr[x].valtag += c; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].mntag) <span class="built_in">update_key</span>(x &lt;&lt; <span class="number">1</span>, tr[x].mntag), <span class="built_in">update_key</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tr[x].mntag), tr[x].mntag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[x].valtag) <span class="built_in">update_val</span>(x &lt;&lt; <span class="number">1</span>, tr[x].valtag), <span class="built_in">update_val</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tr[x].valtag), tr[x].valtag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_key</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// if (x == 1) std::cout &lt;&lt; &quot;Modify Key &quot; &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; &#x27; &#x27; &lt;&lt; c &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt; r || tr[x].r &lt; l) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> <span class="built_in">update_key</span>(x, c);</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="built_in">modify_key</span>(x &lt;&lt; <span class="number">1</span>, l, r, c), <span class="built_in">modify_key</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, c);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_val</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// if (x == 1) std::cout &lt;&lt; &quot;Modify Val &quot; &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; &#x27; &#x27; &lt;&lt; c &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt; r || tr[x].r &lt; l) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> <span class="built_in">update_val</span>(x, c);</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="built_in">modify_val</span>(x &lt;&lt; <span class="number">1</span>, l, r, c), <span class="built_in">modify_val</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, c);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125; seg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">seg.<span class="built_in">modify_key</span>(<span class="number">1</span>, <span class="number">1</span>, std::<span class="built_in">min</span>(nw[x], nw[y]) - <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">seg.<span class="built_in">modify_val</span>(<span class="number">1</span>, std::<span class="built_in">max</span>(nw[x], nw[y]), n - <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">seg.<span class="built_in">modify_key</span>(<span class="number">1</span>, <span class="number">1</span>, std::<span class="built_in">min</span>(nw[x], nw[y]) - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">seg.<span class="built_in">modify_val</span>(<span class="number">1</span>, std::<span class="built_in">max</span>(nw[x], nw[y]), n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">answer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (seg.tr[<span class="number">1</span>].mn == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, seg.tr[<span class="number">1</span>].val);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一棵 $n$ 个点的以 1 为根的树和一个删除序列，每次删除一个 $[2, n]$ 之类的点，当对于任意一个删除的点都有其所有子树的点都被删除时，答案加上删除点的连通块个数。一棵树的价值为最后删除完的答案。动态修改树，删除一条边，加上一条边，保证还是树。实时维护答案。$n, q\leq 5\times 10 ^ 5$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="结论" scheme="https://mydcwfy.github.io/tags/%E7%BB%93%E8%AE%BA/"/>
    
    <category term="线段树" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="树相关" scheme="https://mydcwfy.github.io/tags/%E6%A0%91%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>UOJ559 [NOI2020]命运</title>
    <link href="https://mydcwfy.github.io/2022/08/07/UOJ559/"/>
    <id>https://mydcwfy.github.io/2022/08/07/UOJ559/</id>
    <published>2022-08-07T06:27:16.000Z</published>
    <updated>2022-08-07T07:23:59.157Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一棵 $n$ 个点的有根树和 $m$ 条直上直下的链，问有多少种给每条边赋值 0 或 1 的方案数使得 $m$ 条链至少有一个 1。$n, m\leq 5\times 10 ^ 5$，2s，1024 MB。</p><span id="more"></span><p>题意明摆着叫你容斥，那么我们就容斥呗（但是好像有简单 DP 做法？）。暴力容斥，钦定一些链必须全部为 0，然后乘上 $(-1) ^ x$ 贡献到答案。直接做是 $O(2 ^ m n)$，用 DP 优化，考虑设 $f_{i, j}$ 表示 $i$ 为根的子树内已经选好，且从 $i$ 到 $j$ 链（$j$ 是 $i$ 的祖先）已经全部被钦定为 0 了的方案数。这样就可以写出转移：<br>$$<br>\begin{aligned}<br>f_{x, \min(j, k)} \leftarrow&amp; f_{v, j} f_{x, k} \\<br>f_{x, x} \leftarrow&amp; 2f_{v, v}\\<br>f_{x, u_i} \leftarrow&amp; -f_{x, x}[x = v_i]\\<br>f_{x, x} \leftarrow&amp; 1<br>\end{aligned}<br>$$<br>$j, k$ 按照 $dep$ 比较，$u, v$ 是一条直上直下的链。这样直接做是 $O(n ^ 2)$ 的，仍然无法通过。</p><p>我们观察转移，注意到非 0 项的个数其实并不多，产生一个非零项的方法只有从 $f_{x, x}$ 和从 $-f_{x, x}\rightarrow f_{x, u_i}$ 两个部分。容易发现产生的总 0 项的个数是 $O(n + m)$ 级别的。其余都是在不同的 $x$ 之间转移，于是这个可以使用线段树合并转移，时空复杂度均为 $O((n + q)\log n)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="built_in">adj</span>(tr[x].sum = tr[tr[x].lc].sum + tr[tr[x].rc].sum - Mod); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">tr[x].sum = (LL) tr[x].sum * c % Mod;</span><br><span class="line">tr[x].lt = (LL) tr[x].lt * c % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].lt == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">update</span>(tr[x].lc, tr[x].lt), <span class="built_in">update</span>(tr[x].rc, tr[x].lt);</span><br><span class="line">tr[x].lt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> sump, <span class="type">int</span> sumq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="built_in">update</span>(q, sump), q;</span><br><span class="line"><span class="keyword">if</span> (!q) <span class="keyword">return</span> <span class="built_in">update</span>(p, sumq), p;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">tr[p].sum = ((LL) (tr[p].sum + sump) * tr[q].sum + (LL) sumq * tr[p].sum) % Mod;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(p), <span class="built_in">pushdown</span>(q);</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, rp = tr[tr[p].rc].sum, rq = tr[tr[q].rc].sum;</span><br><span class="line">tr[p].lc = <span class="built_in">merge</span>(tr[p].lc, tr[q].lc, l, mid,</span><br><span class="line"><span class="built_in">adj</span>(rp = sump + rp - Mod), <span class="built_in">adj</span>(rq = sumq + rq - Mod));</span><br><span class="line">tr[p].rc = <span class="built_in">merge</span>(tr[p].rc, tr[q].rc, mid + <span class="number">1</span>, r, sump, sumq);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pushup</span>(p), p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x || ql &gt; r || qr &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> tr[x].sum;</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(tr[x].lc, ql, qr, l, mid)</span><br><span class="line">+ <span class="built_in">query</span>(tr[x].rc, ql, qr, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pos, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x) x = ++ nodecnt;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in">void</span>(<span class="built_in">adj</span>(tr[x].sum += c - Mod));</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (pos &lt;= mid) <span class="built_in">modify</span>(tr[x].lc, l, mid, pos, c);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">modify</span>(tr[x].rc, mid + <span class="number">1</span>, r, pos, c);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rdfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::<span class="built_in">sort</span>(con[x].<span class="built_in">begin</span>(), con[x].<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">con[x].<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(con[x].<span class="built_in">begin</span>(), con[x].<span class="built_in">end</span>()), con[x].<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span> (con[x].<span class="built_in">size</span>())</span><br><span class="line"><span class="built_in">modify</span>(rt[x], <span class="number">1</span>, n, con[x][<span class="number">0</span>], Mod - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">modify</span>(rt[x], <span class="number">1</span>, n, dep[x], <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">rdfs</span>(v, x);</span><br><span class="line"><span class="type">int</span> extra = <span class="built_in">query</span>(rt[v], dep[v], dep[v], <span class="number">1</span>, n);</span><br><span class="line"><span class="built_in">modify</span>(rt[v], <span class="number">1</span>, n, dep[v], Mod - extra);</span><br><span class="line"><span class="built_in">modify</span>(rt[v], <span class="number">1</span>, n, dep[x], extra * <span class="number">2</span> % Mod);</span><br><span class="line">rt[x] = <span class="built_in">merge</span>(rt[x], rt[v], <span class="number">1</span>, n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for (int i = 1; i &lt;= dep[x]; ++ i) std::cout &lt;&lt; query(rt[x], i, i, 1, n) &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; &#x27;\n&#x27;;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">g[u].<span class="built_in">push_back</span>(v), g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pre_dfs</span>(<span class="number">1</span>);</span><br><span class="line">std::cin &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">con[v].<span class="built_in">push_back</span>(dep[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">rdfs</span>(<span class="number">1</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">query</span>(rt[<span class="number">1</span>], <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, n) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一棵 $n$ 个点的有根树和 $m$ 条直上直下的链，问有多少种给每条边赋值 0 或 1 的方案数使得 $m$ 条链至少有一个 1。$n, m\leq 5\times 10 ^ 5$，2s，1024 MB。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="线段树合并" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"/>
    
    <category term="树相关" scheme="https://mydcwfy.github.io/tags/%E6%A0%91%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>LOJ2268 [SDOI2017]苹果树</title>
    <link href="https://mydcwfy.github.io/2022/08/06/LOJ2268/"/>
    <id>https://mydcwfy.github.io/2022/08/06/LOJ2268/</id>
    <published>2022-08-05T23:54:20.000Z</published>
    <updated>2022-08-06T09:30:45.225Z</updated>
    
    <content type="html"><![CDATA[<p>题意：有一棵 $n$ 个点的有根树，每个点有 $a_i$ 个苹果，在 $i$ 处选一个苹果的价值是 $v_i$，一个节点能选苹果当且仅当他的父亲也选了至少一个。假设选的最大深度是 $d$，选了 $t$ 个苹果，要求 $t - d\leq k$，$k$ 给定。求能获得的最大价值。$T(T\leq 5)$ 组数据，$n\leq 2\times 10 ^ 4$，$ k\leq 5\times 10 ^ 5$，$nk\leq 2.5\times 10 ^ 7$，$1\leq v_i\leq 100$，5s。</p><span id="more"></span><p>容易发现题目直接给了个 $nk\leq 2.5\times 10 ^ 7$，那么显然复杂度就是 $O(nk)$，在多重背包的时候还必须使用单调队列优化。另外，不能使用任何的背包合并，因为复杂度为 $O(k ^ 2)$，唯一能合并的只是最后我们只需要一个答案，可以在 $O(k)$ 时间合并。那么我们必须找到两个背包合并得到答案。</p><p>首先容易发现一个事实：我们肯定会去选叶子节点。因为我们不选的话，让他任意选择一个儿子一定不劣。然后我们会发现一个树被我们用这一条根到叶子的链划分成了三部分：</p><ol><li>根到叶子的链</li><li>该链的左边</li><li>该链的右边</li></ol><p>这个左右暂且不好定义，我们先放在这里。容易发现我们根到叶子的链如果都只选择一个的话，这条链本身是免费的（不需要代价），如果要多选的话，我们可以考虑把这个点建一个新儿子，存放 $a_i - 1$ 个苹果。这个节点一定在链的左边或者右边（废话），那么就当作其他节点计算了。容易发现这个贡献方法是正确的。</p><p>首先我们考虑如何表示该链的左边和右边。这里巧妙的运用到了 <code>dfn</code> 序。考虑正向遍历邻接表和逆向遍历邻接表的后序遍历：</p><img src="/2022/08/06/LOJ2268/dfs1.png" class=""><img src="/2022/08/06/LOJ2268/dfs2.png" class=""><p>（注意这里没有新加的一个儿子）</p><p>假设我们考虑第一个图中 <code>dfn</code> 序为 2 的点，容易发现他的左边的点就是 <code>dfn</code> 序为 $[1, 1]$ 的区间。在第二个图中的 <code>dfn</code> 序为 4，$[1, 3]$ 区间的点就是他右边的点。</p><p>现在我们对树的左边和右边的定义就比较清晰了，我们预处理出这两个背包，然后 $O(k)$ 合并即可。</p><p>最后一个问题就是怎样求一段区间 <code>dfn</code> 序的树上背包。对于一个节点，可以强制至少选一个，否则的话需要跳过一个整的子树。这个是一个多重背包，显然 $O(nk)$ 即可。</p><p>综上，时间复杂度 $O(nk)$，可以通过，但比较卡常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">chkpack</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;f, std::vector&lt;<span class="type">int</span>&gt; &amp;g)</span> </span>&#123; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lim; ++ i) <span class="built_in">chkmax</span>(f[i], g[i]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backpack</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;f, <span class="type">int</span> w, <span class="type">int</span> v, <span class="type">bool</span> flag = <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!w) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;backPack &quot; &lt;&lt; w &lt;&lt; &#x27; &#x27; &lt;&lt; v &lt;&lt; std::endl;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> q[M];</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(lim + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">1</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lim; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt &amp;&amp; i - q[hh] &gt; w) hh ++;</span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt) &#123;</span><br><span class="line"><span class="keyword">if</span> (flag) tmp[i] = f[q[hh]] + (i - q[hh]) * v;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">chkmax</span>(tmp[i], f[q[hh]] + (i - q[hh]) * v);</span><br><span class="line"><span class="comment">// chkmax(f[i], f[q[hh]] + (i - q[hh]) * v);</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag) tmp[i] = -INF;</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt &amp;&amp; f[q[tt]] - q[tt] * v &lt; f[i] - i * v) tt --;</span><br><span class="line">q[++ tt] = i;</span><br><span class="line">&#125;</span><br><span class="line">f.<span class="built_in">swap</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> pre = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sz[x] = <span class="number">1</span>, sum[x] = (pre += val[x]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x]) <span class="built_in">dfs1</span>(v, pre), sz[x] += sz[v];</span><br><span class="line">nw1[dfn1[x] = ++ *dfn1] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x]) <span class="built_in">dfs2</span>(v);</span><br><span class="line">nw2[dfn2[x] = ++ *dfn2] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; lim;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;fa[i], &amp;a[i], &amp;val[i]);</span><br><span class="line"><span class="type">int</span> _n = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">fa[++ _n] = i, a[_n] = a[i] - <span class="number">1</span>, val[_n] = val[i], a[i] = <span class="number">1</span>;</span><br><span class="line">pren = n, n = _n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) g[i].<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) g[fa[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">*dfn1 = <span class="number">0</span>, <span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) std::<span class="built_in">reverse</span>(g[i].<span class="built_in">begin</span>(), g[i].<span class="built_in">end</span>());</span><br><span class="line">*dfn2 = <span class="number">0</span>, <span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">pre1[<span class="number">0</span>].<span class="built_in">assign</span>(lim + <span class="number">1</span>, -INF), pre2[<span class="number">0</span>].<span class="built_in">assign</span>(lim + <span class="number">1</span>, -INF);</span><br><span class="line">pre1[<span class="number">0</span>][<span class="number">0</span>] = pre2[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="built_in">backpack</span>(pre1[i] = pre1[i - <span class="number">1</span>], a[nw1[i]], val[nw1[i]], <span class="literal">true</span>), <span class="built_in">chkpack</span>(pre1[i], pre1[i - sz[nw1[i]]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="built_in">backpack</span>(pre2[i] = pre2[i - <span class="number">1</span>], a[nw2[i]], val[nw2[i]], <span class="literal">true</span>), <span class="built_in">chkpack</span>(pre2[i], pre2[i - sz[nw2[i]]]);</span><br><span class="line"><span class="comment">/*for (int i = 1; i &lt;= n; ++ i) std::cout &lt;&lt; nw1[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt;= n; ++ i, std::cout &lt;&lt; &#x27;\n&#x27;)</span></span><br><span class="line"><span class="comment">for (int j = 0; j &lt;= lim; ++ j) std::cout &lt;&lt; pre1[i][j] &lt;&lt; &#x27; &#x27;;*/</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= pren; ++ i)</span><br><span class="line"><span class="keyword">if</span> (g[i].<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= lim; ++ j) <span class="built_in">chkmax</span>(res, sum[i] + pre1[dfn1[i] - <span class="number">2</span>][j] + pre2[dfn2[i] - <span class="number">1</span>][lim - j]);</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：有一棵 $n$ 个点的有根树，每个点有 $a_i$ 个苹果，在 $i$ 处选一个苹果的价值是 $v_i$，一个节点能选苹果当且仅当他的父亲也选了至少一个。假设选的最大深度是 $d$，选了 $t$ 个苹果，要求 $t - d\leq k$，$k$ 给定。求能获得的最大价值。$T(T\leq 5)$ 组数据，$n\leq 2\times 10 ^ 4$，$ k\leq 5\times 10 ^ 5$，$nk\leq 2.5\times 10 ^ 7$，$1\leq v_i\leq 100$，5s。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="树相关" scheme="https://mydcwfy.github.io/tags/%E6%A0%91%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>LOJ2290 [THUWC2017]随机二分图</title>
    <link href="https://mydcwfy.github.io/2022/08/06/LOJ2290/"/>
    <id>https://mydcwfy.github.io/2022/08/06/LOJ2290/</id>
    <published>2022-08-05T23:35:47.000Z</published>
    <updated>2022-08-07T06:26:05.831Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定左右各 $n$ 个点的二分图和 $m$ 种边，每一种边有三种情况：</p><ol><li>这种边只有一条，有 $50\%$ 的概率出现。</li><li>这种边有两条，同时出现或者不出现，概率均为 $50\%$。</li><li>这种边有两条，分别出现，概率均为 $50\%$。</li></ol><p>求完美匹配的期望数量，对 $10 ^ 9 + 7$ 取模。$n\leq 15$。</p><span id="more"></span><p>首先考虑拆期望贡献，变为每一种完美匹配的出现概率之和。</p><p>我们直接考虑 DP，记 $f(S, T)$ 表示左边已选集合为 $S$，右边已选集合为 $T$ 的时候的期望数量。枚举不在 $S$ 中的最小元素和谁匹配即可，如果出现 2、3 类边，直接暴力转移。复杂度 $O(2 ^ {2n})$，实际由于 $S$ 的情况很少，可以通过。</p><p>这个做法看似很对，但是在处理 2 和 3 类边的时候会出现一些问题。具体的，虽然我们可能同时出现了两条边，但是在最后的完美匹配中的边可能只有一条，这样的话这种方法就不太可行。</p><p>我们容易发现如果我们只考虑两条边中的一条，他的出现概率就是 $50\%$，只不过会在两条边同时出现的时候出现一些问题。我们先不管这个条件，按照 1 类边的表针任意选择两条边，这样在不选边和选一条边都是正确的。唯一不正确的就是当两条边同时存在时，这个概率并不是 $25 \%$。2 类边是 $50\%$ 的概率，所以我们钦定强制选这两条边，并钦定同时出现的概率为 $25\%$。3 类边同理。</p><p>这样我们可以在 $O(2 ^ {2n})$ 的时间内解决该问题，用记忆化搜索可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dp</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S == tot &amp;&amp; T == tot) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (mp[S].<span class="built_in">count</span>(T)) <span class="keyword">return</span> mp[S][T];</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>, le = __builtin_ctz(S ^ tot);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ri = <span class="number">0</span>; ri &lt; n; ++ ri)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((T &gt;&gt; ri &amp; <span class="number">1</span>) || typ[le][ri] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; S &lt;&lt; &#x27; &#x27; &lt;&lt; T &lt;&lt; &#x27; &#x27; &lt;&lt; (S | (1 &lt;&lt; le)) &lt;&lt; &#x27; &#x27; &lt;&lt; (T | (1 &lt;&lt; ri)) &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">res = (res + <span class="built_in">Dp</span>(S | (<span class="number">1</span> &lt;&lt; le), T | (<span class="number">1</span> &lt;&lt; ri)) * (Mod + <span class="number">1LL</span>) / <span class="number">2</span>) % Mod;</span><br><span class="line"><span class="keyword">auto</span> [u, v] = pr[le][ri];</span><br><span class="line"><span class="keyword">if</span> (u == le || v == ri || (S &gt;&gt; u &amp; <span class="number">1</span>) || (T &gt;&gt; v &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; S &lt;&lt; &#x27; &#x27; &lt;&lt; T &lt;&lt; &#x27; &#x27; &lt;&lt; (S | (1 &lt;&lt; le) | (1 &lt;&lt; u)) &lt;&lt; &#x27; &#x27; &lt;&lt; (T | (1 &lt;&lt; ri) | (1 &lt;&lt; v)) &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">if</span> (typ[le][ri] == <span class="number">1</span>)</span><br><span class="line">res = (res + <span class="built_in">Dp</span>(S | (<span class="number">1</span> &lt;&lt; le) | (<span class="number">1</span> &lt;&lt; u), T | (<span class="number">1</span> &lt;&lt; ri) | (<span class="number">1</span> &lt;&lt; v)) * (Mod + <span class="number">1LL</span>) / <span class="number">4</span>) % Mod;</span><br><span class="line"><span class="keyword">if</span> (typ[le][ri] == <span class="number">2</span>)</span><br><span class="line">res = (res + <span class="built_in">Dp</span>(S | (<span class="number">1</span> &lt;&lt; le) | (<span class="number">1</span> &lt;&lt; u), T | (<span class="number">1</span> &lt;&lt; ri) | (<span class="number">1</span> &lt;&lt; v)) * (Mod - (Mod + <span class="number">1LL</span>) / <span class="number">4</span>)) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mp[S][T] = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定左右各 $n$ 个点的二分图和 $m$ 种边，每一种边有三种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这种边只有一条，有 $50\%$ 的概率出现。&lt;/li&gt;
&lt;li&gt;这种边有两条，同时出现或者不出现，概率均为 $50\%$。&lt;/li&gt;
&lt;li&gt;这种边有两条，分别出现，概率均为 $50\%$。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;求完美匹配的期望数量，对 $10 ^ 9 + 7$ 取模。$n\leq 15$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>LOJ6179 Pyh 的求和</title>
    <link href="https://mydcwfy.github.io/2022/08/05/LOJ6179/"/>
    <id>https://mydcwfy.github.io/2022/08/05/LOJ6179/</id>
    <published>2022-08-05T13:10:13.000Z</published>
    <updated>2022-08-05T13:37:29.819Z</updated>
    
    <content type="html"><![CDATA[<p>题意：求 $\sum_{i = 1} ^ n \sum_{j = 1} ^ m \varphi(ij)\bmod 998244353$。$T(T\leq 10 ^ 5)$ 组数据，$n, m\leq 10 ^ 5$，4s，64MB。</p><span id="more"></span><p>首先一个容易发现的性质是 $\varphi(ij) = \dfrac{\varphi(i) \varphi(j) \gcd(i, j)}{\varphi(\gcd(i, j))}$。考虑每个质因数的贡献即可。</p><p>那么一阵推导（默认 $n\leq m$）：<br>$$<br>\begin{aligned}<br>ans =&amp; \sum_{i = 1} ^ n \sum_{j = 1} ^ m \dfrac{\varphi(i) \varphi(j) \gcd(i, j)}{\varphi(\gcd(i, j))}\\<br>=&amp; \sum_{d = 1} ^ n \dfrac d{\varphi(d)} \sum_{i = 1} ^ {\frac nd} \sum_{j = 1} ^ {\frac md} [\gcd(i, j) = 1] \varphi(id) \varphi(jd)\\<br>=&amp; \sum_{d = 1} ^ n \dfrac d{\varphi(d)} \sum_{i = 1} ^ {\frac nd} \sum_{j = 1} ^ {\frac md} \varphi(id) \varphi(jd) \sum_{k | i, k | j} \mu(k)\\<br>=&amp; \sum_{d = 1} ^ n \dfrac d{\varphi(d)} \sum_{k = 1} ^ {\frac nd} \mu(k) \sum_{i = 1} ^ {\frac n{dk}}\sum_{j = 1} ^ {\frac m{dk}} \varphi(idk) \varphi(jdk)\\<br>=&amp; \sum_{T = 1} ^ n (\sum_{i = 1} ^ {\frac nT} \varphi(iT)) (\sum_{j = 1} ^ {\frac mT} \varphi(jT)) \sum_{d | T} \dfrac {d\mu(\dfrac Td)}{\varphi(d)}<br>\end{aligned}<br>$$<br>容易发现后面的 $\sum_{d | T} \dfrac {d\mu(\dfrac Td)}{\varphi(d)}$ 可以在 $O(n\log n)$ 的时间预处理，如果求出了前面的一坨，容易单次 $O(\sqrt n)$ 整除分块计算。问题在于前面的这两个不是很好和整除分块一起计算。</p><p>考虑有两种处理办法：</p><ol><li>预处理 $f(n, m, T) = \sum_{i = 1} ^ n \sum_{j = 1} ^ m  \varphi(iT) \varphi(jT)$ 并使用前缀和，这样就可以使用整除分块。</li><li>预处理 $g(n, T) = \sum_{i = 1} ^ n f(iT)$，不使用前缀和和整除分块。</li></ol><p>两个可以平衡规划一下，考虑到神秘的空间限制，大概确定一个阈值即可， $\dfrac mT$ 小于他的使用预处理整除分块，否则使用暴力。时间限制比较宽松，只要平衡规划一般能通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, B = <span class="number">50</span>, Mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">phi[<span class="number">1</span>] = mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) prime[++ cnt] = i, phi[i] = i - <span class="number">1</span>, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++ j)</span><br><span class="line">&#123;</span><br><span class="line">st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">phi[i * prime[j]] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">mu[i * prime[j]] = -mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">adj</span>(mu[i]), invphi[i] = <span class="built_in">qpow</span>(phi[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d * i &lt;= n; ++ d)</span><br><span class="line">g[i * d] = (g[i * d] + (LL) d * invphi[d] % Mod * mu[i]) % Mod;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> T = <span class="number">1</span>; T &lt;= n; ++ T)</span><br><span class="line">&#123;</span><br><span class="line">f[T].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, tmp; i * T &lt;= n; ++ i)</span><br><span class="line">f[T].<span class="built_in">push_back</span>(<span class="built_in">adj</span>(tmp = f[T].<span class="built_in">back</span>() + phi[i * T] - Mod));</span><br><span class="line">cnt += f[T].<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s1 = <span class="number">1</span>; s1 &lt;= B; ++ s1)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s2 = <span class="number">1</span>; s2 &lt;= B; ++ s2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> &amp;v = S[s1][s2];</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, ed = std::<span class="built_in">min</span>(n / s1, n / s2); i &lt;= ed; ++ i)</span><br><span class="line">v.<span class="built_in">push_back</span>((v.<span class="built_in">back</span>() + (LL) f[i][s1] * f[i][s2] % Mod * g[i]) % Mod);</span><br><span class="line">cnt += v.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line">std::cerr &lt;&lt; (cnt * <span class="number">4</span> + std::<span class="built_in">abs</span>(&amp;mem1 - &amp;mem2)) / <span class="number">1048576.</span> &lt;&lt; <span class="string">&quot; MB\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m, res = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">if</span> (n &gt; m) std::<span class="built_in">swap</span>(n, m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m / B; ++ i)</span><br><span class="line">res = (res + (LL) g[i] * f[i][n / i] % Mod * f[i][m / i]) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = m / B + <span class="number">1</span>, r, tn, tm; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = std::<span class="built_in">min</span>(n / (tn = n / l), m / (tm = m / l));</span><br><span class="line"><span class="built_in">adj</span>(<span class="built_in">adj</span>(res += S[tn][tm][r] - Mod) -= S[tn][tm][l - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sieve</span>(<span class="number">1e5</span> + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">std::cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T --) <span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：求 $\sum_{i = 1} ^ n \sum_{j = 1} ^ m \varphi(ij)\bmod 998244353$。$T(T\leq 10 ^ 5)$ 组数据，$n, m\leq 10 ^ 5$，4s，64MB。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="平衡规划" scheme="https://mydcwfy.github.io/tags/%E5%B9%B3%E8%A1%A1%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>51Nod1965 奇怪的式子</title>
    <link href="https://mydcwfy.github.io/2022/07/25/51Nod1965/"/>
    <id>https://mydcwfy.github.io/2022/07/25/51Nod1965/</id>
    <published>2022-07-25T06:36:33.000Z</published>
    <updated>2022-07-25T08:26:22.148Z</updated>
    
    <content type="html"><![CDATA[<p>题意：求 $\prod_{i = 1} ^ n \sigma_0(i) ^ {i + \mu(i)}$。$n\leq 10 ^ {11}$，对 $10 ^ {12} + 39$ 取模，$T(T\leq 3)$ 组数据，15s。</p><span id="more"></span><p><a href="/2022/02/13/Min-25-Sieve/">前置知识</a>，即使会也可以看看里面的一些定义，下文会用到~</p><p>离谱模数 + 奇怪卡常题，不过 Min_25 的应用是非常不错的。</p><p>首先我们容易发现 $i + \mu(i)$ 似乎没有任何性质，考虑拆开计算。那么分别计算 $\sigma_0(i) ^ i$ 和 $\sigma_0(i) ^ {\mu(i)}$。</p><h3 id="1-正常的-Min-25-筛"><a href="#1-正常的-Min-25-筛" class="headerlink" title="1. 正常的 Min_25 筛"></a>1. 正常的 Min_25 筛</h3><hr><h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h4><p>直接考虑 Min_25 筛，考虑计算 $\prod\sigma_0(i) ^ i$。假设我们已经知道了一些 $x$ 的 $\prod \sigma_0(x) ^ x$，考虑怎样在这些数上所有乘 $p$（$p$ 是一个质数，$s$ 和 $p$ 都互质）。直接推式子：<br>$$<br>\begin{aligned}<br>&amp;\prod \sigma_0(p\times x) ^ {p\times x}\\<br>=&amp; \prod \sigma_0(p) ^ {p\times x} \times \prod \sigma_0(x) ^ {p\times x}\\<br>=&amp; (\sigma_0(p) ^ p) ^ {\sum x} \times (\prod \sigma_0(x) ^ x) ^ p<br>\end{aligned}<br>$$<br>容易发现我们还需要计算 $\sum x$，这个在 Min_25 递归过程中很容易计算。$p$ 也可以换成 $p ^ k$，和上面的推导是相同的，可以直接使用。</p><h4 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h4><p>下面考虑 $\prod\sigma_0(i) ^ {\mu(i)}$。首先一个比较重要的性质为我们只需要管 $p_1p_2 \dots p_k$ 类似的数，因为 $\mu(i)$ 为 0 的话就没有贡献。而写成这样，我们又可以表示 $\sigma_0(i)$ 为 $2 ^ {d(i)}$，其中 $d(i)$ 表示 $i$ 的质因子个数。那么只需要计算 $\sum d(i)\mu(i)$ 即可。</p><p>还是考虑 Min_25 筛的递归过程，我们只需要枚举次幂 $k = 1$ 即可。继续计算时，还是会遇到类似合并两个答案的问题。</p><p>假设前面我们已经算好了一些 $\sum d(x) \mu(x)$，现在考虑对这些所有数乘上一个 $p$。还是直接推式子：<br>$$<br>\begin{aligned}<br>&amp;\sum d(x\times p)\mu(x\times p)\\<br>=&amp; \sum (d(x) + 1)(-\mu(x))\\<br>=&amp; -\sum d(x)\mu(x) - \sum \mu(x)<br>\end{aligned}<br>$$<br>递归的过程需要同时计算 $\mu(x)$，这个是容易的。</p><hr><p>那么我们就得到了一个使用递归 Min_25 筛的做法。</p><details><summary>递归代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> LL Mod1 = <span class="number">1000000000039LL</span>, Mod2 = <span class="number">1000000000038LL</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LPow</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> B = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    LL sk[B], bk[B];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sk[<span class="number">0</span>] = bk[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; B; ++ i) sk[i] = sk[i - <span class="number">1</span>] * x % Mod1;</span><br><span class="line">        bk[<span class="number">1</span>] = sk[B - <span class="number">1</span>] * x % Mod1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; B; ++ i) bk[i] = (s128) bk[i - <span class="number">1</span>] * bk[<span class="number">1</span>] % Mod1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">LL <span class="title">lpow</span><span class="params">(LL n)</span> </span>&#123; <span class="keyword">return</span> n %= Mod2, (s128) bk[n &gt;&gt; <span class="number">20</span>] * sk[n &amp; <span class="number">1048575</span>] % Mod1; &#125;</span><br><span class="line">&#125; lp[<span class="number">25</span>];</span><br><span class="line"><span class="type">bool</span> mem2;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL a, LL k = Mod1 - <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = (s128) a * a % Mod1)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (s128) res * a % Mod1;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) prime[++ cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getid</span><span class="params">(LL x)</span> </span>&#123; <span class="keyword">return</span> x &lt;= sq ? id1[x] : id2[n / x]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveg1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) g[i] = a[i] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) sp[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        LL le = (LL) prime[i] * prime[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; a[j] &gt;= le; ++ j)</span><br><span class="line">            g[j] -= g[<span class="built_in">getid</span>(a[j] / prime[i])] - sp[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; g[1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveg2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) g[i] = ((s128) a[i] * (a[i] + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>) % Mod2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) sp[i] = sp[i - <span class="number">1</span>] + prime[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        LL le = (LL) prime[i] * prime[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; a[j] &gt;= le; ++ j)</span><br><span class="line">            g[j] = (g[j] + (s128) (g[<span class="built_in">getid</span>(a[j] / prime[i])] - sp[i - <span class="number">1</span>] + Mod2)</span><br><span class="line">                * (Mod2 - prime[i])) % Mod2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; g[1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PLL <span class="title">S1</span><span class="params">(LL n, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prime[i] &gt;= n) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    LL res = -g[<span class="built_in">getid</span>(n)] + sp[i], tot = res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nw = i + <span class="number">1</span>; nw &lt;= cnt &amp;&amp; (LL) prime[nw] * prime[nw] &lt;= n; ++ nw)</span><br><span class="line">    &#123;</span><br><span class="line">        PLL frm = <span class="built_in">S1</span>(n / prime[nw], nw);</span><br><span class="line">        res -= frm.first + frm.second, tot -= frm.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;res, tot&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PLL <span class="title">S2</span><span class="params">(LL n, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prime[i] &gt;= n) <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    LL res = lp[<span class="number">2</span>].<span class="built_in">lpow</span>(g[<span class="built_in">getid</span>(n)] - sp[i] + Mod2), tot = g[<span class="built_in">getid</span>(n)] - sp[i] + Mod2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nw = i + <span class="number">1</span>; nw &lt;= cnt &amp;&amp; (LL) prime[nw] * prime[nw] &lt;= n; ++ nw)</span><br><span class="line">    &#123;</span><br><span class="line">        LL cur = prime[nw];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; cur &lt;= n; cur *= prime[nw], ++ k)</span><br><span class="line">        &#123;</span><br><span class="line">            PLL frm = <span class="built_in">S2</span>(n / cur, nw);</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="number">1</span>) frm.second ++;</span><br><span class="line">            LL mul, t = (s128) cur * frm.second % Mod2;</span><br><span class="line">            <span class="keyword">if</span> (k + <span class="number">1</span> &lt; <span class="number">25</span>) mul = lp[k + <span class="number">1</span>].<span class="built_in">lpow</span>(t);</span><br><span class="line">            <span class="keyword">else</span> mul = <span class="built_in">qpow</span>(k + <span class="number">1</span>, t);</span><br><span class="line">            res = (s128) res * mul % Mod1 * <span class="built_in">qpow</span>(frm.first, cur) % Mod1;</span><br><span class="line">            tot = (tot + (s128) frm.second * cur) % Mod2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;res, tot&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    sq = std::<span class="built_in">sqrt</span>(n), tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">1</span>, r, t; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t = n / l, r = n / t;</span><br><span class="line">        a[++ tot] = t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt;= sq) id1[t] = tot;</span><br><span class="line">        <span class="keyword">else</span> id2[r] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solveg1</span>();</span><br><span class="line">    <span class="keyword">auto</span> res1 = <span class="built_in">S1</span>(n, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; (res1.first + Mod2 * 10) % Mod2 &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    <span class="built_in">solveg2</span>();</span><br><span class="line">    <span class="keyword">auto</span> res2 = <span class="built_in">S2</span>(n, <span class="number">0</span>);</span><br><span class="line">    LL res = (s128) <span class="built_in">qpow</span>(<span class="number">2</span>, res1.first + Mod2 * <span class="number">10</span>) * res2.first % Mod1;</span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="2-迭代的-Min-25-筛"><a href="#2-迭代的-Min-25-筛" class="headerlink" title="2. 迭代的 Min_25 筛"></a>2. 迭代的 Min_25 筛</h3><p>如果认真观察一些 Min_25 的题目的话，会发现一个事实：如果带递归的 Min_25，一般只能跑 $10 ^ {10}$，但是如果只有第一部分迭代的话，一般可以跑 $10 ^ {11}$，不过时限略大。本题中，上面给出的代码在单组 $10 ^ {11}$ 的情况下需要跑 1min 的时间，很明显的印证了上面所说到的这一点。（递归中还带快速幂，显然无法接受）</p><p>考虑使用迭代的方法计算这两部分。可能就和正常理解的 Min_25 不太相同。</p><hr><h4 id="第二部分-1"><a href="#第二部分-1" class="headerlink" title="第二部分"></a>第二部分</h4><p>先看第二部分罢。</p><p>注意到这个部分递归的时候，$p$ 的次幂都是 $k = 1$，考虑从这里入手。</p><p>还是类似于 Min_25 筛的定义，设 $S(n, i)$ 为所有满足 $\mathrm{lpf}(x) &gt; p_i\lor i\in P$ 的数的 $\sum d(x)\mu(x)$ 的和，其中 $\mathrm{lpf}(x)$ 表示 $x$ 的最小质因子，$p_i$ 是第 $i$ 个质数，$P$ 是质数集合。</p><p>考虑直接迭代求 $G(n, i)$。和 Min_25 筛第一部分不同的地方在于，我们现在求的是 $G(n, 0)$ 而不是 $G(n, k)$（保证 $p_k &gt; \sqrt n$），所以我们应该倒序枚举 $i$。</p><p>注意到我们迭代的时候也用到了 $\sum \mu(i)$，设 $H(n, k)$ 为满足条件的 $\mu(x)$ 的和。</p><p>大力推式子，可以得到：<br>$$<br>\begin{aligned}<br>G(n, i - 1) =&amp; G(n, i) - (G(\dfrac n{p_i}, i) + i) - (H(\dfrac n{p_i}, i) + i)\\<br>H(n, i - 1) =&amp; H(n, i) - (H(\dfrac n{p_i}, i) + i)<br>\end{aligned}<br>$$<br>$+i$ 的原因是我们要把 $p_{1\dots i}$ 的贡献除去，每个的 $d(i)\mu(i)$ 和 $\mu(i)$ 都是 -1，所以减掉贡献应该 $+i$。</p><p>那么按照这个式子计算，最后 $G(n, 0)$ 就是答案。这个计算过程类似于 Min_25 第一步，并不需要滚动数组。</p><h4 id="第一部分-1"><a href="#第一部分-1" class="headerlink" title="第一部分"></a>第一部分</h4><p>那么再来看第一部分。这个就和上面那一个优化思路就不同了，因为枚举的 $p$ 的次幂不一定是 1 了。</p><p>从朴素的方向出发，我们考虑计算每一个质因子的贡献。大力推式子：<br>$$<br>\begin{aligned}<br>\prod_{i = 1} ^ n \sigma_0(i) ^ i =&amp; \prod_{p\in P} \prod_{k} (k + 1) ^ {\sum_{i = 1} ^ n [p ^ k \mid i\land p ^ {k + 1}\nmid i] i}<br>\end{aligned}<br>$$<br>指数上的一坨我们展开一下：<br>$$<br>\begin{aligned}<br>&amp;\sum_{i = 1} ^ n [p ^ k \mid i \land p ^ {k + 1} \nmid i]\\<br>=&amp; \sum_{i = 1} ^ n [p ^ k | i]i - \sum_{i = 1} ^ n [p ^ {k + 1} | i] i\\<br>=&amp; p ^ k \sum_{i = 1} ^ {\frac n{p ^ k}}i - p ^ {k + 1} \sum_{i = 1} ^ {\frac n{p ^ {k + 1}}} i\\<br>=&amp; p ^ k \mathrm{sum}(\dfrac n{p ^ k}) - p ^ {k + 1} \mathrm{sum} (\dfrac n{p ^ {k + 1}})<br>\end{aligned}<br>$$<br>其中 $\mathrm{sum}(x)$ 表示 $\sum_{i = 1} ^ x i$，为 $\dfrac {x\times (x + 1)}2$。</p><p>这么多 $(p, k)$ 并不好计算，但是注意到 $p &gt; \sqrt n$ 的时候，$k = 1$，似乎是一个不错的办法。</p><p>首先计算 $p\leq \sqrt n$。直接暴力计算即可，时间复杂度并不高，反正很快。</p><p>下面来看 $p &gt; \sqrt n$ 的情况。注意到 $k = 1$ 的情况是很好表示的，我们可以马上写出式子：<br>$$<br>\prod_{p\in P\land p &gt; \sqrt n} 2 ^ {p \times \mathrm{sum}(\lfloor \frac np\rfloor )}<br>$$<br>注意到我们需要对 $\dfrac np$ 进行整除分块，然后需要求出区间素数的和。这个是直接使用 Min_25 第一部分就可以很快得到的（类似 区间素数问题），那么我们也可以只通过迭代计算第一部分的答案了。</p><hr><p>通过对 Min_25 的改造，对式子的推导，我们最终还是通过简单的 Min_25 第一部分的迭代就可以计算这个答案了。时间复杂度不太会算，据说都是 $O(n ^ {\frac 34})$ 的。新算法能在 3s 左右得到 $10 ^ {11}$ 的答案的，可见还是比递归写法快不少的。</p><p>代码实现方面，注意是 $\bmod P$ 还是 $\bmod \varphi(P)$ 是需要注意的。好像不能使用 <code>__int128_t</code>，那就写 <code>long double</code> 乘法罢。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> LL Mod1 = <span class="number">1000000000039LL</span>, Mod2 = <span class="number">1000000000038LL</span>;</span><br><span class="line"><span class="function">LL <span class="title">mul1</span><span class="params">(LL a, LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> x = (<span class="type">long</span> <span class="type">double</span>) a * b;</span><br><span class="line">    <span class="keyword">return</span> (a * b - (LL) (x / Mod1) * Mod1 + Mod1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">mul2</span><span class="params">(LL a, LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> x = (<span class="type">long</span> <span class="type">double</span>) a * b;</span><br><span class="line">    <span class="keyword">return</span> (a * b - (LL) (x / Mod2) * Mod2 + Mod2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL a, LL k = Mod1 - <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = <span class="built_in">mul1</span>(a, a))</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = <span class="built_in">mul1</span>(res, a);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) prime[++ cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getid</span><span class="params">(LL x)</span> </span>&#123; <span class="keyword">return</span> x &lt;= sq ? id1[x] : id2[n / x]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">sum1</span><span class="params">(LL x)</span> </span>&#123; <span class="keyword">return</span> x &amp; <span class="number">1</span> ? <span class="built_in">mul2</span>(x, (x + <span class="number">1</span>) / <span class="number">2</span>) : <span class="built_in">mul2</span>(x / <span class="number">2</span>, x + <span class="number">1</span>); &#125;</span><br><span class="line"><span class="function">LL&amp; <span class="title">adj</span><span class="params">(LL &amp;x)</span> </span>&#123; <span class="keyword">return</span> x += x &gt;&gt; <span class="number">63</span> &amp; Mod2; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveg1</span><span class="params">()</span> <span class="comment">// sigma(i) * i</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) g[i] = <span class="built_in">sum1</span>(a[i]) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) h[i] = a[i] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) sp[i] = sp[i - <span class="number">1</span>] + prime[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) sph[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        LL le = (LL) prime[i] * prime[i], tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>, id; j &lt;= tot &amp;&amp; a[j] &gt;= le; ++ j)</span><br><span class="line">            g[j] = (g[j] + (Mod2 - <span class="built_in">adj</span>(tmp = g[id = <span class="built_in">getid</span>(a[j] / prime[i])] - sp[i - <span class="number">1</span>]))</span><br><span class="line">                 * prime[i]) % Mod2,</span><br><span class="line">            h[j] -= h[id] - sph[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; g[1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveg2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) h[i] = Mod2 - h[i], g[i] = h[i];</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; g[1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cnt; i; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        LL le = (LL) prime[i] * prime[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; a[j] &gt;= le; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nid = <span class="built_in">getid</span>(a[j] / prime[i]);</span><br><span class="line">            <span class="built_in">adj</span>(<span class="built_in">adj</span>(h[j] -= h[nid]) -= i);</span><br><span class="line">            g[j] = (g[j] - h[nid] - i - g[nid] - i + <span class="number">4</span> * Mod2) % Mod2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; g[1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    sq = std::<span class="built_in">sqrt</span>(n) + <span class="number">1</span>, tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">1</span>, r, t; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t = n / l, r = n / t;</span><br><span class="line">        a[++ tot] = t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt;= sq) id1[t] = tot;</span><br><span class="line">        <span class="keyword">else</span> id2[r] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">solveg1</span>();</span><br><span class="line">    <span class="type">int</span> lim = <span class="number">1</span>;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; a[lim + <span class="number">1</span>] &gt;= sq; ++ lim) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime[i] &gt; a[lim]) <span class="keyword">break</span>;</span><br><span class="line">        LL cur = prime[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; cur &lt;= n; k ++, cur *= prime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            LL mul = (<span class="built_in">mul2</span>(cur, <span class="built_in">sum1</span>(n / cur))</span><br><span class="line">                + <span class="built_in">mul2</span>((Mod2 - cur) * prime[i] % Mod2, <span class="built_in">sum1</span>(n / cur / prime[i]))) % Mod2;</span><br><span class="line">            res = <span class="built_in">mul1</span>(res, <span class="built_in">qpow</span>(k + <span class="number">1</span>, mul));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL mul = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">1</span>, r, t; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t = n / l, r = n / t;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getid</span>(r) &gt; lim) <span class="keyword">continue</span>;</span><br><span class="line">        mul = (mul + <span class="built_in">mul2</span>(g[<span class="built_in">getid</span>(r)] - g[std::<span class="built_in">min</span>(lim, <span class="built_in">getid</span>(l - <span class="number">1</span>))] + Mod2, <span class="built_in">sum1</span>(t))) % Mod2;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">mul1</span>(res, <span class="built_in">qpow</span>(<span class="number">2</span>, mul));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">solveg2</span>();</span><br><span class="line">    res = <span class="built_in">mul1</span>(res, <span class="built_in">qpow</span>(<span class="number">2</span>, g[<span class="number">1</span>]));</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; g[1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; res % Mod1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：求 $\prod_{i = 1} ^ n \sigma_0(i) ^ {i + \mu(i)}$。$n\leq 10 ^ {11}$，对 $10 ^ {12} + 39$ 取模，$T(T\leq 3)$ 组数据，15s。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="Min_25" scheme="https://mydcwfy.github.io/tags/Min-25/"/>
    
  </entry>
  
  <entry>
    <title>HDU4997 Biconnected</title>
    <link href="https://mydcwfy.github.io/2022/07/23/HDU4997/"/>
    <id>https://mydcwfy.github.io/2022/07/23/HDU4997/</id>
    <published>2022-07-22T23:30:21.000Z</published>
    <updated>2022-07-22T23:56:48.722Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一个 $n$ 个点 $m$ 条边的无向图，问有多少个 $m$ 条边组成的集合使得只有这些边存在让 $n$ 个点构成一个边双连通分量。$n\leq 10$，对 $10 ^ 9 + 7$ 取模。</p><span id="more"></span><p>其实这个很难计数，因为我们不好实时判断一个边双联通分量是否存在。考虑对其进行容斥。</p><p>首先考虑一个简单的问题：让 $n$ 个点构成连通图的方案数。这个可以通过状态压缩 + 容斥解决，对于每一个集合 $S$，记连通图方案数为 $g(S)$，枚举编号最小的那个点（其实哪个点都行）所在的集合，然后就可以得到以下式子：<br>$$<br>g(S) = f(S) - \sum_{T\subsetneq S, id\in T} g(T) * f(S / T)<br>$$<br>$f(S)$ 代表任意连边的方案数，即为 $\displaystyle 2 ^ {\sum[(u, v)\in E\land u\in S\land v\in S]}$。</p><p>这样我们可以在 $O(3 ^ n)$ 时间内求出所有的 $g(S)$，还是可以接受的。</p><p>然后我们类似于上面这种方法，计算 $h(S)$，表示 $S$ 集合内部组成一个双连通分量的方案数。</p><p>我们直接模仿上面的方法，枚举 $T$ 为最小编号所在集合，然后其他的只需要满足是连通图就可以了。但是这会带来一个问题，就是 $T$ 和 $S/T$ 之间的连边不好确定，因为需要保证 $T$ 和 $S / T$ 联通，但是 $T$ 不会和 $S / T$ 中的任何部分组成边双连通。</p><p>$n \leq 10$ 非常小，我们可以直接考虑枚举点双集合，这需要一个 Bell 数枚举所有集合划分。连通图缩点后一定是一个树，那么我们可以考虑对这个生成树进行计数。对这个生成树计数就显得更为可做，我们预先知道两两之间的连边条数，用矩阵树定理即可求解。想知道两两连边条数，我们可以直接暴力预处理计算，也可以在特定位置 +1，使用集合幂级数，或者是预处理一个点到集合的连边数，都是可以的。</p><p>时间复杂度不好估量，大概是 $O(\mathrm{Bell}(n)n ^ 3)$，可以通过就是了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">det</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; ++ j)</span><br><span class="line"><span class="keyword">if</span> (a[j][i]) &#123;</span><br><span class="line">t = j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!~t) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i ^ t) x ^= <span class="number">1</span>, std::<span class="built_in">swap</span>(a[i], a[t]);</span><br><span class="line">res = (LL) res * a[i][i] % Mod;</span><br><span class="line">LL Inv = <span class="built_in">qpow</span>(a[i][i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; ++ j) a[i][j] = (LL) a[i][j] * Inv % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = n; k &gt;= i; -- k)</span><br><span class="line">a[j][k] = (a[j][k] + (LL) (Mod - a[i][k]) * a[j][i]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x ? <span class="built_in">adj</span>(res = -res) : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; all)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (all.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> m = all.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line"><span class="keyword">if</span> (i != j) a[i][j] = bew[all[i - <span class="number">1</span>]][all[j - <span class="number">1</span>]];</span><br><span class="line"><span class="keyword">else</span> a[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) t += a[i][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line"><span class="keyword">if</span> (a[i][j]) a[i][j] = Mod - a[i][j];</span><br><span class="line">a[i][i] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for (int i = 1; i &lt;= m; ++ i, puts(&quot;&quot;))</span></span><br><span class="line"><span class="comment">for (int j = 1; j &lt;= m; ++ j)</span></span><br><span class="line"><span class="comment">printf(&quot;%d &quot;, a[i][j]);*/</span></span><br><span class="line"><span class="type">int</span> ans = <span class="built_in">det</span>(m - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;x : all) ans = (LL) ans * g[x] % Mod;</span><br><span class="line"><span class="comment">/*for (int x : all) printf(&quot;%d &quot;, x);</span></span><br><span class="line"><span class="comment">printf(&quot;: %d\n&quot;, ans);*/</span></span><br><span class="line"><span class="built_in">adj</span>(res += ans - Mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s, std::vector&lt;<span class="type">int</span>&gt; &amp;all)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="built_in">solve</span>(all);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; s &lt;&lt; &#x27; &#x27; &lt;&lt; all.size() &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">all.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">ctz</span>(s);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s2 = s; s2; s2 = (s2 - <span class="number">1</span>) &amp; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!(s2 &gt;&gt; t &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">all.<span class="built_in">back</span>() = s2;</span><br><span class="line"><span class="built_in">dfs</span>(s ^ s2, all);</span><br><span class="line">&#125;</span><br><span class="line">all.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">ban.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line"><span class="keyword">if</span> (u &gt; v) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">ban.<span class="built_in">insert</span>(&#123;-- u, -- v&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line"><span class="keyword">if</span> (i &gt;= j || ban.<span class="built_in">count</span>(&#123;i, j&#125;)) a[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> a[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s) ins[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s1 = <span class="number">0</span>; s1 &lt; (<span class="number">1</span> &lt;&lt; n); ++ s1)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s2 = <span class="number">0</span>; s2 &lt; (<span class="number">1</span> &lt;&lt; n); ++ s2) bew[s1][s2] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line"><span class="keyword">if</span> (a[i][j]) ins[(<span class="number">1</span> &lt;&lt; i) | (<span class="number">1</span> &lt;&lt; j)] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++ j)</span><br><span class="line">bew[<span class="number">1</span> &lt;&lt; i][<span class="number">1</span> &lt;&lt; j] = bew[<span class="number">1</span> &lt;&lt; j][<span class="number">1</span> &lt;&lt; i] = a[j][i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s1 = <span class="number">0</span>; s1 &lt; (<span class="number">1</span> &lt;&lt; n); ++ s1)</span><br><span class="line"><span class="keyword">if</span> (s1 &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s2 = <span class="number">0</span>; s2 &lt; (<span class="number">1</span> &lt;&lt; n); ++ s2)</span><br><span class="line">bew[s1][s2] += bew[s1 ^ (<span class="number">1</span> &lt;&lt; i)][s2];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s2 = <span class="number">0</span>; s2 &lt; (<span class="number">1</span> &lt;&lt; n); ++ s2)</span><br><span class="line"><span class="keyword">if</span> (s2 &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s1 = <span class="number">0</span>; s1 &lt; (<span class="number">1</span> &lt;&lt; n); ++ s1)</span><br><span class="line">bew[s1][s2] += bew[s1][s2 ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line"><span class="keyword">if</span> (s &gt;&gt; i &amp; <span class="number">1</span>) ins[s] += ins[s ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line">&#123;</span><br><span class="line">f[s] = pw2[ins[s]];</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">ctz</span>(s);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s2 = s &amp; (s - <span class="number">1</span>); s2; s2 = (s2 - <span class="number">1</span>) &amp; s)</span><br><span class="line"><span class="keyword">if</span> (s2 &gt;&gt; t &amp; <span class="number">1</span>) f[s] = (f[s] + (LL) (Mod - f[s2]) * pw2[ins[s ^ s2]]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line">res = <span class="number">0</span>, <span class="built_in">dfs</span>(s, tmp), <span class="built_in">adj</span>(g[s] = f[s] - res);</span><br><span class="line"><span class="comment">// for (int s = 1; s &lt; (1 &lt;&lt; n); ++ s) printf(&quot;%d &quot;, g[s]);</span></span><br><span class="line">std::cout &lt;&lt; g[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一个 $n$ 个点 $m$ 条边的无向图，问有多少个 $m$ 条边组成的集合使得只有这些边存在让 $n$ 个点构成一个边双连通分量。$n\leq 10$，对 $10 ^ 9 + 7$ 取模。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="集合幂级数" scheme="https://mydcwfy.github.io/tags/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"/>
    
    <category term="矩阵树定理" scheme="https://mydcwfy.github.io/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
</feed>
