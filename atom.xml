<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mydcwfy&#39;s Blog</title>
  
  
  <link href="https://mydcwfy.github.io/atom.xml" rel="self"/>
  
  <link href="https://mydcwfy.github.io/"/>
  <updated>2022-07-08T14:02:48.627Z</updated>
  <id>https://mydcwfy.github.io/</id>
  
  <author>
    <name>mydcwfy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BZOJ3811 玛里苟斯</title>
    <link href="https://mydcwfy.github.io/2022/07/08/BZOJ3811/"/>
    <id>https://mydcwfy.github.io/2022/07/08/BZOJ3811/</id>
    <published>2022-07-08T13:34:07.000Z</published>
    <updated>2022-07-08T14:02:48.627Z</updated>
    
    <content type="html"><![CDATA[<p>利用好了期望的性质，除了线性基几乎没有卡点，非常有意思。</p><span id="more"></span><p>题意：给定一个长度为 $n$ 的序列 $a$，任选一个子序列，求 $(\oplus_{i\in S} a_i) ^ k$ 的期望并输出准确值。$n\leq 10 ^ 5$，保证答案小于 $2 ^ {63}$，$k\leq 5$。</p><p>答案不超过 $2 ^ {63}$ 大概提示我们对于不同的 $k$ 有不同的 $a_i$ 数据范围。</p><p>首先 $k = 1$ 的情况是好做的，根据期望的线性性，每位计算，如果有一个数的某一位出现了 1，那么选与不选的概率相同，也就是 01 的概率相同。那么最后的答案就是或的和除以 2。</p><p>然后考虑 $k = 2$ 的情况。一个经典的做法是枚举两位（可以相同），计算同时为 1 的概率并乘上贡献。全是 00 贡献为 0，如果全是 00 或 11，那么两位只绑在一起的，概率为 $\dfrac 12$。否则出现一个 01 或者 10 的话，假设前面都是 11 或 00，那么出现 11 的概率和 00 的概率都是 $\dfrac 12$。来了一个 01 或者 10，11 和 00 想要不变，就不能选，那么 11 和 00 的概率都变成了 $\dfrac 14$。而 01 和 10 的概率也都变成了 $\dfrac 14$。四者概率相同后，后面的就没法再改变了。于是出现 01 或 10 的情况，就是 $\dfrac 14$ 的概率。</p><p>这时答案的二倍一定是整数，因为如果两个选择的都是最低位的话，概率不会是 $\dfrac 14$，所以最后判一下是奇数还是偶数，除以 2 输出即可。</p><p>然后考虑 $k\geq 3$ 的情况。这时由于线性基一定能表示原来所有数能表示的范围，但是线性基现在只有不超过 $21$ 位，那么我们直接暴力枚举所有可能的情况即可。其实对于剩下能被线性基元素线性表示的元素是没有意义的，因为如果选了这个元素，相当于线性基内表示他的元素出现次数 $\oplus 1$。这样只需考虑线性基内的元素，直接爆搜即可。</p><p>最后一个问题就是最后的小数如何输出。可能爆 <code>unsigned long long</code>，所以把小数部分和整数部分分开存，这样都不会爆。还有一个结论是答案的二倍还是整数。证明可以考虑类似 $k = 2$ 的证法，比较麻烦，就不讲了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinearBasis</span> &#123;</span></span><br><span class="line">ULL a[N];</span><br><span class="line">ULL&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> a[x]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(ULL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">63</span>; ~i; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!(x &gt;&gt; i &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (!a[i]) <span class="keyword">return</span> a[i] = x, <span class="literal">true</span>;</span><br><span class="line">x ^= a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; chk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%llu&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">ULL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) res |= a[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu&quot;</span>, res &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (res &amp; <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;.5&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">2</span>) &#123;</span><br><span class="line">ULL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b1 = <span class="number">0</span>; b1 &lt; <span class="number">32</span>; ++ b1)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b2 = <span class="number">0</span>; b2 &lt; <span class="number">32</span>; ++ b2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">bool</span> flag1 = <span class="literal">false</span>, flag2 = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; (!flag1 || !flag2); ++ i)</span><br><span class="line">flag1 |= a[i] &gt;&gt; b1 &amp; <span class="number">1</span>, flag2 |= a[i] &gt;&gt; b2 &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (!flag1 || !flag2) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">bool</span> dif = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; !dif; ++ i)</span><br><span class="line"><span class="keyword">if</span> ((a[i] &gt;&gt; b1 &amp; <span class="number">1</span>) ^ (a[i] &gt;&gt; b2 &amp; <span class="number">1</span>)) dif = <span class="literal">true</span>;</span><br><span class="line">res += <span class="number">1ULL</span> &lt;&lt; (b1 + b2 - dif);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu&quot;</span>, res &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (res &amp; <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;.5&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sz = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) sz += chk.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">ULL res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">std::vector&lt;ULL&gt; all;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">63</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (chk[i]) all.<span class="built_in">push_back</span>(chk[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; sz); ++ s)</span><br><span class="line">&#123;</span><br><span class="line">ULL cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++ i)</span><br><span class="line"><span class="keyword">if</span> (s &gt;&gt; i &amp; <span class="number">1</span>) cur ^= all[i];</span><br><span class="line">ULL a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cs = <span class="number">1</span>; cs &lt;= k; ++ cs)</span><br><span class="line">a *= cur, b *= cur, a += b &gt;&gt; sz, b &amp;= (<span class="number">1</span> &lt;&lt; sz) - <span class="number">1</span>;</span><br><span class="line">res1 += a, res2 += b;</span><br><span class="line">&#125;</span><br><span class="line">res1 += res2 &gt;&gt; sz, res2 &amp;= (<span class="number">1</span> &lt;&lt; sz) - <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; res1;</span><br><span class="line"><span class="keyword">if</span> (res2) <span class="built_in">puts</span>(<span class="string">&quot;.5&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;利用好了期望的性质，除了线性基几乎没有卡点，非常有意思。&lt;/p&gt;</summary>
    
    
    
    
    <category term="线性基" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
    <category term="期望" scheme="https://mydcwfy.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>CF Educational Round#125</title>
    <link href="https://mydcwfy.github.io/2022/07/08/CF-Round-Edu125/"/>
    <id>https://mydcwfy.github.io/2022/07/08/CF-Round-Edu125/</id>
    <published>2022-07-08T00:02:00.000Z</published>
    <updated>2022-07-08T00:56:18.446Z</updated>
    
    <content type="html"><![CDATA[<p>赛时偷瞄 F 难度，不小心看到了做法，结果还是不会……</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：$T(T\leq 3000)$ 给定 $x, y$，问在每步距离只能走整数长度情况下，最少游走几步能从 $(0, 0)$ 走到 $(x, y)$。$0\leq x, y\leq 50$。</p><p>容易发现答案不超过 2，因为 $(0, 0)\to (0, y)\to (x, y)$ 就可以两步完成。一步和不走的情况判一下就可以了。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：有一个长度为 $n + 1$ 的序列 $a$，已知 $a_0 = 0$，$a_i$ 只能在 $a_{i - 1}$ 的基础上加 $x$ 或者减 $y$，并且每一项不能超过 $B$，求最大和。$n\leq 2\times 10 ^ 5$，$1\leq x, y, B\leq 10 ^ 9$。</p><p>容易发现一个贪心：能加则加，否则减。简单的证明一下：容易发现反面就是 $a_{i - 1} + x\leq B$，但是 $a_i = a_{i - 1} - y$。这时如果找不到后面的一个 $j$ 是 $a_{j - 1} + x$ 的话，显然可以把这一步替换成 $+x$。否则的话，我们交换 $i, j$ 的操作，容易发现 $[i, j)$ 这一段是递减的，$a_i\leq B$，那么所有都符合 $\leq B$ 的条件，而 $a_j$ 不变。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定一个 $n$ 的括号序列，要求每次找到一个好的最短前缀，然后删除这个前缀。一个括号序列是好的当且仅当它是一个合法的括号序列或者是一个回文串且长度不小于 2。问会删除多少次，最后剩下长度是多少。$\sum n\leq 5\times 10 ^ 5$。</p><p>容易发现我们拿一个指针向前扫，然后实时判断该段区间是否合法，即可做到 $O(n)$ 次询问一段区间是否合法。</p><p>首先第一个条件，由于是双指针，$r$ 右指针的变化量是 $O(1)$ 的，可以动态维护是不是合法的括号序列。当且仅当 $cnt = 0$，且任意时刻 $cnt\geq 0$，表示左括号减右括号。</p><p>第二个条件随便 Hash 一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gethash1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (hash1[r] + (LL) (Mod - pw3[r - l + <span class="number">1</span>]) * hash1[l - <span class="number">1</span>]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gethash2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (hash2[l] + (LL) (Mod - pw3[r - l + <span class="number">1</span>]) * hash2[r + <span class="number">1</span>]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((r - l + <span class="number">1</span>) &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">gethash1</span>(l, mid) == <span class="built_in">gethash2</span>(mid, r);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gethash1</span>(l, mid) == <span class="built_in">gethash2</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s + <span class="number">1</span>);</span><br><span class="line">pw3[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) pw3[i] = pw3[i - <span class="number">1</span>] * <span class="number">3LL</span> % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">hash1[i] = (hash1[i - <span class="number">1</span>] * <span class="number">3LL</span> + (s[i] == <span class="string">&#x27;)&#x27;</span>)) % Mod;</span><br><span class="line">hash2[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i)</span><br><span class="line">hash2[i] = (hash2[i + <span class="number">1</span>] * <span class="number">3LL</span> + (s[i] == <span class="string">&#x27;)&#x27;</span>)) % Mod;</span><br><span class="line"><span class="keyword">int</span> i, j, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i = j + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>, flag = <span class="number">1</span>;</span><br><span class="line">j = i;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= n &amp;&amp; !<span class="built_in">check</span>(i, j))</span><br><span class="line">&#123;</span><br><span class="line">top += s[j] == <span class="string">&#x27;(&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (top &lt; <span class="number">0</span>) flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">0</span> &amp;&amp; flag) <span class="keyword">break</span>;</span><br><span class="line">++ j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; n) <span class="keyword">break</span>;</span><br><span class="line">cnt ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, cnt, n - i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：有 $n$ 种剑，每一种有每秒攻击力 $d_i$ 和 生命值 $h_i$，以及单价 $c_i$ 金币。有 $m$ 只怪兽，每秒攻击力为 $D_i$，生命值为 $H_i$。攻击一个怪兽只能买一种剑，但个数不限。攻击时间是连续的，也就是说击败时间可以不是整数。你能获胜当且仅当怪兽死亡的时间严格比你任意一把剑死亡的时间短。问能否在 $C$ 个金币内买剑，使得你一定能获胜，如果能输出最小金币数。$n, m\leq 3\times 10 ^ 5$，$C\leq 10 ^ 6$，$d_i, h_i, D_i\leq 10 ^ 6$，$H_i\leq 10 ^ {12}$。</p><p>注意到能获胜当且仅当 $cnt\times d_i\times h_i &gt; D\times H$，$cnt$ 表示买的数量。一下把 $cnt\times d_i\times h_i$ 称作权值。</p><p>很明显 $d, h$ 范围都很大，无法做文章。看到 $C$ 很小，考虑变换思路，设 $s_i$ 表示 $i$ 个金币内最多能买到的权值。</p><p>我们有了 $s_i$ 过后，可以去更新他的倍数，这样我们可以在 $O(C\log C)$ 的时间内得到 $s$。</p><p>后面直接在 $s$ 上二分查找第一个大于怪兽权值的位置即可，注意特判无法做到的情况。</p><p>时间复杂度 $O(n + (m + C)\log C)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m, C;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; C;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, c, d, h; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;c, &amp;d, &amp;h);</span><br><span class="line"><span class="built_in">chkmax</span>(mx[c], (LL) d * h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">chkmax</span>(mx[i], mx[i - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">2</span>; i * d &lt;= C; ++ d)</span><br><span class="line"><span class="built_in">chkmax</span>(mx[i * d], mx[i] * d);</span><br><span class="line">&#125;</span><br><span class="line">std::cin &gt;&gt; m;</span><br><span class="line">LL d, h;</span><br><span class="line"><span class="keyword">while</span> (m --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;d, &amp;h), d *= h;</span><br><span class="line"><span class="keyword">if</span> (mx[C] &lt;= d) <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, std::<span class="built_in">upper_bound</span>(mx + <span class="number">1</span>, mx + C + <span class="number">1</span>, d) - mx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：问有多少张点数为 $n$ 的带边权完全图，边权 $\in [1, k]$，并且以 1 为根的菊花是原图的一棵最小生成树，对 998244353 取模。$n, k\leq 250$，4s。</p><p>简单计数题。</p><p>容易发现我们把 $(1, i)$ 的连边的权值放在 $i$ 上，相当于 $w(i, j)\geq \max\{a(i), a(j)\}$，考虑顺序枚举 $[1, k]$ 中出现的次数，然后用 EGF 类似的形式计算答案。记录 $f_{i, s}$ 表示当前最大值为 $i$，且已经有 $s$ 个点被选的方案数。大力转移，随便做做满足 $w(x, y)\geq i$ 的个数即可。时间复杂度 $O(n ^ 2k)$ 或 $O(n ^ 2k\log n)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k, -- n;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= n; ++ s) g[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= n; ++ s)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nxt = <span class="number">1</span>; nxt + s &lt;= n; ++ nxt)</span><br><span class="line">g[s + nxt] = (g[s + nxt] + (LL) f[s] * infact[nxt] % Mod *</span><br><span class="line"><span class="built_in">qpow</span>(k - i + <span class="number">1</span>, nxt * s + (nxt - <span class="number">1</span>) * nxt / <span class="number">2</span>)) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= n; ++ s) <span class="built_in">adj</span>(f[s] += g[s] - Mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= n; ++ s) f[s] = (LL) f[s] * fact[s] % Mod;</span><br><span class="line">std::cout &lt;&lt; f[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：在一棵 $n$ 个点的树上，每个点可以选择一个字符，有 $q$ 个限制：$(x_i, y_i)$ 的路径组成的串，要么是 $s_i$，要么是 $s_i$ 翻转，记作 $\overline s$。问是否存在一种合法的解，若存在则给出一组。$n, q, \sum s_i\leq 4\times 10 ^ 5$，9s。</p><p>注意到”要么……要么……“，想一想发现这其实是一个 2-SAT 的模型。考虑对每一个限制设一个 <code>bool</code> 变量，表示是否翻转。但是如果我们把 26 个字母在同一个点上都设出来，显然不是一个 2-SAT 模型了。</p><p>容易发现其实一个位置如果一旦被一个点覆盖，那么他一定最多只有两种字符选择，那么这时就可以转化成一个 2-SAT 模型。设 $c_{i, j}$ 表示 $i$ 位置的 $j$ 选择，如果 $c_{i, j}$ 不对应 $s$，那么就会连向 $\overline s$，而反过来 $s$ 就会连向 $c_{i, \neg j}$。其他同理。于是需要开 $2\times n + 2\times m$ 个点，跑一下是否满足条件即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++ *dfn, ins[stk[++ top] = x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], v; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (!dfn[v = e[i]]) <span class="built_in">tarjan</span>(v), <span class="built_in">chkmin</span>(low[x], low[v]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ins[v]) <span class="built_in">chkmin</span>(low[x], dfn[v]);</span><br><span class="line"><span class="keyword">if</span> (low[x] ^ dfn[x]) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line">++ *bel;</span><br><span class="line"><span class="keyword">do</span> bel[cur = stk[top --]] = *bel, ins[cur] = <span class="literal">false</span>; <span class="keyword">while</span> (cur != x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dep[x] = dep[fa] + <span class="number">1</span>, f[x] = fa;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (v != fa) <span class="built_in">dfs</span>(v, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">getpath</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; pth1, pth2;</span><br><span class="line"><span class="keyword">while</span> (u != v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dep[u] &gt; dep[v]) pth1.<span class="built_in">push_back</span>(u), u = f[u];</span><br><span class="line"><span class="keyword">else</span> pth2.<span class="built_in">push_back</span>(v), v = f[v];</span><br><span class="line">&#125;</span><br><span class="line">pth1.<span class="built_in">push_back</span>(u);</span><br><span class="line">std::<span class="built_in">reverse</span>(pth2.<span class="built_in">begin</span>(), pth2.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : pth2) pth1.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="keyword">return</span> pth1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n + <span class="number">2</span> * m; ++ i) h[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">g[u].<span class="built_in">push_back</span>(v), g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> getid = [&amp;](<span class="keyword">int</span> u, <span class="keyword">char</span> c) &#123;</span><br><span class="line"><span class="keyword">if</span> (!gt[u][<span class="number">0</span>]) gt[u][<span class="number">0</span>] = c;</span><br><span class="line"><span class="keyword">if</span> (gt[u][<span class="number">0</span>] == c) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!gt[u][<span class="number">1</span>]) gt[u][<span class="number">1</span>] = c;</span><br><span class="line"><span class="keyword">if</span> (gt[u][<span class="number">1</span>] == c) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> id = <span class="number">1</span>, u, v; id &lt;= m; ++ id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;u, &amp;v, s);</span><br><span class="line"><span class="keyword">auto</span> path = <span class="built_in">getpath</span>(u, v);</span><br><span class="line"><span class="keyword">int</span> sz = path.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">2</span>; ++ x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">getid</span>(path[i], s[i]) != x) &#123;</span><br><span class="line"><span class="built_in">add</span>(path[i] + x * n, <span class="number">2</span> * n + id);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">2</span> * n + m + id, path[i] + !x * n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">getid</span>(path[i], s[sz - i - <span class="number">1</span>]) != x) &#123;</span><br><span class="line"><span class="built_in">add</span>(path[i] + x * n, <span class="number">2</span> * n + m + id);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">2</span> * n + id, path[i] + !x * n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!gt[i][<span class="number">0</span>]) gt[i][<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!gt[i][<span class="number">1</span>]) gt[i][<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n + <span class="number">2</span> * m; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (bel[i] == bel[i + n]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>), <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * n + <span class="number">1</span>; i &lt;= <span class="number">2</span> * n + m; ++ i)</span><br><span class="line"><span class="keyword">if</span> (bel[i] == bel[i + m])</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>), <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">putchar</span>(gt[i][bel[i + n] &lt; bel[i]]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;赛时偷瞄 F 难度，不小心看到了做法，结果还是不会……&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>AT Code Festival 2017 Qual B F Largest Smallest Cyclic Shift</title>
    <link href="https://mydcwfy.github.io/2022/07/07/AT-Code-Festival-2017-Qual-B-F/"/>
    <id>https://mydcwfy.github.io/2022/07/07/AT-Code-Festival-2017-Qual-B-F/</id>
    <published>2022-07-07T09:53:25.000Z</published>
    <updated>2022-07-07T11:03:26.569Z</updated>
    
    <content type="html"><![CDATA[<p>神秘贪心 + 构造题。</p><span id="more"></span><p>题意：有 $x$ 个 <code>a</code>，$y$ 个 <code>b</code>，$z$ 个 <code>c</code>，所有由这些字符组成的字符串中，设 $f(S)$ 为 $S$ 的最小表示，求最大的 $f(S)$。$A + B + C\leq 50$。</p><p>有一个神秘的做法：首先需要保证 $S = f(S)$，然后保证 $S$ 最大；维护一个 <code>std::multiset</code>，表示所有待合并的字符串。每次拿出最小的和最大的，拼起来放回去，最后就可以得到答案。</p><p>怎么证明？不太会，谁叫官方题解和这个做法一点关系没有 /kk，网上的证明大多是没有说明白的，找到了 CF 上的 <a href="https://codeforces.com/blog/entry/55027#comment-389844">讨论</a>，大概知道了。</p><p>首先我们需要判断这两个构造方案是相同的。打一个表就可以发现时刻 <code>std::multiset</code> 里面都只有 3 种串。也是好证明的，因为我们拿着两种串”厮杀“，最后肯定会有一个串没有了，产生的串都是一种，所以时刻都只有 3 种串。接着自己手动推一下，其实就是 CF 讨论的构造方法。</p><p>下面我们来证明一下正确性。首先我们看到剩下的 3 种串一定都是严格有比较大小的，也就是我们把 <code>a</code> 放在开头一定是比 <code>b</code>  放在开头小，<code>b</code> 比 <code>c</code> 放在开头小。对于第一种变化后的情况 <code>ac, b, c</code>，开头不一样，显然合法。<code>a, ac, b</code>，虽然 <code>a</code> 和 <code>ac</code> 相同，但是我们找不到其他的前缀满足接在 <code>a</code> 后面还能和 <code>ac</code> 相同的，所以一旦 <code>a</code> 放在前面，肯定比 <code>ac</code> 放在前面小。</p><p>那么根据上面的说法，我们很容易得到最小表示的开头一定是 <code>a</code>，显然考虑贪心，我们如果在所有的 <code>a</code> 后面都接上 <code>c</code>，这样的最小表示一定是最大的，我们就可以递归下去计算答案；如果 <code>a</code> 无法全部接 <code>c</code>，那么剩余的 <code>a</code> 也是剩下的 3 种串中最小的，我们还是在 <code>a</code> 的后面接最大的串，这个其实又是相当于递归计算的过程了。</p><p>综上，我们就可以得到该算法的正确性了。下面有 <code>std::multiset</code> 和递归写法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> A, B, C;</span><br><span class="line">std::cin &gt;&gt; A &gt;&gt; B &gt;&gt; C;</span><br><span class="line"><span class="keyword">while</span> (A --) all.<span class="built_in">insert</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (B --) all.<span class="built_in">insert</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (C --) all.<span class="built_in">insert</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (all.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> itera = all.<span class="built_in">begin</span>(), iterb = -- all.<span class="built_in">end</span>();</span><br><span class="line">std::string add = *itera + *iterb;</span><br><span class="line">all.<span class="built_in">erase</span>(itera), all.<span class="built_in">erase</span>(iterb), all.<span class="built_in">insert</span>(add);</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; *all.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">solve</span><span class="params">(std::vector&lt;std::string&gt; s, std::vector&lt;<span class="keyword">int</span>&gt; cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!cnt[<span class="number">0</span>] &amp;&amp; !cnt[<span class="number">2</span>]) <span class="keyword">return</span> s[<span class="number">1</span>] * cnt[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (cnt[<span class="number">0</span>] &amp;&amp; cnt[<span class="number">2</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> (cnt[<span class="number">0</span>] &gt;= cnt[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">solve</span>(&#123;s[<span class="number">0</span>], s[<span class="number">0</span>] + s[<span class="number">2</span>], s[<span class="number">1</span>]&#125;, &#123;cnt[<span class="number">0</span>] - cnt[<span class="number">2</span>], cnt[<span class="number">2</span>], cnt[<span class="number">1</span>]&#125;);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">solve</span>(&#123;s[<span class="number">0</span>] + s[<span class="number">2</span>], s[<span class="number">1</span>], s[<span class="number">2</span>]&#125;, &#123;cnt[<span class="number">0</span>], cnt[<span class="number">1</span>], cnt[<span class="number">2</span>] - cnt[<span class="number">0</span>]&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!cnt[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> (!cnt[<span class="number">1</span>]) <span class="keyword">return</span> s[<span class="number">2</span>] * cnt[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">solve</span>(&#123;s[<span class="number">1</span>], <span class="string">&quot;&quot;</span>, s[<span class="number">2</span>]&#125;, &#123;cnt[<span class="number">1</span>], <span class="number">0</span>, cnt[<span class="number">2</span>]&#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!cnt[<span class="number">1</span>]) <span class="keyword">return</span> s[<span class="number">0</span>] * cnt[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">solve</span>(&#123;s[<span class="number">0</span>], <span class="string">&quot;&quot;</span>, s[<span class="number">1</span>]&#125;, &#123;cnt[<span class="number">0</span>], <span class="number">0</span>, cnt[<span class="number">1</span>]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> A, B, C;</span><br><span class="line">std::cin &gt;&gt; A &gt;&gt; B &gt;&gt; C;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">solve</span>(&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;, &#123;A, B, C&#125;) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;神秘贪心 + 构造题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>AT Code Festival 2017 Qual B E Popping Balls</title>
    <link href="https://mydcwfy.github.io/2022/07/07/AT-Code-Festival-2017-Qual-B-E/"/>
    <id>https://mydcwfy.github.io/2022/07/07/AT-Code-Festival-2017-Qual-B-E/</id>
    <published>2022-07-07T08:45:24.000Z</published>
    <updated>2022-07-07T09:52:14.398Z</updated>
    
    <content type="html"><![CDATA[<p>组合数学真有趣。</p><span id="more"></span><p>题意：现在有 $A + B$ 个球组成的序列，前 $A$ 个是红色的，后 $B$ 个是蓝球，你可以在开始时选定两个数 $s, t$，你可以从 $1, s, t$ 三个位置取出球。问取出球的不同序列的个数，对 $10 ^ 9 + 7$ 取模。$A, B\leq 2000$。</p><p>其实注意到我们并不能直接枚举 $s, t$ 计算，因为不同的 $s, t$ 可能得到相同的结果。考虑另外的转换方式。</p><p>首先注意到在 $len \geq t$ 的时候，$s$ 是没有意义的，因为它如果拿走的是红球，可以被 1 所替代，如果拿的是蓝球，可以被 $t$ 所替代，所以我们可以只先考虑 $t$ 取的情况。</p><p>我们想要得到最多的序列，那么我们把 $t$ 放在第一个蓝球的位置（后面还有 $B$ 个），这样位置 1 和 位置 $t$ 一共可以取 $B$ 次，然后位置 $t$ 就没有用了。注意到除了我们钦定了第一次为蓝球外，每一次我们都可以在红球和蓝球之间任意选择，这时候的选择面是最广的，可以覆盖到其他情况。</p><p>假设我们前面取了 $i$ 个蓝球，那么等到 $s$ 取的时候，和 $t$ 的情况类似，但是只剩下 $B - i$ 个蓝球了，和刚才一样，我们从 $B - i$ 次机会中选择 $j$ 种，选完$B - i$ 次过后就只剩 1 位置可以选了。</p><p>我们现在相当于是只考虑了蓝球的情况，还需要考虑红球的情况。红球有 3  个去向：在 $t$ 拿到第一个蓝球之前，在 $s$ 和 $t$ 之间，在 $s$ 选完的后面。$t$ 选择的时候消耗了 $B - i$ 个红球，$s$ 选择的时候消耗了 $B - i - j$ 个红球（消耗是指混在蓝球当中的那些红球），那么剩下了 $A - 2\times B + 2\times i + j$ 个红球可以放在三个位置。利用插板法可以得到贡献。</p><p>最后由于 $s, t$ 可能取不到一个蓝球，注意到这时的蓝球一定是一段的，贡献为 $A + 1$。</p><p>于是最后的答案为：<br>$$<br>\sum_{i = 1} ^ B \sum_{j = 1} ^ {B - i} \binom Bi \binom{B - i} j \binom {A - 2\times B + 2\times i + j + 2}2 + A + 1<br>$$<br>直接计算即可，时间复杂度 $O(A + B ^ 2)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">int</span> A, B, res = <span class="number">0</span>;</span><br><span class="line">std::cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i + j &lt;= B; ++ j)</span><br><span class="line">res = (res + (LL) <span class="built_in">C</span>(B - <span class="number">1</span>, i - <span class="number">1</span>) * <span class="built_in">C</span>(B - i - <span class="number">1</span>, j - <span class="number">1</span>) % Mod</span><br><span class="line">* <span class="built_in">C</span>(A - <span class="number">2</span> * B + <span class="number">2</span> * i + j + <span class="number">2</span>, <span class="number">2</span>)) % Mod;</span><br><span class="line">res = (res + A + <span class="number">1</span>) % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;组合数学真有趣。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>CF643F Bears and Juice</title>
    <link href="https://mydcwfy.github.io/2022/07/06/CF643F/"/>
    <id>https://mydcwfy.github.io/2022/07/06/CF643F/</id>
    <published>2022-07-06T13:55:08.000Z</published>
    <updated>2022-07-06T14:12:19.291Z</updated>
    
    <content type="html"><![CDATA[<p>有趣的信息量分析 + 组合数学题目。</p><span id="more"></span><p>题意：有一些个酒桶，有一个是酒，另外的都是果汁，有 $n$ 只熊玩游戏，每天可以选择一些酒桶集合（可以为空），倒出一杯喝掉，如果喝到了酒就会睡觉到游戏结束，并且不能超过 $p$ 只熊在睡觉，否则判为失败。如果至少有一只熊没有睡觉，并且他能判断哪一个是酒，就算游戏胜利。问给 $t$ 天时间，这些熊最多能辨别多少个酒桶。你需要给出 $t\in [1, q]$ 的答案，并将 $\oplus i\times ans_i$ 输出，对 $2 ^ {32}$ 取模。$n\leq 10 ^ 9$，$p\leq 130$，$q\leq 2\times 10 ^ 6$。</p><p>考虑最大的信息量，$n$ 只熊有 $i$ 只睡着了，有 $\binom ni$ 种情况；这 $i$ 只熊可以在 $[1, t]$ 的时间内任意一天开始睡觉，得到的信息量为 $t ^ i$。那么就可以得到：<br>$$<br>ans_t = \sum_{i = 0} ^ {\min\{n - 1, p\}} \binom ni t ^ i<br>$$<br>这个为什么是对的呢？首先容易发现这是上界，因为我们最多只能得到这么多的信息，能区分的也就只有这么多了。</p><p>下面我们需要干的事情就是构造一种方案使得正好能区分这么多的信息量。考虑对所有情况编一个号，它对应着选出了哪些熊睡觉，还有睡觉的那些熊多久开始睡觉。没有被选中的始终不会碰这一个酒桶；被选中的熊会在自己对应的天数选中这个酒桶。容易发现不同的酒桶其实是独立的，因为我可以选择任意多的酒桶。</p><p>那么我们就得到了构造，也就得到了答案。下面考虑如何计算。</p><p>其实 $t ^ i$ 这一部分是简单的，可以在 $O(pq)$ 的时间内做完，可以承受。计算 $\displaystyle \binom ni$ 可以拆成下降幂除以阶乘的形式，然后暴力枚举两个数并约分。注意到这个是整数，所以一定是合法的。求解单个的复杂度为 $O(p ^ 2\log n)$，可以接受。</p><p>总时间复杂度 $O(p ^ 3\log n + pq)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">C</span><span class="params">(uint n, uint m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::vector&lt;uint&gt; <span class="title">a</span><span class="params">(m)</span>, <span class="title">b</span><span class="params">(m)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; m; ++ i) a[i] = n - i;</span><br><span class="line"><span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; m; ++ j) b[j] = j + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (uint &amp;x : a)</span><br><span class="line"><span class="keyword">for</span> (uint &amp;y : b) &#123;</span><br><span class="line">uint G = <span class="built_in">Gcd</span>(x, y);</span><br><span class="line">x /= G, y /= G;</span><br><span class="line">&#125;</span><br><span class="line">uint res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (uint &amp;x : a) res *= x;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; p &gt;&gt; T;</span><br><span class="line">uint ed = std::<span class="built_in">min</span>(n - <span class="number">1</span>, p);</span><br><span class="line"><span class="function">std::vector&lt;uint&gt; <span class="title">bn</span><span class="params">(ed + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt;= ed; ++ i) bn[i] = <span class="built_in">C</span>(n, i);</span><br><span class="line">uint res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (uint t = <span class="number">1</span>; t &lt;= T; ++ t)</span><br><span class="line">&#123;</span><br><span class="line">uint ans = <span class="number">0</span>, cur = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt;= ed; ++ i, cur *= t) ans += cur * bn[i];</span><br><span class="line">res ^= ans * t;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有趣的信息量分析 + 组合数学题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>LOJ2143 [SHOI2017]组合数问题</title>
    <link href="https://mydcwfy.github.io/2022/07/06/LOJ2143/"/>
    <id>https://mydcwfy.github.io/2022/07/06/LOJ2143/</id>
    <published>2022-07-06T13:34:42.000Z</published>
    <updated>2022-07-06T13:54:06.290Z</updated>
    
    <content type="html"><![CDATA[<p>有意思的一道题目，做法比较多。</p><span id="more"></span><p>题意：求：<br>$$<br>\sum_{i = 0} ^ n [i\bmod k = r] \binom ni \bmod p<br>$$<br>$n\leq 10 ^ 9$，$k\leq 50$，$p &lt; 2 ^ {30}$。</p><h3 id="做法-1：单位根反演"><a href="#做法-1：单位根反演" class="headerlink" title="做法 1：单位根反演"></a>做法 1：单位根反演</h3><p>看到 $[i\bmod k = r]$，果断单位根反演。<br>$$<br>\begin{aligned}<br>&amp;\sum_{i = 0} ^ n [i\bmod k = r] \binom ni\\<br>=&amp; \sum_{i = 0} ^ n \binom ni \dfrac 1k \sum_{j = 0} ^ {k - 1} \omega_k ^ {ij - rj}\\<br>=&amp; \dfrac 1k \sum_{j = 0} ^ {k - 1} \omega_k ^ {-rj} \sum_{i = 0} ^ n \binom ni \omega_k ^ {ij}\\<br>=&amp; \dfrac 1k \sum_{j = 0} ^ {k - 1} \omega_k ^ {-rj} (\omega_k ^ {j} + 1) ^ n<br>\end{aligned}<br>$$<br>但是我们前面说到 $k|p - 1$ 才有单位根，那怎么办呢？其实可以直接能成一个多项式的形式，类似于 $\sum_{i = 0} ^ {k - 1} a_i \omega_k ^ {i}$ 来代替单个数，这样可以实现乘法加法运算，可以得到最终解、</p><p>有一个问题就是最后的数不一定是只有 $\omega_k ^ {0}$ 位置有数，但是我们前面有看到答案一定是整数。这里可以按照 $\sum_{i = 0 } ^ {k - 1}\omega_k ^ {i} = 0$，$\omega_k ^ {\frac k2} = -1$ 等式子化简，可以证明最后一定可以得到正确答案。另外一个问题就是 $\dfrac 1k$ 并不好处理、一个神秘的办法是按照 $p\times k$ 取模计算，由于答案是整数，直接 最后 $\times \dfrac 1k$ 即可。</p><p>时间复杂度 $O(k ^ 3\log n)$ 或者是 $O(k ^ 2\log k\log n)$，有没有更优的还没有细究。</p><p>代码写了但是没写对，有时间来重写（</p><h3 id="做法-2：矩阵乘法"><a href="#做法-2：矩阵乘法" class="headerlink" title="做法 2：矩阵乘法"></a>做法 2：矩阵乘法</h3><p>我们可以看到 $\displaystyle \binom ni$ 的组合意义，就是走 $n$ 步，每一次可以走到 $(i + 1, j)$ 或者是 $(i + 1, j + 1)$，最后走到了 $(n, i)$ 这个位置的方案数。而这个式子又是可以通过递推得到的。</p><p>然后怎么把 $\bmod k = r$ 加进去呢？我们就强制走到 $(x, k)$ 就是 $(x, 0)$，这样最后回到 $r$ 这个位置的方案数就是答案。</p><p>我们就可以很容易的写出矩阵的转移方程， 矩阵乘法即可，时间复杂度 $O(k ^ 3\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; a;</span><br><span class="line"><span class="built_in">Matrix</span>() : <span class="built_in">a</span>(k, std::vector&lt;<span class="keyword">int</span>&gt;(k)) &#123;&#125;</span><br><span class="line"><span class="keyword">auto</span>&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> a[x]; &#125;</span><br><span class="line">Matrix <span class="keyword">operator</span> *(Matrix b) <span class="keyword">const</span> &#123;</span><br><span class="line">Matrix res;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; k; ++ l)</span><br><span class="line">res[i][l] = (res[i][l] + (LL) a[i][j] * b[j][l]) % Mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">qpow</span><span class="params">(Matrix a, LL d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Matrix res;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i) res[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; d; d &gt;&gt;= <span class="number">1</span>, a = a * a)</span><br><span class="line"><span class="keyword">if</span> (d &amp; <span class="number">1</span>) res = res * a;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; Mod &gt;&gt; k &gt;&gt; r, n *= k;</span><br><span class="line">Matrix trs;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i) trs[i][(i + <span class="number">1</span>) % k] ++, trs[i][i] ++;</span><br><span class="line">trs = <span class="built_in">qpow</span>(trs, n);</span><br><span class="line">std::cout &lt;&lt; trs[<span class="number">0</span>][r] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="做法-3：生成函数"><a href="#做法-3：生成函数" class="headerlink" title="做法 3：生成函数"></a>做法 3：生成函数</h3><p>看到组合数，我们很自然的（？）就想到了二项式定理，那么不考虑模数的话，生成函数就是 $(1 + x) ^ n$，然后如果需要得到次数 $\bmod k$ 的结果，直接对长度为 $k$ 的多项式循环卷积即可。</p><p>暴力卷积 $O(k ^ 2\log n)$，使用 <a href="/2022/06/21/BlueStein-Algorithm/">BlueStein 算法</a> 循环卷积可以做到 $O(k\log k)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">poly <span class="keyword">operator</span> *(poly a, poly b) &#123;</span><br><span class="line">    <span class="function">poly <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++ j)</span><br><span class="line">            res[(i + j) % k] = (res[(i + j) % k] + (LL) a[i] * b[j]) % Mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; Mod &gt;&gt; k &gt;&gt; r, n *= k;</span><br><span class="line">    <span class="function">poly <span class="title">st</span><span class="params">(k)</span>, <span class="title">a</span><span class="params">(k)</span></span>;</span><br><span class="line">    a[<span class="number">0</span>] ++, a[<span class="number">1</span> % k] ++, st[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>, a = a * a)</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            st = st * a;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; st[r] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有意思的一道题目，做法比较多。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="矩阵乘法" scheme="https://mydcwfy.github.io/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"/>
    
    <category term="生成函数" scheme="https://mydcwfy.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
    <category term="单位根反演" scheme="https://mydcwfy.github.io/tags/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>LOJ2142 [SHOI2017]相逢是问候</title>
    <link href="https://mydcwfy.github.io/2022/07/06/LOJ2142/"/>
    <id>https://mydcwfy.github.io/2022/07/06/LOJ2142/</id>
    <published>2022-07-06T10:46:52.000Z</published>
    <updated>2022-07-06T11:14:28.429Z</updated>
    
    <content type="html"><![CDATA[<p>神秘扩展欧拉定理 + 均摊线段树。</p><span id="more"></span><p>题意：维护一个长度为 $n$ 的序列 $a$，修改是对 $[l, r]$ 将 $a_i$ 变为 $c ^ {a_i}$，或者询问 $\sum_{i = l} ^ r a_i$，输出 $\bmod p$ 的答案就可。$n, c$ 开始给定，$n, q\times 5\times 10 ^ 4$，$p\leq 10 ^ 8$。</p><p>显然 $a_i$ 的值仅和 $a_i$ 的初始值以及修改操作覆盖的次数有关。看到如此庞大的数，考虑扩展欧拉定理：$a ^ n\equiv a ^ {n\bmod \varphi(p) + \varphi(p)}\pmod p$，这时需要保证 $n\geq \varphi(p)$。</p><p>如果不操作，那么和 $a_i\bmod p$ 的值有关；如果操作一次，和 $a_i\bmod \varphi(p)$ 有关；如果操作两次，即 $c ^ {a_i}\bmod \varphi(p)$ 有关，即 $a_i\bmod \varphi(\varphi(p))$ 有关……这样下去，当 $\varphi(\varphi…(p)) = 1$ 的时候，这个答案和 $a_i$ 和操作次数都没有关了，它变成了一个定值（和操作次数无关是因为再操作相当于修改 $a_i$，没有什么用了）。</p><p>这样我们只需要维护前几次操作。大概是多少次呢？</p><blockquote><p>结论：该深度为 $O(\log p)$ 级别。</p><p>证明：对于偶数来说，$\varphi(p)\leq \dfrac p2$；对于奇数来说，$2|\varphi(p)$，可以由 $\varphi(p)$ 的定义式得到。</p></blockquote><p>这样我们就只需要暴力计算前 $O(\log n)$ 项即可。计算由于是暴力计算，而且不能利用前面的信息，只能依次按照原式计算。时间复杂度 $O(n\log ^ 3 n + q\log n)$，不太能过。</p><p>注意到我们的一个 $\log$ 是来自于快速幂的，但是容易发现底数只有一种，模数只有 $O(\log p)$ 种，于是光速幂预处理，可以做到 $O(n\log ^ 2 n + q\log n + \sqrt q\log p)$，可以通过。</p><p>注意扩展欧拉定理只能在 $n\geq \varphi(p)$ 时才能使用，所以需要判断指数是否 $\geq \varphi(p)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LPow</span> &#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">32768</span>;</span><br><span class="line"><span class="keyword">int</span> sk[B], bk[B], Mod;</span><br><span class="line"><span class="built_in">LPow</span>() : <span class="built_in">Mod</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _Mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Mod = _Mod;</span><br><span class="line">sk[<span class="number">0</span>] = bk[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; B; ++ i) sk[i] = (LL) sk[i - <span class="number">1</span>] * c % Mod;</span><br><span class="line">bk[<span class="number">1</span>] = (LL) sk[B - <span class="number">1</span>] * c % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; B; ++ i) bk[i] = (LL) bk[i - <span class="number">1</span>] * bk[<span class="number">1</span>] % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lpow</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> bk[x &gt;&gt; <span class="number">15</span>] * (LL) sk[x &amp; (B - <span class="number">1</span>)] % Mod; &#125;</span><br><span class="line">&#125; lp[<span class="number">70</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / i; ++ i)</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">res /= i, res *= (i - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n ^ <span class="number">1</span>) res /= n, res *= (n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r, cnt, sum;</span><br><span class="line">&#125; tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">adj</span>(tr[x].sum  = tr[x &lt;&lt; <span class="number">1</span>].sum + tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum - Mod);</span><br><span class="line">tr[x].cnt = std::<span class="built_in">min</span>(tr[x &lt;&lt; <span class="number">1</span>].cnt, tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[x] = &#123;l, r, <span class="number">0</span>, a[l]&#125;;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].cnt &gt; lim || tr[x].l &gt; r || tr[x].r &lt; l) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l == tr[x].r) &#123;</span><br><span class="line">tr[x].cnt ++;</span><br><span class="line"><span class="keyword">int</span> cur = a[tr[x].l];</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = tr[x].cnt; i; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = cur;</span><br><span class="line">LL res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (tmp -- &amp;&amp; !flag) &#123;</span><br><span class="line">res *= c;</span><br><span class="line"><span class="keyword">if</span> (res &gt;= lp[i].Mod) &#123;</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cur = lp[i].<span class="built_in">lpow</span>(cur);</span><br><span class="line"><span class="keyword">if</span> (flag || lp[i].Mod == <span class="number">1</span>) cur += lp[i].Mod;</span><br><span class="line">&#125;</span><br><span class="line">tr[x].sum = cur % Mod;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span>, l, r), <span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt; r || tr[x].r &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> tr[x].sum;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">adj</span>(tmp = <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span>, l, r) + <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r) - Mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;神秘扩展欧拉定理 + 均摊线段树。&lt;/p&gt;</summary>
    
    
    
    
    <category term="线段树" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="均摊" scheme="https://mydcwfy.github.io/tags/%E5%9D%87%E6%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>LOJ2988 [CTSC2016]萨菲克斯 · 阿瑞</title>
    <link href="https://mydcwfy.github.io/2022/07/06/LOJ2988/"/>
    <id>https://mydcwfy.github.io/2022/07/06/LOJ2988/</id>
    <published>2022-07-06T09:40:24.000Z</published>
    <updated>2022-07-06T10:32:01.870Z</updated>
    
    <content type="html"><![CDATA[<p>奇怪的后缀数组计数。</p><span id="more"></span><p>题意：给定 $m$ 中互不相同的字符，每一个字符有 $c_i$ 个，问所有由这些字符组成的长度为 $n$ 的字符串中，不同的后缀数组有多少个。对 $10 ^ 9 + 7$ 取模，$n, m\leq 500$。</p><p>后缀数组是不好统计的，考虑如何将后缀数组转化为其他的一些东西。注意到我们可以把后缀数组不同位置的关系一一找出来，那么 $n$ 个字符就可以转化为一个不等式链。具体的，如果 $sa_{i + 1} + 1$ 排名比 $sa_i + 1$ 小，那么 $s_{sa_i} &lt; s_{sa_{i + 1}}$，否则 $s_{sa_i}\leq s_{sa_{i + 1}}$。</p><p>注意到一个“满”的不等式链一定和一个后缀数组形成双射，其中“满”表示每一处的 $&lt;$ 都确实是 $&lt;$，不能变成 $\leq$。</p><p>现在我们就可以通过不等式链的方案数来反向计算后缀数组的个数。假设我们已经出现了 $k - 1$ 个 $&lt;$，将原不等式链分成了 $k$ 段，分别为 $a_1, a_2\cdots, a_k$，那么不等式链的方案数就是 $\dfrac{n!}{\prod_{i = 1} ^ k a_i!}$。</p><p>这样看似很对，但是注意到一个问题：我们在计算 $k$ 段的时候，可能中间某些 $&lt;$ 是不必要的，也就是说，在某些情况下，这个 $&lt;$ 其实是一个 $\leq$，它并不是“满”的。这样就有可能算重了，因为不是“满”的就有可能被“满”的方案重新算一次，而这两个对应的后缀数组又是相同的。</p><p>另外一个可能算重的地方就是如果 $c_i$ 未用完，但是 $i$ 和 $i + 1$ 的交界处确实用的是 $\leq$，那么这个也是算重了的，因为我们可以把 $i + 1$ 替换成 $i$，这样就会算重。</p><p>接下来我们考虑刚才的 $\leq$ 和 $&lt;$ 的算重问题。因为我们无法限制某一个位置一定是 $&lt;$，所以只好考虑容斥，如果我们把 $x$ 个 $&lt;$ 强制变为了 $\leq$，那么贡献需要乘上 $(-1) ^ x$。</p><p>接下来的事情就是比较套路的 DP 优化容斥了。设 $f(i, j, k)$ 表示考虑到第 $i$ 个字符，目前长度为 $j$，最后一段 $\leq$ 链长度为 $k$ 的方案数。注意我们这里使用类似于 EGF 的办法，先把所有的 $\dfrac{1}{a_i!}$ 乘起来，最后乘 $n!$。考虑转移：</p><ol><li>正常的把这一段 $c_i$ 个全部接在前面 $\leq$ 链上：$f(i, j, k) \times 1\to f(i + 1, j + c_i, k + c_i)$。</li><li>可能只选择一部分，直接将该 $\leq$ 链正常结束：$f(i, j, k)\times \dfrac1{(k + l)!}\to f(i + 1, j + l, 0)$，其中 $l\in [0, c_i]$。</li><li>可能只选择一部分，本应该是 $&lt;$，但是容斥为 $\leq$：$f(i, j, k) \times -1\to f(i + 1, j + l, k + l)$。</li></ol><p>直接转移是 $O(n ^ 3 m)$ 的，可以考虑前缀和，把 $(j, k)$ 看作二维平面，那么第 2、3 部分计算的都是对角线的一部分，按照对角线方向前缀和即可做到 $O(n ^ 2m)$，可以通过。</p><p>不得不说，这道题<strong>后缀数组转化为不等式链</strong>的方法还是很巧妙的，另外 DP 优化容斥还是一个不错的题目。注意 $c_i = 0$ 时需要跳过，不然可能出现奇怪的无法转移的错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, c + i);</span><br><span class="line"><span class="keyword">if</span> (!c[i]) -- i, -- m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// f_&#123;j, k&#125; *-1 -&gt; f_&#123;j + l, k + l&#125;,</span></span><br><span class="line"><span class="comment">// *infact[k + l] -&gt; f_&#123;j + l, 0&#125; </span></span><br><span class="line"><span class="comment">// -&gt; f_&#123;j + cnt, k + cnt&#125;</span></span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> c = ::c[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; ++ k)</span><br><span class="line">&#123;</span><br><span class="line">sum[j][k] = f[j][k];</span><br><span class="line"><span class="keyword">if</span> (j &amp;&amp; k) <span class="built_in">adj</span>(sum[j][k] += sum[j - <span class="number">1</span>][k - <span class="number">1</span>] - Mod);</span><br><span class="line">f[j][k] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= j; ++ k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">adj</span>(f[j][k] -= sum[j - <span class="number">1</span>][k - <span class="number">1</span>]);</span><br><span class="line">f[j][<span class="number">0</span>] = (f[j][<span class="number">0</span>] + (LL) sum[j - <span class="number">1</span>][k - <span class="number">1</span>] * infact[k]) % Mod;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= c &amp;&amp; k &gt;= c)</span><br><span class="line"><span class="built_in">adj</span>(f[j][k] += sum[j - c][k - c] - Mod);</span><br><span class="line"><span class="keyword">if</span> (j &gt; c &amp;&amp; k &gt; c)</span><br><span class="line">f[j][<span class="number">0</span>] = (f[j][<span class="number">0</span>] + (LL) sum[j - c - <span class="number">1</span>][k - c - <span class="number">1</span>] * (Mod - infact[k])) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">adj</span>(res += f[n][<span class="number">0</span>] - Mod);</span><br><span class="line">&#125;</span><br><span class="line">res = (LL) res * fact[n] % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;奇怪的后缀数组计数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="后缀数据结构" scheme="https://mydcwfy.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>CF Round#779</title>
    <link href="https://mydcwfy.github.io/2022/07/04/CF-Round-779/"/>
    <id>https://mydcwfy.github.io/2022/07/04/CF-Round-779/</id>
    <published>2022-07-04T12:48:54.000Z</published>
    <updated>2022-07-05T01:35:43.558Z</updated>
    
    <content type="html"><![CDATA[<p>赛时 E 看错题了……</p><p>赛时进度：ABCD1D2 Accepted。</p><p>赛后进度：All Accepted。</p><span id="more"></span><p>可能会和官方题解做法不同，欢迎 Hack。</p><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：在一个 01 序列中，至少插入多少个数才能使得任意一段子区间 0 的个数都不超过 1 的个数。</p><p>赛时直接降智，还先做的 B 再回来做的 A，实时排名达到了 4000+。</p><p>容易发现两个 0 之间至少有 2 个 1，不够的塞满。容易发现这样操作过后，其他区间也是合法的。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：问有多少个长度为 $n$ 的排列满足：<br>$$<br>\gcd(1\times p_1, 2\times p_2, \cdots, n\times p_n) \ne 1<br>$$<br>$T(T\leq 1000)$ 组数据，$n\leq 1000$。</p><p>观察样例，发现奇数答案都为 0，考虑从奇偶性入手。</p><p>假设 $n$ 是偶数，那么有 $\dfrac n2$ 个奇数，容易发现这些数必须全部放在偶数位置才能保证 $\gcd$ 包含 2。而想要包含更大的质因数，比如 3，只有 $\dfrac n3$ 个位置，却有 $\dfrac {2n}3$ 个数必须放在 3 的倍数的位置，就不可能。</p><p>那么 $n$ 是偶数时，所有奇数必须放在偶数位置，那么答案就是 $(\dfrac n2!) ^ 2$。</p><p>当 $n$ 是奇数的时候，发现奇数多一个没地方放，所以答案就是 0。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给出一个排列，定义一个 $i$ 变换得到一个排列为 $\{p_{n - i + 1} , \cdots, p_n, p_1, \cdots, p_{n - i} \}$，已知 $i$ 变换后的不同的前缀最大值有 $c_i$ 个，问是否存在这样的排列。$\sum n\leq 10 ^ 5$。</p><p>我的想法是和题面反过来的，可能略有不适，请谅解。反转后容易转化为 $p$ 开始的循环排列前缀最大值。</p><p>首先注意到，假设 $n$ 在位置 $p$，那么 $p$ 这个位置前缀最大值的个数是 1，且没有其他位置前缀最大值个数是 1，因为有一个是自己，有一个是 $n$。</p><p>如果 $i$ 的前缀最大值个数是 $c_i$，那么我们可以发现 $i - 1$ 的前缀最大值的个数一定不超过 $c_i + 1$，因为类似于单调栈的，我们会弹出多个元素，但是只会加入一个元素。</p><p>那么我们就得到了该排列存在的必要条件了。欲证明其充分性，可以考虑构造一组合法解，像单调栈一样构造，这里不再展开。</p><p>注意实现的时候需要反过来（是有点小阴间）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">int</span> st = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (~st) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>));</span><br><span class="line">st = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!~st) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>));</span><br><span class="line"><span class="keyword">auto</span> nxt = [&amp;](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> x % n + <span class="number">1</span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> pre = [&amp;](<span class="keyword">int</span> x) &#123; <span class="built_in"><span class="keyword">return</span></span> (x + n - <span class="number">2</span>) % n + <span class="number">1</span>; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">nxt</span>(st); i != st; i = <span class="built_in">nxt</span>(i))</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; a[<span class="built_in">pre</span>(i)] + <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>));</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：已知一个区间 $[l, r]$ 和 $a_i\oplus x$，其中 $a_i$ 是一个 $[l, r]$ 的排列，但是 $x$ 未知，要求给出 $x$ 的一组合法解，保证存在。$0\leq l\leq r &lt; 2 ^ {17}$，D1 满足 $l = 0$。</p><p>看了一下，似乎和官方题解做法不同。</p><p>先考虑 D1 怎么做。都看到异或了，显然是和二进制有关。首先如果 $r + 1$ 是 2 的次幂，那么输出任意一个 $a_i\oplus x$ 都是合法的。否则 $r + 1$ 不是 2 的次幂，那么最高位 $t$ 一定会出现 1 的个数和 0 的个数不同的情况，而且有一边的个数是 $2 ^ t$（因为你把低端的都拿到了），如果是 1 的个数是 $2 ^ t$ 的话，为了把这个数变到 $[0, 2 ^ t - 1]$，我们需要 $\oplus 2 ^ t$。高位的直接递归下去做即可，时间复杂度 $O(r\log r)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; __builtin_ctz(n)) == n) <span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; (bit + <span class="number">1</span>)) &lt;= R) bit ++;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; sel1, sel2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : a)</span><br><span class="line"><span class="keyword">if</span> (x &gt;&gt; bit &amp; <span class="number">1</span>) sel1.<span class="built_in">push_back</span>(x ^ (<span class="number">1</span> &lt;&lt; bit));</span><br><span class="line"><span class="keyword">else</span> sel2.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>) sel1.<span class="built_in">size</span>() != (<span class="number">1</span> &lt;&lt; bit)) <span class="keyword">return</span> <span class="built_in">solve</span>(sel1, R ^ (<span class="number">1</span> &lt;&lt; bit));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">solve</span>(sel2, (R ^ <span class="number">1</span> &lt;&lt; bit)) ^ (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D2 相对于 D1 来说情况更复杂，主要是存在下界导致不再存在 $2 ^ t$ 这样好的性质了。如果你对刚才的流程比较熟悉的话，你会发现几个问题：</p><ol><li>还是像刚才一样划分了，如果两边的个数相同怎么办？</li><li>刚才有一边明摆着不用递归，现在两边都需要递归，如何确保复杂度及正确性？</li></ol><p>对于第一个问题，首先我们发现，这样的情况一定出现在类似 $\{2, 3, 4, 5\}$ 这样中间位置恰好是 2 的次幂的时候。可以证明我们现在两边递归都是可以的。因为如果我们翻转过来，其实相当于是在答案上 $\oplus 7$，其实还是正确的。</p><p>对于第二个问题，首先由于每一次处理一位，那么每一个数最多遍历 $O(\log r)$ 次，时间复杂度还是 $O(r\log r)$。</p><p>对于正确性，我们刚才说到如果 $l\oplus r$（在上一题中是 $r$）是 2 的次幂的话，我们随便返回一个 $a_i \oplus l$ 即可。但是这给实现起来带来了很大挑战。一个比较新奇的做法就是你返回最小的那个 $a_i\oplus l$，他的低位都是 0，然后和其他答案按位或起来，这样两边的答案就可以得到融合。由于题目保证有解，所以肯定不会出现无法合并的解被强行按位或。</p><p>这样就可以解决这个问题，时间复杂度 $O(r\log r)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; __builtin_ctz(n)) == n &amp;&amp; (L ^ (n - <span class="number">1</span>)) == R) &#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : a) <span class="built_in">chkmin</span>(res, x ^ L);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> bit = <span class="number">31</span> - __builtin_clz(L ^ R), ans = <span class="number">0</span>, mid = L | ((<span class="number">1</span> &lt;&lt; bit) - <span class="number">1</span>);</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; sel1, sel2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : a)</span><br><span class="line"><span class="keyword">if</span> (x &gt;&gt; bit &amp; <span class="number">1</span>) sel1.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="keyword">else</span> sel2.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>) sel1.<span class="built_in">size</span>() != (R &amp; ((<span class="number">1</span> &lt;&lt; bit) - <span class="number">1</span>)) + <span class="number">1</span>)</span><br><span class="line">std::<span class="built_in">swap</span>(sel1, sel2), ans ^= <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">solve</span>(sel2, L, mid) | <span class="built_in">solve</span>(sel1, mid + <span class="number">1</span>, R) | ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：给定一个 $n\times n$ 的网格，每个网格写了一个 $1\sim n \times n$ 的数字且各不相同。先手选择一个起点，得到该点权值（注意权值并不会消失），然后又后手走。后手选择的点必须满足和前一个点曼哈顿距离 $&gt; k$，可以重复走同一个点。问 $10 ^ {100}$ 步后谁会获胜，或者是平局。输出对于有每一个点，先手选择他开始的最后的结局。$n\leq 2000$。</p><p>考虑一个结论：</p><blockquote><p>如果这一步走到的点比出发点权值小，那么走该步的人一定会输。</p><p>证明：另外一个人走回去就一定获得正收益。</p></blockquote><p>这启示我们只能往更高点走，谁抢到了最高点谁就获胜。</p><p>首先先手如果选择在最高点开始，直接获胜<del>不给后手一点机会</del>。如果选择在距离最高点 $&gt;k$ 的位置，显然后手必胜。但是这么分析后面难度较大，考虑按照权值倒序枚举。</p><p>现在我们只能走到已经枚举过的点，如果我们能走到一个先手必败的场面，那么这个点就是先手获胜的，否则就是先手必负的。</p><p>如何判断在曼哈顿距离 $&gt; k$ 的位置有没有先手必败的点呢？到这里可以直接二维数点之类的办法，但是 $O(n ^ 2\log ^ 2 n)$ 能不能过有点看人品。</p><p>考虑<strong>曼哈顿距离的一个有趣结论：$|x_1 - x_2| + |y_1 - y_2| = \max\{x_1 + y_1 - (x_2 + y_2), x_1 - y_1 - (x_2 - y_2)\}$。</strong>你可以把坐标系旋转 45 度看看，就可以得到。</p><p>剩下的我们只需要找到是否所有先手必败的点和当前点的距离 $\leq k$，那么只需要维护 $\max\{x + y\}, \min\{x + y\}$，$\max\{x - y\}, \min\{x - y\}$ 就可以判断。时间复杂度 $O(n ^ 2\log n)$ 或 $O(n ^ 2)$，注意输入输出效率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">read</span>(n, k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) <span class="built_in">read</span>(a[i][j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">v[(i - <span class="number">1</span>) * n + j] = &#123;a[i][j], i, j&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(v + <span class="number">1</span>, v + n * n + <span class="number">1</span>, [&amp;](Node &amp;a, Node &amp;b) &#123;</span><br><span class="line"><span class="keyword">return</span> a.val &gt; b.val;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">int</span> mx1 = v[<span class="number">1</span>].i + v[<span class="number">1</span>].j, mn1 = mx1, mx2 = v[<span class="number">1</span>].i - v[<span class="number">1</span>].j, mn2 = mx2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n * n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = v[i].i, y = v[i].j;</span><br><span class="line"><span class="keyword">if</span> (mx1 &gt; x + y + k) dp[x][y] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (mn1 &lt; x + y - k) dp[x][y] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (mx2 &gt; x - y + k) dp[x][y] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (mn2 &lt; x - y - k) dp[x][y] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (!dp[x][y])</span><br><span class="line"><span class="built_in">chkmax</span>(mx1, x + y), <span class="built_in">chkmin</span>(mn1, x + y),</span><br><span class="line"><span class="built_in">chkmax</span>(mx2, x - y), <span class="built_in">chkmin</span>(mn2, x - y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3</span>] = <span class="string">&quot;MG&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i, <span class="built_in">write</span>(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) <span class="built_in">write</span>(s[dp[i][j]]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：给定一个长度为 $n$ 的 01 串，选出某些子区间（不能相交），要求长度和为 $m$，且 1 的占比和原串相同。最小化子区间数量并给出方案，或报告无解。</p><p>容易发现 1 的个数应该为 $\dfrac{mc_1}{n}$，$c_x$ 表示 $x$ 的出现次数。如果这步时整数，显然无解。</p><p>假设我们把这个看作是一个循环的串，那么有 $n$ 个不同的长度为 $m$ 的子串。</p><blockquote><p>结论 1：假设 $n$ 个子串中 1 个数最多有 $mx$ 个，最少有 $mn$ 个，则 $mn\leq \dfrac{mc_1}n \leq mx$。</p><p>证明：反证法，如果所有 1 个数都 $&lt;\dfrac{mc_1}{n}$（$&gt;\dfrac{mc_1}n$ 同理），那么把所有的加起来，容易发现所有数被覆盖了 $m$ 次，但是根据这个我们算出一定少于 $mc_1$ 个，矛盾。</p></blockquote><p>这个结论提示我们我们要找的可能只需要一个区间。</p><blockquote><p>结论 2：$[mn, mx]$ 每一个数都有一个对应的子串。</p><p>证明：考虑 $mn$ 产生的位置到 $mx$ 产生的位置的这段区间。主义党两个相邻的子串只有一个位置没有重合，也就是说变化量最多只有 1，而最前面是 $mn$，最后是 $mx$，只能一步一步变化，那么每一个位置都能覆盖到。</p></blockquote><p>这说明如果我们可以循环取的话，答案一定为 1。</p><blockquote><p>结论 3：原问题答案不超过 2。</p><p>证明：在这 $=\dfrac{mc_1}n$ 的长度为 $m$ 的子串中，每一个最多都只需要原串的 2 段就可以拼起来。</p></blockquote><p>剩下的就很好做了，我们先枚举原串长度为 $m$ 的子串，这些串的答案为 1，需要优先选，然后选择那些循环的串，这些串的答案为 2。容易发现根绝刚才的结论，一定有解。</p><p>这样就可以做了，时间复杂度 $O(n)$。实现时可以复制一倍做，很简洁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;n, &amp;m, s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">pre[i] = pre[i - <span class="number">1</span>] + (s[i] &amp; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i)</span><br><span class="line">pre[i] = pre[i - <span class="number">1</span>] + (s[i - n] &amp; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (m % (n / <span class="built_in">Gcd</span>(n, pre[n]))) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line"><span class="keyword">int</span> sel = (<span class="keyword">long</span> <span class="keyword">long</span>) m * pre[n] / n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= <span class="number">2</span> * n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pre[i] - pre[i - m] != sel) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (i &lt;= n) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1\n%d %d\n&quot;</span>, i - m + <span class="number">1</span>, i);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2\n%d %d\n%d %d\n&quot;</span>, <span class="number">1</span>, i - n, i - m + <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;赛时 E 看错题了……&lt;/p&gt;
&lt;p&gt;赛时进度：ABCD1D2 Accepted。&lt;/p&gt;
&lt;p&gt;赛后进度：All Accepted。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>LOJ2014 [SCOI2016]萌萌哒</title>
    <link href="https://mydcwfy.github.io/2022/07/01/LOJ2014/"/>
    <id>https://mydcwfy.github.io/2022/07/01/LOJ2014/</id>
    <published>2022-07-01T12:41:13.000Z</published>
    <updated>2022-07-02T03:15:32.381Z</updated>
    
    <content type="html"><![CDATA[<p>有趣的倍增 ST 表题目。</p><span id="more"></span><p>题意：有一个 $n$ 位数，$m$ 个限制表示 $[l_1, r_1]$ 和 $[l_2, r_2]$ 子区间是相同的。问有多少个 $n$ 位数满足这一条件。$n, m\leq 10 ^ 5$。</p><p>容易得到区间相同是由可合并性的，考虑将这个区间划分成 $O(\log n)$ 个区间来分别拆开做。但是一个很神秘的问题是我们如果使用线段树的话，两个算然都是 $O(\log n)$ 个区间，但是他们的个数、形态不完全相同，所以不能使用线段树。</p><p>怎么办呢？直接考虑对每一个位置建 $O(\log n)$ 个节点，表示 $[pos, pos + 2 ^ k - 1]$ 区间，这样我们就可以直接合并这两个区间就可以了。不考虑并查集的复杂度，那么就是 $O(m\log n)$。</p><p>然后考虑怎么把这个下放到每一个节点。首先我们当前状态下一定只有同层可能联通，假设处理到了 $k$ 层，那么我们考虑将这些区间的左右区间分别合并在一起，然后留给 $k - 1$ 层去做。这个似乎有点像线段树的懒标记的合并啊，思路还是比较妙的。</p><p>最后时间复杂度 $O((n + m)\log n)$，可以通过。注意首位不能为 0，答案为 $9\times 10 ^ {cnt - 1}$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; L; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; ++ i)</span><br><span class="line">id[st[i][j] = ++ tot] = i, f[tot] = tot;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l1, r1, l2, r2; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line"><span class="keyword">int</span> len = r1 - l1 + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span>; ~j; -- j)</span><br><span class="line"><span class="keyword">if</span> (len &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">merge</span>(st[l1][j], st[l2][j]), l1 += <span class="number">1</span> &lt;&lt; j, l2 += <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = L - <span class="number">1</span>; j; -- j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(st[i][j]) != st[i][j]) &#123;</span><br><span class="line"><span class="keyword">int</span> x = i, y = id[<span class="built_in">find</span>(st[i][j])];</span><br><span class="line"><span class="built_in">merge</span>(st[x][j - <span class="number">1</span>], st[y][j - <span class="number">1</span>]);</span><br><span class="line"><span class="built_in">merge</span>(st[x + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>], st[y + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, res = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(i) == i &amp;&amp; (++ cnt) &gt; <span class="number">1</span>) res = res * <span class="number">10LL</span> % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有趣的倍增 ST 表题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="倍增" scheme="https://mydcwfy.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>CF809E Surprise me!</title>
    <link href="https://mydcwfy.github.io/2022/06/30/CF809E/"/>
    <id>https://mydcwfy.github.io/2022/06/30/CF809E/</id>
    <published>2022-06-30T14:09:06.000Z</published>
    <updated>2022-07-01T03:26:43.484Z</updated>
    
    <content type="html"><![CDATA[<p>比较套路的莫比乌斯反演，以及虚树处理。</p><span id="more"></span><p>题意：给定一棵 $n$ 点的树，边权均为 1，每个点有一个权值 $a_i$ ,求：<br>$$<br>\dfrac{1}{n(n - 1)} \sum_{i = 1} ^ n \sum_{j = 1} ^ n \text{dist}(i, j) \varphi(a_ia_j)<br>$$<br>$n\leq 2\times 10 ^ 5$，保证 $a$ 是一个 $1\sim n$ 的排列。</p><p>首先一个重要的套路是<strong>数论函数内尽量不要有多个变量，尽量转化为单变量</strong>。</p><p>观察 $\varphi(n)$ 的定义式，容易知道这是 $n\prod_{p | n}(1 - \dfrac 1p)$，$p$ 是质数。先把 $(i, j)$ 连边直接连 $(a_i, a_j)$，这样就不用考虑编号问题了。如果 $i, j$ 同时有 $p$ 这个质因子，会乘两道 $1 - \dfrac 1p$，所以需要 $\gcd(i, j)$ 除掉一个。再自己凑一下就可以得到：<br>$$<br>\varphi(i\times j) = \dfrac{\varphi(i)\varphi(j)\gcd(i, j)} {\varphi(\gcd(i, j))}<br>$$<br>带入原式，看到 $\gcd$，直接暴力莫比乌斯反演：<br>$$<br>\begin{aligned}<br>&amp;\sum_{i = 1} ^ n\sum_{j = 1} ^ n \dfrac{\varphi(i) \varphi(j) \gcd(i, j)} {\varphi(\gcd(i, j))} \text{dist}(i, j)\\<br>=&amp; \sum_{d = 1} ^ n \dfrac{d}{\varphi(d)} \sum_{i = 1} ^ n \sum_{j = 1} ^ n [\gcd(i, j) = d] \varphi(i) \varphi(j) \text{dist}(i, j)\\<br>=&amp; \sum_{d = 1} ^ n \dfrac d{\varphi(d)} \sum_{k = 1} ^ {\frac nd} \sum_{kd | i} \sum_{kd | j} \mu(k) \varphi(i) \varphi(j) \text{dist}(i, j)\\<br>=&amp; \sum_{T = 1} ^ n \sum_{d | T} \dfrac{d\mu(\frac Td)}{\varphi(d)} \sum_{T | i} \sum_{T | j} \varphi(i) \varphi(j) \text{dist}(i, j)<br>\end{aligned}<br>$$<br>然后我们可以枚举 $T$，这样有用的节点就只有 $\dfrac nT$ 个了。我们相当于是求：<br>$$<br>\sum_{i = 1} ^ m\sum_{j = 1} ^ m v_i v_j\text{dist}(i, j)<br>$$<br>对这些节点建虚树计算，即可保证复杂度。具体的，直接考虑树形 DP，维护子树内的 $\varphi$ 和，以及子树内到他的距离乘 $\varphi$ 的和。这样就可以换根 DP 计算。</p><p>由于建虚树需要 $O(m\log m)$，$m$ 为总点数，那么最后复杂度为 $O(n\log ^ 2 n)$，可以通过。</p><p>坑点：注意虚树上有些节点是不能计算权值的，某些不是 $T$ 的节点应该把 $v$ 设为 0。虚树上的边权不为 1，转移略麻烦。注意清空，老问题了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SolvingLCA &#123;</span><br><span class="line"><span class="keyword">int</span> st[N &lt;&lt; <span class="number">1</span>][<span class="number">19</span>], lg[N &lt;&lt; <span class="number">1</span>], fi[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">st[++ cnt][<span class="number">0</span>] = x, fi[x] = cnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h1[x], v; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> ((v = e[i]) ^ fa) <span class="built_in">dfs</span>(v, x), st[++ cnt][<span class="number">0</span>] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dmin</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> fi[x] &lt; fi[y] ? x : y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++ i) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lg[cnt]; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= cnt; ++ i)</span><br><span class="line">st[i][j] = <span class="built_in">dmin</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (fi[x] &gt; fi[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line"><span class="keyword">int</span> k = lg[fi[y] - fi[x] + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dmin</span>(st[fi[x]][k], st[fi[y] - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> SolvingLCA::LCA;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span>&amp; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123; <span class="keyword">return</span> x += x &gt;&gt; <span class="number">31</span> &amp; Mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k = Mod - <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = (LL) a * a % Mod)</span><br><span class="line">(k &amp; <span class="number">1</span>) &amp;&amp; (res = (LL) res * a % Mod);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *h, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> *h, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c = <span class="number">1</span>)</span> </span>&#123; <span class="built_in">add</span>(h, a, b, c), <span class="built_in">add</span>(h, b, a, c); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">st[<span class="number">1</span>] = <span class="number">1</span>, phi[<span class="number">1</span>] = mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) prime[cnt ++] = i, phi[i] = i - <span class="number">1</span>, mu[i] = Mod - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; i * prime[j] &lt; N; ++ j)</span><br><span class="line">&#123;</span><br><span class="line">st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">phi[i * prime[j]] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">mu[i * prime[j]] = Mod - mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[x] = ++ *dfn, dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h1[x], v; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> ((v = e[i]) != fa) <span class="built_in">dfs</span>(v, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!top) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(stk[top = <span class="number">1</span>] = x);</span><br><span class="line"><span class="keyword">int</span> lca = <span class="built_in">LCA</span>(stk[top], x);</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; dep[stk[top - <span class="number">1</span>]] &gt; dep[lca])</span><br><span class="line"><span class="built_in">link</span>(h2, stk[top - <span class="number">1</span>], stk[top], dep[stk[top]] - dep[stk[top - <span class="number">1</span>]]), top --;</span><br><span class="line"><span class="keyword">if</span> (dep[stk[top]] &gt; dep[lca]) <span class="built_in">link</span>(h2, lca, stk[top], dep[stk[top]] - dep[lca]), top --;</span><br><span class="line"><span class="keyword">if</span> (lca != stk[top]) stk[++ top] = lca, extranodes.<span class="built_in">push_back</span>(lca);</span><br><span class="line">stk[++ top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sz[x] = val[x], dis[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h2[x], v; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> ((v = e[i]) != fa)</span><br><span class="line"><span class="built_in">dfs1</span>(v, x), <span class="built_in">adj</span>(sz[x] += sz[v] - Mod),</span><br><span class="line">dis[x] = (dis[x] + dis[v] + (LL) sz[v] * w[i]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa = <span class="number">0</span>, <span class="keyword">int</span> prew = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x != <span class="number">1</span>)</span><br><span class="line">tdis[x] = (tdis[fa] + (sz[<span class="number">1</span>] - <span class="number">2LL</span> * sz[x] + Mod) * prew) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h2[x], v; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> ((v = e[i]) ^ fa) <span class="built_in">dfs2</span>(v, x, w[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h1, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h1));</span><br><span class="line"><span class="built_in">memset</span>(h2, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h2));</span><br><span class="line"><span class="built_in">sieve</span>();</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v), u = a[u], v = a[v];</span><br><span class="line"><span class="built_in">link</span>(h1, u, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>), SolvingLCA::<span class="built_in">prework</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= n; ++ d)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * d &lt;= n; ++ i)</span><br><span class="line">mul[i * d] = (mul[i * d] + (LL) d * mu[i] % Mod * <span class="built_in">qpow</span>(phi[d])) % Mod;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, frmidx = idx;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= n; ++ d)</span><br><span class="line">&#123;</span><br><span class="line">allnodes.<span class="built_in">clear</span>(), extranodes.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &lt;= n; i += d)</span><br><span class="line">allnodes.<span class="built_in">push_back</span>(i), val[i] = phi[i];</span><br><span class="line">extranodes = allnodes;</span><br><span class="line">std::<span class="built_in">sort</span>(allnodes.<span class="built_in">begin</span>(), allnodes.<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line"><span class="keyword">return</span> dfn[x] &lt; dfn[y];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (d ^ <span class="number">1</span>) stk[top = <span class="number">1</span>] = <span class="number">1</span>, extranodes.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : allnodes) <span class="built_in">insert</span>(x);</span><br><span class="line"><span class="keyword">while</span> (-- top) <span class="built_in">link</span>(h2, stk[top], stk[top + <span class="number">1</span>], dep[stk[top + <span class="number">1</span>]] - dep[stk[top]]);</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>), tdis[<span class="number">1</span>] = dis[<span class="number">1</span>], <span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : allnodes)</span><br><span class="line">cur = (cur + (LL) phi[x] * tdis[x]) % Mod;</span><br><span class="line">res = (res + mul[d] * (LL) cur) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : allnodes) h2[x] = <span class="number">-1</span>, val[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : extranodes) h2[x] = <span class="number">-1</span>;</span><br><span class="line">idx = frmidx;</span><br><span class="line">&#125;</span><br><span class="line">res = (LL) res * <span class="built_in">qpow</span>(n * (n - <span class="number">1LL</span>) % Mod) % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;比较套路的莫比乌斯反演，以及虚树处理。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="莫比乌斯反演" scheme="https://mydcwfy.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
    <category term="虚树" scheme="https://mydcwfy.github.io/tags/%E8%99%9A%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>CF1109D Sasha and Interesting Fact from Graph Theory</title>
    <link href="https://mydcwfy.github.io/2022/06/30/CF1109D/"/>
    <id>https://mydcwfy.github.io/2022/06/30/CF1109D/</id>
    <published>2022-06-30T10:07:22.000Z</published>
    <updated>2022-07-01T03:27:02.015Z</updated>
    
    <content type="html"><![CDATA[<p>神秘 prufer 序列 + 组合数学。</p><span id="more"></span><p>题意：有多少棵 $n$ 个点的树，满足每一条边的边权在 $[1, m]$ 中，且满足 $a, b$ 的距离为 $m$。$n, m\leq 10 ^ 6$。</p><p>直接考虑 prufer 序列计算，首先枚举 $a, b$ 之间一共有多少点，设为 $d$，此时我们需要枚举 $a, b$ 之间的点分别是哪些，贡献为 $(n - 2) ^ \underline{d - 2}$。然后考虑中间的边权，容易得到 $d - 1$ 个的和为 $m$，那么就是 $\binom{m - 1}{d - 1}$。然后考虑剩下的贡献。注意到其实 $d$ 个点可以看作缩成了一个点，还剩 $n - d + 1$ 个点，只不过每次他的出现，可以有 $d$ 个可连。</p><p><strong>和度数相关，考虑 prufer 序列</strong>。先不管复杂度，考虑枚举 prufer 序列，枚举缩的大点在 prufer 序列中出现了 $j$ 次，那么贡献需要选 $j$ 个位置，为 $\binom{n - d - 1}{j}$，然后每个 $d$ 个点都可以连，为 $d ^ {j + 1}$（注意是出现次数 +1 为度数），剩下的点随便选，为 $(n - d)$ 种，总贡献为 $(n - d) ^ {n - d - j - 1}$。还有边权没有算，容易得到就是 $m ^ {n - d}$。</p><p>于是总贡献可以写作：<br>$$<br>\sum_{d = 2} ^ n (n - 2) ^ \underline{d - 2} \binom{m - 1}{d - 1}m ^ {n - d} \sum_{j = 0} ^ {n - d - 1} \binom{n - d - 1}j d ^ {j + 1} (n - d) ^ {n - d - j - 1}<br>$$<br>注意到后面的 $d ^ {j + 1}$ 去掉一个 $d$ 移到前面，后面就是一个二项式定理。可以写作：<br>$$<br>\sum_{d = 2} ^ n (n - 2) ^ \underline{d - 2} \binom{m - 1}{d - 1} m ^ {n - d} n ^ {n - d - 1}<br>$$<br>但是注意 $d = n$ 时会出锅，于是对 $d = n$，单独计算，为 $(n - 2)!\binom{m - 1}{n - 2}$。直接计算即可，时间复杂度 $O(n\log n)$ 或 $O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %*d %*d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">int</span> res = (LL) <span class="built_in">C</span>(m - <span class="number">1</span>, n - <span class="number">2</span>) * fact[n - <span class="number">2</span>] % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++ i)</span><br><span class="line">res = (res + (LL) <span class="built_in">qpow</span>(m, n - i) * <span class="built_in">C</span>(m - <span class="number">1</span>, i - <span class="number">2</span>) % Mod * fact[n - <span class="number">2</span>] % Mod</span><br><span class="line">* infact[n - i] % Mod * i % Mod * <span class="built_in">qpow</span>(n, n - i - <span class="number">1</span>)) % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;神秘 prufer 序列 + 组合数学。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="prufer 序列" scheme="https://mydcwfy.github.io/tags/prufer-%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P5219 无聊的水题 I</title>
    <link href="https://mydcwfy.github.io/2022/06/30/Luogu-P5219/"/>
    <id>https://mydcwfy.github.io/2022/06/30/Luogu-P5219/</id>
    <published>2022-06-30T08:37:33.000Z</published>
    <updated>2022-06-30T09:23:10.517Z</updated>
    
    <content type="html"><![CDATA[<p>prufer 序列 + 多项式重工业。</p><span id="more"></span><p>题意：求有多少棵大小为 $n$ 的有根树满足最大度数为 $m$。$n\leq 5\times 10 ^ 4$，$m\leq n$。</p><p>最大点度数为 $m$，显然可以转化为最大点度数 $\geq m$ 减去最大点度数 $\leq m - 1$ 的方案数。下面仅计算 $\leq m$ 的情况。</p><p><strong>树的计数的常用两个手段是 Matrix-Tree 矩阵树定理和 prufer 序列</strong>。考虑使用 prufer 序列计算。由于度数等于出现次数 +1，于是我们只需要限定每一个点的出现次数 $&lt;m$ 即可。</p><p>由于是同一个点出现多次只算一种方案，考虑使用 EGF，然后直接计算他的 $n$ 次方即可。直接使用倍增快速幂即可通过，似乎没必要使用什么 $\ln/\exp$ 的方法。</p><p>时间复杂度 $O(n\log ^ 2n)$ 或 $O(n\log n)$。并不卡常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lim &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="function">poly <span class="title">bs</span><span class="params">(lim + <span class="number">1</span>, <span class="number">1</span>)</span>, <span class="title">res</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; ++ i) bs[i] = (LL) bs[i] * infact[i] % Mod;</span><br><span class="line"><span class="keyword">int</span> k = n;</span><br><span class="line"><span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, bs = bs * bs, bs.<span class="built_in">resize</span>(std::<span class="built_in">min</span>((<span class="keyword">int</span>) bs.<span class="built_in">size</span>(), n - <span class="number">1</span>)))</span><br><span class="line"><span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * bs, res.<span class="built_in">resize</span>(std::<span class="built_in">min</span>((<span class="keyword">int</span>) res.<span class="built_in">size</span>(), n - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> res[n - <span class="number">2</span>] * (LL) fact[n - <span class="number">2</span>] % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">int</span> m, res;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">adj</span>(res = <span class="built_in">solve</span>(m - <span class="number">1</span>) - <span class="built_in">solve</span>(m - <span class="number">2</span>)));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;prufer 序列 + 多项式重工业。&lt;/p&gt;</summary>
    
    
    
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    <category term="prufer 序列" scheme="https://mydcwfy.github.io/tags/prufer-%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LOJ2106 [JLOI2015]有意义的字符串</title>
    <link href="https://mydcwfy.github.io/2022/06/30/LOJ2106/"/>
    <id>https://mydcwfy.github.io/2022/06/30/LOJ2106/</id>
    <published>2022-06-30T07:44:09.000Z</published>
    <updated>2022-06-30T08:32:40.932Z</updated>
    
    <content type="html"><![CDATA[<p>经典矩阵乘法计算无理数幂题目。</p><span id="more"></span><p>题意：求<br>$$<br>\lfloor (\dfrac{b + \sqrt d}2) ^ n \rfloor \bmod 7528443412579576937<br>$$<br>$b ^ 2\leq d &lt; (b + 1) ^ 2\leq 10 ^ {18}$，$b\bmod 2 = 1$，$d\bmod 4 = 1$。</p><p>首先样例给出了一个 $\dfrac{1 + \sqrt 5}{2}$（这个怎么不符合数据范围啊）的例子，我们很容易联想到计算 $(\dfrac {1 + \sqrt 5} 2) ^ n + (\dfrac {1 - \sqrt 5} 2) ^ n$，因为这是斐波那契数列的通项公式。</p><p>同样的，我们可以考虑计算 $(\dfrac{b + \sqrt d}2) ^ n + (\dfrac {b - \sqrt d}{2}) ^ n$ 的答案。容易发现这两个无理数其实是 $x ^ 2 - bx + \dfrac{b ^ 2 - d}{4} = 0$ 的两根。</p><p>然后给出一个经典结论：</p><blockquote><p>马上可以得到递推式为 $f_n = bf_{n - 1} + \dfrac{d - b ^ 2}4 f_{n - 2}$。</p></blockquote><p>证明可以考虑展开该式子。</p><blockquote><p>设 $a_1 = \dfrac{b + \sqrt d}2$，$a_2 = \dfrac{b - \sqrt d}2$，那么我们的答案就是 $a_1 ^ n + a_2 ^ n$。考虑化出 $a_1 ^ {n - 1} + a_2 ^ {n - 1}$，那么容易发现需要乘上一个 $a_1 + a_2$，但是还是会多一些项，我们整理一下，可以得到：<br>$$<br>a_1 ^ n - a_2 ^ n = (a_1 + a_2) (a_1 ^ {n - 1} + a_2 ^ {n - 1}) - a_1a_2(a_1 ^ {n - 2} + a_2 ^ {n - 2})<br>$$<br>于是代换为 $f_n$ 就可以得到上面的式子。至于为什么要扯到一元二次方程，是因为其实这个就是韦达定理（</p></blockquote><p>这样剩下的，我们只需要求出 $f_0, f_1$ 即可用矩阵乘法得到 $f_n$。</p><p>但是原问题还没完：怎么求得下取整的答案？</p><p>容易发现由于题目限制，我们很容易得到 $b - \sqrt d \in(-1, 0]$，那么显然 $(\dfrac{b - \sqrt d}2) ^ n$ 的绝对值 $&lt;1$。如果 $n$ 是偶数，并且 $b\not = \sqrt d$，那么加了一部分才得到 $f_n$，所以答案应 -1，否则不变。</p><p>注意模数很大，需要用龟速乘或者 <code>__int128</code> 计算乘法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL b, d, n;</span><br><span class="line">std::cin &gt;&gt; b &gt;&gt; d &gt;&gt; n;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>), <span class="number">0</span>;</span><br><span class="line">Matrix st;</span><br><span class="line">st[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>, st[<span class="number">1</span>][<span class="number">1</span>] = b, st[<span class="number">0</span>][<span class="number">1</span>] = (d - b * b) / <span class="number">4</span>;</span><br><span class="line">st = <span class="built_in">qpow</span>(st, n);</span><br><span class="line">LL res = ((s128) st[<span class="number">1</span>][<span class="number">0</span>] * b + (s128) <span class="number">2</span> * st[<span class="number">0</span>][<span class="number">0</span>]) % Mod;</span><br><span class="line"><span class="keyword">if</span> (!(n &amp; <span class="number">1</span>) &amp;&amp; d != b * b) res --;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典矩阵乘法计算无理数幂题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="矩阵乘法" scheme="https://mydcwfy.github.io/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LOJ2320 「清华集训 2017」生成树计数</title>
    <link href="https://mydcwfy.github.io/2022/06/30/LOJ2320/"/>
    <id>https://mydcwfy.github.io/2022/06/30/LOJ2320/</id>
    <published>2022-06-30T02:12:58.000Z</published>
    <updated>2022-06-30T06:44:22.926Z</updated>
    
    <content type="html"><![CDATA[<p>有难度的树上计数 + 多项式重工业。</p><span id="more"></span><p>题意：给定 $n$ 棵树，每棵树有 $a_i$ 个节点，随意连接 $n - 1$ 条边使得 $n$ 棵树联通，设连边后第 $i$ 棵树连边度数为 $d_i$，定义其权值为：<br>$$<br>(\prod_{i = 1} ^ n d_i ^ m) (\sum_{i = 1} ^ n d_i ^ m)<br>$$<br>求权值之和。$n\leq 3\times 10 ^ 4$，$m\leq 30$。</p><p>对 LOJ 讨论区题解的详细阐述，$m$ 可以 $10 ^ 9$。</p><p>首先不考虑 $\sum_{i = 1} ^ n d_i ^ m$ 怎么做。</p><p>直接考虑 prufer 序列，转化为序列问题，假设 $c_i$ 为 $i$ 出现的次数：<br>$$<br>\begin{aligned}<br>ans =&amp; (n - 2)! \prod_{i = 1} ^ n \dfrac{(c_i + 1) ^ m a_i ^ {c_i + 1}} {c_i!}\\<br>=&amp; (n - 2)!\prod_{i = 1} ^ n a_i \prod_{i = 1} ^ n \dfrac{(c_i + 1) ^ m a_i ^ {c_i}} {c_i!}<br>\end{aligned}<br>$$<br>考虑使用生成函数，设 $F_i(x)$ 表示 $i$ 树的生成函数，使用 EGF 即可得到：<br>$$<br>F_i(x) = \sum_{j = 0} \dfrac{(j + 1) ^ m (a_ix) ^ j}{j!}<br>$$<br>那么答案就是 $(n - 2)!\prod_{i = 1} ^ n a_i [x ^ {n - 2}] \prod_{i = 1} ^ n F_i(x)$。但是注意到有 $n$ 个生成函数，无法计算。</p><p>但是本题的生成函数有一个特殊的性质：$i$ 相关的只有 $(a_ix) ^ i$。这给我们一启示：按照 $a_ix$ 为一个整体先计算。</p><p>另外，所有都是乘法，不好做，<strong>乘转加使用 $\ln/\exp$，</strong>于是答案的生成函数可以写作：<br>$$<br>ans = (n - 2)!\prod_{i = 1} ^ n a_i [x ^ {n - 2}]\exp\sum_{i = 1} ^ n \ln F(a_i x)<br>$$<br>先计算出 $\ln F(a_i x)$，那么 $\ln$ 的和就可以写作：<br>$$<br>\sum_{i = 1} ^ n \ln F(a_ix) = \sum_{j = 0} x ^ j (\sum_{i = 1} ^ n a_i ^ j) [x ^ j]\ln F(a_ix)<br>$$<br>注意到有一个等幂和计算，于是可以套用 <a href="/2022/06/18/Luogu-P4705/">Luogu P4705 玩游戏</a> 的套路计算即可，于是我们可以在 $O(n\log ^ 2 n)$ 的时间内得出答案的生成函数。</p><p>然后考虑加上 $\sum_{i = 1} ^ n d_i ^ m$ 如何计算。分开考虑 $i$ 的贡献，那么其实是我们把 $F_i(x)$ 的生成函数相应部分去掉，然后加上 $G_i(x)$ 的贡献。$G_i(x)$ 的生成函数比较好表达，为：<br>$$<br>G_i(x) = \sum_{j = 0} \dfrac{(j + 1) ^ {2m} a_i ^ j x ^ j}{j!}<br>$$<br>那么整个的生成函数可以写作：<br>$$<br>(\sum_{i = 1} ^ n \dfrac{G_i(x)} {F_i(x)}) (\prod_{i = 1} ^ nF_i(x))<br>$$<br>容易发现这个 $G(x)$ 也可以使用类似于 $a_ix$ 绑定一起的方式计算，那么我们可以把 $\sum_{i = 1} ^ n\dfrac{G_i(x)}{F_i(x)}$ 用刚才求等幂和的算法求出来，最后把两个生成函数乘起来，就可以得到答案了。时间复杂度 $O(n\log ^ 2 n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> solve = [&amp;](<span class="keyword">auto</span> &amp;self, poly &amp;a, <span class="keyword">int</span> l, <span class="keyword">int</span> r) -&gt; poly &#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> &#123;<span class="number">1</span>, a[l]&#125;;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">self</span>(self, a, l, mid) * <span class="built_in">self</span>(self, a, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="function">poly <span class="title">a</span><span class="params">(n)</span>, <span class="title">f</span><span class="params">(n - <span class="number">1</span>)</span>, <span class="title">g</span><span class="params">(n - <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : a) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">p1</span><span class="params">(solve(solve, a, <span class="number">0</span>, n - <span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="keyword">int</span> res = p1.<span class="built_in">back</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++ i) res = (LL) res * i % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mul = <span class="built_in">qpow</span>(i + <span class="number">1</span>, m);</span><br><span class="line">f[i] = (LL) infact[i] * mul % Mod;</span><br><span class="line">g[i] = (LL) infact[i] * mul % Mod * mul % Mod;</span><br><span class="line">&#125;</span><br><span class="line">g = g * <span class="built_in">Inv</span>(f), g.<span class="built_in">resize</span>(n - <span class="number">1</span>), p1 = <span class="built_in">Ln</span>(p1), f = <span class="built_in">Ln</span>(f);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) <span class="built_in">adj</span>(p1[i] = -p1[i]);</span><br><span class="line">p1[i] = (LL) p1[i] * i % Mod;</span><br><span class="line">&#125;</span><br><span class="line">p1[<span class="number">0</span>] = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++ i)</span><br><span class="line">g[i] = (LL) g[i] * p1[i] % Mod, f[i] = (LL) f[i] * p1[i] % Mod;</span><br><span class="line">res = (LL) res * (<span class="built_in">Exp</span>(f) * g)[n - <span class="number">2</span>] % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有难度的树上计数 + 多项式重工业。&lt;/p&gt;</summary>
    
    
    
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    <category term="分治" scheme="https://mydcwfy.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="prufer 序列" scheme="https://mydcwfy.github.io/tags/prufer-%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>AT Code Festival 2017 Qual A F Squeezing Slimes</title>
    <link href="https://mydcwfy.github.io/2022/06/30/AT-Code-Festival-2017-Qual-A-F/"/>
    <id>https://mydcwfy.github.io/2022/06/30/AT-Code-Festival-2017-Qual-A-F/</id>
    <published>2022-06-30T01:12:44.000Z</published>
    <updated>2022-06-30T01:32:38.311Z</updated>
    
    <content type="html"><![CDATA[<p>有趣的结论题。</p><span id="more"></span><p>题意：目前有 $\sum_{i = 1} ^ n a_i$ 个 1，每次可以选定一个长度为 $2m$ 的区间，然后 1、2 合并，3、4 合并，最后剩下 $m$ 个数，称为一次操作。问最少多少次操作使得该序列变为 $a$。$n\leq 10 ^ 5$，$a_i\leq 10 ^ 9$。</p><p><a href="https://atcoder.jp/contests/code-festival-2017-quala/tasks/code_festival_2017_quala_f">题目传送门 AtCoder</a></p><p>正向不好做，考虑逆向变换。假设 $x$ 为当前这个处理的数，设 $c$ 为最大的满足 $2 ^ c \leq x$ 的数，如果 $2 ^ c = x$，那么我们可以把 $c$ 次操作和前后都一起分裂，否则的话，我们需要另外一次操作，且只能和一边一起分裂。</p><p>画一个分解 5 的图理解：</p><img src="/2022/06/30/AT-Code-Festival-2017-Qual-A-F/sample.png" class=""><p>这样我们前两次分裂操作都可以和前面和后面同步，但最后一次操作只能和前面同步（也可以翻转和后面同步）。</p><p>按序扫描 $a$，记录 $ls$ 表示前面能传过来的操作次数。如果 $ls &lt; c$，那么我们需要额外的 $c - ls$ 操作来补齐，否则不需要。另外，如果需要额外的操作，如果 $ls &gt; c$，我们可以选择与前面一起分裂，否则重新开一次操作，$ls$ 也加 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, ls = <span class="number">0</span>, res = <span class="number">0</span>, x, cur;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">while</span> (n --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), cur = std::<span class="built_in">log</span>(x) / std::<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">bool</span> flag = (<span class="number">1</span> &lt;&lt; cur) != x;</span><br><span class="line"><span class="keyword">if</span> (ls &lt;= cur) res += cur - ls;</span><br><span class="line"><span class="keyword">else</span> flag = <span class="literal">false</span>;</span><br><span class="line">ls = cur;</span><br><span class="line"><span class="keyword">if</span> (flag) ls ++, res ++;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有趣的结论题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>AGC038E Gachapon</title>
    <link href="https://mydcwfy.github.io/2022/06/28/AGC038E/"/>
    <id>https://mydcwfy.github.io/2022/06/28/AGC038E/</id>
    <published>2022-06-28T13:54:46.000Z</published>
    <updated>2022-07-02T01:38:21.409Z</updated>
    
    <content type="html"><![CDATA[<p>DP 优化 min-max 容斥套路似乎是 min-max 容斥唯一考法了……</p><span id="more"></span><p>题意：有一个随机数生成器，每次生成一个 $[1, n]$ 的随机数，$i$ 生成的概率是 $\dfrac{a_i}{\sum a_i}$，当所有数出现次数都 $\geq b_i$ 时停止，求期望操作次数。$n\leq 400$，$\sum a_i\leq 400$，$\sum b_i\leq 400$。</p><p>首先考虑 min-max 容斥，可以得到：<br>$$<br>ans = \sum_{S\subseteq \{1, 2, \cdots, n\}, s\not= \varnothing} (-1) ^ {|S| - 1} E(\min_{i\in S})<br>$$<br>后面表示在 $S$ 当中 所有元素出现次数 $\geq b_i$ 时的操作次数 的最小值 的期望。考虑如何求出后面一坨。</p><p>操作次数显然很难求，考虑一个比较常见的转化：<strong>统计所有合法时操作次数的和等于统计所有不合法状态的概率和</strong>。容易发现这是对的。</p><p>考虑一个不合法的出现次数序列 $\{c_1, c_2, \cdots, c_n\}$，那么 $c_i &lt; b_i$，然后考虑这个的出现概率，即为：<br>$$<br>\prod_{i \in S} (\dfrac{a_i}{\sum_{j\in S}a_j}) ^ {c_i}\times  \dfrac{(\sum_{i\in S} c_i)!}{\prod_{i\in S} c_i!}<br>$$<br>第一个表示我们钦定每一位出现哪一个数，出现概率的乘积。后面表示可能出现的排列情况。</p><p>现在我们已经把 $S$ 的期望算出来了，但是我们发现这个时候每选择 $S$ 中的数，其实在原问题中只是 $\dfrac {\sum_{i\in S} a_i}{\sum a}$ 的概率，那么就是说，我们的期望值还需要乘上 $\dfrac{\sum a}{\sum_{i\in S} a_i}$，才能得到在原问题中的期望。</p><p>于是我们就可以把整个式子写出来了：<br>$$<br>\sum_{S\subseteq \{1, 2, \cdots, n\}, S\not=\varnothing} (-1) ^ {|S| - 1} \dfrac{\sum a}{\sum_{i\in S}a_i} \sum_{c_1, c_2, \cdots, c_n}[c_i&lt;b_i] \prod_{i \in S} (\dfrac{a_i}{\sum_{j\in S}a_j}) ^ {c_i}\times  \dfrac{(\sum_{i\in S} c_i)!}{\prod_{i\in S} c_i!}<br>$$<br>还是很难算，注意到我们需要把整体的设为状态，比如涉及到的有 $\sum_{i\in S} a_j$，$\sum_{i\in S}c_j$，于是考虑把这两维设为状态计算。剩下的拆开计算即可。</p><p>于是直接考虑转移，枚举 $i, \sum_{\in S} c_i, \sum_{i\in S} a_i$ 和当前的 $c$，看似复杂度 $O(n ^ 4)$，但其实由于 $\sum b$ 是一个量级，所以枚举 $i$ 和 $c$ 总体是 $O(n)$，于是总时间复杂度 $O(n ^ 3)$，可以通过。空间比较卡，滚动即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) std::cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = Mod - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> id = <span class="number">1</span>; id &lt;= n; ++ id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(f[id &amp; <span class="number">1</span>], <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f[id &amp; <span class="number">1</span>]));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> sa = <span class="number">0</span>; sa &lt; N; ++ sa)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> sc = <span class="number">0</span>; sc &lt; N; ++ sc) &#123;</span><br><span class="line"><span class="keyword">if</span> (!f[(id - <span class="number">1</span>) &amp; <span class="number">1</span>][sa][sc]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> frm = f[(id - <span class="number">1</span>) &amp; <span class="number">1</span>][sa][sc];</span><br><span class="line"><span class="built_in">adj</span>(f[id &amp; <span class="number">1</span>][sa][sc] += frm - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>, mul = <span class="number">1</span>; c &lt; b[id]; ++ c, mul = (LL) mul * a[id] % Mod) &#123;</span><br><span class="line"><span class="keyword">int</span> &amp;to = f[id &amp; <span class="number">1</span>][sa + a[id]][sc + c];</span><br><span class="line">to = (to + (LL) (Mod - mul) * infact[c] % Mod * frm) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, suma = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) suma += a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> sa = <span class="number">0</span>; sa &lt; N; ++ sa)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> sc = <span class="number">0</span>, frm; sc &lt; N; ++ sc) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(frm = f[n &amp; <span class="number">1</span>][sa][sc])) <span class="keyword">continue</span>;</span><br><span class="line">ans = (ans + (LL) suma * <span class="built_in">qpow</span>(sa, Mod - <span class="number">2</span> - sc) % Mod * fact[sc] % Mod * frm) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;DP 优化 min-max 容斥套路似乎是 min-max 容斥唯一考法了……&lt;/p&gt;</summary>
    
    
    
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="期望" scheme="https://mydcwfy.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
    <category term="min-max 容斥" scheme="https://mydcwfy.github.io/tags/min-max-%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P5850 calc加强版</title>
    <link href="https://mydcwfy.github.io/2022/06/28/Luogu-P5850/"/>
    <id>https://mydcwfy.github.io/2022/06/28/Luogu-P5850/</id>
    <published>2022-06-28T08:31:38.000Z</published>
    <updated>2022-06-28T10:05:03.890Z</updated>
    
    <content type="html"><![CDATA[<p>又是多项式重工业。</p><span id="more"></span><p>题意：求所有长度为 $n$ 的序列满足每一个数都在 $[1, k]$ 且互不相等的权值和。权值定义为每一个数的乘积。你需要输出 $n\in [1, lim]$ 的答案，$lim\leq 5\times 10 ^ 5$，$k&lt; 998244353$，3s。</p><p>看到不等，那么每一个数最多出现一次，并且可以转为无序，于是最后答案要乘上 $n!$。</p><p>考虑其生成函数为 $\prod_{i = 1} ^ k (ix + 1)$，但是规模过大，无法分治 NTT。</p><p>考虑经典取 $\ln$，那么我们现要求出 $\sum_{i = 1} ^ k \ln(ix + 1)$。对其泰勒展开，可以得到：<br>$$<br>\begin{aligned}<br>\ln F(x) =&amp; \sum_{i = 1} ^ k \ln (ix + 1)\\<br>=&amp; \sum_{i = 1} ^ k \sum_{j = 1} \dfrac{(-1) ^ {j + 1} (ix) ^ j}j\\<br>=&amp; \sum_{j = 1} \dfrac{(-1) ^ {j + 1}}{j} \sum_{i = 1} ^ k i ^ j<br>\end{aligned}<br>$$<br>下面我们需要干的事情就是求 $\sum_{i = 1} ^ k i ^ j$。</p><p>考虑其 EGF，我们可以得到：<br>$$<br>\begin{aligned}<br>G(x) =&amp; \sum_{j = 0} \dfrac{x ^ j}{j!} \sum_{i = 0} ^ k i ^ j\\<br>=&amp; \sum_{i = 0} ^ k \sum_{j = 0} \dfrac{(ix) ^ j}{j!}\\<br>=&amp; \sum_{i = 0} ^ k e ^ {ix}<br>\end{aligned}<br>$$<br>最后一步等比求和一下，可以得到 $G(x) = \dfrac{e ^ {(k + 1)x} - 1}{e ^ x - 1}$。直接求逆即可，注意常数项都为 0，需要向低移一位。</p><p>其实 $i, j$ 的下界不重要，因为我们最后取的一定是 $[1, n]$ 的答案，和 0 没有关系。注意 EGF 最后需要乘上 $i!$。</p><p>如果你被卡常的话，请将 $e ^ x$ 和 $e ^ {(k + 1)x}$手动计算，一般常数正常的都能过。（总感觉话没说对……）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">inv[<span class="number">1</span>] = fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) fact[i] = (LL) fact[i - <span class="number">1</span>] * i % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++ i) inv[i] = (LL) (Mod - Mod / i) * inv[Mod % i] % Mod;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">std::cin &gt;&gt; k &gt;&gt; n;</span><br><span class="line"><span class="function">poly <span class="title">A</span><span class="params">(n + <span class="number">2</span>)</span>, <span class="title">B</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">A[<span class="number">1</span>] = k + <span class="number">1</span>, A = <span class="built_in">Exp</span>(A), A.<span class="built_in">erase</span>(A.<span class="built_in">begin</span>());</span><br><span class="line">B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++ i) B[i] = (LL) B[i - <span class="number">1</span>] * inv[i + <span class="number">1</span>] % Mod;</span><br><span class="line">A = A * <span class="built_in">Inv</span>(B), A.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) A[i] = (LL) A[i] * fact[i] % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, op = <span class="number">1</span>; i &lt;= n; ++ i, op = Mod - op)</span><br><span class="line">A[i] = (LL) A[i] * inv[i] % Mod * op % Mod;</span><br><span class="line">A[<span class="number">0</span>] = <span class="number">0</span>, A = <span class="built_in">Exp</span>(A);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (LL) A[i] * fact[i] % Mod);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;又是多项式重工业。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    <category term="生成函数" scheme="https://mydcwfy.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF Round Global#21</title>
    <link href="https://mydcwfy.github.io/2022/06/28/CF-Round-Global-21/"/>
    <id>https://mydcwfy.github.io/2022/06/28/CF-Round-Global-21/</id>
    <published>2022-06-28T01:51:41.000Z</published>
    <updated>2022-06-28T03:05:22.944Z</updated>
    
    <content type="html"><![CDATA[<p>还算没有掉分……主要是 E 过于板子的功劳。</p><p>赛时 ABCDE Accepted，Score：5682，Rank #412。</p><p>改题进度：ABCDEF Accepted。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定长度 $n$ 的数组 $a$ 和一个数字 $z$，每次可以选一个 $a$ 中的 $x$，$x\leftarrow x|z$，$z\leftarrow x\odot z$，求 $a$ 最大值的最大值。</p><p>容易发现因为 $z$ 不可能增加，最多操作一次。判断一下即可。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定序列 $a$，每次可以选定 $[l, r]$ 使得他们值都变为原来的 $\text{mex}$，求变为 0 的最少次数。</p><p>首先答案肯定不超过 2，因为可以两次操作整个数组，一定都变为 0。</p><p>如果都是 0，答案为 0。</p><p>如果不含 0 的区间只有 1 个，那么操作这个区间即可，答案为 1。</p><p>否则答案为 2。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>给定两个数组 $a, b$，再给定 $t$，每次可以把一个被 $t$ 整的数 $x$，变为 $t$ 个 $\dfrac xt$ 插入在原位置，或者把 $t$ 个相邻的 $x$ 合并为一个 $xt$。问 $a$ 能否变成 $b$。</p><p>容易发现操作可逆，那么我们可以先把所有的操作 1 做了，然后再做操作 2。那么问题可以转化成 $a, b$ 经过操作 1 能否相同。</p><p>一个显然的想法是我们一直操作下去直到无法操作。暴力拆分肯定不好，我们考虑维护极长的相同的数的连续段，这样就可以做了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;PIL&gt; <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;PIL&gt; res;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (x % m == <span class="number">0</span>) t *= m, x /= m;</span><br><span class="line"><span class="keyword">if</span> (res.<span class="built_in">size</span>() &amp;&amp; res.<span class="built_in">back</span>().first == x) res.<span class="built_in">back</span>().second += t;</span><br><span class="line"><span class="keyword">else</span> res.<span class="built_in">push_back</span>(&#123;x, t&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">auto</span> v1 = <span class="built_in">get</span>(n);</span><br><span class="line">std::cin &gt;&gt; k;</span><br><span class="line"><span class="keyword">auto</span> v2 = <span class="built_in">get</span>(k);</span><br><span class="line"><span class="keyword">if</span> (v1.<span class="built_in">size</span>() != v2.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>), <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, ed = v1.<span class="built_in">size</span>(); i &lt; ed; ++ i)</span><br><span class="line"><span class="keyword">if</span> (v1[i].first != v2[i].first || v1[i].second != v2[i].second)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>), <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定一个排列 $a$，$i, j(i &lt; j)$ 之间有连边当且仅当 $a_i, a_j$ 都是 $a_{i\to j}$ 的极值。求 1 到 $n$ 的最短路。$n\leq 2.5\times 10 ^ 5$，$ \sum n\leq 5\times 10 ^ 5$。</p><p>考虑观察性质，假设 1 的位置是 $p$，那么连边不可能跨过 $p$，也就是说一定会导致经过 1 一次。同样会经过 $n$ 所在位置 $q$ 一次。而我们又发现，$p, q$ 之间又有连边，这样我们就可以计算 $[1, p]$ 的距离，$[q, n]$ 的距离，加上 $[p, q]$ 之间距离为 1，于是可以递归。（$p, q$ 可以交换）</p><p>于是用 ST 表查询区间最大值、最小值的位置即可，时间复杂度 $O(n\log n)$，可以优化到 $O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; solve = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> id1 = <span class="built_in">qmin</span>(l, r), id2 = <span class="built_in">qmax</span>(l, r);</span><br><span class="line"><span class="keyword">if</span> (id1 &gt; id2) std::<span class="built_in">swap</span>(id1, id2);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; &#x27; &#x27; &lt;&lt; id1 &lt;&lt; &#x27; &#x27; &lt;&lt; id2 &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">solve</span>(l, id1) + <span class="built_in">solve</span>(id2, r) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">solve</span>(<span class="number">1</span>, n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：在无限的网格上，从 0 开始标号，前 $n$ 列的 $[0, a_i - 1]$ 都是黑的，其余都是白的，最开始有一个棋子在 $(0, 0)$，每次可以移动在 $(i, j)$ 的棋子，会分裂成两个棋子到 $(i + 1, j)$ 和 $(i, j + 1)$ 的位置。求最少操作次数使得黑的都没有棋子，对 $10 ^ 9 + 7$ 取模。$n, a_i\leq 2\times 10 ^ 5$，$a$ 单调不升。</p><p>考虑每一个黑色位置的贡献。$(i, j)$ 这个位置的贡献可以由 $(i - 1, j)$ 和 $(i, j - 1)$ 贡献而来。注意到如果这两个位置合法，那么一定都是黑色的，因为 $a$ 单调不升。</p><p>这就是组合数，容易得到他为 $\binom{i + j}i$，那么我们可以写出如下答案式子：<br>$$<br>ans = \sum_{i = 0} ^ {n - 1} \sum_{j = 0} ^ {a_i - 1} \binom{i + j}{i}<br>$$<br>时间复杂度 $O(na)$，无法通过。看看后面这个式子应该由比较好的性质。</p><p>记 $t = i, m = a_i - 1$，则我们需要计算的就是 $\sum_{j = 0} ^ m \binom{j + t}{t}$。如果对组合数学比较熟悉的话马上就可以得到这个式子其实等于 $\binom{m + 1 + t}{t + 1}$。</p><p>于是我们就得到了最终的答案：<br>$$<br>ans = \sum_{i = 0} ^ {n - 1} \binom{i + a_i}{i + 1}<br>$$<br>直接计算，时间复杂度 $O(n)$。</p><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：给定所有三元组 $(x, y, z)$ 是否满足 $d(x, y) = d(y, z)$，要求构造一棵树使得满足上面所有条件，或报告无解。$n\leq 100$。</p><p>有一个关键性质：如果我们已经知道了某一条树边，我们马上就可以还原出整个树。</p><p>具体的，我们考虑得到 $x$ 和他的父亲 $fa$，我们可以还原出所有 $v$，他们一定满足 $dis(x, v) = dis(fa, x)$。</p><p>我们如果不知道边的话，直接考虑枚举 1 和某个点的树边，按照这个暴力计算，即可得到一棵树。</p><p>然后考虑如何判断该树是否合法。直接暴力 $O(n ^ 3)$ Floyd 即可。</p><p>总时间复杂度 $O(n ^ 4)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> frm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dis[x][frm] = dis[frm][x] = <span class="number">1</span>;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; ++ v)</span><br><span class="line"><span class="keyword">if</span> (!vis[v] &amp;&amp; mp[frm][x][v]) edg.<span class="built_in">push_back</span>(&#123;v, x&#125;), <span class="built_in">dfs</span>(v, x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) vis[i] = <span class="literal">false</span>;</span><br><span class="line">edg.<span class="built_in">assign</span>(<span class="number">1</span>, &#123;<span class="number">1</span>, v&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) dis[i][j] = (n + <span class="number">1</span>) * (i != j);</span><br><span class="line">vis[<span class="number">1</span>] = vis[v] = <span class="literal">true</span>, <span class="built_in">dfs</span>(v, <span class="number">1</span>), <span class="built_in">dfs</span>(<span class="number">1</span>, v);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line"><span class="built_in">chkmin</span>(dis[i][j], dis[i][k] + dis[k][j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= n; ++ k)</span><br><span class="line"><span class="keyword">if</span> ((dis[i][j] == dis[j][k]) ^ mp[i][j][k])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> buf[N];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k) mp[i][k][j] = buf[k] &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) mp[i][j][i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k)</span><br><span class="line">mp[j][k][i] = mp[i][k][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">2</span>; v &lt;= n; ++ v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">check</span>(v)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [u, v] : edg) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, u, v);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;还算没有掉分……主要是 E 过于板子的功劳。&lt;/p&gt;
&lt;p&gt;赛时 ABCDE Accepted，Score：5682，Rank #412。&lt;/p&gt;
&lt;p&gt;改题进度：ABCDEF Accepted。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P3600 随机数生成器</title>
    <link href="https://mydcwfy.github.io/2022/06/28/Luogu-P3600/"/>
    <id>https://mydcwfy.github.io/2022/06/28/Luogu-P3600/</id>
    <published>2022-06-28T00:38:24.000Z</published>
    <updated>2022-06-28T00:58:40.168Z</updated>
    
    <content type="html"><![CDATA[<p>一个 min-max 容斥题目。</p><span id="more"></span><p>题意：给定 $m$ 个区间 $[l_i, r_i]$，每次得到的权值为所有区间最小值的最大值，该序列 $n$ 个数均在 $[1, x]$ 内均匀随机，求期望权值的大小。$n, m, x\leq 2000$。</p><p>最小值的最大值显然不可做，考虑 min-max 容斥，将其转化为最小值的最小值。</p><p>那么式子可以写成：<br>$$<br>\sum_{S\subseteq \{1, 2, \cdots, m\}, S\not= \varnothing } (-1) ^ {|S| - 1}\min_{i\in S} \{ \min_{j = l_i} ^ {r_i } a_j \}<br>$$<br>注意到后面的式子仅与区间的并的长度有关，考虑将区间并的长度压进状态 DP 计算。</p><p>首先有一些区间是没有意义的，就是包含其他区间的区间，可以先排除掉。这样保证了所有区间按 $r$ 排序后 $l$ 也是递增的。</p><p>考虑 DP，设 $f(i, j)$ 表示最后一个位置是 $i$，且当前区间并的长度为 $j$ 的方案数。注意我们需要把 $(-1) ^ {|S| - 1}$ 的系数也带上。</p><p>考虑加入一个区间，那么我们需要计算的就是 $f(r_i, j)$，可以直接暴力计算：<br>$$<br>f(r_i, j) = \sum_{t = 1} ^ {l_i - 1} f(t, j - len) + \sum_{t = l_i} ^ {r_i - 1} f(t, j - r_i + t)<br>$$<br>这样计算时间复杂度为 $O(n ^ 2 m)$，无法通过，考虑使用前缀和优化。</p><p>前面一半很好前缀和，注意到后半部分他的 $t - j$ 一定的话，那么贡献到的位置也是一定的，因为区间并的变化量是 $r - t$。</p><p>那么，我们可以通过 $O(nm)$ 的时间计算 $f(i, j)$，前缀和一下即可得到区间并长度为 $j$ 的方案数（带系数）。</p><p>剩下的过程，我们发现 $x$ 很小，我们需要计算区间并长度为 $j$ 时最小值为 $x$ 的概率。考虑差分，计算最小值 $\leq x$ 的概率减去 $\leq x - 1$ 的概率即可。计算 $\leq x$ 的概率可以通过对立面（所有数都大于 $x$）来计算。后半部分时间复杂度 $O(nx)$。</p><p>于是我们在 $O(nm + nx)$ 的时间完成，可以通过。</p><p><strong>注意求哪些区间没有覆盖其他区间的时候，相等的区间不能全部删去！</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; x &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a[i].l, &amp;a[i].r);</span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + m + <span class="number">1</span>, [&amp;](Interval &amp;v1, Interval &amp;v2) &#123; <span class="keyword">return</span> v1.r &lt; v2.r; &#125;);</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m &amp;&amp; flag; ++ j)</span><br><span class="line">flag &amp;= !(a[i].r &gt;= a[j].r &amp;&amp; a[i].l &lt;= a[j].l) || (a[i].l == a[j].l &amp;&amp; a[i].r == a[j].r);</span><br><span class="line"><span class="keyword">if</span> (flag) tmp[++ top] = a[i];</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">swap</span>(a, tmp), m = top;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) g[a[i].r].<span class="built_in">push_back</span>(i);</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = pre1[<span class="number">0</span>][<span class="number">0</span>] = pre2[<span class="number">0</span>][<span class="number">0</span>] = Mod - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt;= n; ++ r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> id : g[r])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l = a[id].l;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = r - l + <span class="number">1</span>, ls = r - l + <span class="number">1</span>; len &lt;= r; ++ len)</span><br><span class="line">f[r][len] = (f[r][len] - (LL) pre1[l - <span class="number">1</span>][len - ls] - (pre2[r - <span class="number">1</span>][r - len] - pre2[l - <span class="number">1</span>][r - len]) - f[r][len] + <span class="number">4LL</span> * Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">0</span>; len &lt;= r; ++ len)</span><br><span class="line"><span class="built_in">adj</span>(pre1[r][len] = pre1[r - <span class="number">1</span>][len] + f[r][len] - Mod),</span><br><span class="line"><span class="built_in">adj</span>(pre2[r][r - len] = pre2[r - <span class="number">1</span>][r - len] + f[r][len] - Mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> val = <span class="number">1</span>; val &lt;= x; ++ val)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ak = <span class="built_in">qpow</span>(x) * (LL) (x - val) % Mod, p = ak, &amp;cur = pro[val];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j, p = (LL) p * ak % Mod)</span><br><span class="line">cur = (cur + (LL) p * pre1[n][j]) % Mod;</span><br><span class="line"><span class="built_in">adj</span>(cur = <span class="number">1</span> - cur);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; val &lt;&lt; &#x27; &#x27; &lt;&lt; cur &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="built_in">adj</span>(cur -= pro[val - <span class="number">1</span>]), res = (res + (LL) cur * val) % Mod;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; val &lt;&lt; &#x27; &#x27; &lt;&lt; cur &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="built_in">adj</span>(cur += pro[val - <span class="number">1</span>] - Mod);</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个 min-max 容斥题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="期望" scheme="https://mydcwfy.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
    <category term="min-max 容斥" scheme="https://mydcwfy.github.io/tags/min-max-%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
</feed>
