<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mydcwfy&#39;s Blog</title>
  
  
  <link href="https://mydcwfy.github.io/atom.xml" rel="self"/>
  
  <link href="https://mydcwfy.github.io/"/>
  <updated>2022-02-15T23:54:32.011Z</updated>
  <id>https://mydcwfy.github.io/</id>
  
  <author>
    <name>mydcwfy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Min_25 筛</title>
    <link href="https://mydcwfy.github.io/2022/02/13/Min-25-Sieve/"/>
    <id>https://mydcwfy.github.io/2022/02/13/Min-25-Sieve/</id>
    <published>2022-02-13T04:57:51.000Z</published>
    <updated>2022-02-15T23:54:32.011Z</updated>
    
    <content type="html"><![CDATA[<p>非常 NB 的一个筛法，虽然复杂度可能会趋近线性 $O(n ^ {1 - \epsilon})$，但是在 OI 范围内非常不错。</p><span id="more"></span><h2 id="1-算法介绍"><a href="#1-算法介绍" class="headerlink" title="1. 算法介绍"></a>1. 算法介绍</h2><p>要么是 $O(\dfrac{n ^ {\frac34}}{\log n})$，还有一种是 $O(n ^ {1 - \epsilon})$，反正可以在 $10^{10}$ 范围内跑 1s 左右。</p><h2 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2. 算法流程"></a>2. 算法流程</h2><p>感觉比杜教筛更好构造。</p><p>假设 $f(x)$ 的前缀和是我们要求的。</p><p>分为两步：先求出在当 $x \in P$（表示 $x$ 是质数）的 $f(x)$ 的前缀和，第二步通过质数的前缀和求出整个的前缀和。</p><h3 id="1）求-g-x-f-x-x-in-P-的前缀和"><a href="#1）求-g-x-f-x-x-in-P-的前缀和" class="headerlink" title="1）求 $g(x) = f(x)[x \in P]$  的前缀和"></a>1）求 $g(x) = f(x)[x \in P]$  的前缀和</h3><p>我们找到一个多项式 $g(x)$，使得 $x \in P$ 的时候 $f(x) = g(x)$。</p><p>定义 $\text{lpf}(x)$ 是 $x$ 的最小质因数，$p_x$ 表示第 $x$ 个质数。</p><p>先将多项式拆为多个 $x ^ k$，这样的话 $g(x)$ 就是一个完全积性函数了，即满足 $g(ab) = g(a) \cp g(b)$。</p><p>我们定义 $h(n, k) = \sum_{i = 1}^n [i \in P \lor \text{lpf}(i) &gt; p_k]g(i)$。</p><p><del>（显然状态数比 $n$ 还大）</del></p><p>我们考虑从 $h(…, k - 1)$ 转移到 $h(n, k)$。</p><p>考虑 $h(n, k - 1)$ 变为 $h(n, k)$，需要减去 $\text{lpf}(x) = p_k$ 的数。</p><p>如果我们将 $x$ 除以 $p_k$，又怎么样呢？</p><p>那么剩下的变为 $\text{lpf}(\dfrac x{p_k})\geq p_k$。至于为什么是 $\geq$，是因为可能有单个数可能有多个 $p_k$ 质因子。</p><p>这不和 $h(\dfrac n{p_k}, k - 1)$ 定义很像了吗！</p><p>对比一下：<br>$$<br>\begin{aligned}<br>h(\dfrac n{p_k}, k - 1) &amp;= \sum_{i = 1}^{\frac n{p_k}}[i \in P \lor \text{lpf}(i) \geq p_k]g(i)\\<br>&amp;= \sum_{i = 1}^{\frac n{p_k}}[\text{lpf}(i) \geq p_k]g(i) + h(p_{k - 1}, p_{k - 1})<br>\end{aligned}<br>$$<br>其中为什么要加 $h(p_{k - 1}, p_{k - 1})$ 呢？因为 $h(\dfrac n{p_k}, k - 1)$ 包含了 $[1, \dfrac{n}{p_k}]$ 所有质数，而小于 $p_k$ 的质数我们前面的是没有计算到的，所以要加上 $[1, p_{k - 1}]$ 的所有质数的函数值，显然 $g(p_{k - 1}, p_{k - 1})$ 就可以满足要求。这样我们就可以得出：<br>$$<br>\begin{aligned}<br>\sum_{i = 1}^{\frac n{p_k}}[\text{lpf}(i) \geq p_k]g(i) = h(\dfrac n{p_k}, k - 1) - h(p_{k - 1}, p_{k - 1})<br>\end{aligned}<br>$$<br>又由于 $g$ 是完全积性函数（记得前面我们拆开多项式的目的吗？），我们可以得到这样的递推式：<br>$$<br>\begin{aligned}<br>h(n, k) &amp;= h(n, k - 1) - \sum_{i = 1}^n [\text{lpf}(i) = p_k] g(i)\\<br>&amp;= h(n, k - 1) - g(p_k)\sum_{i = 1}^{\frac n{p_k}} [\text{lpf}(i) \geq p_k]g(i)\\<br>&amp;= h(n, k - 1) - g(p_k)(h(\dfrac n{p_k}, k - 1) - h(p_{k - 1}, k - 1))<br>\end{aligned}<br>$$<br>按照这个递推，最后我们就可以得到所有质数位置的值的前缀和，即为 $h(n, k)$，其中 $p_k &gt; \sqrt n$。</p><h3 id="2）根据质数点的值求整个的前缀和"><a href="#2）根据质数点的值求整个的前缀和" class="headerlink" title="2）根据质数点的值求整个的前缀和"></a>2）根据质数点的值求整个的前缀和</h3><p>现在我们经过第一步的计算，已经知道了只有质数点的值 $g(x) = [x \in P]f(x)$ 的前缀，记为 $r(x)$。</p><p>我们定义 $S(n, k)$ 表示 $\displaystyle \sum_{i = 2}^n [\text{lpf}(i) &gt; p_k]f(k)$。</p><p>类似刚刚推导 $h(n, k)$ 的方法，我们可以较为简单的求，注意是积性函数而不是完全积性函数。</p><p>我们考虑最小的质因数 $p_v &gt; p_k$，然后枚举 $p_v$ 的指数。如是就可以从 $S(\dfrac n{p_v^e}, v)$ 转移，因为剩下的质因数都得大于 $p_v$。</p><p>注意我们的 $S(n, k)$ 没有定义 1，所以我们还要先加上 $&gt; p_k$ 的质数的所有的和，这样我们就可以直接使用 $r(n) - h(p_k, k)$ 代替。</p><p>注意如果 $e \not= 1$，$p_v^e$ 本身就是合数，没有包含在 $r(n) - h(p_k, k)$ 中，所以我们要加上他们。</p><p>根据积性函数的定义，我们可以得到：<br>$$<br>\begin{aligned}<br>S(n, k) = r(n) - h(p_k, k) + \sum_{v = i + 1}^{p_v \leq n}\sum_{e = 1}^{p_v^e \leq n} f(p_v^e)(S(\dfrac n{p_e^v}, v) + [v\not= 1])<br>\end{aligned}<br>$$</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p>显然，如果一个数不是质数，那么 $\text{lpf}(n) \leq \sqrt n$，所以我们计算 $h(n, k)$ 的时候可以直接处理 $[1, \sqrt n]$ 的所有质数就可以了。</p><p>但是我们如果直接循环 $h(i, k)(i \in [1, n], p_k \leq \sqrt n)$，那么肯定暴力都跑不过。</p><p>可以发现，除了 $h(p_{k - 1}, k - 1)$，其余都是和 $n$ 有关。又有一个整除的小定理：<br>$$<br>\left\lfloor\dfrac{\left\lfloor\dfrac na\right\rfloor}{b}\right\rfloor = \left\lfloor\dfrac n{ab}\right\rfloor<br>$$<br>这说明，不管我们除什么，前面的 $h(n, k), h(\dfrac n{p_k}, k - 1)$ 都只会访问到 $\dfrac ni(i \in [1, n])$，而这个最多只有 $O(\sqrt n)$ 个取值。</p><p>这个实现可以直接整除分块，将可以访问到的值存到两个数组，可以表示为：<br>$$<br>id(x) =<br>\begin{cases}<br>id1(x) (x \leq \sqrt n)\\<br>id2(\left\lfloor\dfrac nx\right\rfloor) (x &gt; \sqrt n)<br>\end{cases}<br>$$<br>当然偷懒的话可以多一个 $\log$ 的 <code>map</code>，但是似乎也不难，直接写整除分块了（本身算法就有点卡，还是不要给自己添麻烦吧 qwq</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_id</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x &lt;= sq ? id1[x] : id2[n / x];&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (LL l = <span class="number">1</span>, r, t; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = n / (n / l), t = n / r;</span><br><span class="line">a[++ tot] = t;<span class="comment">//a 存的是这个位置存的是哪个数</span></span><br><span class="line"><span class="keyword">if</span> (t &lt;= sq) id1[t] = tot;</span><br><span class="line"><span class="keyword">else</span> id2[n / t] = tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接着简单的分析复杂度：枚举质数 $O(\dfrac{\sqrt n}{\ln \sqrt n})$，枚举 $O(\sqrt n)$ 个数，前面时间复杂度为 $O(\dfrac n{\ln \sqrt n})$，显然跑不进 1s。</p><p>我们还有一个优化：在枚举 $h(n, k)$ 的时候，我们可以发现 $h(\dfrac n{p_k}, k - 1) - h(p_{k - 1}, k - 1)$ 有贡献时，肯定需要满足 $\dfrac{n}{p_k} \geq p_k$，否则 $h(\dfrac n{p_k}, k - 1)$ 就全是质数，并且只有 $[1, p_k)$ 中的质数，也就是 $h(p_{k - 1}, k - 1)$，那么后面贡献就是 0。所以我们只需枚举 $n$ 到 $p_k ^ 2$。</p><p>另外，$h(p_{k - 1}, k - 1)$ 最多也只有 $O(\dfrac{\sqrt n}{\ln \sqrt n})$ 个，我们直接预处理就可以了。这个我们记为 $sp_{k - 1}$。</p><p>（代码用的是 $g(n, k)$ 表示 $h(n, k)$，且只开了一维数组，因为访问的时候一定是标号小（即对应的 <code>a[]</code> 大）的从小的转移，可以用标号从小到大）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">LL le = (LL)prime[i] * prime[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; a[j] &gt;= le; ++ j)</span><br><span class="line">g[j] -= g[<span class="built_in">get_id</span>(a[j] / prime[i])] - sp[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于后面是同样的，我们计算 $S(n, k)$ 时，如果 $p_v^2 &gt; n$，只能枚举 $e = 1$，那么 $[e \not= 1] = 0$，$S(\dfrac{n}{p_v}, v)$ 由于 $\dfrac n{p_v} &lt; p_v$ 所以就为 0，我们就无需枚举。</p><p>反正后面 $S(n, k)$ 是不需要记忆化的（跑得还挺快</p><p>最后注意 $S(n, 0) = \sum_{i = 2}^n f(i)$，返回这个，需要加 $f(1)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">S</span><span class="params">(LL n, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (prime[i] &gt;= n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> now = <span class="built_in">get_id</span>(n);</span><br><span class="line">LL res = (f[now] - sp[i] + Mod) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nw = i + <span class="number">1</span>; nw &lt; cnt &amp;&amp; ((LL)prime[nw]) * prime[nw] &lt;= n; ++ nw)</span><br><span class="line"><span class="keyword">for</span> (LL now = prime[nw], k = <span class="number">1</span>; now &lt;= n; k ++, now *= prime[nw])&#123;</span><br><span class="line">LL t = now % Mod;</span><br><span class="line">res = (res + <span class="built_in">f</span>(now) % Mod * ((<span class="built_in">S</span>(n / now, nw) + (k != <span class="number">1</span>)) % Mod) % Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-例题"><a href="#4-例题" class="headerlink" title="4. 例题"></a>4. 例题</h2><h4 id="T1：区间素数个数"><a href="#T1：区间素数个数" class="headerlink" title="T1：区间素数个数"></a>T1：区间素数个数</h4><p><a href="https://loj.ac/p/6235">题目传送门 LOJ</a></p><p>观察到这个函数并不是积性函数，所以我们似乎没法使用杜教筛等算法求解。</p><p><del>观察标题可得，</del>我们可以发现，$h(n, x)(p_x &gt; \sqrt n)$ 就是 $\sum_{i = 1}^n[i \in P]g(i)$，我们直接让 $g(x) = 1$，即可求出 $[1, n]$ 的质数个数即可。</p><details><summary> 点击查看代码 </summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> id1[N], id2[N], tot, prime[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line">LL g[N], n, sq, a[N], sp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">st[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) prime[cnt ++] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; i * prime[j] &lt; N; ++ j)</span><br><span class="line">&#123;</span><br><span class="line">st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_id</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x &lt;= sq ? id1[x] : id2[n / x];&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this problem has a times 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solveg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i) sp[i] = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) g[i] = a[i] - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">LL le = (LL)prime[i] * prime[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; a[j] &gt;= le; ++ j)</span><br><span class="line">g[j] -= g[<span class="built_in">get_id</span>(a[j] / prime[i])] - sp[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line">sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="built_in">sieve</span>(sq + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (LL l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">a[++ tot] = n / r;</span><br><span class="line"><span class="keyword">if</span> (n / r &lt;= sq) id1[n / r] = tot;</span><br><span class="line"><span class="keyword">else</span> id2[n / (n / r)] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">solveg</span>();</span><br><span class="line">std::cout &lt;&lt; g[<span class="built_in">get_id</span>(n)] &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h4 id="T2：简单的函数"><a href="#T2：简单的函数" class="headerlink" title="T2：简单的函数"></a>T2：简单的函数</h4><p><a href="https://loj.ac/p/6053">题目传送门 LOJ</a></p><p>首先有一个小学老师教的结论：偶质数只有 2。</p><p>那么，$f(i) = i\oplus 1 (i \in P)$ 就是：<br>$$<br>\begin{cases}<br>i - 1 (i \not= 2)\\<br>i - 1 + 2 (i = 2)<br>\end{cases}<br>$$<br>我们就可以通过先筛 $g(i) = i,g(i) = 1$ 来得到 $f(i)(i \in P)$。</p><p>最后，我们计算 $\sum_{i = 1}^n f(i)$ 的时候，由于 $f(2) = 3$，所以我们在筛到 $2$ 的时候应该加上 2。</p><p>具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">S</span><span class="params">(LL n, <span class="keyword">int</span> x)</span><span class="comment">//x 从 0  开始标号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (prime[x] &gt;= n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">LL res = (f[<span class="built_in">get_id</span>(n)] - sp[x] + Mod + <span class="number">2</span> * (x == <span class="number">-1</span> &amp;&amp; n &gt; <span class="number">1</span>)) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nw = x + <span class="number">1</span>; (LL)prime[nw] * prime[nw] &lt;= n &amp;&amp; nw &lt; cnt; ++ nw)</span><br><span class="line"><span class="keyword">for</span> (LL k = <span class="number">1</span>, pk = prime[nw]; pk &lt;= n; ++ k, pk *= prime[nw])</span><br><span class="line">res += (prime[nw] ^ k) * (<span class="built_in">S</span>(n / pk, nw) + (k != <span class="number">1</span>)) % Mod;</span><br><span class="line"><span class="keyword">return</span> res % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3：DIVCNTK"><a href="#T3：DIVCNTK" class="headerlink" title="T3：DIVCNTK"></a>T3：DIVCNTK</h4><p><a href="https://www.spoj.com/problems/DIVCNTK/">题目传送门 SPOJ</a></p><p>要求 $\sum_{i = 1}^n d(i ^ k)\bmod 2^{64}$，其中 $d(x)$ 代表 $x$ 的约数个数。</p><p>我们可以简单的发现，$d(x ^ k)$ 是积性函数：$d(a^kb^k) = d(a^k)d(b^k) (a \perp b)$。</p><p>令 $f(x) = d(x ^ k)$，我们再尝试推一下 $f(p ^ c) = c(k + 1)$。发现这是一个简单的多项式，我们尝试拆开 $f(p^c) = c$，Min_25 筛即可。</p><p>代码不给了，留作练习题<del>（逃</del></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;非常 NB 的一个筛法，虽然复杂度可能会趋近线性 $O(n ^ {1 - \epsilon})$，但是在 OI 范围内非常不错。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>AGC016F 题解</title>
    <link href="https://mydcwfy.github.io/2022/02/07/AGC016F/"/>
    <id>https://mydcwfy.github.io/2022/02/07/AGC016F/</id>
    <published>2022-02-07T13:28:46.000Z</published>
    <updated>2022-02-07T13:32:49.745Z</updated>
    
    <content type="html"><![CDATA[<p>$SG$ 函数的妙用。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给定一个有向图，其中边都是小编号向大编号连边。现在 Alice 和 Bob 交替移动两个石子。两个石子最开始在 1 和 2。</p><p>现在要求只保留一些边，求在剩下的图中 Alice 能胜的情况个数。答案模 $1e9 + 7$。</p><h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2. 题解"></a>2. 题解</h2><p>很明显，我们需要求 $sg(1) != sg(2)$ 的方案数，这个可以简单的用总数减 $sg(1) = sg(2)$  的方案数。</p><p>怎么做呢？</p><p>我们枚举点集 $S$，让这些点的 $sg(x) = 0$，设剩下的点集为 $T$。</p><p>明显，$S$ 之间没有边，$T$ 中的点都有至少一条边连向 $S$。</p><p>然后，我们如果将 $S$ 删去，那么 $sg(x), x\in T$ 都会减 1。于是就可以从 $f(T)$ 转移到 $f(S \cup T)$。</p><p>题目给的限制就是 $1, 2$ 被分在同一个集合里了。</p><p>我们暴力枚举 $S$，枚举子集的时间复杂度为 $O(3 ^ n)$，可以通过。</p><p><strong>总结：删掉 $sg = 0$ 的状态，所有状态 $sg$ 减一。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">out[-- u] |= (<span class="number">1</span> &lt;&lt; -- v);</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j; j = (j - <span class="number">1</span>) &amp; i)&#123;</span><br><span class="line"><span class="keyword">if</span> ((i &amp; <span class="number">1</span>) ^ (i &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> ((j &amp; <span class="number">1</span>) ^ (j &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">LL now = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++ k)</span><br><span class="line"><span class="keyword">if</span> ((i ^ j) &gt;&gt; k &amp; <span class="number">1</span>) now = now * (pw[cnt[out[k] &amp; j]] - <span class="number">1</span>) % Mod;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j &gt;&gt; k &amp; <span class="number">1</span>) now = now * (pw[cnt[out[k] &amp; (i ^ j)]]) % Mod;</span><br><span class="line">f[i] = (f[i] + f[i ^ j] * now) % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;$SG$ 函数的妙用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="SG 函数" scheme="https://mydcwfy.github.io/tags/SG-%E5%87%BD%E6%95%B0/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>CF566C</title>
    <link href="https://mydcwfy.github.io/2022/01/24/CF566C/"/>
    <id>https://mydcwfy.github.io/2022/01/24/CF566C/</id>
    <published>2022-01-24T12:37:14.000Z</published>
    <updated>2022-01-24T13:00:21.515Z</updated>
    
    <content type="html"><![CDATA[<p>求导的思想找极值点挺不错的，还有点分治降低树的高度。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p><a href="https://www.luogu.com.cn/problem/CF566C">题目传送门 Luogu</a></p><p><a href="https://codeforces.com/problemset/problem/566/C">题目传送门 Codeforces</a></p><p>求有点权、边的长度的树的重心，距离定义为 $(\sum w)^{\frac32}$，注意要求落在点上，并且求出该点到其他点的距离和。</p><p>$n\leq 2 \times 10 ^ 5$。</p><h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2. 题解"></a>2. 题解</h2><p>首先，暴力 $O(n ^ 2)$ 可以 TLE。</p><p>假设距离和函数为 $f(x) = \sum_{i = 1}^n d(i, x)^\frac32$。</p><p>我们考虑假设退化成一条链的情况：这个一定是一个下凸函数，我们可以直接三分答案，每一次求 $f(x)$ 为 $O(n)$ 的，总复杂度为 $O(n \log n)$。</p><p>可不可以不用三分呢？</p><p>观察到这个函数是一个多项式，我们可以对其求导。</p><p>最开始，这个导函数一直是负，突然到了最优解 $u$ 附近的时候，边为了正，很明显，我们可以先得到导函数，再对导函数二分查找第一次变为正的位置。</p><p>但是我们来到树上的时候，不能一步跳很远，只能单步跳，时间复杂度明显和高度 $h$ 有关，为 $O(nh)$，怎么办呢？</p><p>相信你已经想到了，直接<strong>点分治重构树</strong>！</p><p>我们看一下哪棵子树的导函数是小于 0 的，有小于 0 的向那边跳就是了。</p><p>同时有前面的理论，我们可以发现，树的重心一定只有一个（可能不在点上而在边上），他向四周扩散都是变大的。</p><p>我们层层逼近，一定只有 $\log n$ 层，时间复杂度为 $O(n \log n)$，可以通过。</p><p><strong>总结：求导逼近极值点；点分治降低树高度</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">double</span> &amp;dev, <span class="keyword">int</span> nowd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// if (vis[x]) return;</span></span><br><span class="line">sum += <span class="built_in">pow</span>(nowd, <span class="number">1.5</span>) * a[x], dev += <span class="number">1.5</span> * <span class="built_in">sqrt</span>(nowd) * a[x];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (e[i] != fa) <span class="built_in">dfs</span>(e[i], x, dev, nowd + w[i]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[x]) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">get_wc</span>(x, <span class="number">-1</span>, <span class="built_in">get_size</span>(x, <span class="number">-1</span>), x);<span class="comment">//求重心</span></span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> sumd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line">dv[e[i]] = <span class="number">0</span>, <span class="built_in">dfs</span>(e[i], x, dv[e[i]], w[i]), sumd += dv[e[i]];<span class="comment">//求导数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum &lt; res) res = sum, ansu = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sumd - <span class="number">2</span> * dv[e[i]] &lt;= <span class="number">0</span>)&#123;<span class="comment">//这里是一步推导，我们如果向这边的话，其他的导数为正，这个为负，也就是总和减去两倍当前的导数</span></span><br><span class="line"><span class="built_in">work</span>(e[i]);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;求导的思想找极值点挺不错的，还有点分治降低树的高度。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="点分治" scheme="https://mydcwfy.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>UOJ671诡异操作 题解</title>
    <link href="https://mydcwfy.github.io/2022/01/24/UOJ671/"/>
    <id>https://mydcwfy.github.io/2022/01/24/UOJ671/</id>
    <published>2022-01-24T11:40:42.000Z</published>
    <updated>2022-02-07T13:34:38.655Z</updated>
    
    <content type="html"><![CDATA[<p>思想值得借鉴。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p><a href="https://uoj.ac/problem/671">题目传送门 UOJ</a></p><p>给定长度为 $n$ 的数组，最大为 $2^{128} - 1$，要求支持以下操作：</p><ol><li>$\forall i \in [l, r],\  a(i):= \dfrac{a(i)}{v}$。</li><li>$\forall i \in [l, r],\ a(i) := a(i)$ &amp; $v$。</li><li>求 $\sum_{i = l}^r a(i)$，答案对 $2^{128}$ 取模。</li></ol><p>$n\leq 3\times10^5, q\leq 2 \times 10 ^ 5$，时限 3s，空间 1GB。</p><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><p>$a(i)$ 用 <code>__uint128_t</code> 存储，可能常数有<del>亿</del>点大。</p><p>首先观察 $a(i)$ 在操作中不断减小，所以最多被除 $\log a(i)$ 次，存一下该区间有没有非 0 的数，没有的话直接退出。时间复杂度易得为 $O(q(\log n + \log a(i)))$。</p><p>对于第二个操作，我们可以先在这个区间上打一个标记，然后可以用一个 128 的数组存下来每一位出现了多少次，然后 &amp;v 的时候直接将对应的 1 位赋值为 0，更新答案即可。时间复杂度为 $O(q\log n\log a(i))$。<del>（然后你会发现 5000 的点都要跑 1s+）</del></p><p>怎么优化呢？</p><p>我们只要考虑压缩 128 的数组。这个数组每一个数都不大于 $len$，用 short 就可以存下来，显然信息密度不够。</p><p>我们考虑<strong>将 128 数组里的每一个位里存的数二进制拆分，然后将答案存入一个 $\log len$ 的数组。</strong></p><p>具体来说，比如有一个 $2^5$ 出现了 5 次，那么我们就在 $cnt[0]$ 和 $cnt[2]$ 插入 $2^5$。这样就可以实现一个 $\log a_i$ 向 $\log len$ 的方向转变。</p><p>我们再来看，如果 &amp;v 的时候怎么样呢？之间每一位都 &amp;v 就可以了，因为每一位存的是出现 $2^i$ 次的数的总和，而又不会互相干扰。</p><p>求和的时候，直接 $\sum cnt(i) \times 2^i$ 就可以了，时间复杂度同样是 $\log len$。</p><p>所以我们就可以得到复杂度为 $O(\log n \log len) = O(\log^2 n)$。</p><p>总时间复杂度为 $O(q(\log a(i) + \log^2 n))$，空间复杂度 $O(n \log n)$，卡一卡就可以过了。（但是有些 Hack 数据真的毒瘤，$cnt$ 数组用 <code>vector</code> 实现就 T 了，必须使用数组。</p><p><strong>总结：可以将一个 $\log a$ 长但存的数不大的数组通过二进制拆分的手段压缩为 $\log len$。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) (x &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) (x &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="keyword">using</span> u128 = <span class="keyword">__uint128_t</span>;</span><br><span class="line"><span class="keyword">const</span> u128 Mand = <span class="number">-1</span>;<span class="comment">//明显任意一个数 &amp;Mand 不变</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[x].any = tr[<span class="built_in">l</span>(x)].any | tr[<span class="built_in">r</span>(x)].any;</span><br><span class="line">u128 now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tr[x].sz; ++ i)&#123;</span><br><span class="line">u128 le = i &lt; tr[<span class="built_in">l</span>(x)].sz ? tr[<span class="built_in">l</span>(x)].cnt[i] : <span class="number">0</span>,</span><br><span class="line">ri = i &lt; tr[<span class="built_in">r</span>(x)].sz ? tr[<span class="built_in">r</span>(x)].cnt[i] : <span class="number">0</span>;</span><br><span class="line">tr[x].cnt[i] = (le ^ ri) ^ now;</span><br><span class="line">now = (le &amp; ri) | ((le ^ ri) &amp; now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_and</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">const</span> u128 &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[x].lt &amp;= v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tr[x].sz; ++ i) tr[x].cnt[i] &amp;= v;</span><br><span class="line">tr[x].any = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tr[x].sz; ++ i) tr[x].any |= (tr[x].cnt[i] &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].lt == Mand) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">update_and</span>(<span class="built_in">l</span>(x), tr[x].lt), <span class="built_in">update_and</span>(<span class="built_in">r</span>(x), tr[x].lt);</span><br><span class="line">tr[x].lt = Mand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_div</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">const</span> u128 &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tr[x].any) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l == tr[x].r)</span><br><span class="line">&#123;</span><br><span class="line">tr[x].cnt[<span class="number">0</span>] /= v, tr[x].any = (tr[x].cnt[<span class="number">0</span>] &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="built_in">update_div</span>(<span class="built_in">l</span>(x), v), <span class="built_in">update_div</span>(<span class="built_in">r</span>(x), v);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_and</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">const</span> u128 &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> <span class="built_in">update_and</span>(x, v);</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="keyword">int</span> mid = (tr[x].l + tr[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify_and</span>(<span class="built_in">l</span>(x), l, r, v);</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify_and</span>(<span class="built_in">r</span>(x), l, r, v);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_div</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">const</span> u128 &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> <span class="built_in">update_div</span>(x, v);</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="keyword">int</span> mid = (tr[x].l + tr[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify_div</span>(<span class="built_in">l</span>(x), l, r, v);</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify_div</span>(<span class="built_in">r</span>(x), l, r, v);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;思想值得借鉴。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="线段树" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>最小圆覆盖</title>
    <link href="https://mydcwfy.github.io/2022/01/20/mininum-circle/"/>
    <id>https://mydcwfy.github.io/2022/01/20/mininum-circle/</id>
    <published>2022-01-20T10:31:26.000Z</published>
    <updated>2022-01-20T11:58:39.381Z</updated>
    
    <content type="html"><![CDATA[<p>还是一个计算几何。</p><span id="more"></span><h2 id="1-性质"><a href="#1-性质" class="headerlink" title="1. 性质"></a>1. 性质</h2><h3 id="1）唯一性"><a href="#1）唯一性" class="headerlink" title="1）唯一性"></a>1）唯一性</h3><p>明显，如果我们能找到两个圆的话，他们的交也一定是可以的。我们可以尝试构造以相交的弦为直径构造一个圆，很明显会更小。</p><img src="/2022/01/20/mininum-circle/%E5%94%AF%E4%B8%80%E6%80%A7.png" class=""><h3 id="2）"><a href="#2）" class="headerlink" title="2）"></a>2）</h3><p><strong>如果 $P$ 不在集合 $S$ 的最小覆盖圆的内部，则 $P$ 在 ${P}\cup S$ 的最小覆盖圆的边上。</strong></p><p>首先，一个最小覆盖圆肯定会经过集合内的至少三个点。（在集合点数 $\geq 3$ 的时候）</p><p>反证：假设 $P$ 不在 ${P}\cup S$ 的最小覆盖圆的边上，那么 ${P}\cup S$ 的最小覆盖圆就是 $S$ 的最小覆盖圆。</p><p>但是 $S$ 的最小覆盖圆是无法覆盖到 $P$ 的，所以就会导致 ${P}\cup S$ 的最小圆覆盖无法覆盖到 $P$，矛盾，故原命题成立。</p><h2 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2. 算法流程"></a>2. 算法流程</h2><p>首先随机化，防止复杂度退化。</p><p>接着，我们将圆设置为 $(p(1), 0)$，表示圆心和半径。</p><p>然后，我们枚举每一个点，如果当前点 $p(i)$ 不在最小覆盖圆里的话，那么，我们由前面的性质得到，$p(i)$ 一定在 ${1, …, i}$ 的最小圆覆盖的边上。</p><p>现在，我们将圆设置为 $(p(i), 0)$，然后再暴力枚举前面的点。</p><p>如果如果 $p(j)$ 不在圆内的话，那么 $p(j)$ 在 ${1, …, j}\cup{i}$ 的最小圆覆盖的边上。同时，由于 $p(i)$ 不在 ${1, …, i - 1}$ 的最小圆覆盖里，那么一定导致 $p(i)$ 不在 ${1, …, j}$ 的最小覆盖圆上。</p><p>那么，我们就可以得到，$p(i), p(j)$ 都在 ${1, …, j}\cup {i}$ 的圆的边上。</p><p>因为找一个圆需要 $3$ 个点才能确定，所以我们再去寻找一个点。</p><p>我们将圆设置为 $p(i), p(j)$ 为直径的圆，再从前循环 $p(k)$，寻找到 $p(k)$ 不在 $p(i), p(j)$ 为直径的圆上。仿照前面的证明，我们就可以得到 $p(k), p(i), p(j)$ 都在圆上，我们就是求出了 ${1, …, k} \cup{i, j}$ 的最小圆覆盖。</p><p>最后我们一直循环，直到最后覆盖到了 ${1, …, i - 1}\cup{i}$ 也就是 ${1, …, i}$ 的圆覆盖。</p><h2 id="3-复杂度"><a href="#3-复杂度" class="headerlink" title="3. 复杂度"></a>3. 复杂度</h2><p>看似有 $O(n ^ 3)$，但是两步判断都是 $\dfrac{3}{n}$ 的概率，我们就可以得到时间复杂度为 $O(n)$。（感觉特别玄学</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">get_point</span><span class="params">(Point p1, Point k1, Point p2, Point k2)</span></span>&#123;</span><br><span class="line">Point u = p1 - p2;</span><br><span class="line"><span class="keyword">double</span> t = (k2 * u) / (k1 * k2);</span><br><span class="line"><span class="keyword">return</span> p1 + k1 * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Circle <span class="title">circle_by_point</span><span class="params">(Point a, Point b, Point c)</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> l1 = <span class="built_in">get_line</span>(a, b), l2 = <span class="built_in">get_line</span>(a, c);</span><br><span class="line">Point o = <span class="built_in">get_point</span>(l1.first, l1.second, l2.first, l2.second);</span><br><span class="line"><span class="keyword">return</span> &#123;o, <span class="built_in">dist2</span>(a, o)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Circle <span class="title">min_circle</span><span class="params">(Point *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">random_shuffle</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line">Circle ans = &#123;p[<span class="number">1</span>], <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">in_circle</span>(ans, p[i])) <span class="keyword">continue</span>;</span><br><span class="line">ans = &#123;p[i], <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++ j)&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">in_circle</span>(ans, p[j])) <span class="keyword">continue</span>;</span><br><span class="line">ans = &#123;(p[i] + p[j]) / <span class="number">2</span>, <span class="built_in">dist2</span>((p[i] + p[j]) / <span class="number">2</span>, p[i])&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; j; ++ k)</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">in_circle</span>(ans, p[k])) ans = <span class="built_in">circle_by_point</span>(p[i], p[j], p[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans.r = <span class="built_in">sqrt</span>(ans.r);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;还是一个计算几何。&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算几何" scheme="https://mydcwfy.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>凸包与旋转卡壳</title>
    <link href="https://mydcwfy.github.io/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/"/>
    <id>https://mydcwfy.github.io/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/</id>
    <published>2022-01-19T10:37:25.000Z</published>
    <updated>2022-01-21T12:51:18.703Z</updated>
    
    <content type="html"><![CDATA[<p>前置知识：计算几何。</p><span id="more"></span><h2 id="1-凸包"><a href="#1-凸包" class="headerlink" title="1. 凸包"></a>1. 凸包</h2><p>直接理解为我们用一条橡皮筋围住这些点。</p><p>我们就不再介绍 Javis 算法，直接介绍两个时间复杂度更优的 Graham 和 Andrew 算法。</p><h3 id="1）Graham-算法"><a href="#1）Graham-算法" class="headerlink" title="1）Graham 算法"></a>1）Graham 算法</h3><p>我们首先选择最左下方的点，注意到这个点一定是凸包上的点。假设这个点为 A。</p><p>接着，我们按照 A 点与这些点的连线与水平线的夹角排序。注意到如果夹角相同，将最远的点放在最前面。</p><p>接着，我们扫描整个数组，同时维护一个栈，记录当前的凸包里的点。</p><p>我们要加入一个点的时候，如果当前的栈里的点会和这个点形成一个顺时针的转角的话，我们就将栈顶弹出。</p><img src="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/%E5%87%B8%E5%8C%851.png" class=""><p>看到这个图，我们现在要将红线上面的点加入，容易发现红线下面这个点是一定不需要的，我们直接弹出即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Point &amp;t1, <span class="keyword">const</span> Point &amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t1 - p[<span class="number">1</span>]) * (t2 - p[<span class="number">1</span>]) &gt; eps || (<span class="built_in">fabs</span>((t1 - p[<span class="number">1</span>]) * (t2 - p[<span class="number">1</span>])) &lt; eps &amp;&amp; <span class="built_in">dist</span>(p[<span class="number">1</span>], t1) &gt; <span class="built_in">dist</span>(p[<span class="number">1</span>], t2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    <span class="keyword">if</span> (p[i].y &lt; p[t].y || (<span class="built_in">fabs</span>(p[i].y - p[t].y) &lt; eps &amp;&amp; p[i].x &lt; p[t].x)) t = i;</span><br><span class="line"><span class="built_in">swap</span>(p[<span class="number">1</span>], p[t]);</span><br><span class="line"><span class="built_in">sort</span>(p + <span class="number">2</span>, p + n + <span class="number">1</span>, cmp);</span><br><span class="line">stk[++ top] = p[<span class="number">1</span>], stk[++ top] = p[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; (stk[top] - stk[top - <span class="number">1</span>]) * (p[i] - stk[top]) &lt; -eps) top --;</span><br><span class="line">    stk[++ top] = p[i];</span><br><span class="line">&#125;</span><br><span class="line">stk[++ top] = p[<span class="number">1</span>];<span class="comment">//第一个点进入两次，便于计算周长面积</span></span><br></pre></td></tr></table></figure><h3 id="2）Andrew-算法"><a href="#2）Andrew-算法" class="headerlink" title="2）Andrew 算法"></a>2）Andrew 算法</h3><p>我们不再按照夹角排序，直接使用 x 坐标排序，结果又如何呢？</p><p>我们这么遍历，发现只会走到一半的凸壳。</p><p>于是，我们再会过来遍历一次，就可以把另一半的凸壳遍历到了！</p><p>这个算法避免的一些复杂的夹角的计算，常数略小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2)</span></span>&#123;<span class="keyword">return</span> (p1.x == p2.x) ? (p1.y &lt; p2.y) : p1.x &lt; p2.x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Andrew</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; (p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> ((p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt; <span class="number">0</span>) usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> top --;</span><br><span class="line">usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">usd[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (usd[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; (p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> ((p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt; <span class="number">0</span>) usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> top --;</span><br><span class="line">usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）例题"><a href="#3）例题" class="headerlink" title="3）例题"></a>3）例题</h3><h4 id="T1：信用卡凸包"><a href="#T1：信用卡凸包" class="headerlink" title="T1：信用卡凸包"></a>T1：信用卡凸包</h4><p><a href="https://www.luogu.com.cn/problem/P3829">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2938/">题目传送门 AcWing</a></p><p>我们可以发现，一个凸多边形的外角是 $360^{\circ}$。</p><p>那么，圆形一定贡献的是一个周角的大小。剩下的，我们发现可以向内平移到圆心的位置。按圆心凸包即可。</p><img src="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/%E5%87%B8%E5%8C%852.png" class=""><p>可以发现，黑直线的长度就是红线的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %lf %lf %lf&quot;</span>, &amp;n, &amp;a, &amp;b, &amp;R);</span><br><span class="line">a -= <span class="number">2</span> * R, b -= <span class="number">2</span> * R;</span><br><span class="line"><span class="keyword">double</span> x, y, th;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf&quot;</span>, &amp;x, &amp;y, &amp;th);</span><br><span class="line">x += eps, y += eps, th += eps;</span><br><span class="line">p[(i &lt;&lt; <span class="number">2</span>) - <span class="number">3</span>] = (Point)&#123;x, y&#125; + <span class="built_in">rotate</span>(&#123;b / <span class="number">2</span>, a / <span class="number">2</span>&#125;, th);</span><br><span class="line">p[(i &lt;&lt; <span class="number">2</span>) - <span class="number">2</span>] = (Point)&#123;x, y&#125; + <span class="built_in">rotate</span>(&#123;-b / <span class="number">2</span>, a / <span class="number">2</span>&#125;, th);</span><br><span class="line">p[(i &lt;&lt; <span class="number">2</span>) - <span class="number">1</span>] = (Point)&#123;x, y&#125; + <span class="built_in">rotate</span>(&#123;-b / <span class="number">2</span>, -a / <span class="number">2</span>&#125;, th);</span><br><span class="line">p[(i &lt;&lt; <span class="number">2</span>)] = (Point)&#123;x, y&#125; + <span class="built_in">rotate</span>(&#123;b / <span class="number">2</span>, -a / <span class="number">2</span>&#125;, th);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Andrew</span>(n &lt;&lt; <span class="number">2</span>);</span><br><span class="line"><span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; ++ i)</span><br><span class="line">res += <span class="built_in">dist</span>(p[stk[i]], p[stk[i + <span class="number">1</span>]]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>, res + <span class="number">2</span> * <span class="built_in">acos</span>(<span class="number">-1</span>) * R);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-半平面交"><a href="#2-半平面交" class="headerlink" title="2. 半平面交"></a>2. 半平面交</h2><p>我们介绍一种办法（我似乎并不知道是什么算法），能在 $O(n \log n)$ 的时间求出围住的凸多边形（注意好像不能判断无解的情况）。</p><p>为了方便，我们定义半平面存储为一条有向直线，在这条直线逆时针（可以理解为左边）的部分即为半平面。</p><h3 id="1）算法流程"><a href="#1）算法流程" class="headerlink" title="1）算法流程"></a>1）算法流程</h3><p>我们首先按照每条线与 $x$ 轴的夹角排序，如果相同，说明是平行的，我们按照从左至右的顺序。</p><p>然后，我们顺次插入每一个半平面。我们维护一个如此的双端队列来表示当前的半平面。</p><img src="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A41.png" class=""><p>接着，我们插入的时候，看一下有没有在当前半平面外面的交点，也就是判断有没有在直线顺时针的点，有的话就删除。</p><img src="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A42.png" class=""><p>比如蓝点在新加入的蓝线右边，所以肯定会导致最后加入的黑线被弹出队尾。</p><p>注意有可能线的方向不定导致会弹出队首，所以前后都要判断。</p><p>最后的时候，我们再用队首来尝试弹出队尾，队尾尝试弹出队首。</p><p>注意我们求夹角的时候，可以使用 <code>atan2(x, y)</code>，这样可以防止出现 <code>nan</code> 的情况，因为他会判断 $y$ 是否等于 0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">get_point_</span><span class="params">(Point p1, Point k1, Point p2, Point k2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point u = p1 - p2;</span><br><span class="line"><span class="keyword">double</span> t = (k2 * u) / (k1 * k2);</span><br><span class="line"><span class="keyword">return</span> &#123;t * k1.x + p1.x, t * k1.y + p1.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">get_point</span><span class="params">(<span class="keyword">const</span> Line &amp;l1, <span class="keyword">const</span> Line &amp;l2)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">get_point_</span>(l1.st, l1.ed - l1.st, l2.st, l2.ed - l2.st);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">on_right</span><span class="params">(<span class="keyword">const</span> Line &amp;a, <span class="keyword">const</span> Line &amp;b, <span class="keyword">const</span> Line &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point t = <span class="built_in">get_point</span>(b, c);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sgn</span>((a.ed - a.st) * (t - a.st)) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">half_plane</span><span class="params">(Line l[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(l + <span class="number">1</span>, l + n + <span class="number">1</span>, lcmp);</span><br><span class="line">hh = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; !<span class="built_in">cmp</span>(<span class="built_in">angle</span>(l[i]), <span class="built_in">angle</span>(l[i - <span class="number">1</span>]))) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[i], l[q[tt - <span class="number">1</span>]], l[q[tt]])) tt --;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[i], l[q[hh]], l[q[hh + <span class="number">1</span>]])) hh ++;</span><br><span class="line">q[++ tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[q[hh]], l[q[tt - <span class="number">1</span>]], l[q[tt]])) tt --;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[q[tt]], l[q[hh]], l[q[hh + <span class="number">1</span>]])) hh ++;</span><br><span class="line">q[++ tt] = q[hh];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）例题"><a href="#2）例题" class="headerlink" title="2）例题"></a>2）例题</h3><h4 id="T2：-JLOI-2013-赛车"><a href="#T2：-JLOI-2013-赛车" class="headerlink" title="T2：[JLOI 2013]赛车"></a>T2：[JLOI 2013]赛车</h4><p><a href="https://www.luogu.com.cn/problem/P3256">题目传送门 Luogu</a></p><p>半平面交的模板题，注意用 <code>long double</code>，并且把精度调高一点。</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> LD;</span><br><span class="line"><span class="keyword">const</span> LD eps = <span class="number">1e-18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">LD x, y;</span><br><span class="line">Point <span class="keyword">operator</span> +(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x + t.x, y + t.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Point <span class="keyword">operator</span> -(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">LD <span class="keyword">operator</span> *(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * t.y - y * t.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">Point st, ed;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; id;</span><br><span class="line">&#125;l[N];</span><br><span class="line"><span class="keyword">int</span> q[N], hh, tt;</span><br><span class="line"><span class="keyword">int</span> ki[N], vi[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> angle = [](<span class="keyword">const</span> Line &amp;l)&#123;<span class="keyword">return</span> <span class="built_in">atan2</span>(l.ed.y - l.st.y, l.ed.x - l.st.x);&#125;;</span><br><span class="line"><span class="keyword">auto</span> sgn = [](LD x)&#123;<span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">fabs</span>(x) &lt; eps) ? <span class="number">0</span> : (x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>);&#125;;</span><br><span class="line"><span class="keyword">auto</span> cmp = [](LD x, LD y)&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>(x - y);&#125;;</span><br><span class="line"><span class="keyword">auto</span> lcmp = [](<span class="keyword">const</span> Line &amp;l1, <span class="keyword">const</span> Line &amp;l2)&#123;</span><br><span class="line">LD A = <span class="built_in">angle</span>(l1), B = <span class="built_in">angle</span>(l2);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cmp</span>(A, B) == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">sgn</span>((l1.ed - l1.st) * (l2.ed - l1.st)) &lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> A &lt; B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">get_point_</span><span class="params">(Point p1, Point k1, Point p2, Point k2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point del = p1 - p2;</span><br><span class="line">LD t = (k2 * del) / (k1 * k2);</span><br><span class="line"><span class="keyword">return</span> &#123;t * k1.x + p1.x, t * k1.y + p1.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">get_point</span><span class="params">(<span class="keyword">const</span> Line &amp;l1, <span class="keyword">const</span> Line &amp;l2)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">get_point_</span>(l1.st, l1.ed - l1.st, l2.st, l2.ed - l2.st);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">on_right</span><span class="params">(<span class="keyword">const</span> Line &amp;a, <span class="keyword">const</span> Line &amp;b, <span class="keyword">const</span> Line &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point t = <span class="built_in">get_point</span>(b, c);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sgn</span>((t - a.st) * (a.ed - a.st)) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">half_plane</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(l + <span class="number">1</span>, l + n + <span class="number">1</span>, lcmp);</span><br><span class="line">hh = <span class="number">1</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; !<span class="built_in">cmp</span>(<span class="built_in">angle</span>(l[i]), <span class="built_in">angle</span>(l[i - <span class="number">1</span>]))) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[i], l[q[tt - <span class="number">1</span>]], l[q[tt]])) tt --;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[i], l[q[hh]], l[q[hh + <span class="number">1</span>]])) hh ++;</span><br><span class="line">q[++ tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[q[tt]], l[q[hh]], l[q[hh + <span class="number">1</span>]])) hh ++;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[q[hh]], l[q[tt - <span class="number">1</span>]], l[q[tt]])) tt --;</span><br><span class="line">q[++ tt] = q[hh];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = hh; i &lt; tt; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : l[q[i]].id) ans.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : ans) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;PII, vector&lt;<span class="keyword">int</span>&gt; &gt; ids;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">l[++ cnt] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">10000</span>, <span class="number">0</span>&#125;, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>)&#125;;</span><br><span class="line">l[++ cnt] = &#123;&#123;<span class="number">0</span>, <span class="number">10000</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>)&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; ki[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; vi[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">ids[&#123;ki[i], vi[i]&#125;].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : ids)</span><br><span class="line">l[++ cnt] = &#123;&#123;<span class="number">0</span>, c.first.first&#125;, &#123;<span class="number">1</span>, c.first.first + c.first.second&#125;, c.second&#125;;</span><br><span class="line"><span class="built_in">half_plane</span>(cnt);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="3-三维凸包"><a href="#3-三维凸包" class="headerlink" title="3. 三维凸包"></a>3. 三维凸包</h2><h3 id="1）三维空间向量"><a href="#1）三维空间向量" class="headerlink" title="1）三维空间向量"></a>1）三维空间向量</h3><h4 id="a-加减、数乘、模长"><a href="#a-加减、数乘、模长" class="headerlink" title="a. 加减、数乘、模长"></a>a. 加减、数乘、模长</h4><p>与二维向量相同，不再赘述。</p><h4 id="b-点乘"><a href="#b-点乘" class="headerlink" title="b. 点乘"></a>b. 点乘</h4><p>得到是一个数。</p><p>$(x1, y1, z1) \cdot (x2, y2, z2) = x1x2 + y1y2 + z1z2$。</p><p>注意满足 $|A||B|\cos&lt;A, B&gt; = A \cdot B$。</p><h4 id="c-叉乘"><a href="#c-叉乘" class="headerlink" title="c. 叉乘"></a>c. 叉乘</h4><p>得到不是数，是一个行列式的结果。<br>$$<br>det\left(<br>\begin{matrix}<br>i &amp; j &amp; k\<br>x1 &amp; y1 &amp; z1\<br>x2 &amp; y2 &amp; z2<br>\end{matrix}<br>\right)<br>$$<br>注意 $i, j, k$ 是空间单位向量，得到的明显也是一个三位向量。</p><p>展开行列式，可以得到：$(x1, y1, z1) \times (x2, y2, z2) = (y1z2 - y2z1, x2z1 - x1z2, x1y2 - x2y1)$。</p><h4 id="d-多面体欧拉定理"><a href="#d-多面体欧拉定理" class="headerlink" title="d. 多面体欧拉定理"></a>d. 多面体欧拉定理</h4><p>点数 - 棱数 + 面数 = 2。</p><h4 id="e-平面的法向量"><a href="#e-平面的法向量" class="headerlink" title="e. 平面的法向量"></a>e. 平面的法向量</h4><p>法向量是指垂直于</p><p>任意取两个向量</p><h3 id="2）三维凸包-增量法"><a href="#2）三维凸包-增量法" class="headerlink" title="2）三维凸包 - 增量法"></a>2）三维凸包 - 增量法</h3><p>其实是一个暴力算法，时间复杂度为 $O(n ^ 2)$。</p><p>我们首先找到任意不共面的 4 个点，使得可以形成一个凸包。</p><p>然后，我们尝试加入每一个点。</p><p>如果它在凸包里，则跳过；否则我们考虑加入。</p><p>假设这个点是一个太阳，那么一定会有一些面是“白天”，还有一些棱是“晨昏线”。</p><p>我们将”白天“全部删除，并且将”晨昏线“与新加的点相连，形成新的凸包。</p><p>具体看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Convex_3d</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> bitset&lt;N&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, ncnt = <span class="number">0</span>;</span><br><span class="line">pl[++ cnt] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, pl[++ cnt] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">ncnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++ j)&#123;</span><br><span class="line"><span class="keyword">bool</span> t = pl[j].<span class="built_in">above</span>(p[i]);</span><br><span class="line"><span class="keyword">if</span> (!t) np[++ ncnt] = pl[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++ k)</span><br><span class="line">g[pl[j].v[k]][pl[j].v[(k + <span class="number">1</span>) % <span class="number">3</span>]] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++ k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a = pl[j].v[k], b = pl[j].v[(k + <span class="number">1</span>) % <span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span> (g[a][b] &amp;&amp; !g[b][a]) np[++ ncnt] = &#123;a, b, i&#125;;</span><br><span class="line">&#125;</span><br><span class="line">cnt = ncnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++ j) pl[j] = np[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-旋转卡壳"><a href="#4-旋转卡壳" class="headerlink" title="4. 旋转卡壳"></a>4. 旋转卡壳</h2><p>其实不是一种模板或者算法，而是一种思想或者是做题的技巧。</p><h3 id="1）思想"><a href="#1）思想" class="headerlink" title="1）思想"></a>1）思想</h3><p>我们定义<strong>对踵点</strong>为任意两条平行的直线，向中间靠拢的时候碰到的点。</p><img src="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B31.png" class=""><p>很明显，我们的对踵点的个数是 $O(n)$ 级别的，所以我们并不需要枚举每一条平行的直线。我们可以考虑直接枚举与凸包边平行的边。</p><p>下面假设我们要寻找直径，也就是最长的线段。</p><p>我们先确定 $p(i)$ 为对踵点的一端，我们怎样才能寻找到与之相对的对踵点呢？</p><p>很明显，我们可以暴力枚举，但时间复杂度是 $O(n ^ 2)$，不优。</p><p>我们可以发现，随着我们的 $p(i)$ 一直都是顺时针（或者逆时针）旋转的，$p(j)$ 也一定是顺时针旋转的。</p><p>所以，我们可以使用双指针算法，可以做到 $O(n)$，瓶颈在前面的凸包，时间复杂度为 $O(n \log n)$。</p><p>怎样判断哪个点是最远的呢？我们回顾<strong>叉积</strong>的定义，发现是三角形的面积。我们再拉一个 $p(i + 1)$ 过来，就可以求面积了，同时这条直线就是 $p(i), p(i + 1)$。</p><p>具体看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">2</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ((s[i + <span class="number">1</span>] - s[i]) * (s[j] - s[i]) &lt; (s[i + <span class="number">1</span>] - s[i]) * (s[j + <span class="number">1</span>] - s[i])) j = (j + <span class="number">1</span>) % n;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(<span class="built_in">dist2</span>(s[i], s[j]), <span class="built_in">dist2</span>(s[i + <span class="number">1</span>], s[j])));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2）例题-1"><a href="#2）例题-1" class="headerlink" title="2）例题"></a>2）例题</h3><h4 id="T1：求最远点距离"><a href="#T1：求最远点距离" class="headerlink" title="T1：求最远点距离"></a>T1：求最远点距离</h4><p><a href="https://www.luogu.com.cn/problem/P1452">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/description/2941/">题目传送门 AcWing</a></p><p>刚才讲到的，直接上代码。</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    Point <span class="keyword">operator</span> -(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    LL <span class="keyword">operator</span> *(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (LL)x * t.y - (LL)y * t.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="keyword">int</span> stk[N], top, n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> cmp = [](Point t1, Point t2)&#123;</span><br><span class="line">    <span class="keyword">return</span> t1.x == t2.x ? t1.y &lt; t2.y : t1.x &lt; t2.x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dist2</span><span class="params">(Point p1, Point p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Andrew</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> usd[N];</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; (p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt;= <span class="number">0</span>)</span><br><span class="line">            usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line">        usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    usd[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (usd[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; (p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt; <span class="number">0</span>)</span><br><span class="line">            usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line">        usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    top --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">get_dist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">dist2</span>(p[stk[<span class="number">1</span>]], p[stk[<span class="number">2</span>]]);</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">2</span>; i &lt;= top; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ((p[stk[i + <span class="number">1</span>]] - p[stk[i]]) * (p[stk[j]] - p[stk[i]]) &lt; (p[stk[i + <span class="number">1</span>]] - p[stk[i]]) * (p[stk[j + <span class="number">1</span>]] - p[stk[i]]))</span><br><span class="line">            j = j % top + <span class="number">1</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(<span class="built_in">dist2</span>(p[stk[i + <span class="number">1</span>]], p[stk[j]]), <span class="built_in">dist2</span>(p[stk[i]], p[stk[j]])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">    <span class="built_in">Andrew</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">get_dist</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h4 id="T2：最小矩形覆盖"><a href="#T2：最小矩形覆盖" class="headerlink" title="T2：最小矩形覆盖"></a>T2：最小矩形覆盖</h4><p><a href="https://www.luogu.com.cn/problem/P3187">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2144/">题目传送门 AcWing</a></p><p>先搁着 qwq</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> INF = <span class="number">1e20</span>, eps = <span class="number">1e-12</span>, Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point <span class="keyword">operator</span> +(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + t.x, y + t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> -(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> *(<span class="keyword">double</span> t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x * t, y * t&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> /(<span class="keyword">double</span> t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x / t, y / t&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> *(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * t.y - y * t.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> &amp;(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * t.x + y * t.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N], ans[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> stk[N], top, n;</span><br><span class="line"><span class="keyword">double</span> mxa = INF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(x) &lt; eps ? <span class="number">0</span> : (x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>(x - y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">(Point a)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(a &amp; a);&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">(Point a, Point b, Point c)</span></span>&#123;<span class="keyword">return</span> (b - a) * (c - a);&#125;</span><br><span class="line"><span class="function">Point <span class="title">normal</span><span class="params">(Point t)</span></span>&#123;<span class="keyword">return</span> t / <span class="built_in">len</span>(t);&#125;</span><br><span class="line"><span class="function">Point <span class="title">rotate</span><span class="params">(Point a, <span class="keyword">double</span> th)</span></span>&#123;<span class="keyword">return</span> &#123;a.x * <span class="built_in">cos</span>(th) + a.y * <span class="built_in">sin</span>(th), a.y * <span class="built_in">cos</span>(th) - a.x * <span class="built_in">sin</span>(th)&#125;;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pcmp</span><span class="params">(Point a, Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">project</span><span class="params">(Point a, Point b, Point c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((b - a) &amp; (c - a)) / <span class="built_in">len</span>(b - a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Andrew</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> usd[N];</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, pcmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">area</span>(p[stk[top - <span class="number">1</span>]], p[stk[top]], p[i]) &gt;= <span class="number">0</span>)</span><br><span class="line">            usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line">        usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    usd[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (usd[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">area</span>(p[stk[top - <span class="number">1</span>]], p[stk[top]], p[i]) &gt;= <span class="number">0</span>)</span><br><span class="line">            usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line">        usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(stk + <span class="number">1</span>, stk + top + <span class="number">1</span>);</span><br><span class="line">    top --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_ju</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">3</span>, k = <span class="number">2</span>, l = <span class="number">3</span>; i &lt;= top; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        Point d = p[stk[i]], e = p[stk[i + <span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cmp</span>(<span class="built_in">area</span>(d, e, p[stk[j]]), <span class="built_in">area</span>(d, e, p[stk[j + <span class="number">1</span>]])) &lt; <span class="number">0</span>)</span><br><span class="line">            j = j % top + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cmp</span>(<span class="built_in">project</span>(d, e, p[stk[k]]), <span class="built_in">project</span>(d, e, p[stk[k + <span class="number">1</span>]])) &lt; <span class="number">0</span>)</span><br><span class="line">            k = k % top + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) l = j;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cmp</span>(<span class="built_in">project</span>(d, e, p[stk[l]]), <span class="built_in">project</span>(d, e, p[stk[l + <span class="number">1</span>]])) &gt; <span class="number">0</span>)</span><br><span class="line">            l = l % top + <span class="number">1</span>;</span><br><span class="line">        Point x = p[stk[j]], y = p[stk[k]], z = p[stk[l]];</span><br><span class="line">        <span class="keyword">double</span> h = <span class="built_in">area</span>(d, e, x) / <span class="built_in">len</span>(e - d),</span><br><span class="line">               w = ((y - z) &amp; (e - d)) / <span class="built_in">len</span>(e - d);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; h &lt;&lt; &#x27; &#x27; &lt;&lt; w &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (h * w &lt; mxa)&#123;</span><br><span class="line">            mxa = h * w;</span><br><span class="line">            ans[<span class="number">0</span>] = d + <span class="built_in">normal</span>(e - d) * <span class="built_in">project</span>(d, e, y);</span><br><span class="line">            ans[<span class="number">3</span>] = d + <span class="built_in">normal</span>(e - d) * <span class="built_in">project</span>(d, e, z);</span><br><span class="line">            Point t = <span class="built_in">normal</span>(<span class="built_in">rotate</span>(e - d, -Pi / <span class="number">2</span>));</span><br><span class="line">            ans[<span class="number">1</span>] = ans[<span class="number">0</span>] + t * h;</span><br><span class="line">            ans[<span class="number">2</span>] = ans[<span class="number">3</span>] + t * h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">    <span class="built_in">Andrew</span>();</span><br><span class="line">    <span class="comment">// cout &lt;&lt; top &lt;&lt; endl, exit(0);</span></span><br><span class="line">    <span class="built_in">find_ju</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.5lf\n&quot;</span>, mxa);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cmp</span>(ans[i].y, ans[k].y) &lt; <span class="number">0</span> || !<span class="built_in">cmp</span>(ans[i].y, ans[k].y) &amp;&amp; <span class="built_in">cmp</span>(ans[i].x, ans[k].x) &lt; <span class="number">0</span>)</span><br><span class="line">            k = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i, k ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">4</span>) k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> x = ans[k].x + eps, y = ans[k].y + eps;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt; eps) x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(y) &lt; eps) y = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.5lf %.5lf\n&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;前置知识：计算几何。&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算几何" scheme="https://mydcwfy.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
    <category term="凸包" scheme="https://mydcwfy.github.io/tags/%E5%87%B8%E5%8C%85/"/>
    
    <category term="旋转卡壳" scheme="https://mydcwfy.github.io/tags/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/"/>
    
  </entry>
  
  <entry>
    <title>计算几何基础</title>
    <link href="https://mydcwfy.github.io/2022/01/19/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://mydcwfy.github.io/2022/01/19/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/</id>
    <published>2022-01-19T06:28:54.000Z</published>
    <updated>2022-01-19T12:32:46.419Z</updated>
    
    <content type="html"><![CDATA[<p>需要的初高中几何知识是比较多的。</p><span id="more"></span><h2 id="1-数学基础"><a href="#1-数学基础" class="headerlink" title="1. 数学基础"></a>1. 数学基础</h2><p>$$<br>\begin{aligned}<br>\pi &amp;= \arccos(-1)\\<br>c^2 &amp;= a^2 + b^2 - 2ab\cos\theta<br>\end{aligned}<br>$$</p><p>第一个的原理来自于：$\cos \pi = -1$。</p><p>第二个是一个余弦定理。</p><h2 id="2-关于浮点数"><a href="#2-关于浮点数" class="headerlink" title="2. 关于浮点数"></a>2. 关于浮点数</h2><p>比如我们比较两个数的时候，他们可能因为计算的误差而不同。所以我们必须定义一个 $\epsilon$，表示两个的差别，如果在 $\epsilon$ 中的话，我们就认为这两个数相等。$\epsilon$ 可以定义为 $10^{-8}, 10^{-9}$ 等等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_equal</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(x - y) &lt; eps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，如果比较两个数的大小，我们同样也要使用 $\epsilon$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x - y) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-向量"><a href="#3-向量" class="headerlink" title="3. 向量"></a>3. 向量</h2><p>首先，简单的向量加减不再展开。</p><p>我们先介绍点乘：$a \cdot b = |a||b|\cos&lt;a, b&gt;$。</p><p>如果在二维点坐标下计算，就是 $(a, b) \cdot (c, d) = ac + bd$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dot</span><span class="params">(Point a, Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们计算一个向量的模的时候，可以直接计算就是了，也可以 $|a| = \sqrt{a \cdot a}$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">(Point a)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">dot</span>(a, a));&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用点乘来计算两个之间的夹角。</p><p>$\cos&lt;a, b&gt; = \dfrac{a\cdot b}{|a||b|}$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_angle</span><span class="params">(Point a, Point b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">acos</span>(<span class="built_in">dot</span>(a) / <span class="built_in">length</span>(a) / <span class="built_in">length</span>(b));&#125;</span><br></pre></td></tr></table></figure><p>还有一种乘法，是叉乘：$a\times b = |a||b|\sin&lt;a, b&gt;$。</p><p>如果是二维点坐标，就是 $(a, b)\times (c, d) = ad - bc$。</p><p>如果叉乘大于 0 的话，那么 $a$ 向量在 $b$ 向量的顺时针的方向。注意叉乘没有交换性。一般将叉乘重载为乘法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Point a, Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个，我们转一个角。</p><p>直接写出公式，证明可以使用和差角公式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">rotate</span><span class="params">(Point a, <span class="keyword">double</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;a.x * <span class="built_in">cos</span>(c) - a.y * <span class="built_in">sin</span>(c), a.x * <span class="built_in">sin</span>(c) + a.y * <span class="built_in">cos</span>(c)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-计算几何"><a href="#4-计算几何" class="headerlink" title="4. 计算几何"></a>4. 计算几何</h2><p>似乎能写的似乎不多……</p><p>我们简单的看几个比较常用的。</p><h3 id="1）直线相交"><a href="#1）直线相交" class="headerlink" title="1）直线相交"></a>1）直线相交</h3><p>首先，判断两个直线是否相交：$a\times b \not= 0$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_cross</span><span class="params">(Point a, Point b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">cross</span>(a, b) != <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="2）线段相交"><a href="#2）线段相交" class="headerlink" title="2）线段相交"></a>2）线段相交</h3><p>分为两步：快速排斥实验和跨立实验。</p><p>快速排斥实验是指如果两个线段所在的矩形如果不相交，那么两条线段一定不相交。</p><img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C.png" class=""><p>如果两个线段所在的矩形是相交的，也不说明两条线段是相交的。</p><img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C2.png" class=""><p>我们需要判断两个线段相交的话，需要判断一个线段的两个点是否在另外一个线段所在直线的两侧。</p><p>具体来说，就是判断 $(p3 - p1) \times (p2 - p1)$ 与 $(p4 - p1) \times (p2 - p1)$ 是否异号。</p><p>另外，我们可以直接对这两条线段都这么计算，可以省去第一步。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cross_seg</span><span class="params">(Point p1, Point p2, Point p3, Point p4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (((p1 - p3) * (p4 - p3)) * ((p2 - p3) * (p4 - p3)) &gt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (((p3 - p1) * (p2 - p1)) * ((p4 - p1) * (p2 - p1)) &gt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）判断一个点是否在多边形内"><a href="#3）判断一个点是否在多边形内" class="headerlink" title="3）判断一个点是否在多边形内"></a>3）判断一个点是否在多边形内</h3><p>注意不一定是凸多边形。</p><p>有一个结论：<strong>经过凸多边形的边奇数次，就在凸多边形内。</strong></p><p>很明显，没经过一次边，就会导致从外到内，或者从内到外。最后一定是在外部，所以奇数次的话该点就在里面。</p><p>注意这个结论在经过某一个顶点或者射线与边重合时并不适用，所以我们随机一个在凸多边形外部的点判断就可以了。</p><p>（不保证代码正确</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in_polygon</span><span class="params">(Point *p, Point a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p[n + <span class="number">1</span>] = p[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>((p[<span class="number">1</span>] - p[i]) * (p[i + <span class="number">1</span>] - p[i])) &lt; eps &amp;&amp;</span><br><span class="line"><span class="built_in">dot</span>(p[<span class="number">1</span>] - p[i], p[i + <span class="number">1</span>] - p[i]) &gt; eps &amp;&amp; <span class="built_in">dot</span>(p[i + <span class="number">1</span>] - p[<span class="number">1</span>], p[i + <span class="number">1</span>] - p[i]) &gt; eps)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Point c = &#123;(<span class="keyword">double</span>)<span class="built_in">rand</span>(), (<span class="keyword">double</span>)<span class="built_in">rand</span>()&#125;;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; !flag; ++ i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>((c - a) * (p[i] - a)) &lt; eps &amp;&amp; <span class="built_in">fabs</span>((c - a) * (p[i + <span class="number">1</span>] - a)) &lt; eps)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">flag ^= <span class="built_in">cross_seg</span>(a, c, p[i], p[i + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4）多边形面积"><a href="#4）多边形面积" class="headerlink" title="4）多边形面积"></a>4）多边形面积</h3><p>这是一个结论，我们就不证明了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sum_area</span><span class="params">(Point *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++ i)</span><br><span class="line">res += (p[i + <span class="number">1</span>] - p[<span class="number">1</span>]) * (p[i] - p[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-例题"><a href="#5-例题" class="headerlink" title="5. 例题"></a>5. 例题</h2><h3 id="T1：玩具"><a href="#T1：玩具" class="headerlink" title="T1：玩具"></a>T1：玩具</h3><p><a href="http://poj.org/problem?id=2318">题目传送门 POJ</a></p><p>我们二分，找到第一个在该点左边的隔板。判断这个点是否在线段的右边（这里是顺时针方向），直接用叉乘即可。</p><details><summary>完整代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">LL x, y;</span><br><span class="line">Point <span class="keyword">operator</span> +(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x + t.x, y + t.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Point <span class="keyword">operator</span> -(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">LL <span class="keyword">operator</span> *(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * t.y - y * t.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;L, R, now, up[N], dn[N];</span><br><span class="line"><span class="keyword">int</span> n, m, cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> is_fir = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %lld %lld %lld %lld&quot;</span>, &amp;m, &amp;L.x, &amp;R.y, &amp;R.x, &amp;L.y);</span><br><span class="line">up[<span class="number">0</span>] = &#123;L.x, L.y&#125;, dn[<span class="number">0</span>] = &#123;L.x, R.y&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;dn[i].x, &amp;up[i].x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) up[i].y = L.y, dn[i].y = R.y;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) cnt[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!is_fir) <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cse = <span class="number">1</span>; cse &lt;= m; ++ cse)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;now.x, &amp;now.y);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((now - up[mid]) * (dn[mid] - up[mid]) &gt; <span class="number">0</span>) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cnt[l] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>, i, cnt[i]);</span><br><span class="line">is_fir = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;需要的初高中几何知识是比较多的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算几何" scheme="https://mydcwfy.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>P3321</title>
    <link href="https://mydcwfy.github.io/2021/12/27/P3321/"/>
    <id>https://mydcwfy.github.io/2021/12/27/P3321/</id>
    <published>2021-12-27T13:58:09.000Z</published>
    <updated>2021-12-27T14:30:15.756Z</updated>
    
    <content type="html"><![CDATA[<p>比较难想，但其实是一个套路。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给定匹配串 $a$ 和原串 $b$，要求像 KMP 一样匹配，但是有通配符（指和每一个都可以匹配），给出所有的起点可以匹配。</p><p>$|a|,|b|\leq 10 ^ 5 $。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>（以下字符串默认从 0 开始）</p><p>首先，肯定不是暴力枚举每一个通配符的匹配字符。</p><p>其中，对于一个字符串 $s$，构造<br>$$<br>F(x) = \sum_{i = 0}^{|s| - 1} [s(i) == ‘*’]\times s(i) \ x ^ i<br>$$<br>表示如果是通配符的话，就是 0，否则就是原字符本身。</p><p>我们现在假设要求 $k$ 这个位置能否匹配。</p><p>我们考虑构造：<br>$$<br>H_k = \sum_{i = 0}^{m - 1} A(i) \times B(i + k - 1) \times (A(i) - B(i + k - 1)) ^ 2\ x ^ i<br>$$<br>那么，$[x^i]H(x)$ 为 0 的话，有 3 种情况：</p><ol><li>$A(i) = 0$</li><li>$B(i) = 0$</li><li>$A(i) = B(i + x - 1)$</li></ol><p>可以发现，这三种情况正好对应的有通配符的情况下的匹配。</p><p>由于每一项非负，所以只要有一项不是 0，所以整个就不是 0。</p><p>那么，我们展开一下：<br>$$<br>H_k = \sum_{i = 0}^{m - 1} (A(i)^3B(i + k - 1) - 2A(i)^2B(i + k - 1) ^ 2 + A(i)B(i + k - 1) ^ 3)<br>$$<br>那么，我们就只需要求出所有的 $H(x)$，每一位都是 $H_k$，只需要统计 0 的个数就可以了。<br>$$<br>H(x) = \sum_{k = 0}^{n - 1}\sum_{i = 0}^{m - 1} (A(i)^3B(i + k - 1) - 2A(i)^2B(i + k - 1) ^ 2 + A(i)B(i + k - 1) ^ 3)<br>$$<br>这个很明显是一个差相等的会放到一个 $H_k$ 中，根据套路，我们把它翻转一个。<br>$$<br>H(x) = \sum_{k = 0}^{n - 1}\sum_{i = 0}^{m - 1} (A(m - i - 1)^3B(i + k - 1) - 2A(m - i - 1)^2B(i + k - 1) ^ 2 + A(m - i - 1)B(i + k - 1) ^ 3)<br>$$<br>直接 NTT 就可以了。注意每一项都要 NTT，而不是一次 NTT 直接计算。</p><p>注意<a href="https://www.luogu.com.cn/discuss/303076">有人卡 998244353</a>，直接把原根换成 5 或者模数换为 167772161 就可以了。但是确实可以被卡。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">Match</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">char</span> *s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; mat;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">strlen</span>(s1), n = <span class="built_in">strlen</span>(s2);</span><br><span class="line">    <span class="built_in">reverse</span>(s1, s1 + m);</span><br><span class="line">    <span class="keyword">static</span> LL f[N], g[N], h[N], a[N], b[N];</span><br><span class="line">    <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (n + m + <span class="number">1</span>)) bit ++;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) h[i] = f[i] = g[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s1[i] == <span class="string">&#x27;*&#x27;</span>) f[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> f[i] = s1[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s2[i] == <span class="string">&#x27;*&#x27;</span>) g[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> g[i] = s2[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//H(i - j) += F(i) * G(j) * (F(i) - G(j)) ^ 2</span></span><br><span class="line">    <span class="comment">//H(i + j - m - 1) += F(i) * G1(m - j - 1) * (F(i) - G1(j)) ^ 2</span></span><br><span class="line">    <span class="comment">/*for (int i = 0; i &lt; tot; ++ i)</span></span><br><span class="line"><span class="comment">        f[i] = (qpow(f[i], 3) * g[i] % Mod - qpow(f[i] * g[i] % Mod, 2) * 2 % Mod + qpow(g[i], 3) * f[i] % Mod + Mod) % Mod;*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = f[i] * f[i] * f[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) b[i] = g[i];</span><br><span class="line">    <span class="built_in">NTT</span>(a, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) h[i] = (h[i] + a[i] * b[i]) % Mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = f[i] * f[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) b[i] = g[i] * g[i];</span><br><span class="line">    <span class="built_in">NTT</span>(a, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) h[i] = (h[i] + (Mod - <span class="number">2</span>) * a[i] % Mod * b[i]) % Mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = f[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) b[i] = g[i] * g[i] * g[i];</span><br><span class="line">    <span class="built_in">NTT</span>(a, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) h[i] = (h[i] + a[i] * b[i]) % Mod;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NTT</span>(h, bit, <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// for (int i = m - 1; i &lt; n; ++ i) cout &lt;&lt; h[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line">    <span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (h[i] == <span class="number">0</span>) mat.<span class="built_in">push_back</span>(i - m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;比较难想，但其实是一个套路。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>二次剩余与 Cipolla 算法</title>
    <link href="https://mydcwfy.github.io/2021/12/26/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%E4%B8%8E-Cipolla-%E7%AE%97%E6%B3%95/"/>
    <id>https://mydcwfy.github.io/2021/12/26/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%E4%B8%8E-Cipolla-%E7%AE%97%E6%B3%95/</id>
    <published>2021-12-26T07:24:45.000Z</published>
    <updated>2021-12-30T12:11:50.248Z</updated>
    
    <content type="html"><![CDATA[<p>虽说比较困难，但是代码实现十分简单。</p><span id="more"></span><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>我们求解 $x ^ 2 \equiv n \pmod p$，其中 $n, p$ 给定，$p$ 是质数。就是二次剩余，可以记为 $x = \sqrt n$。</p><p>一般使用 Cipolla 算法，时间复杂度是玄学，期望是 $O(\log n)$，一般也比较稳定。</p><h2 id="2-推导过程"><a href="#2-推导过程" class="headerlink" title="2. 推导过程"></a>2. 推导过程</h2><p>首先，证明一下<strong>在 $\bmod p$ 意义下的有 $\sqrt n$ 的 $n$ 的个数有 $\dfrac{p - 1}{2}$ 个。</strong></p><p>首先，我们容易发现，$x$ 与 $p - x$ 在 $\bmod p$ 意义下是相等的。于是我们只需要判断 $x\in[1, \dfrac{p - 1}{2}]$ 的 $x ^ 2$ 是不相同的。这样的话，对于 $\dfrac{p - 1}{2}$ 个 $n$ 都有两个不同的二次剩余对应它。</p><p>使用反证法，我们假设 $x_1,x_2\in[1, \dfrac{p - 1}{2}]$ 的平方是一样的，那么可以得到 $(x_2 +x_1)(x_2 - x_1)\equiv 0\pmod p$。但是 $x_2 + x_1$ 和 $x_2 - x_1$ 都是不可能相等的，所以不可能存在这样的 $x_1$ 和 $x_2$。</p><p>第二个，我们有一个定理：<strong>如果 $n^{\frac{p - 1}{2}}\equiv 1\pmod p$，那么 $n$ 在 $\bmod p$ 下是有二次剩余的。</strong></p><p>这一个比较难证，这里就略过了。但是一个可以明确的地方是 $\forall n, n^{\frac{p - 1}2}\bmod p\in {1, p - 1}$。因为 $n^{p - 1}\bmod p = 1$。</p><p>第三个，我们找到一个 $a$，使得 $a^2 - n$ 是一个非二次剩余。找到 $a$ 的话，我们使用随机化算法，在 $[0, p - 1]$ 中随机，然后判断 $(a ^ 2 - n)^{\frac{p - 1}2}$ 是否等于 $-1\bmod p$。由于有 $\dfrac{p - 1}{2}$ 个数不是二次剩余，所以我们期望 2 次就可以找到一个 $a ^ 2 - n$。这一步的期望是 $O(\log n)$。</p><p>设 $w = a ^ 2 - n$。</p><p>最后一步，我们定义一个二维向量 $(a, b)$，表示 $a + b\sqrt w$。</p><p>我们可以得到第三个结论：<strong>将二维向量当作一个数来乘，$\sqrt n = (a, 1) ^{\frac{p - 1}{2}}$。</strong></p><p>其中，$(a, 1)$ 表示 $a + \sqrt w$ 这个数，我们将这个数 $\dfrac{p - 1}{2}$ 次方，实部就是 $\sqrt n$。</p><p>证明也太难了，我们就不讲了。</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p>首先，我们将向量直接看做复数封装好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    ll x, y;</span><br><span class="line">&#125;;</span><br><span class="line">ll w;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">mul</span><span class="params">(Complex t1, Complex t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(t1.x * t2.x % p + t1.y * t2.y % p * w % p) % p, (t1.x * t2.y % p + t1.y * t2.x % p) % p&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">qpow_com</span><span class="params">(Complex a, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Complex res = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = <span class="built_in">mul</span>(res, a);</span><br><span class="line">        a = <span class="built_in">mul</span>(a, a);</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>qpow_com</code> 表示复数快速幂，其实是比较简单的。</p><p>然后就可以直接实现了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="built_in">rand</span>() % p;</span><br><span class="line">        w = (a * a % p - n + p) % p;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">qpow</span>(w, (p - <span class="number">1</span>) / <span class="number">2</span>) == p - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow_com</span>(&#123;a, <span class="number">1</span>&#125;, (p + <span class="number">1</span>) / <span class="number">2</span>).x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完全版。</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cipolla</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    LL x, y;</span><br><span class="line">&#125;;</span><br><span class="line">LL w, Mod;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">mul</span><span class="params">(Complex a, Complex b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(a.x * b.x % Mod + a.y * b.y % Mod * w % Mod) % Mod, (a.x * b.y + a.y * b.x) % Mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">qpow_com</span><span class="params">(Complex a, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Complex res = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = <span class="built_in">mul</span>(res, a);</span><br><span class="line">        a = <span class="built_in">mul</span>(a, a);</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL a, LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * a % Mod;</span><br><span class="line">        a = a * a % Mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cipolla</span>(<span class="keyword">int</span> _Mod = <span class="number">998244353</span>) : <span class="built_in">Mod</span>(_Mod) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Mod_Sqrt</span><span class="params">(LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL a;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="built_in">rand</span>() % Mod;</span><br><span class="line">        w = (a * a - n + Mod) % Mod;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">qpow</span>(w, (Mod - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) == Mod - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow_com</span>(&#123;a, <span class="number">1</span>&#125;, (Mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>).x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽说比较困难，但是代码实现十分简单。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="二次剩余" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/"/>
    
  </entry>
  
  <entry>
    <title>P7590</title>
    <link href="https://mydcwfy.github.io/2021/12/26/P7590/"/>
    <id>https://mydcwfy.github.io/2021/12/26/P7590/</id>
    <published>2021-12-26T05:00:01.000Z</published>
    <updated>2021-12-26T05:01:58.637Z</updated>
    
    <content type="html"><![CDATA[<p>单调队列。</p><span id="more"></span><h2 id="0-前置知识-amp-废话"><a href="#0-前置知识-amp-废话" class="headerlink" title="0. 前置知识 &amp; 废话"></a>0. 前置知识 &amp; 废话</h2><p>说实话，出题人的办法我没太看懂，于是就想了另外一种方法。</p><p>本题解需要你掌握：单调队列</p><p><a href="https://www.luogu.com.cn/problem/P1886">本算法位置</a></p><p>时间复杂度仍为 $O(n)$，但常数较标程略大，故需要点 <del>玄学优化</del>。</p><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给你一个环，每一个点都可以加一定的权值 x，从一个点到下一个点都要减少一定的权值，要保证随时都要 $x\geq0$，可以在一个点时恰好为 0。</p><p>从每一个点开始时，权值都等于 0。</p><p>如果有一个点可以运动 1 周，输出最小编号，否则输出 “Failed!”。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>出题人的方法我确实没看懂。</p><h3 id="1）朴素"><a href="#1）朴素" class="headerlink" title="1）朴素"></a>1）朴素</h3><p>首先考虑朴素算法。</p><p>定义<br>$$<br>d[x]=a[x]-b[x],sum[x]=\sum_{i=1}^{x}d[i]<br>$$<br>所以如果从 i 可以到 i+1，需要满足：<br>$$<br>a[i]=sum[i+1]-sum[i]\geq 0<br>$$<br>我们可以考虑将环拆成 2 倍的链。</p><p>如果从 i 可以的话，需要满足：<br>$$<br>\forall j\in [i,i+n-1],sum[j]\geq sum[i-1]<br>$$<br>时间复杂度为 $O(n^2)$，期望得分 30 分。</p><p><a href="https://www.luogu.com.cn/paste/oewr50t0">代码放置处</a></p><p>实际打代码时，我们可以以它为对拍代码。</p><h3 id="2）堆优化"><a href="#2）堆优化" class="headerlink" title="2）堆优化"></a>2）堆优化</h3><p>其实，我们不难发现，对于该式，我们可以使用堆优化。</p><p>时间复杂度 $O(n\log n)$，期望得分 70 分。</p><p>不放代码了 <del>逃</del>。</p><h3 id="3）单调队列"><a href="#3）单调队列" class="headerlink" title="3）单调队列"></a>3）单调队列</h3><p>我们进一步挖掘性质，可以发现，我们需要的是 $[i,i+n-1]$ 的最小值，且 i 不断变大。</p><p>这难道不是和单调队列相似吗？</p><p>那么就可以了。</p><p>如果 $j&lt;k,sum[j]&gt;sum[k]$，那么 j 不可能成为某个点的最小值。</p><p>维护一个单调队列，使其保持递增的顺序。</p><p>队头是最小值。</p><p>那么就可以了 吗？ <del>雾</del>。</p><p>单调队列虽然是 $O(n)$,但常数相对于标程更大，而最大 $\sum n=2\times 10^7$，很可能超时。</p><h2 id="3-常数优化"><a href="#3-常数优化" class="headerlink" title="3. 常数优化"></a>3. 常数优化</h2><ol><li>我开始 scanf+O2 竟然超时了，所以快读是时候了。</li><li>听说 register 可以加快，用一用也不错。</li></ol><p>这样一阵 <del>玄学</del> 优化后，我们就不用 O2 最大点也可以只用 600ms 就过了。</p><h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll d[<span class="number">2</span>*N],sum[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">int</span> hh,tt,q[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (hh&lt;=tt&amp;&amp;sum[q[tt]]&gt;=sum[x]) tt--;</span><br><span class="line">q[++tt]=x;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((c=<span class="built_in">getchar</span>())&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) ;</span><br><span class="line">    x=c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c=<span class="built_in">getchar</span>())&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// freopen(&quot;randdata.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">// freopen(&quot;myans.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">re <span class="keyword">int</span> cas,n,x;</span><br><span class="line"><span class="built_in">get</span>(cas);</span><br><span class="line"><span class="keyword">while</span> (cas--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">get</span>(n);</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">get</span>(x),d[i]=x;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">get</span>(x);</span><br><span class="line">d[i]-=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) d[i+n]=d[i];</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;++i) sum[i]=sum[i<span class="number">-1</span>]+d[i];<span class="comment">//,cout&lt;&lt;sum[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">hh=<span class="number">1</span>;tt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">insert</span>(i);</span><br><span class="line">re <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (hh&lt;=tt&amp;&amp;q[hh]&lt;i) hh++;</span><br><span class="line"><span class="built_in">insert</span>(i+n<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// printf(&quot;%d %d\n&quot;,hh,tt);</span></span><br><span class="line"><span class="keyword">if</span> (sum[i<span class="number">-1</span>]&lt;=sum[q[hh]])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="built_in">puts</span>(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;单调队列。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="单调队列" scheme="https://mydcwfy.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>P7225</title>
    <link href="https://mydcwfy.github.io/2021/12/26/P7225/"/>
    <id>https://mydcwfy.github.io/2021/12/26/P7225/</id>
    <published>2021-12-26T04:58:34.000Z</published>
    <updated>2021-12-26T04:59:15.412Z</updated>
    
    <content type="html"><![CDATA[<p>极为简单的交互题目。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>你站在一个格子，你可以移动到相邻的格子（如果相邻的格子不是障碍物的话）。</p><p>现在你需要回答走能走到的格子有哪些。</p><h2 id="2-关于交互题"><a href="#2-关于交互题" class="headerlink" title="2. 关于交互题"></a>2. 关于交互题</h2><p>请确保你知道交互题的评测方式与做法。</p><p>其实，大概的意思就是你和另外一个程序同时运行，并交换数据。</p><p>本蒟蒻由于没做过几道交互题，只能讲到这个地步啦。</p><h2 id="3-本题"><a href="#3-本题" class="headerlink" title="3. 本题"></a>3. 本题</h2><p>主要有两种思路：bfs 和 dfs。</p><p>注意观察 bfs 的性质：他是走到一个位置后，一会在进行扩展。</p><p>但是，本题中，我们希望的是他走的时候，是连续的，并且有回溯过程。</p><p>看到原题，他只会给你当前格子的信息，不会给你其他格子的。</p><p>所以，我们采用 dfs 进行搜索，并时刻记录有没有被访问。</p><p>由于每一个格子访问次数是常数，所以复杂度为 $O(n^2)$。</p><h2 id="4-AC-代码"><a href="#4-AC-代码" class="headerlink" title="4.AC 代码"></a>4.AC 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(i,j) (i-1)*n+j-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> check(i,j) (i&gt;1&amp;&amp;j&gt;1&amp;&amp;i&lt;n&amp;&amp;j&lt;n&amp;&amp;m[i][j]==-1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">705</span>][<span class="number">705</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,n,m[<span class="number">705</span>][<span class="number">705</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">4</span>]=&#123;<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;W&#x27;</span>&#125;;</span><br><span class="line">string ans;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">bool</span> <span class="title">move_to</span><span class="params">(<span class="keyword">char</span> position)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(x+dx[i],y+dy[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">move_to</span>(op[i])) m[x+dx[i]][y+dy[i]]=<span class="number">0</span>,<span class="built_in">dfs</span>(x+dx[i],y+dy[i]),<span class="built_in">move_to</span>(op[<span class="number">3</span>-i]);</span><br><span class="line">            <span class="keyword">else</span> m[x+dx[i]][y+dy[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">string <span class="title">find_out_map</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    ans=<span class="string">&quot;&quot;</span>;n=N;</span><br><span class="line">    <span class="built_in">memset</span>(m,<span class="number">-1</span>,<span class="keyword">sizeof</span> m);</span><br><span class="line">    <span class="built_in">dfs</span>(x,y);</span><br><span class="line">    ans=<span class="string">&quot;&quot;</span>;m[x][y]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (m[i][j]==<span class="number">0</span>) ans+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> ans+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-半个交互库"><a href="#5-半个交互库" class="headerlink" title="5. 半个交互库"></a>5. 半个交互库</h2><p>我自己做的时候，由于没有交互库，无法得知自己是否正确。</p><p>自己手写的代码，算半个交互库，希望对你有所帮助。</p><p>（同时是本题的非交互写法）。</p><p>也增添了评测。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(i,j) (i-1)*n+j-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> check(i,j) (i&gt;1&amp;&amp;j&gt;1&amp;&amp;i&lt;n&amp;&amp;j&lt;n&amp;&amp;m[i][j]==-1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">705</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,n,m[N][N],nowx,nowy;</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">4</span>]=&#123;<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;W&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ansmap[N][N],tot;</span><br><span class="line">string ans,stdans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">move_to</span><span class="params">(<span class="keyword">char</span> position)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++tot&gt;=<span class="number">5e5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Too many operations!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position==<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ansmap[nowx+<span class="number">1</span>][nowy])</span><br><span class="line">        &#123;</span><br><span class="line">            nowx++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ansmap[nowx][nowy<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            nowy--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position==<span class="string">&#x27;W&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ansmap[nowx<span class="number">-1</span>][nowy])</span><br><span class="line">        &#123;</span><br><span class="line">            nowx--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ansmap[nowx][nowy+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            nowy++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(x+dx[i],y+dy[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">move_to</span>(op[i])) m[x+dx[i]][y+dy[i]]=<span class="number">0</span>,<span class="built_in">dfs</span>(x+dx[i],y+dy[i]),<span class="built_in">move_to</span>(op[<span class="number">3</span>-i]);</span><br><span class="line">            <span class="keyword">else</span> m[x+dx[i]][y+dy[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">find_out_map</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*put your code here</span></span><br><span class="line"><span class="comment">      this is mine*/</span></span><br><span class="line">    ans=<span class="string">&quot;&quot;</span>;n=N;</span><br><span class="line">    <span class="built_in">memset</span>(m,<span class="number">-1</span>,<span class="keyword">sizeof</span> m);</span><br><span class="line">    <span class="built_in">dfs</span>(x,y);</span><br><span class="line">    ans=<span class="string">&quot;&quot;</span>;m[x][y]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (m[i][j]==<span class="number">0</span>) ans+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> ans+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;nowx&gt;&gt;nowy&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;stdans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (stdans[<span class="built_in">get</span>(i,j)]!=<span class="string">&#x27;0&#x27;</span>) ansmap[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> ansmap[i][j]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//put in the stdmap</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find_out_map</span>(nowx,nowy,n)==stdans) <span class="built_in">puts</span>(<span class="string">&quot;Accepted.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Wrong Answer!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;极为简单的交互题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>P3329</title>
    <link href="https://mydcwfy.github.io/2021/12/26/P3329/"/>
    <id>https://mydcwfy.github.io/2021/12/26/P3329/</id>
    <published>2021-12-26T04:55:56.000Z</published>
    <updated>2021-12-26T04:57:58.171Z</updated>
    
    <content type="html"><![CDATA[<p>最小割树的模板题。</p><span id="more"></span><h2 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1. 前置知识"></a>1. 前置知识</h2><p><a href="https://www.luogu.com.cn/problem/P4897">最小割树（Gomory-Hu Tree）</a></p><p>如果你不知道，可以看 <a href="https://mydcwfy.github.io/2021/12/26/Network-flow/">网络流</a> 或 <a href="https://mydcwfy.github.io/2021/12/26/P4897/">最小割树</a> （ <del>都是我的博客</del> ）</p><p>当然，你也可以看一下下面的解释。</p><h2 id="2-最小割树（Gomory-Hu-Tree）"><a href="#2-最小割树（Gomory-Hu-Tree）" class="headerlink" title="2. 最小割树（Gomory-Hu Tree）"></a>2. 最小割树（Gomory-Hu Tree）</h2><p>（ <del>这也是来自我的博客</del> ）</p><p>很明显，不可能每次求最小割（复杂度为 $O(n^4m)$）。</p><p>我们将一个网络流的图转化为一棵树，其中原图 $u$ 到 $v$ 的最小割即为转化到树上。</p><p>树的一个性质是：删除一条边，树变得不连通。</p><p>那么，我们可以任意选 2 个点 $s$ 与 $t$，跑最小割（即最大流），然后再连一条从 $s$ 到 $t$ 的边。</p><p>又 Dinic 算法最后一次 bfs 相当于求一个最小割，原图就被分为了两部分。</p><p>最后分治就可以了，复杂度为 $O(n^3m)$（Dinic 跑不满的，所以不会超时）。</p><p>按这样建出的树，就是一棵无根树。</p><p>我们可以发现一个有趣的性质：$u$ 到 $v$ 的最小割就是树上从 $u$ 到 $v$ 的所有路径长的最小值。</p><p>可以感性地理解一下（ <del>主要是太菜不会证</del> ）：最小割即为最小的路径长，把 $u$ 到 $v$ 的任意一条路径切断，都是割。</p><h2 id="3-回归本题"><a href="#3-回归本题" class="headerlink" title="3. 回归本题"></a>3. 回归本题</h2><p>还是比较简单。</p><p>直接预处理，将所有的点对之间的最小割求出来。</p><p>有一下两种做法。</p><h3 id="1）-直接扫描"><a href="#1）-直接扫描" class="headerlink" title="1） 直接扫描"></a>1） 直接扫描</h3><p>由于出题人比较良心，这个题的 $Q$ 比较少，可以通过 $O(Qn^2)$，还是可以过的。</p><h3 id="2）-使用有序排列"><a href="#2）-使用有序排列" class="headerlink" title="2） 使用有序排列"></a>2） 使用有序排列</h3><p>我们也可以先将所有的最小割排序好，每次询问，直接查询在有序数列中的位置，减下标即可。</p><p><del>我太懒了</del>，使用了第一种。</p><h2 id="4-Code"><a href="#4-Code" class="headerlink" title="4. Code"></a>4. Code</h2><p>注意要建双向边，否则就不是两边都可以被割掉了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF=<span class="number">1e15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line">ll w[M],ans[N][N];</span><br><span class="line"><span class="keyword">int</span> cur[N],d[N],q[N],S,T,n,m;</span><br><span class="line"><span class="keyword">int</span> node[N],tmp1[N],tmp2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">e[idx]=a,ne[idx]=h[b],w[idx]=<span class="number">0</span>,h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">int</span> hh=<span class="number">1</span>,tt=<span class="number">1</span>;</span><br><span class="line">q[<span class="number">1</span>]=S;cur[S]=h[S];d[S]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (hh&lt;=tt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q[hh++];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (!d[e[i]]&amp;&amp;w[i])</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+<span class="number">1</span>;</span><br><span class="line">cur[e[i]]=h[e[i]];</span><br><span class="line"><span class="keyword">if</span> (e[i]==T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[++tt]=e[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findflow</span><span class="params">(<span class="keyword">int</span> x,ll limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x==T) <span class="keyword">return</span> limit;</span><br><span class="line">ll flow=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=cur[x];~i&amp;&amp;flow&lt;limit;i=ne[i])</span><br><span class="line">&#123;</span><br><span class="line">cur[x]=i;</span><br><span class="line"><span class="keyword">if</span> (d[e[i]]==d[x]+<span class="number">1</span>&amp;&amp;w[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">findflow</span>(e[i],<span class="built_in">min</span>(w[i],limit-flow));</span><br><span class="line"><span class="keyword">if</span> (!t) d[e[i]]=<span class="number">-1</span>;</span><br><span class="line">w[i]-=t,w[i^<span class="number">1</span>]+=t,flow+=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i+=<span class="number">2</span>)</span><br><span class="line">w[i]=(w[i]+w[i^<span class="number">1</span>]),w[i^<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">ll r=<span class="number">0</span>,flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">bfs</span>()) <span class="keyword">while</span> (flow=<span class="built_in">findflow</span>(S,INF)) r+=flow;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l==r) <span class="keyword">return</span> ;</span><br><span class="line">S=node[l],T=node[l+<span class="number">1</span>];</span><br><span class="line">ll t=<span class="built_in">dinic</span>();</span><br><span class="line">    <span class="keyword">int</span> s=node[l],tt=node[l+<span class="number">1</span>];</span><br><span class="line">ans[T][S]=ans[S][T]=t;</span><br><span class="line"><span class="comment">//printf(&quot;%d %d:%d\n&quot;,S,T,ans[S][T]);</span></span><br><span class="line"><span class="keyword">int</span> cnt1=<span class="number">0</span>,cnt2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=l;i&lt;=r;++i)</span><br><span class="line"><span class="keyword">if</span> (d[node[i]]) tmp1[++cnt1]=node[i];</span><br><span class="line"><span class="keyword">else</span> tmp2[++cnt2]=node[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt1;++i) node[i+l<span class="number">-1</span>]=tmp1[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt2;++i) node[cnt1+l+i<span class="number">-1</span>]=tmp2[i];</span><br><span class="line"><span class="built_in">work</span>(l,l+cnt1<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">work</span>(l+cnt1,r);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt1;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt2;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ii=node[i+l<span class="number">-1</span>],jj=node[j+cnt1+l<span class="number">-1</span>];</span><br><span class="line">ans[jj][ii]=ans[ii][jj]=<span class="built_in">min</span>(<span class="built_in">min</span>(ans[ii][s],ans[s][tt]),ans[tt][jj]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Case=<span class="number">0</span>;cin&gt;&gt;Case;</span><br><span class="line">    <span class="keyword">while</span> (Case--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">        idx=<span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j) ans[i][j]=INF;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        ll z;</span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lld&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            <span class="built_in">add</span>(x,y,z);<span class="built_in">add</span>(y,x,z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) node[i]=i;</span><br><span class="line">        <span class="built_in">work</span>(<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">int</span> que;cin&gt;&gt;que;</span><br><span class="line">        <span class="keyword">while</span> (que--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;z);</span><br><span class="line">            <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">                    <span class="keyword">if</span> (ans[i][j]&lt;=z) tot++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tot/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最小割树的模板题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流" scheme="https://mydcwfy.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>CF455B</title>
    <link href="https://mydcwfy.github.io/2021/12/26/CF455B/"/>
    <id>https://mydcwfy.github.io/2021/12/26/CF455B/</id>
    <published>2021-12-26T04:51:37.000Z</published>
    <updated>2021-12-26T04:52:11.738Z</updated>
    
    <content type="html"><![CDATA[<p>SG 函数的简单题目。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>两人交替在开始为空字符串的后面加入字符，要求必须随时为给定的字符串集的某一个串的前缀。将会进行 $k$ 次游戏，上一局输的人作为下一局的先手，最后一局胜利的人获得最终的胜利。在足够聪明的情况下，问第一局的先手是否会赢。</p><p>字符串的总个数 $\leq10^5$，字符串的总字符数 $\leq10^5$，$k\leq10^9$。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>首先，我们可以转化为一个在 Trie 上走，不能走者输的情况。</p><p>考虑 $k=1$ 的情况：这不就是一个 SG 函数的应用吗？</p><p>遍历一遍 Trie，叶节点为先手必败，如果一个节点的某个儿子是先手必败，那么该节点先手必胜，否则先手必败。</p><p>那么，我们可以简单的写出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_trie</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> has_son = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (son[u][i]) has_son = <span class="number">1</span>, <span class="built_in">get_trie</span>(son[u][i]);</span><br><span class="line"><span class="keyword">if</span> (!has_son)&#123;</span><br><span class="line">sg[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (son[u][i] &amp;&amp; !sg[son[u][i]])</span><br><span class="line">&#123;</span><br><span class="line">sg[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sg[u] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们考虑 $k=2$ 的情况。</p><p>如果先手 $k=1$ 是一定会胜而不可能输的（注意，这里指即使先手想输也不可能），那么，先手一定会在前一局的时候尽一切可能去输（感觉有点不合常理），这样他就会获得下一局的先手，而获得最后的胜利。</p><p>所以，我们在 $k&gt;1$ 的时候，不仅要考虑先手能否可以胜利，还要考虑先手能否失败。</p><p>怎样计算先手能否失败呢？我们将前面叶节点的时候设为必胜（是指一定可以输掉游戏，不是原来的游戏的必胜），那么如果最后根节点是必胜的话，那么他一定可以在走到叶节点为必胜状态，也就是可以输掉。</p><p>接着，我们发现先手有四种情况了：可胜可败，只能胜，只能败，不能胜也不能败（由后手控制力）。</p><ol><li><p>可胜可败：发现先手可以操控答案的走向，一定是可以赢的。</p></li><li><p>只能胜：最开始的先手和后手会交替先走，所以现在要看 $k$ 的奇偶，奇就是先手胜，偶就是后者胜。</p></li><li><p>只能败：先手每次都会败，也因为每次都败，每次都是先手，所以最后先手败。</p></li><li><p>不能胜也不能败：后手操控答案的走向，所以一定是输的。</p></li></ol><p>那么，我们就可以写出了最后的判断代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((able_win &amp;&amp; able_lose)) <span class="built_in">puts</span>(<span class="string">&quot;First&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (able_win) <span class="built_in">puts</span>(k &amp; <span class="number">1</span> ? <span class="string">&quot;First&quot;</span> : <span class="string">&quot;Second&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (able_lose) <span class="built_in">puts</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Second&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="3-Code"><a href="#3-Code" class="headerlink" title="3. Code"></a>3. Code</h2><p>前面基本已经展示了，这里给一个完整代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], rt = <span class="number">1</span>, tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> id[N], n, k, flag, sg[N], able_lose, able_win;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u = rt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; s[i]; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!son[u][s[i] - <span class="string">&#x27;a&#x27;</span>]) son[u][s[i] - <span class="string">&#x27;a&#x27;</span>] = ++ tot;</span><br><span class="line">u = son[u][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">id[i] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_trie</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> has_son = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (son[u][i]) has_son = <span class="number">1</span>, <span class="built_in">get_trie</span>(son[u][i]);</span><br><span class="line"><span class="keyword">if</span> (!has_son)&#123;</span><br><span class="line">sg[u] = flag;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (son[u][i] &amp;&amp; !sg[son[u][i]])</span><br><span class="line">&#123;</span><br><span class="line">sg[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sg[u] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">insert</span>(i, str);</span><br><span class="line">&#125;</span><br><span class="line">flag = <span class="number">1</span>, <span class="built_in">get_trie</span>(<span class="number">1</span>);<span class="comment">//flag 是指叶节点是胜还是败</span></span><br><span class="line">able_lose = sg[<span class="number">1</span>];</span><br><span class="line">flag = <span class="number">0</span>, <span class="built_in">get_trie</span>(<span class="number">1</span>);</span><br><span class="line">able_win = sg[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> ((able_win &amp;&amp; able_lose)) <span class="built_in">puts</span>(<span class="string">&quot;First&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (able_win) <span class="built_in">puts</span>(k &amp; <span class="number">1</span> ? <span class="string">&quot;First&quot;</span> : <span class="string">&quot;Second&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (able_lose) <span class="built_in">puts</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;SG 函数的简单题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="SG 函数" scheme="https://mydcwfy.github.io/tags/SG-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF919E</title>
    <link href="https://mydcwfy.github.io/2021/12/26/CF919E/"/>
    <id>https://mydcwfy.github.io/2021/12/26/CF919E/</id>
    <published>2021-12-26T04:49:27.000Z</published>
    <updated>2021-12-26T04:50:43.969Z</updated>
    
    <content type="html"><![CDATA[<p>模拟和逆元题目。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>求<br>$$<br>n\cdot a^n\equiv b\pmod p<br>$$<br>在 $[1,x]$ 的正整数解的个数，其中 $a,b,p,x$ 给定。</p><p>$p\leq10^6+3,x\leq10^{12},1\leq a,b&lt;p$。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>首先，看到 $p\leq10^6+3$，一定是要 $O(p)$ 枚举，然后再做。</p><h4 id="a）枚举-n"><a href="#a）枚举-n" class="headerlink" title="a）枚举 $n$"></a>a）枚举 $n$</h4><p>那么，原题转化为了 $t\cdot a^n\equiv b\pmod p$ 的解了。</p><p>很明显是一个 BSGS，时间复杂度为 $O(\sqrt p)$ 或 $O(\sqrt p\log \sqrt p)$，取决于 map 还是 Hash。</p><p>但是，总时间为 $O(p\sqrt p)$，很明显无法通过。</p><h4 id="b）枚举-a-n"><a href="#b）枚举-a-n" class="headerlink" title="b）枚举 $a^n$"></a>b）枚举 $a^n$</h4><p>首先，我们考虑 $a^n$ 的取值有多少种。</p><p>由于 $a^{p-1}\equiv 1\pmod p$，所以循环节一定是 $p-1$，那么我们就可以枚举 $n\bmod (p-1)$，得到所有的 $a^n$ 的取值。</p><p>那么，原题就是 $n\cdot t\equiv b\pmod p$ 的解。</p><p>咦，这不就是一个逆元了吗？</p><p>于是，我们可以 $O(\log p)$ 求出逆元（因为一定有），那么，我们就可以求出 $n\bmod p$ 的值。</p><h4 id="c）合并答案"><a href="#c）合并答案" class="headerlink" title="c）合并答案"></a>c）合并答案</h4><p>这道题在 CF 上有中国剩余定理的标签，大概就是这里用的吧。</p><p>我们已经得到了 $t1=n\bmod (p-1)$ 和 $t2=n\bmod p$ 的值，直接由中国剩余定理就可以了。</p><p>其实手玩也不是不可以，直接设 $n=kp+t2$，代入第一个就可以得到：<br>$$<br>\begin{aligned}<br>kp+t2&amp;\equiv t1 \pmod {p-1}\<br>k+t2&amp;\equiv t1\pmod {p-1}\<br>k&amp;\equiv t2-t1\pmod {p-1}<br>\end{aligned}<br>$$<br>就解出了 $n$ 的最小正整数取值了。</p><p>周期<del>很明显</del>是 $p\cdot(p-1)$，将答案加入即可。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><p>实际实现的时候可以预处理算出 $a$ 的逆元，每次枚举 ${a^t}$ 的逆元的时候可以通过 ${a^{t-1}}^{-1}$ 乘上 $a^{-1}$ 即可。</p><p>码风略丑，请见谅。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; Mod &gt;&gt; x;</span><br><span class="line">ll now = b, inv = <span class="built_in">qpow</span>(a, Mod - <span class="number">2</span>), lim = Mod * (Mod - <span class="number">1</span>), ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (ll modp1 = <span class="number">0</span>; modp1 &lt; Mod - <span class="number">1</span>; ++ modp1, now = now * inv % Mod)</span><br><span class="line">&#123;<span class="comment">//modp1 是枚举的 t，now 就是上面的 b 乘以（ a 的 t 次方的逆元），也就是 t1</span></span><br><span class="line">ll mx = (modp1 - now + (Mod - <span class="number">1</span>)) % (Mod - <span class="number">1</span>) * Mod + now;<span class="comment">//mx 是 n 的最小取值</span></span><br><span class="line">mx = (mx % lim + lim) % lim;<span class="comment">//lim 是 Mod * Mod - 1，是 n 的周期</span></span><br><span class="line"><span class="keyword">if</span> (mx &lt;= x) ans += (x - mx + lim) / lim;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;模拟和逆元题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>CF306C</title>
    <link href="https://mydcwfy.github.io/2021/12/26/CF306C/"/>
    <id>https://mydcwfy.github.io/2021/12/26/CF306C/</id>
    <published>2021-12-26T04:47:10.000Z</published>
    <updated>2021-12-26T04:47:37.220Z</updated>
    
    <content type="html"><![CDATA[<p>简单的组合数学。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给出 $n$ 天，以及<strong>互不相同</strong>的 $w$ 件好事、$b$ 件坏事，每天只能出现好事、坏事中的一种，要求发生的顺序为 好事 - 坏事 - 好事 的情况的方案数，答案对 $10^9+9$ 取模。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>首先，<strong>互不相同</strong>可以直接转化为<strong>相同</strong>，也就是我们可以现将答案算出来，然后乘上 $w!\cdot b!$ 即可。</p><p>我们再来想如果处理相同的。</p><p>我们发现，当好事的总天数一定的时候，前面有多少个、后面有多少个其实是不影响答案的，因为前面不管有多少个，其实都是一样的。</p><p>所以，我们可以统计 好事 - 坏事 的情况，然后对于每一个好事天数一定的，我们将一些好事的天放在坏事后面，就可以满足答案了。</p><p>答案将会乘上好事的天数减 1。</p><p>现在思路已经比较明显了：我们直接暴力枚举好事的天数 $x$，那么坏事的天数就是 $n-x$。</p><p>然后，我们发现，要将 $w$ 个好事放入 $x$ 天，每天至少一个，所以方案数就为 $\binom{w-1}{x-1}$。</p><p>坏事同理。</p><p>预处理组合数可以用 $O(n)$ 预处理阶乘及其逆元，不过没必要，直接 $O(n^2)$ 就可以了。</p><h2 id="3-Code"><a href="#3-Code" class="headerlink" title="3. Code"></a>3. Code</h2><p>注意要处理两倍的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; w &gt;&gt; b;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gday = <span class="number">1</span>; gday &lt; n; ++ gday)<span class="comment">//枚举好事的天数</span></span><br><span class="line">        ans = (ans + (gday - <span class="number">1ll</span>) * C[w - <span class="number">1</span>][gday - <span class="number">1</span>] % Mod * C[b - <span class="number">1</span>][n - gday - <span class="number">1</span>] % Mod) % Mod;</span><br><span class="line">    cout &lt;&lt; <span class="number">1ll</span> * ans * fact[w] % Mod * fact[b] % Mod &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单的组合数学。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>CF1335F</title>
    <link href="https://mydcwfy.github.io/2021/12/26/CF1335F/"/>
    <id>https://mydcwfy.github.io/2021/12/26/CF1335F/</id>
    <published>2021-12-26T04:43:02.000Z</published>
    <updated>2021-12-26T04:46:35.318Z</updated>
    
    <content type="html"><![CDATA[<p>基环树的简单题目。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><ul><li>给定一个 $n\times m$ 的黑白网格，每一个点都会有一个方向，如果放置的机器人走到这里的话，将会按照该方向走下去。现在要放置最多的机器人，使得机器人永远不会走到同一个点上（每一步中间相遇的不算）。在放置最多的基础上，要求最开始放在黑色上的机器人最多。</li><li>有 $t$ 组数据，$n\times m\leq10^6,\sum n\times m\leq10^6,t\leq5\times10^4$。</li></ul><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>其实如果想到图论的话，就比较简单了。</p><p>首先，我们考虑怎样才能 <strong>永远不相撞</strong>。</p><p>所有的机器人最后一定是在环上一直绕圈，又由于速度相同，所以永远不会相撞。</p><p>易得第一问答案不可能大于环上点的数量（因为如果有多的话，走到最后，一定会有两个机器人在同一个点，明显不符合条件）。</p><p>注意到每一个点有且只有一个出边，所以原图一共有 $n\times m$ 个点，同样也有 $n\times m$ 条边。</p><p>？这不就是基环树吗？</p><p>通过基环树的方法，我们可以简单的找出所有的环。不考虑第二问的话，我们直接将所有的机器人放在环上，这个就是一个最优解。</p><p>那么第一问就解决了，答案就是环的数量。</p><p>下面我们来看第二问：怎样让最多的机器人在黑色点上？</p><p>已经是黑色点的我们可以不管了，我们可以将一些白色的点替换为非环的黑点。</p><p>我们画一个图，来看一下需要满足什么样的条件才可以。</p><img src="/2021/12/26/CF1335F/CF1335F.png" class=""><p>当前，如果我们将一个机器人放在 b 点，经过两步之后，就会走到 c 点，如果最开始放在 a 点，也会走到 c 点。</p><p>所以其实 a 点和 b 点是等价的，换句话说，他们最后在环上的位置是等价的。</p><p>推广一下，对于任意一个点，假设他向上走走到环里需要的步数为 $x$，那么他就等价于环里距他最近的点往回走 $x$ 步得到的点。</p><p>转化为代码，就是：<code>cir[((dep - from) % sz + sz) % sz + 1]</code>，其中 $cir$ 存的是环的编号，从 1 开始，$sz$ 是指环的大小，$from$ 是指离他最近的点<strong>是环中的第几个。</strong></p><p>这几个都是可以在第二次遍历基环树的时候很简单的得到。具体可以看代码。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><p>注意由于有多组数据，不能使用 <code>memset</code> 之类的，而且读入的时候要直接转化为基环树上的编号。</p><p>码风略丑，请见谅。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> cir[N], tot, ed[N], cnt, fu[N];</span><br><span class="line"><span class="keyword">int</span> n, m, blk[N];</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">bool</span> ins[N], vis[N], onc[N], abl[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_c</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> from)</span><span class="comment">//找环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ins[x] = vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (i == (from ^ <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">fu[j] = x;</span><br><span class="line"><span class="keyword">if</span> (!vis[j]) <span class="built_in">dfs_c</span>(j, i);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ins[j])&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = x; k != j; k = fu[k]) cir[++ cnt] = k, onc[k] = <span class="literal">true</span>;</span><br><span class="line">cir[++ cnt] = j, onc[j] = <span class="literal">true</span>;</span><br><span class="line">ed[++ tot] = cnt;</span><br><span class="line"><span class="keyword">if</span> ((i &amp; <span class="number">1</span>)) <span class="built_in">reverse</span>(cir + ed[tot - <span class="number">1</span>] + <span class="number">1</span>, cir + ed[tot] + <span class="number">1</span>);</span><br><span class="line">&#125;<span class="comment">//注意此时如果 i &amp; 1 的话，找到的环和我们的环是相反的，我们要调换过来</span></span><br><span class="line">&#125;</span><br><span class="line">ins[x] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_d</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> cirst, <span class="keyword">int</span> dep, <span class="keyword">int</span> sz)</span><span class="comment">//cirst 表示环在 cir 数组里开始的位置，dep 是指当前的深度（我为了方便，加上了出发点的编号，方便直接计算，无需多余传参）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">abl[cirst + (dep % sz + sz) % sz] |= blk[x];</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[e[i]] || onc[e[i]]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs_d</span>(e[i], cirst, dep - <span class="number">1</span>, sz);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;<span class="keyword">return</span> (i - <span class="number">1</span>) * m + j;&#125;<span class="comment">//转换编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">idx = cnt = tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; ++ i) h[i] = <span class="number">-1</span>, blk[i] = onc[i] = abl[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) blk[<span class="built_in">get</span>(i, j)] = str[j] == <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (str[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span> : <span class="built_in">link</span>(<span class="built_in">get</span>(i, j), <span class="built_in">get</span>(i, j - <span class="number">1</span>));<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span> : <span class="built_in">link</span>(<span class="built_in">get</span>(i, j), <span class="built_in">get</span>(i, j + <span class="number">1</span>));<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span> : <span class="built_in">link</span>(<span class="built_in">get</span>(i, j), <span class="built_in">get</span>(i - <span class="number">1</span>, j));<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> : <span class="built_in">link</span>(<span class="built_in">get</span>(i, j), <span class="built_in">get</span>(i + <span class="number">1</span>, j));<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; ++ i) vis[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) <span class="built_in">dfs_c</span>(i, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; ++ i) vis[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = ed[i - <span class="number">1</span>] + <span class="number">1</span>; j &lt;= ed[i]; ++ j) <span class="built_in">dfs_d</span>(cir[j], ed[i - <span class="number">1</span>] + <span class="number">1</span>, j - ed[i - <span class="number">1</span>] - <span class="number">1</span>, ed[i] - ed[i - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> tblk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) tblk += abl[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, cnt, tblk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;基环树的简单题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="图论" scheme="https://mydcwfy.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="基环树" scheme="https://mydcwfy.github.io/tags/%E5%9F%BA%E7%8E%AF%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>CF1175B</title>
    <link href="https://mydcwfy.github.io/2021/12/26/CF1175B/"/>
    <id>https://mydcwfy.github.io/2021/12/26/CF1175B/</id>
    <published>2021-12-26T04:41:59.000Z</published>
    <updated>2021-12-26T04:45:30.646Z</updated>
    
    <content type="html"><![CDATA[<p>简单的模拟。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给定一串语句，并有变量 $x$，初始为 $0$，仅含有一下三种类型：</p><ol><li><code>for n</code>：表示循环 $n$ 次，直到与之匹配的 <code>end</code>。</li><li><code>end</code>：表示循环结束。</li><li><code>add</code>：将 $x$ 加一。</li></ol><p>执行完后，如果 $x\geq2^{32}$，输出 <code>OVERFLOW!!!</code>，否则输出 $x$ 的值。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>$x$ 的值就是 <code>add</code> 的执行次数。</p><p>我们可以在记录一个变量 $mul$，表示当前的语句将会被执行多少次。</p><p>所以碰到 <code>add</code> 的时候，将当前的 $x$ 加上 $mul$ 即可。</p><p>注意，这道题 $mul$ 最大会达到 $100^{5000}$，所以注意我们如果 $mul\geq 2^{32}$，就可以直接赋值为 $2^{32}$。</p><p>但是，这里又有一个问题：$mul=2^{32}$ 之后，碰上 <code>end</code>，我们将要 $mul$ 除以当前的循环次数，明显就错误了。</p><p>处理方法也很简单：用一个栈记录所有的 <code>for n</code>，然后使用前缀积 $pre$ 维护，于是退栈的时候，我们直接将当前的 $mul$ 赋值为 $pre[top-1]$ 即可。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = (<span class="number">1ll</span> &lt;&lt; <span class="number">32</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n, top;</span><br><span class="line">ll x, stk[N], tmp, pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;OVERFLOW!!!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;a&#x27;</span>) x += pre[top];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;tmp);</span><br><span class="line">            stk[++ top] = tmp;</span><br><span class="line">            pre[top] = pre[top - <span class="number">1</span>] * tmp;</span><br><span class="line">            <span class="keyword">if</span> (pre[top]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>) top --;</span><br><span class="line">        <span class="keyword">if</span> (pre[top] &gt; INF) pre[top] = INF + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; INF) <span class="built_in">overflow</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单的模拟。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>CF337C</title>
    <link href="https://mydcwfy.github.io/2021/12/26/CF337C/"/>
    <id>https://mydcwfy.github.io/2021/12/26/CF337C/</id>
    <published>2021-12-26T04:40:44.000Z</published>
    <updated>2021-12-26T04:41:12.714Z</updated>
    
    <content type="html"><![CDATA[<p>还是比较好想的，感觉难度应该在黄至绿之间。</p><span id="more"></span><p>话说这道题怎么没人做啊……</p><p>如果有没有考虑到的，请轻喷作者 qwq</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><ul><li>给出 $n$ 道题，答对了 $m$ 道题，按照规则安排 $m$ 道题的顺序，使得分数最小。输出对 $10^9+9$ 取模后的值。</li><li>从前向后扫描，答对一道分数加 $1$，计数器 $cnt$ 加一，如果 $cnt=k$，那么当前分数翻倍，$cnt$ 清零。如果答错 $cnt$ 清零。</li><li>$2\leq k\leq n\leq10^9,0\leq m\leq n$。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们首先考虑的肯定是尽量让 $m$ 道题目被翻倍的次数最少。</p><p>首先，一种情况是我们间隔开 $m$ 道题，使得每一道题都不会翻倍，那么答案就是 $m$。</p><p>具体就是 $k-1$ 道对，$1$ 道错，排列下去最后可以不需要 $1$ 道错误。</p><p>判断条件就是 $(n-m+1)\cdot(k-1)\geq m$。</p><p>第二种情况就是不得不要翻倍。</p><p>考虑第二个样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input:</span><br><span class="line">5 4 2</span><br><span class="line">output:</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>我们发现，不论怎么放错误的那个，一定都会有 $2$ 个会相连。（三个相连可以拆分为 $2+1$</p><p>那么，让相连的放在哪呢？</p><p>如果放在后面的话，一定会使答案变大，所以肯定放在最前面，让翻倍的尽量少。</p><p>所以，就可以构造成这样了：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ha2e8qfg.png"></p><p>注意到，前面会有 $n-(n-m)\cdot k$ 个连续的绿色。</p><p>按照这样计算即可.</p><p>假设前面有 $t$ 个连续的 $k$ 个绿色，前面的绿色的贡献就是 $k\cdot2^t+k\cdot2^{t-1}+…+k\cdot2$，注意最后未满 $k$ 个的由于没有特殊贡献，可以放到后面计算，为 $m-t\cdot k$。</p><p>前面的式子可以化简为 $k\cdot(2^{t+1}-2)$，快速幂即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"><span class="keyword">if</span> ((n - m + <span class="number">1</span>) * (k - <span class="number">1</span>) &gt;= m)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll t = (m - (n - m) * (k - <span class="number">1</span>)) / k;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (k * (<span class="built_in">qpow</span>(<span class="number">2</span>, t + <span class="number">1</span>) - <span class="number">2</span> + Mod) % Mod + m - k * t) % Mod);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;还是比较好想的，感觉难度应该在黄至绿之间。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>P5088</title>
    <link href="https://mydcwfy.github.io/2021/12/26/P5088/"/>
    <id>https://mydcwfy.github.io/2021/12/26/P5088/</id>
    <published>2021-12-26T04:38:15.000Z</published>
    <updated>2021-12-26T04:39:37.928Z</updated>
    
    <content type="html"><![CDATA[<p>杂题，没有什么说的。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p><a href="https://www.luogu.com.cn/problem/P5088">原题面</a></p><p>抽象一下题意：</p><p>求 $k1,k2$，使得：<br>$$<br>k1\times N:k2\times M=A:B<br>$$<br>（先使 $\gcd(A,B)=1$</p><p>然后，题目要求的就是 $k1+k2-2$ 的最小值。</p><p>对应到原题意是什么呢？</p><p>我们假设有无穷多个这样的 $N\times M$ 的矩形，然后我们不反射，直接穿过，直到碰到交界的点为止。</p><img src="/2021/12/26/P5088/P5088.png" class=""><p>蓝线是原来的反射路径，但是我们可以通过一系列的翻折，使得路径变为绿线。</p><p>变为绿线，其实已经简洁了许多。</p><p>我们假设横向的有 $k1$ 个 $N$，纵向的有 $k2$ 个 $M$，那么最后 $\zeta$ 的对边是 $k2\times M$，邻边是 $k1\times N$。</p><p>于是，我们可以得到：<br>$$<br>\cot\zeta=\dfrac{k1\times N}{k2\times M}=\dfrac{A}{B}<br>$$<br>也就是上面的式子了。</p><p>至于反射了多少次，其实就是穿过边界了多少次。</p><p><del>大眼观察法</del>易得 $ans=k1+k2-2$。</p><p>问题转化为怎样求 $k1,k2$。</p><p>首先，可以得到一个解：$k1=A\times M,k2=B\times N$。</p><p>然后，我们可以同时除以一个数 $x$。</p><p>那么需要满足：$x|A\times M,x|B\times N$。（不然的话，$k1,k2$ 无法整除 $x$，就不是整数了）。</p><p>综上，我们其实就可以总结出这道题的答案了：<br>$$<br>ans=\dfrac{A\times M+B\times N}{\gcd(A\times M,B\times N)}<br>$$</p><h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h2><p>数据水了一点，没有卡掉 <code>long long</code>。</p><p>唯一注意的是 $A=0$ 或 $B=0$ 的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">read</span>(n, m, a, b);</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">0</span> || b == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line">ll g = <span class="built_in">Gcd</span>(a, b);</span><br><span class="line">a /= g, b /= g;</span><br><span class="line">ll x = <span class="built_in">Gcd</span>(a * m, b * n);</span><br><span class="line"><span class="built_in">write</span>(a * m / x + b * n / x - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;杂题，没有什么说的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>P4539</title>
    <link href="https://mydcwfy.github.io/2021/12/26/P4539/"/>
    <id>https://mydcwfy.github.io/2021/12/26/P4539/</id>
    <published>2021-12-26T04:36:21.000Z</published>
    <updated>2021-12-26T04:37:02.133Z</updated>
    
    <content type="html"><![CDATA[<p>一个区间 DP 的较为简单的题目。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><ul><li>要求构造一个大小为 $n$ 的二叉树，按照中序遍历标号为 $1\sim n$，然后给定每个编号的频率 $f_i$，并且给定常数 $k,c$ 为实数，请最小化（设根节点深度为 1）：</li></ul><p>$$<br>\sum_{i=1}^nf_i\times(k\times dep_i+c)<br>$$</p><ul><li>$n\leq30,\sum f_i=1,0&lt;k,c\leq100$</li></ul><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>其实可能很多同学<del>（其实就是我）</del>都会想到 <code>Huffman Tree</code>，它是基于一个贪心的想法，但是我们可以比较一下两个的式子。<br>$$<br>\sum_{i=1}^nf_i\times dep_i<br>$$</p><p>$$<br>\sum_{i=1}f_i\times(k\times dep_i+c)<br>$$</p><p>这两个其实是有一定区别的。</p><p>本题中，不同节点是一定会出现祖先关系，并且只有 $n$ 个节点。但是 <code>Huffman Tree</code> 却要求给定的 $n$ 个节点不能出现祖先关系，构造出来后，也会超过 $n$ 个节点。</p><p>那本题怎么做呢？</p><p>首先，我们可以发现一个性质：假设当前子树覆盖的区间为 $[l,r]$，根节点为 $t$，那么左边的子树覆盖的区间为 $[l,t-1]$，右边的子树为 $[t+1,r]$。</p><p>这就是一个典型的区间 DP 了。</p><p>当我们要计算 $dp(l,r)$ 的时候，我们直接枚举根节点 $t$，然后递归计算 $dp(l,t-1)$ 和 $dp(t+1,r)$，然后我们将左右子树直接接在 $t$ 这个节点上。</p><p>怎么计算贡献呢？其实很简单，我们左右的子树的深度都要加一，对于整个的贡献就是 $k\times (s(r)-s(l-1)-f(t))$，其中 $s(i)=\sum_{j=1}^if(j)$。</p><p>再加上 $t$ 的贡献，那么，我们就可以得到式子：<br>$$<br>dp(l,r)=\min_{t\in[l,r]}{dp(l,t-1)+dp(t+1,r)+k\times(s(r)-s(l-1))+c\times f(t) }<br>$$</p><p>时间复杂度为 $O(n^3)$，轻松通过。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><p>采用的递归式写法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> (k + c) * fru[l];</span><br><span class="line"><span class="keyword">double</span> &amp;v = f[l][r];</span><br><span class="line"><span class="keyword">if</span> (v &gt;= <span class="number">0</span>) <span class="keyword">return</span> v;</span><br><span class="line">v = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = l; mid &lt;= r; ++ mid)</span><br><span class="line">v = <span class="built_in">min</span>(v, <span class="built_in">solve</span>(l, mid - <span class="number">1</span>) + k * (s[r] - s[l - <span class="number">1</span>]) + c * fru[mid] + <span class="built_in">solve</span>(mid + <span class="number">1</span>, r));</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个区间 DP 的较为简单的题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="区间 DP" scheme="https://mydcwfy.github.io/tags/%E5%8C%BA%E9%97%B4-DP/"/>
    
  </entry>
  
</feed>
