<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mydcwfy&#39;s Blog</title>
  
  
  <link href="https://mydcwfy.github.io/atom.xml" rel="self"/>
  
  <link href="https://mydcwfy.github.io/"/>
  <updated>2022-10-18T13:40:29.198Z</updated>
  <id>https://mydcwfy.github.io/</id>
  
  <author>
    <name>mydcwfy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ABC273Ex Inv(0,1)ving Insert(1,0)n</title>
    <link href="https://mydcwfy.github.io/2022/10/18/ABC273H/"/>
    <id>https://mydcwfy.github.io/2022/10/18/ABC273H/</id>
    <published>2022-10-18T13:10:05.000Z</published>
    <updated>2022-10-18T13:40:29.198Z</updated>
    
    <content type="html"><![CDATA[<p>题意：定义对序列 $A$（$A$ 包含整数二元组）操作一次为如下操作：选定任意两个相邻的二元组 $(a, b)$ 和 $(c, d)$，在他们中间插入 $(a + c, b + d)$。定义一个二元组序列的价值为从 $A = \{(0, 1), (1, 0)\}$ 开始至少要操作多少次才能包含序列中的所有二元组。如果无法的话价值就是 0。现给定一个长度为 $n$ 的二元组序列 $T$，问所有连续子序列的价值和，对 998244353 取模。$n\leq 10 ^ 5$，$a, b\leq 10 ^ 9$。</p><span id="more"></span><p>首先注意到这个的操作方式和 <a href="https://oi-wiki.org/math/number-theory/stern-brocot/#stern-brocot-%E6%A0%91">Stern-Brocot 树</a> 的构造方式是一样的，那么直接在这棵树上做似乎是一个不错的选择。</p><p>那么根据该树的性质，我们容易得到两种情况是无法得到的：</p><ol><li>$\gcd(a, b) \neq 1$</li><li>$a = 0\land b = 0$</li></ol><p>那么我们相当于现在是划分为一段一段的分别做，每一段内都是合法的状态，然后不同段之间的显然贡献都为 0。现在就处理掉了没有贡献的区间。</p><p>现在我们考虑按照该树的构造办法，我们于是可以这么拆贡献：对于该树上的每一个节点 $[\dfrac ab, \dfrac cd]$（可能 $d$ 为 0，不太严谨，就是 $+\infty$ 的意思），我们考虑要生成 $\dfrac {a + c}{b + d}$ 需要被多少个子串所需要。</p><p>一个充要条件是如果一个子串中存在一个 $\dfrac pq$ 满足 $\dfrac ab &lt; \dfrac pq &lt; \dfrac cd$，那么就需要 $\dfrac {a + c}{b + d}$。那么，我们需要统计所有满足分数在 $(\dfrac ab, \dfrac cd)$ 之间的位置。这样的话就是容易容斥计算的。</p><p>这样直接做复杂度是不对的，应为单次统计至少需要 $O(len)$，$len$ 为在这个区间之间的分数个数。首先我们直接考虑分治下去，将 $[\dfrac ab, \dfrac {a + c}{b + d}]$ 和 $[\dfrac {a + c}{b + d}, \dfrac cd]$ 的答案分别算出来，然后可以启发式合并一下，将少的合并到多的上，用 <code>std::set</code> 维护并动态统计答案，假设每次都有分支的话，复杂度就是 $O(n\log ^ 2 n)$ 的。</p><p>然后我们再来处理假设区间内部的所有数都在 $\dfrac {a + c}{b + d}$ 的一边怎么办。一个极端的情况就是 $(10 ^ 9, 1)$，我们不得不递归 $10 ^ 9$ 层才能找到他。这样显然是不好的，于是我们可以考虑二分一个 $k$ 满足不是所有数都在 $\dfrac {a + kc}{b + kd}$（或者是 $\dfrac {ka + c}{kb + d}$，看在哪一边）的一边。注意到我们相当于在树上是一次跳了 $k$ 层，于是最后的答案要 $\times k$。</p><p>于是总复杂度就是 $O(n\log ^ 2 n + n\log a)$，可以通过。实际实现的时候二分的 $k$ 差一两个是没有问题的，效率如何没测试过（<del>因为我的 $k$ 好像就少 1</del>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Frac</span> &#123;</span><br><span class="line">LL x, y;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">Frac <span class="keyword">operator</span> +(Frac t) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;x + t.x, y + t.y&#125;; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(Frac t) <span class="type">const</span> &#123; <span class="keyword">return</span> (s128) x * t.y &lt; (s128) y * t.x; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &gt;(Frac t) <span class="type">const</span> &#123; <span class="keyword">return</span> (s128) x * t.y &gt; (s128) y * t.x; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> ==(Frac t) <span class="type">const</span> &#123; <span class="keyword">return</span> x == t.x &amp;&amp; y == t.y; &#125;</span><br><span class="line">Frac <span class="keyword">operator</span> *(LL t) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;x * t, y * t&#125;; &#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> iter = s[id].<span class="built_in">insert</span>(x).first;</span><br><span class="line"><span class="type">int</span> y = *std::<span class="built_in">prev</span>(iter), z = *std::<span class="built_in">next</span>(iter);</span><br><span class="line">ans[id] = (ans[id] + (LL) (z - x) * (x - y)) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, Frac lf, Frac rf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= n &amp;&amp; a[l] == lf) l ++;</span><br><span class="line"><span class="keyword">while</span> (r &amp;&amp; a[r] == rf) r --;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[r] &lt; lf + rf) &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>, y = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt; y) &#123;</span><br><span class="line"><span class="type">int</span> mid = (x + y + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (lf * mid + rf &gt; a[r]) x = mid;</span><br><span class="line"><span class="keyword">else</span> y = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">rf = rf + lf * (x - <span class="number">1</span>), cnt = x;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[l] &gt; lf + rf) &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>, y = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt; y) &#123;</span><br><span class="line"><span class="type">int</span> mid = (x + y + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (lf + rf * mid &lt; a[l]) x = mid;</span><br><span class="line"><span class="keyword">else</span> y = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">lf = lf + rf * (x - <span class="number">1</span>), cnt = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x = l, y = r + <span class="number">1</span>, mL, mR;</span><br><span class="line"><span class="keyword">while</span> (x &lt; y) &#123;</span><br><span class="line"><span class="type">int</span> mid = (x + y) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid] &lt; lf + rf) x = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> y = mid;</span><br><span class="line">&#125;</span><br><span class="line">mL = x, x = l - <span class="number">1</span>, y = r;</span><br><span class="line"><span class="keyword">while</span> (x &lt; y) &#123;</span><br><span class="line"><span class="type">int</span> mid = (x + y + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid] &gt; lf + rf) y = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> x = mid;</span><br><span class="line">&#125;</span><br><span class="line">mR = x;</span><br><span class="line"><span class="comment">// Equal (a + c) / (b + d) range</span></span><br><span class="line"><span class="type">int</span> lc = <span class="built_in">solve</span>(l, mL - <span class="number">1</span>, lf, lf + rf), rc = <span class="built_in">solve</span>(mR + <span class="number">1</span>, r, lf + rf, rf);</span><br><span class="line"><span class="keyword">if</span> (s[lc].<span class="built_in">size</span>() &gt; s[rc].<span class="built_in">size</span>()) std::<span class="built_in">swap</span>(lc, rc);</span><br><span class="line"><span class="keyword">if</span> (rc == <span class="number">1</span>) s[rc = ++ tot] = &#123;<span class="number">0</span>, n + <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> t : s[lc])</span><br><span class="line"><span class="keyword">if</span> (t &gt;= <span class="number">1</span> &amp;&amp; t &lt;= n) <span class="built_in">insert</span>(rc, t);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> t = mL; t &lt;= mR; ++ t) <span class="built_in">insert</span>(rc, a[t].id);</span><br><span class="line">res = (res + (LL) ans[rc] * cnt) % Mod;</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">(std::vector&lt;Frac&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">res = <span class="number">0</span>;</span><br><span class="line">n = vec.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) a[i + <span class="number">1</span>] = vec[i], a[i + <span class="number">1</span>].id = i + <span class="number">1</span>;</span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">s[<span class="number">1</span>] = &#123;<span class="number">0</span>, n + <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">solve</span>(<span class="number">1</span>, n, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;), res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：定义对序列 $A$（$A$ 包含整数二元组）操作一次为如下操作：选定任意两个相邻的二元组 $(a, b)$ 和 $(c, d)$，在他们中间插入 $(a + c, b + d)$。定义一个二元组序列的价值为从 $A = \{(0, 1), (1, 0)\}$ 开始至少要操作多少次才能包含序列中的所有二元组。如果无法的话价值就是 0。现给定一个长度为 $n$ 的二元组序列 $T$，问所有连续子序列的价值和，对 998244353 取模。$n\leq 10 ^ 5$，$a, b\leq 10 ^ 9$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分治" scheme="https://mydcwfy.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="启发式合并" scheme="https://mydcwfy.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
    <category term="二分" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="复杂度分析" scheme="https://mydcwfy.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>CF1515H Phoenix and Bits</title>
    <link href="https://mydcwfy.github.io/2022/10/15/CF1515H/"/>
    <id>https://mydcwfy.github.io/2022/10/15/CF1515H/</id>
    <published>2022-10-14T23:34:21.000Z</published>
    <updated>2022-10-15T00:58:04.113Z</updated>
    
    <content type="html"><![CDATA[<p>题意：维护一个集合 $a$，最开始有 $n$ 个元素，有 $m$ 次操作或者询问：</p><ol><li>将 $a_i\in [l, r]$ 的值全部与 $x$。</li><li>将 $a_i\in [l, r]$ 的值全部或 $x$。</li><li>将 $a_i\in [l, r]$ 的值全部异或 $x$。</li><li>询问在 $[l, r]$ 中有多少个不同的 $a_i$。</li></ol><p>$n\leq 2\times 10 ^ 5$，$m\leq 10 ^ 5$，$0\leq a_i &lt; 2 ^ {20}$。</p><span id="more"></span><p>进阶 01 Trie 的模板题。</p><h3 id="寻找一段区间"><a href="#寻找一段区间" class="headerlink" title="寻找一段区间"></a>寻找一段区间</h3><p>类似于 FHQ Treap 的 split 一样，我们考虑在 $[l, r]$ 之间分离出一段 $[x, y]$。此时考虑 $mid$ 在 $[x, y]$ 的位置，向左右递归即可。节点 split 直接新建即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!u || !tr[u].sz) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (bit &lt; <span class="number">0</span> || (l == <span class="number">0</span> &amp;&amp; r == <span class="number">2</span> * (<span class="number">1</span> &lt;&lt; bit) - <span class="number">1</span>)) &#123;</span><br><span class="line">x = u;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; u &lt;&lt; &#x27; &#x27; &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; &#x27; &#x27; &lt;&lt; bit &lt;&lt; &#x27; &#x27; &lt;&lt; tr[u].sz &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="built_in">pushdown</span>(u, bit);</span><br><span class="line"><span class="keyword">if</span> (l &gt;= mid)</span><br><span class="line">y = u, <span class="built_in">split</span>(tr[u].s[<span class="number">1</span>], tr[x = ++ tot].s[<span class="number">1</span>], tr[u].s[<span class="number">1</span>], l ^ mid, r ^ mid, bit - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r &lt; mid)</span><br><span class="line">y = u, <span class="built_in">split</span>(tr[u].s[<span class="number">0</span>], tr[x = ++ tot].s[<span class="number">0</span>], tr[u].s[<span class="number">0</span>], l, r, bit - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// if (l == 0 &amp;&amp; r == mid * 2 - 1) return x = u, void();</span></span><br><span class="line">x = u, y = ++ tot;</span><br><span class="line"><span class="built_in">split</span>(tr[u].s[<span class="number">0</span>], tr[u].s[<span class="number">0</span>], tr[y].s[<span class="number">0</span>], l, mid - <span class="number">1</span>, bit - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">split</span>(tr[u].s[<span class="number">1</span>], tr[u].s[<span class="number">1</span>], tr[y].s[<span class="number">1</span>], <span class="number">0</span>, r ^ mid, bit - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushup</span>(x), <span class="built_in">pushup</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并两棵子树"><a href="#合并两棵子树" class="headerlink" title="合并两棵子树"></a>合并两棵子树</h3><p>没什么好讲的，注意到了叶子节点只能保留一个信息即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;MERGE &quot; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; &#x27; &#x27; &lt;&lt; bit &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">if</span> (!x || !tr[x].sz) <span class="keyword">return</span> y;</span><br><span class="line"><span class="keyword">if</span> (!y || !tr[y].sz) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">if</span> (bit &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; tr[x].val &lt;&lt; &#x27; &#x27; &lt;&lt; tr[y].val &lt;&lt; std::endl;</span></span><br><span class="line"><span class="built_in">assert</span>(!tr[x].sz || !tr[y].sz || tr[x].val == tr[y].val);</span><br><span class="line"><span class="keyword">return</span> tr[x].sz ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(x, bit), <span class="built_in">pushdown</span>(y, bit);</span><br><span class="line">tr[x].s[<span class="number">0</span>] = <span class="built_in">merge</span>(tr[x].s[<span class="number">0</span>], tr[y].s[<span class="number">0</span>], bit - <span class="number">1</span>);</span><br><span class="line">tr[x].s[<span class="number">1</span>] = <span class="built_in">merge</span>(tr[x].s[<span class="number">1</span>], tr[y].s[<span class="number">1</span>], bit - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pushup</span>(x), x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对全局-xor"><a href="#对全局-xor" class="headerlink" title="对全局 xor"></a>对全局 xor</h3><p>我们考虑对于一棵子树全部 xor 怎么做。因为我们已经有 <code>split</code> 了，所以这个操作可以支持区间做。</p><p>这个可以使用懒标记实现。因为子树的节点个数并没有发生改变，而只是对于一些节点的左右儿子交换即可。这个节点的所有信息都可以在不递归子树的情况下 $O(1)$ 维护。</p><p>具体有哪些信息呢？我们目前只需要维护左右儿子、懒标记和不同的数的个数，都很简单，就不讲了。</p><h3 id="对全局-or"><a href="#对全局-or" class="headerlink" title="对全局 or"></a>对全局 or</h3><p>全局 or 是不好做的，因为我们可能合并节点之类的。虽然总结点个数是 $O((n + m)\log a)$ 的，但是我们并不好判断一棵子树内部有没有需要合并的节点。</p><p>首先如果全局 or 在一定情况下可以变成全局 xor，这样不会减少节点，所以我们为了保证复杂度，不能递归。容易发现这个的成立条件是在给定 or 的每一位上全局要么全是 1，要么全是 0。我们考虑记录全局的 or $v_1$ 和全局补集的 or $v_2$（将所有数取反的 or），那么判断条件可以写作 $[(v_2\odot x)\odot v_1 = 0]$（$\odot$ 表示与运算）。另外，此时我们相当于要对全局 xor 上 $v_2\odot x$。</p><p>否则的话，我们至少会出现一个节点的合并，这个时候我们再考虑递归。如果当前节点左右儿子都存在，并且我们这一位会 or 上 1，那么我们可以先将左儿子的所有值 xor 上 $2 ^ {bit}$，然后直接将左右儿子都合并到右儿子即可。</p><p>这个时候再反过去在 xor 的时候维护一下 or 和补集的 or，注意到如果 or 和补集的 or 都包含某一位的话，怎么 xor 这一位都是 1。拆位做一下就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">allxor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> bit, <span class="type">int</span> lt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> v = tr[x].val, lv = tr[x].lval;</span><br><span class="line"><span class="keyword">if</span> (lt &gt;&gt; bit &amp; <span class="number">1</span>) std::<span class="built_in">swap</span>(tr[x].s[<span class="number">0</span>], tr[x].s[<span class="number">1</span>]);</span><br><span class="line">tr[x].val = (v ^ lt) | (v &amp; lv &amp; lt);</span><br><span class="line">tr[x].lval = (lv ^ lt) | (v &amp; lv &amp; lt);</span><br><span class="line">tr[x].lt ^= lt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x || !tr[x].lt || !tr[x].sz) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">allxor</span>(tr[x].s[<span class="number">0</span>], bit - <span class="number">1</span>, tr[x].lt), <span class="built_in">allxor</span>(tr[x].s[<span class="number">1</span>], bit - <span class="number">1</span>, tr[x].lt);</span><br><span class="line">tr[x].lt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allor</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> bit, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!u || !tr[u].sz) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> add = val &amp; tr[u].lval;</span><br><span class="line"><span class="keyword">if</span> (!(add &amp; tr[u].val)) <span class="keyword">return</span> <span class="built_in">allxor</span>(u, bit, add);</span><br><span class="line"><span class="built_in">pushdown</span>(u, bit);</span><br><span class="line"><span class="type">int</span> mid = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">if</span> (val &amp; mid)</span><br><span class="line"><span class="built_in">allxor</span>(tr[u].s[<span class="number">0</span>], bit - <span class="number">1</span>, mid),</span><br><span class="line">tr[u].s[<span class="number">1</span>] = <span class="built_in">merge</span>(tr[u].s[<span class="number">0</span>], tr[u].s[<span class="number">1</span>], bit - <span class="number">1</span>), tr[u].s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">allor</span>(tr[u].s[<span class="number">0</span>], bit - <span class="number">1</span>, val), <span class="built_in">allor</span>(tr[u].s[<span class="number">1</span>], bit - <span class="number">1</span>, val);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对全局-and"><a href="#对全局-and" class="headerlink" title="对全局 and"></a>对全局 and</h3><p>容易发现 $v\odot x = \neg(\neg v |x)$，那么就可以拆分成 or 和 xor 操作。这个就好做了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于一共只有 $O((n + m)\log a)$ 个节点，我们花费 $O(\log a)$ 的时间可以永久删除一个点，所以复杂度时 $O((n + m)\log ^ 2a)$ 的，可以通过。</p><p>由于笔者也是第一次也这种代码，出了很多神秘错误，大概列几点可能常见的：</p><ol><li>计算低位的时候，不管 xor 还是 or 都不能只把 $x$ 的低位传下去，因为需要维护子树的值相关的信息。</li><li>由于 <code>split</code> 时可能出现里面一个数都没有的节点，操作时需要特判一下，比如把所有判断空节点都写成 <code>!tr[u].sz</code>。</li><li>注意 or 判断改为 xor 时的判断条件要准确，因为小样例测不出来。</li></ol><p>只放主函数了，调用的函数上面基本出现了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), <span class="built_in">insert</span>(x);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, typ, l, r, v, x, y; i &lt;= m; ++ i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;typ, &amp;l, &amp;r);</span><br><span class="line"><span class="built_in">split</span>(rt, x, y, l, r, <span class="number">19</span>);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;RANGE &quot; &lt;&lt; tr[x].sz &lt;&lt; &#x27; &#x27; &lt;&lt; tr[x].val &lt;&lt; &#x27; &#x27; &lt;&lt; tr[x].lval &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">if</span> (typ == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tr[x].sz);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (typ == <span class="number">3</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v), <span class="built_in">allxor</span>(x, <span class="number">19</span>, v);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (typ == <span class="number">2</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v), <span class="built_in">allor</span>(x, <span class="number">19</span>, v);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v), <span class="built_in">allxor</span>(x, <span class="number">19</span>, U), <span class="built_in">allor</span>(x, <span class="number">19</span>, U ^ v), <span class="built_in">allxor</span>(x, <span class="number">19</span>, U);</span><br><span class="line">rt = <span class="built_in">merge</span>(y, x, <span class="number">19</span>);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;ALL &quot; &lt;&lt; tr[rt].sz &lt;&lt; &#x27; &#x27; &lt;&lt; tr[rt].val &lt;&lt; &#x27; &#x27; &lt;&lt; tr[x].lval &lt;&lt; &quot;\n\n&quot;;</span></span><br><span class="line"><span class="comment">// exit(0);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：维护一个集合 $a$，最开始有 $n$ 个元素，有 $m$ 次操作或者询问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将 $a_i\in [l, r]$ 的值全部与 $x$。&lt;/li&gt;
&lt;li&gt;将 $a_i\in [l, r]$ 的值全部或 $x$。&lt;/li&gt;
&lt;li&gt;将 $a_i\in [l, r]$ 的值全部异或 $x$。&lt;/li&gt;
&lt;li&gt;询问在 $[l, r]$ 中有多少个不同的 $a_i$。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$n\leq 2\times 10 ^ 5$，$m\leq 10 ^ 5$，$0\leq a_i &amp;lt; 2 ^ {20}$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Trie" scheme="https://mydcwfy.github.io/tags/Trie/"/>
    
    <category term="位运算" scheme="https://mydcwfy.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="复杂度分析" scheme="https://mydcwfy.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>LOJ6736 「2020 集训队论文」最小连通块</title>
    <link href="https://mydcwfy.github.io/2022/10/13/LOJ6736/"/>
    <id>https://mydcwfy.github.io/2022/10/13/LOJ6736/</id>
    <published>2022-10-13T11:56:00.000Z</published>
    <updated>2022-10-13T12:23:44.347Z</updated>
    
    <content type="html"><![CDATA[<p>题意：<strong>交互题</strong>。给出一棵树的点数 $n$，你每次询问可以给出一个点集 $S$ 和一个点 $x$，可以得到 $x$ 是否在点集 $S$ 的最小连通块中，需要还原出树。$n = 1000$，你最多可以询问 22000 次。求构造方案。</p><span id="more"></span><p>这个题的做法有很多，我们切入一个比较简单并且易懂的角度。</p><p>首先我们考虑如果我们已经知道了这棵树的拓扑序后怎么做。注意此时我们需要定义一个根，然后每条边从儿子指向父亲。简单来说就是父亲的拓扑序在儿子的后面。</p><p>注意到我们在拓扑序上枚举到了 $x$，我们求它的所有后代。容易发现它的所有后代都是在它前面的，并且除了 $x$ 的儿子以外，其他的点都已经被这种方式覆盖过了。这给我们一个区分儿子和后代的办法：拿到所有的后代后，直接在拓扑序中把这些点删除，这样后面就不会再遍历到这些点了。那么我们就可以保证，现在拿到的所有的点都满足是 $x$ 的儿子。这样做下去，容易发现询问复杂度是 $O(n\log n)$ 的，因为遍历到一个点就会把他删除，遍历到点的过程可以二分查找前半段是否存在 $x$ 的后代，所以就是 $O(n\log n)$ 的。</p><p>那么现在问题就转化成了求树的拓扑序。假设我们当前 $S$ 集合里面的点都没有放进拓扑序，我们要把 $x$ 子树内全部放进去。做法比较神秘，我们考虑找到一个 $S$ 内部并且在 $x$ 子树内部的点 $y$，然后先将 $y$ 子树内部的点放进拓扑序（注意到 $y$ 子树内部的点一定在 $x$ 前面），$S$ 集合对应更新。我们这样做的话，显然是一定会把 $x$ 子树内部的所有点全部都放进拓扑序。最后放 $x$，这样的话就可以完成构造拓扑序。</p><p>考虑分析一下上述算法的复杂度。注意到每一个 $x$ 都只会被遍历一次（不挂其子树内是什么），找到一个 $x$ 的后代的过程同样可以二分，于是询问复杂度也是 $O(n\log n)$ 的。</p><p>综上，我们可以在询问复杂度 $O(n\log n)$ 的时间内完成，时间复杂度可以较容易地做到 $O(n ^ 2)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) s.<span class="built_in">size</span>(); ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s[i] == x) <span class="keyword">return</span> s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i), <span class="built_in">void</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; s, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask</span>(s, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">del</span>(x);</span><br><span class="line">    <span class="keyword">while</span> (s.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">query</span>(s, x))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">query</span>(&#123;s.<span class="built_in">data</span>(), s.<span class="built_in">data</span>() + mid&#125;, x)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> y = s[l - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">solve</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    ord.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">work</span>(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) s.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = ord[i];</span><br><span class="line">        <span class="keyword">while</span> (vec.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">query</span>(vec, x)) &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">1</span>, r = vec.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">query</span>(&#123;vec.<span class="built_in">data</span>(), vec.<span class="built_in">data</span>() + mid&#125;, x)) r = mid;</span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; &quot;Find &quot; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; vec[l - 1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;x, vec[l - <span class="number">1</span>]&#125;), vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + l - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; res.size() &lt;&lt; &#x27; &#x27; &lt;&lt; ord.size() &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：&lt;strong&gt;交互题&lt;/strong&gt;。给出一棵树的点数 $n$，你每次询问可以给出一个点集 $S$ 和一个点 $x$，可以得到 $x$ 是否在点集 $S$ 的最小连通块中，需要还原出树。$n = 1000$，你最多可以询问 22000 次。求构造方案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="交互" scheme="https://mydcwfy.github.io/tags/%E4%BA%A4%E4%BA%92/"/>
    
    <category term="二分" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="复杂度分析" scheme="https://mydcwfy.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>ARC150D Removing Gacha</title>
    <link href="https://mydcwfy.github.io/2022/10/12/ARC150D/"/>
    <id>https://mydcwfy.github.io/2022/10/12/ARC150D/</id>
    <published>2022-10-12T00:04:45.000Z</published>
    <updated>2022-10-12T00:25:31.944Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定 $n$ 个点的树，定义一个点是好的当且仅当它和它的所有祖先都是黑色的，从所有点都是白点开始，任选一个不好的点染成黑色，问期望染多少次使得所有都是黑色。$n\leq 2\times 10 ^ 5$，对 998244353 取模。</p><span id="more"></span><p>非常 nb 的期望题，做了一整场 /cy</p><p>和题解角度不同，我们考虑每个点的时候，需要考虑它没被祖先覆盖的概率，然后再在它的子树内部任意选，直到选到这个点为止。容易发现我们如果没选在子树内部的话，根据期望的线性性，我们可以把不同子树之间的答案直接加就好了。</p><p>首先考虑在它的子树内部任意选的期望。因为子树的根是没有被选中的，所以所有点都是不好的点，那么期望就是 $sz(x)$ 能选中子树的根。</p><p>然后考虑它没被祖先覆盖的概率。我们不管其他节点，我们现在只关心我们选到了 $x$ 以及所有祖先的情况。这个相当于是我们把所有祖先都染成黑色了，但是 $x$ 没被碰到。</p><p>有一个好点的限制比较烦，但是注意到我们选择好点对概率是没有影响的。所以我们相当于是不管好不好，所有点都是随机一个选择。这样的话，所有点是等价的，那么 $x$ 没被碰到相当于是 $x$ 被最后选到，概率就是 $\dfrac 1{dep(x)}$。</p><p>于是我们可以得到答案为 $\displaystyle \sum_{i = 1} ^ n \dfrac {sz(x)}{dep(x)}$。直接计算即可，时间复杂度 $O(n)$ 或者 $O(n\log a)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x ^ <span class="number">1</span>) dep[x] = dep[fa[x]] + <span class="number">1</span>;</span><br><span class="line">sz[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x]) <span class="built_in">dfs</span>(v), sz[x] += sz[v];</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; dep[x] &lt;&lt; &#x27; &#x27; &lt;&lt; sz[x] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">res = (res + (LL) <span class="built_in">qpow</span>(dep[x] + <span class="number">1</span>) * sz[x]) % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定 $n$ 个点的树，定义一个点是好的当且仅当它和它的所有祖先都是黑色的，从所有点都是白点开始，任选一个不好的点染成黑色，问期望染多少次使得所有都是黑色。$n\leq 2\times 10 ^ 5$，对 998244353 取模。&lt;/p&gt;</summary>
    
    
    
    
    <category term="树相关" scheme="https://mydcwfy.github.io/tags/%E6%A0%91%E7%9B%B8%E5%85%B3/"/>
    
    <category term="期望" scheme="https://mydcwfy.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>ABC272F Two Strings</title>
    <link href="https://mydcwfy.github.io/2022/10/12/ABC272F/"/>
    <id>https://mydcwfy.github.io/2022/10/12/ABC272F/</id>
    <published>2022-10-11T23:44:34.000Z</published>
    <updated>2022-10-12T00:03:25.867Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定两个长度为 $n$ 的字符串 $S, T$，定义 $f(S, i)$ 表示将前 $i$ 个字符放在最后得到的字符串，问有多少个 $(i, j)(0\leq i, j &lt;n)$ 满足 $f(S, i)\leq f(T, j)$。$n\leq 2\times 10 ^ 5$，$S, T$ 仅由小写英文字符构成。</p><span id="more"></span><p>场上没做出来，靠 G 的随机化才上了分……</p><p>我们尝试把 $S, T$ 拼在一起，然后把 $f(S, i)\leq f(T, j)$ 设置为整个字符串内部的某些后缀的大小关系。经过构造可以这样：<br>$$<br>S + S + \texttt a ^ n + T + T + \texttt z ^ n<br>$$<br>首先两倍是很显然的，因为我们需要把前 $i$ 个拼到最后面，复制一遍显然是比较好的选择。如果 $f(S, i) &lt; f(T, j)$，那么在新字符串中，他们对应的后缀一定满足小于关系。如果 $f(S, i) = f(T, j)$ 的话，容易发现他们一定会跳过本身的 $S, T$，而变成 $\tt a, z$ 的比较了。那么也就是说新的字符串，我们只需要比较新的字符串中 $S, T$ 区间的大小关系。</p><p>这个怎么做呢？其实我场上想到这了，但是没想到这是一个 SA 板子 /kk。直接做就好了，复杂度 $O(n\log n)$ 或者 $O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> m = <span class="number">2</span> * n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[i] = s[i + n] = a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[++ m] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[i + m] = s[i + n + m] = b[i];</span><br><span class="line">m += <span class="number">2</span> * n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[++ m] = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"><span class="built_in">get_sa</span>(s);</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, cnt = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line"><span class="keyword">if</span> (sa[i] &lt;= n) cnt ++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sa[i] &gt; <span class="number">3</span> * n &amp;&amp; sa[i] &lt;= <span class="number">4</span> * n) res += cnt;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定两个长度为 $n$ 的字符串 $S, T$，定义 $f(S, i)$ 表示将前 $i$ 个字符放在最后得到的字符串，问有多少个 $(i, j)(0\leq i, j &amp;lt;n)$ 满足 $f(S, i)\leq f(T, j)$。$n\leq 2\times 10 ^ 5$，$S, T$ 仅由小写英文字符构成。&lt;/p&gt;</summary>
    
    
    
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="字符串" scheme="https://mydcwfy.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="后缀数据结构" scheme="https://mydcwfy.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ABC270Ex add 1</title>
    <link href="https://mydcwfy.github.io/2022/09/29/ABC270H/"/>
    <id>https://mydcwfy.github.io/2022/09/29/ABC270H/</id>
    <published>2022-09-29T03:17:11.000Z</published>
    <updated>2022-10-02T02:23:43.448Z</updated>
    
    <content type="html"><![CDATA[<p>题意：有 $n$ 个计数器，每个计数器有一个上界 $a_i$，每次操作会将一个计数器清 0，然后将其他计数器 +1。问期望多少步每个计数器都达到上界。保证 $0 = a_1 \leq a_2 \leq \dots\leq a_n\leq 10 ^ {18}$，$a_n &gt; 0$，$n\leq 2\times 10 ^ 5$，答案对 998244353 取模。</p><span id="more"></span><p>好神的期望题。</p><p>首先 $n$ 个状态显然是不好计数的，我们考虑用一个状态描述。记 $k$ 为 $\max_{i = 1} ^ n(a_i - c_i)$，$c_i$ 表示当前的计数器的数。记录 $f_k$ 表示从状态 $k$ 期望的步数结束。容易发现 $f_0 = 0$。</p><p>考虑设一个 $r$ 为最大的满足 $a_r &lt; k\leq a_{r + 1}$ 的阈值，我们考虑分析两种情况：</p><ol><li>选中清空的 $i$ 满足 $i\leq r$。这时不管清空的是哪一个，我们都容易得到新的状态是 $k - 1$。</li><li>选中清空的 $i$ 满足 $i &gt; r$。这是清空哪一个，$k$ 就会变成哪一个计数器的值。所以就会变成 $a_i$。</li></ol><p>那么据此我们可以得到：<br>$$<br>f_k = \dfrac rn f_{k - 1} + \dfrac 1n \sum_{i = r + 1} ^ n f_{a_i} + 1<br>$$<br>注意到转移方向不确定，我们考虑变化一下，这样 $f_{k - 1}$ 在一边了。</p><p>但是我们又注意到一个问题，就是我们知道的不是最大的那一个，而是最小的那一个（$f_0 = 0$）。</p><p>考虑转化定义，设 $g_k$ 表示开始期望多少能走到状态 $k$。容易发现 $f_k + g_k = f_{a_n}$。那么我们现在已经知道了 $g_{a_n} = 0$，我们需要找到 $g_0$。</p><p>直接暴力带入上面的式子：<br>$$<br>\begin{aligned}<br>f_{a_n} - g_{k} =&amp;\dfrac rn(f_{a_n} - g_{k - 1}) + \dfrac 1n \sum_{i = r + 1} ^ n (f_{a_n} - g_{a_i}) + 1\\<br>g_k =&amp; \dfrac rn g_{k - 1} + \dfrac 1n \sum_{i = r + 1} ^ n g_{a_i} - 1\\<br>g_{k - 1} =&amp; \dfrac nr g_k - \dfrac 1r \sum_{i = r + 1} ^ n g_{a_i} + \dfrac nr<br>\end{aligned}<br>$$</p><p>得到这样的式子过后，我们可以得到一个 $O(a\log a)$ 的做法。但是仍然不够优秀，我们考虑优化。</p><p>容易发现在 $k\in (a_r, a_{r + 1}]$ 的转移都是相同的，因为 $r$ 不变。我们考虑从这里入手。我们记 $suf_r = \sum_{i = r} ^ n g_{a_i}$，有：<br>$$<br>\begin{aligned}<br>g_{k - 1} =&amp; \dfrac nr g_k - \dfrac {suf_{r + 1}}r + \dfrac nr\<br>g_{k - 1} - \dfrac {suf_{r + 1}}{n - r} + \dfrac n{n - r} =&amp; \dfrac nr(g_k - \dfrac {suf_{r + 1}}{n - r} + \dfrac n{n - r})<br>\end{aligned}<br>$$<br>注意到我们把两边的形式化为相同过后，直接快速幂，这个可以省去中间的状态，直接通过 $g_{a_{r + 1}}$ 得到 $g_{a_r}$。<br>$$<br>g_{a_r} + \dfrac {n - suf_{r + 1}}{n - r} = \left(\dfrac nr \right) ^ {a_{r + 1} - a_r} (g_{a_{r + 1}} + \dfrac {n - suf_{r + 1}}{n - r})<br>$$<br>直接计算可以得到 $O(n\log a)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>, x, tmp; i; -- i) &#123;</span><br><span class="line">x = <span class="built_in">qpow</span>((LL) n * <span class="built_in">qpow</span>(i) % Mod, a[i + <span class="number">1</span>] - a[i]);</span><br><span class="line">res[i] = (res[i + <span class="number">1</span>] + (LL) <span class="built_in">adj</span>(tmp = n - suf[i + <span class="number">1</span>]) * <span class="built_in">qpow</span>(n - i)) % Mod * x % Mod;</span><br><span class="line">res[i] = (res[i] + (LL) (Mod - tmp) * <span class="built_in">qpow</span>(n - i)) % Mod;</span><br><span class="line"><span class="built_in">adj</span>(suf[i] = suf[i + <span class="number">1</span>] + res[i] - Mod);</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：有 $n$ 个计数器，每个计数器有一个上界 $a_i$，每次操作会将一个计数器清 0，然后将其他计数器 +1。问期望多少步每个计数器都达到上界。保证 $0 = a_1 \leq a_2 \leq \dots\leq a_n\leq 10 ^ {18}$，$a_n &amp;gt; 0$，$n\leq 2\times 10 ^ 5$，答案对 998244353 取模。&lt;/p&gt;</summary>
    
    
    
    
    <category term="期望" scheme="https://mydcwfy.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>ARC Round#116</title>
    <link href="https://mydcwfy.github.io/2022/09/25/ARC-Round-116/"/>
    <id>https://mydcwfy.github.io/2022/09/25/ARC-Round-116/</id>
    <published>2022-09-25T13:04:44.000Z</published>
    <updated>2022-09-25T23:39:23.489Z</updated>
    
    <content type="html"><![CDATA[<p>All Accepted。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定一个数 $n$，判断 $n$ 的奇因数多还是偶因数多。$T(T\leq 2\times 10 ^ 5)$ 组数据，$n\leq 10 ^ {18}$。</p><p>容易发现如果 $n$ 是奇数肯定是奇因数多，否则如果 $n$ 是 4 的倍数，那么如果 $d$ 是奇因数，那么 $2d, 4d$ 都是偶因数，这样 $n$ 的偶因数多。否则一样多。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定一个序列 $A$，问所有非空子序列 $B$ 的 $\max(B)\times \min(B)$ 的和。$n\leq 2\times 10 ^ 5$，答案对 998244353 取模。</p><p>首先排除我们只选一个数的贡献，假设我们确定最大值和最小值，那么可以得到可以计算的次数为 $2 ^ {r - l}$。注意到 $r, l$ 是分开的，这个可以使用前缀 / 后缀和优化，比如我们记录 $\sum_{i = l} ^ n 2 ^ la_i$ 就可以 $O(\log p)$ 或者 $O(1)$ 计算单个最小值的贡献了。时间复杂度 $O(n\log p)$ 或者 $O(n)$。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定 $n, m$，问有多少个长度为 $n$ 的序列满足 $a_i | a_{i + 1}$ 并且 $1\leq a_i\leq m$。$n, m\leq 2\times 10 ^ 5$，对 998244353 取模。</p><p>考虑我们枚举 $a_n$，那么考虑对每个质因数的次数拆开看，相当于是找一个不减的序列，末项已经确定了。容易发现这就是一个插板法，答案为 $\displaystyle \binom {n + t - 1}{n - 1}$。</p><p>直接计算，复杂度 $O(m\log n)$（要分析成 $O(m\sqrt n)$ 没问题罢，但是感觉就是 $\log$ 的）。</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定 $n, m$，问有多少个长度为 $n$ 的序列和为 $m$ 并且异或和为 0。对 998244353 取模。$n, m\leq 5000$。</p><p>直接考虑按位 DP，注意每一位出现的次数必须为偶数，这样背包 + 组合数学可以做到 $O(n m\log m)$。另外还可以发现每一次操作完后末位必须为 0，否则肯定不合法。同时我们可以把最后一位去掉，可以做到 $O(nm)$。（好像原来也是 $O(nm)$ 的？</p><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>这个题之前的题似乎都比较一眼（</p><p>题意：给定一棵 $n$ 个点的树，你可以选定 $k$ 个关键点，使得 $\max_{i = 1} ^ n \min_{j = 1} ^ k \text{dis}(i, node_j)$ 最小。$n\leq 2\times 10 ^ 5$。</p><p>场上想到了二分 + 树形 DP，但是剩下的写不出来 /ll</p><p>看到这个最大最小，果断二分。</p><p>相当于我们已经给定了一个距离了，问至少要有多少个关键点。</p><p>注意到一棵子树只会对外面产生的影响由两种：一是关键点距离根距离 $&lt;d$，那么会对外面的一些选择产生影响。否则就是至少需要距离根不超过某一值的关键点。</p><p>注意到不同子树之间合并是容易的，反正可能细节比较多就是了。我直接贴代码。从 Um_nik 的写法中得到的，正数表示第一种情况，否则表示第二种情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[x] = add[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x]) &#123;</span><br><span class="line"><span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v, x);</span><br><span class="line">f[x] += f[v];</span><br><span class="line"><span class="keyword">if</span> (add[x] &gt; add[v]) std::<span class="built_in">swap</span>(add[x], add[v]);</span><br><span class="line"><span class="keyword">if</span> (add[x] &lt;= <span class="number">0</span> &amp;&amp; add[v] &gt; <span class="number">0</span> &amp;&amp; add[v] - add[x] &lt;= dis) add[x] = add[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (add[x] == -dis) f[x] ++, add[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (add[x] &gt; <span class="number">0</span>) add[x] ++;</span><br><span class="line"><span class="keyword">else</span> add[x] --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>), f[<span class="number">1</span>] + (add[<span class="number">1</span>] &lt; <span class="number">0</span>) &lt;= k; &#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：有 $n$ 个序列，每个序列长度为 $m_i$，两个人轮流拿数，每次可以把一个长度不为 1 的序列的首尾任意一个数拿走。在两个人都使用最优走法时（先手想让剩的 $n$ 个数和最大，后手相反），问剩的数的和。$n, \sum m\leq 2\times 10 ^ 5$。</p><p>假设所有数列的长度都是奇数，我们想一想该如何选。容易发现此时后手更有主动权，因为如果后手想要维持保留最终点的话时很容易做到的，而他也可以不这么选择。也就是说，如果先手选择的左半，后手也可以选择左半，此时后手肯定希望选到 $a(mid + 1)$，因为他不可能选到 $a(mid + 2)$（先手可以和他平衡），既然选择了删除左半，肯定是希望选到 $a(mid + 1)$。而如果先手先删除右半，那么后手就有机会选择 $a(mid - 1)$。这样的话，先手有能力去掉 $a(mid - 1)$ 和 $a(mid + 1)$ 中的较小值的，剩下的再和 $a(mid)$ 取 $\min$。这样的话，最后能取到的一定是 $\min(a(mid), \max(a(mid - 1), a(mid + 1)))$。</p><p>然后考虑有多个序列的。前面说到后手更有主动权，那么最开始的后手肯定并不希望自己成为先手，而这个又是可以实现的，就是和先手在同一条序列上操作。容易发现操作完后先后手顺序不变，所以直接简单的把所有加起来即可。</p><p>然后考虑有偶数情况的。注意到偶数长度的情况先手占有主动权。我们发现先手可以选择删前还是删后就可以变成一个偶数的情况了，而此时原来的先手就占有主动权了。删前还是删后是由删了过后偶数情况所决定的。</p><p>最后考虑有多个偶数情况的。容易发现由于单个序列先手有主动权，那么肯定先后手轮流先取偶数的序列。最后再考虑去玩过后，原来的先手有没有变成后手，两次的贡献不同。</p><p>时间复杂度 $O(n + \sum m)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, tot; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tot);</span><br><span class="line">sum += tot - <span class="number">1</span>;</span><br><span class="line">a[i].<span class="built_in">resize</span>(tot);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;x : a[i]) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">&#125;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (a[i].<span class="built_in">size</span>() &amp; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">int</span> mid = a[i].<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[i].<span class="built_in">size</span>() == <span class="number">1</span>) res += a[i][mid];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!(sum &amp; <span class="number">1</span>))</span><br><span class="line">res += std::<span class="built_in">min</span>(a[i][mid], std::<span class="built_in">max</span>(a[i][mid - <span class="number">1</span>], a[i][mid + <span class="number">1</span>]));</span><br><span class="line"><span class="keyword">else</span> res += std::<span class="built_in">max</span>(a[i][mid], std::<span class="built_in">min</span>(a[i][mid - <span class="number">1</span>], a[i][mid + <span class="number">1</span>]));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> mid = a[i].<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[i].<span class="built_in">size</span>() == <span class="number">2</span>)</span><br><span class="line">res += std::<span class="built_in">min</span>(a[i][mid - <span class="number">1</span>], a[i][mid]), vec.<span class="built_in">push_back</span>(<span class="built_in">abs</span>(a[i][mid] - a[i][mid - <span class="number">1</span>]));</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> v1 = std::<span class="built_in">max</span>(a[i][mid], std::<span class="built_in">min</span>(a[i][mid - <span class="number">1</span>], a[i][mid + <span class="number">1</span>])),</span><br><span class="line">v2 = std::<span class="built_in">max</span>(a[i][mid - <span class="number">1</span>], std::<span class="built_in">min</span>(a[i][mid - <span class="number">2</span>], a[i][mid]));</span><br><span class="line"><span class="keyword">if</span> (!(sum &amp; <span class="number">1</span>))</span><br><span class="line">v1 = std::<span class="built_in">min</span>(a[i][mid], std::<span class="built_in">max</span>(a[i][mid - <span class="number">1</span>], a[i][mid + <span class="number">1</span>])),</span><br><span class="line">v2 = std::<span class="built_in">min</span>(a[i][mid - <span class="number">1</span>], std::<span class="built_in">max</span>(a[i][mid - <span class="number">2</span>], a[i][mid]));</span><br><span class="line">res += std::<span class="built_in">min</span>(v1, v2), vec.<span class="built_in">push_back</span>(<span class="built_in">abs</span>(v1 - v2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (vec.<span class="built_in">size</span>() + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) vec.<span class="built_in">size</span>(); ++ i)</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) res += vec[i];</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;All Accepted。&lt;/p&gt;</summary>
    
    
    
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>HDU7201 Yet Another Easy Function Sum Problem</title>
    <link href="https://mydcwfy.github.io/2022/09/25/HDU7201/"/>
    <id>https://mydcwfy.github.io/2022/09/25/HDU7201/</id>
    <published>2022-09-25T11:42:31.000Z</published>
    <updated>2022-09-25T13:02:26.324Z</updated>
    
    <content type="html"><![CDATA[<p>题意：求</p><p>$$<br>\sum_{i = 1} ^ n \sum_{j = 1} ^ n H(ij) [\gcd(i, j) = 1]<br>$$<br>其中 $H(x)$ 表示 $x$ 所有质因子的乘积（去重后）。$n\leq 10 ^ 9$，$T(T\leq 5)$ 组数据，满足 $\sum n\leq 2\times 10 ^ 9$。20s。</p><span id="more"></span><p>类似 $\varphi$ 的，我们有一个这样的结论：<br>$$<br>H(ij) = \dfrac {H(i) H(j)}{H(\gcd(i, j))}<br>$$<br>对每个质因数分开看就好了。</p><p>首先看到 $\gcd$ 套路反演一下（所有除法默认下取整）：<br>$$<br>\begin{aligned}<br>&amp; \sum_{i = 1} ^ n \sum_{j = 1} ^ n H(ij) [\gcd(i, j) = 1] \\<br>=&amp; \sum_{i = 1} ^ n \sum_{j = 1} ^ n H(i)H(j) \sum_{d | i, d | j} \mu(d)\\<br>=&amp; \sum_{d = 1} ^ n \mu(d)(\sum_{i = 1} ^ {\frac nd} H(id)) ^ 2<br>\end{aligned}<br>$$<br>这个看样子就不能很好做，至少都得枚举 $d$，这样就不可能低于 $O(n)$。考虑对 $d$ 分治，钦定阈值 $B$，$d\leq B$ 就暴力枚举，否则我们换另外的方法。</p><h3 id="1-d-leq-B"><a href="#1-d-leq-B" class="headerlink" title="1. $d\leq B$"></a>1. $d\leq B$</h3><p>记 $F_1(n, d) = \sum_{i = 1} ^ n H(id)$，那么原式就可以表示成 $\sum_{d = 1} ^ B \mu(d)F_1 ^ 2(\dfrac nd, d)$。考虑如何计算 $F_1(n, d)$。</p><p>注意到有一个 $H(id)$ 很烦，使用上面的套路，我们开始展开：<br>$$<br>\begin{aligned}<br>F_1(n, d) =&amp; \sum_{i = 1} ^ n H(id)\\<br>=&amp; \sum_{k | d} \sum_{i = 1} ^ n [\gcd(i, d) = k] \dfrac {H(i)H(d)}{H(k)}\\<br>=&amp; \sum_{k | d} \dfrac 1{H(k)} \sum_{i = 1} ^ {\frac nk} [\gcd(i, \dfrac dk) = 1] H(ik)H(d)\\<br>=&amp; \sum_{k | d} \dfrac 1{H(k)}\sum_{i = 1} ^ {\frac nk} H(ik)H(d) \sum_{t | i, tk | d} \mu(t)\\<br>=&amp; \sum_{T | d}(\sum_{k | T} \dfrac {\mu(\frac Tk)}{H(k)}) (\sum_{i = 1} ^ {\frac nT} H(iT))\\<br>=&amp; \sum_{T | d} H_1(T) F_1(\dfrac nT, T)<br>\end{aligned}<br>$$<br>这里令 $H_1 = H \times \mu$，表示狄利克雷卷积。容易发现这是一个简单的递归函数，直接递归并记忆化即可。</p><p>注意边界是 $n = 0$（答案显然是 0）或者是 $d = 1$，此时我们相当于是求 $\sum_{i = 1} ^ n H(i)$。这个东西直接使用 Min_25 筛去处理，时间复杂度 $O(\dfrac {n ^ {\frac 34}}{\log n})$。</p><p>不考虑 Min_25 筛的复杂度，我们考虑所有可能的 $F_1(n, d)$ 和可能的转移数。容易发现一个 $F_1(n, d)$ 可能的转移数为 $O(\sigma(d))$。对于从外部调用的 $F_1(n, d)$，就是 $O(\sum_{i = 1} ^ B \sigma(i)) = O(B\log B)$。对于自调用的的 $F_1(m, t)$，一定满足 $m = \dfrac n{t ^ 2x}$，因为前面一个假设不来自外部调用的话，那么上一级的 $d$ 需要满足 $t|d$，我们可以分析得到 $O(\sum_{d = 1} ^ B \dfrac{\sqrt n}d) = O(\sqrt n\log n)$。类似的分析转移数可以得到 $O(\sqrt n\log ^ 2 n)$。总复杂度 $O(B\log n + \sqrt n\log ^ 2n)$，后半部分不管了（</p><h3 id="2-d-gt-B"><a href="#2-d-gt-B" class="headerlink" title="2. $d &gt; B$"></a>2. $d &gt; B$</h3><p>再看 $d$ 显然是不明智的选择，我们考虑把平方看作枚举 $i, j$，计算 $\sum_{d = 1} [id\leq n\land jd\leq n]H(id)H(jd)$。令 $G(m, i, j) = \sum_{d = 1} ^ m \mu(d) H(id)H(jd)$。那么就可以得到原式为：</p><p>$$<br>\sum_{i = 1} ^ {\frac nB} \sum_{j = 1} ^ {\frac nB} (G(\dfrac n{\max(i, j)}, i, j) - G(B, i, j))<br>$$<br>考虑如何计算 $G(m, i, j)$。仍然套路展开 $H(id)$ 和 $H(jd)$，大力计算：<br>$$<br>\begin{aligned}<br>&amp; \sum_{d = 1} ^ m \mu(d) H(id) H(jd)\\<br>=&amp; H(i)H(j)\sum_{d = 1} ^ m \mu(d) H ^ 2(d) \sum_{k_1 | i} [\gcd(i, d) = k_1] \sum_{k_2 | j} [\gcd(j, d) = k_2] \dfrac 1{H(k_1)H(k_2)}\\<br>=&amp; H(i) H(j) \sum_{k_1 | i} \sum_{k_2 | j} \dfrac 1{H(k_1)H(k_2)} \sum_{d = 1} ^ {\frac mk} \mu(dk) H ^ 2(dk) [\gcd(\dfrac i{k_1}, d) = 1][\gcd(\dfrac i{k_2}, d) = 1]\\<br>=&amp; H(i) H(j) \sum_{k_1 | i} \sum_{k_2 | j} \dfrac 1{H(k_1) H(k_2)} \sum_{d = 1} ^ {\frac mk} \mu(dk) H ^ 2(dk) \sum_{t_1 | d, t_1k_1 | i} \mu(t_1) \sum_{t_2 | d, t_2k_2 | j} \mu(t_2) \\<br>=&amp; H(i)H(j) \sum_{T_1 | i} \sum_{T_2 | j} (\sum_{k_1 | T_1} \dfrac {\mu(\frac {T_1}{k_1})}{H(k_1)})(\sum_{k_2 | T_2} \dfrac {\mu(\frac {T_2}{k_2})}{H(k_2)}) \sum_{d = 1} ^ {\frac mT} \mu(dT) H ^ 2(dT)<br>\end{aligned}<br>$$</p><p>上述式子中，$T = \text{lcm} (T_1, T_2)$，$k = \text{lcm} (k_1, k_2)$，最后一个仍然很难算，我们考虑再设一个函数 $F_2$ 来表示。令 $F_2(n, d)$ 为 $\sum_{i = 1} ^ n \mu(di) H ^ 2(di)$。这个和 $F_1$ 是比较类似的，我们就不做每一步的推导了，直接给结论：<br>$$<br>F_2(n, d) = \mu(d) H ^ 2(T) \sum_{T | d} \mu(k) F_2(\dfrac nT, T)<br>$$<br>同样，$F_2$ 的复杂度和 $F_1$ 分析的类似。不是很会分析了 /kk，据说是 $\tilde O(\dfrac {n}{\sqrt B})$。</p><h3 id="平衡规划与代码"><a href="#平衡规划与代码" class="headerlink" title="平衡规划与代码"></a>平衡规划与代码</h3><p>两边平衡一下，取 $B = n ^ {\frac 23}$，可以得到复杂度约为 $O(\dfrac {n ^ {\frac 34}}{\log n} + n ^ {\frac 23} \log n)$。卡卡常大概就可以过了（？）。</p><p>说几点代码细节：</p><ol><li>容易发现递归 $F_2$ 的时候 $\mu(t) = 0$ 可以直接返回。</li><li>$B$ 必须是 $n$ 的约数才能过，原因好像是交界处可能寄。</li><li>Min_25 可以写迭代，比较少见呢。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">H[<span class="number">1</span>] = mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) prime[cnt ++] = i, H[i] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; i * prime[j] &lt; N; ++ j) &#123;</span><br><span class="line">H[i * prime[j]] = H[i];</span><br><span class="line">st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">mu[i * prime[j]] = -mu[i], H[i * prime[j]] *= prime[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) iH[i] = <span class="built_in">qpow</span>(H[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mu[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (mu[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; i * j &lt; N; ++ j)</span><br><span class="line"><span class="built_in">adj</span>(H1[i * j] += iH[j] - Mod);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; i * j &lt; N; ++ j)</span><br><span class="line"><span class="built_in">adj</span>(H1[i * j] -= iH[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; i * j &lt; N; ++ j)</span><br><span class="line"><span class="keyword">if</span> (mu[i * j]) fac[i * j].<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getid</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &lt;= sq ? id1[x] : id2[n / x]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">loc</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">lower_bound</span>(a + <span class="number">1</span>, a + tot + <span class="number">1</span>, x, std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()) - a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sum1</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * (x + <span class="number">1LL</span>) / <span class="number">2</span> % Mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sum2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * (x + <span class="number">1LL</span>) % Mod * (x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) % Mod * (Mod + <span class="number">1</span>) / <span class="number">6</span> % Mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Min25_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sq = std::<span class="built_in">sqrt</span>(n), tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r, t; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = n / l, r = n / t;</span><br><span class="line">a[++ tot] = t;</span><br><span class="line"><span class="keyword">if</span> (t &lt;= sq) id1[t] = tot;</span><br><span class="line"><span class="keyword">else</span> id2[r] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i)</span><br><span class="line"><span class="built_in">adj</span>(sp1[i] = sp1[i - <span class="number">1</span>] + prime[i] - Mod), sp2[i] = (sp2[i - <span class="number">1</span>] + (LL) prime[i] * prime[i]) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) psum1[i] = <span class="built_in">sum1</span>(a[i]) - <span class="number">1</span>, psum2[i] = <span class="built_in">sum2</span>(a[i]) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i) &#123;</span><br><span class="line">LL le = (LL) prime[i] * prime[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>, p = prime[i]; j &lt;= tot &amp;&amp; a[j] &gt;= le; ++ j)</span><br><span class="line">psum1[j] = (psum1[j] + (LL) (sp1[i - <span class="number">1</span>] + Mod - psum1[<span class="built_in">getid</span>(a[j] / p)]) * p) % Mod,</span><br><span class="line">psum2[j] = (psum2[j] + (LL) (sp2[i - <span class="number">1</span>] + Mod - psum2[<span class="built_in">getid</span>(a[j] / p)]) * p * p) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>, x; j &lt;= tot; ++ j)</span><br><span class="line"><span class="built_in">adj</span>(f1[j] = psum1[j] - psum1[x = <span class="built_in">loc</span>(std::<span class="built_in">sqrt</span>(a[j]))]), <span class="built_in">adj</span>(f2[j] = psum2[x] - psum2[j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = cnt - <span class="number">1</span>; ~i; -- i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>, p = prime[i]; j &lt;= tot &amp;&amp; a[j] &gt;= (LL) p * p; ++ j) &#123;</span><br><span class="line">LL cur = p;</span><br><span class="line"><span class="type">int</span> v, nxt;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> e = <span class="number">1</span>; cur * p &lt;= a[j]; ++ e, cur *= p) &#123;</span><br><span class="line"><span class="type">int</span> nxt = a[j] / cur, v;</span><br><span class="line"><span class="keyword">if</span> (nxt &lt; p * p) <span class="built_in">adj</span>(v = psum1[<span class="built_in">getid</span>(nxt)] - sp1[i]);</span><br><span class="line"><span class="keyword">else</span> v = f1[<span class="built_in">getid</span>(nxt)];</span><br><span class="line">f1[j] = (f1[j] + (v + <span class="number">1LL</span>) * p) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((nxt = a[j] / p) &lt; p * p) <span class="built_in">adj</span>(v = sp2[i] - psum2[<span class="built_in">getid</span>(nxt)]);</span><br><span class="line"><span class="keyword">else</span> v = f2[<span class="built_in">getid</span>(nxt)];</span><br><span class="line"><span class="built_in">adj</span>(f1[j] += p - Mod);</span><br><span class="line">f2[j] = (f2[j] + (Mod - p * p) * (v + <span class="number">1LL</span>)) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot; ++ j) f1[j] ++, f2[j] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getF1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> H[d];</span><br><span class="line"><span class="keyword">if</span> (d == <span class="number">1</span>) <span class="keyword">return</span> f1[<span class="built_in">getid</span>(n)];</span><br><span class="line"><span class="keyword">if</span> (mf1[d].<span class="built_in">count</span>(n)) <span class="keyword">return</span> mf1[d][n];</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> T : fac[d])</span><br><span class="line">res = (res + (LL) H1[T] * <span class="built_in">getF1</span>(n / T, T)) % Mod;</span><br><span class="line"><span class="keyword">return</span> mf1[d][n] = (LL) res * H[d] % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getF2</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (d == <span class="number">1</span>) <span class="keyword">return</span> f2[<span class="built_in">getid</span>(n)];</span><br><span class="line"><span class="keyword">if</span> (!mu[d]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (mf2[d].<span class="built_in">count</span>(n)) <span class="keyword">return</span> mf2[d][n];</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k : fac[d])</span><br><span class="line"><span class="keyword">if</span> (mu[k] &gt; <span class="number">0</span>) <span class="built_in">adj</span>(res += <span class="built_in">getF2</span>(n / k, k) - Mod);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mu[k]) <span class="built_in">adj</span>(res -= <span class="built_in">getF2</span>(n / k, k));</span><br><span class="line">res = (LL) res * H[d] % Mod * H[d] % Mod;</span><br><span class="line"><span class="keyword">if</span> (mu[d] &lt; <span class="number">0</span>) <span class="built_in">adj</span>(res = -res);</span><br><span class="line"><span class="keyword">return</span> mf2[d][n] = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">Min25_init</span>();</span><br><span class="line">B = n / (<span class="type">int</span>) (std::<span class="built_in">pow</span>(n, <span class="number">1.</span> / <span class="number">3</span>) + <span class="number">1</span>), B = std::<span class="built_in">max</span>(B, <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, v; i &lt;= B; ++ i)</span><br><span class="line"><span class="keyword">if</span> (mu[i] &gt; <span class="number">0</span>) v = <span class="built_in">getF1</span>(n / i, i), res = (res + (LL) v * v) % Mod;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mu[i]) v = <span class="built_in">getF1</span>(n / i, i), res = (res + (LL) (Mod - v) * v) % Mod;</span><br><span class="line"><span class="type">int</span> lim = n / B;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> T1 = <span class="number">1</span>; T1 &lt;= lim; ++ T1)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> T2 = <span class="number">1</span>; T2 &lt;= lim; ++ T2) &#123;</span><br><span class="line">LL Lcm = (LL) T1 / <span class="built_in">Gcd</span>(T1, T2) * T2, mul = (LL) H1[T1] * H1[T2] % Mod, tmp;</span><br><span class="line"><span class="keyword">if</span> (!mu[Lcm]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = T1, ed = lim; i &lt;= ed; i += T1)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = T2; j &lt;= ed; j += T2)</span><br><span class="line">&#123;</span><br><span class="line">tmp = mul * H[i] % Mod * H[j] % Mod;</span><br><span class="line">res = (res + tmp * <span class="built_in">getF2</span>(n / std::<span class="built_in">max</span>(i, j) / Lcm, Lcm)) % Mod;</span><br><span class="line"><span class="keyword">if</span> (B &gt;= Lcm)</span><br><span class="line">res = (res + tmp * (Mod - <span class="built_in">getF2</span>(B / Lcm, Lcm))) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：求&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\sum_{i = 1} ^ n \sum_{j = 1} ^ n H(ij) [\gcd(i, j) = 1]&lt;br&gt;$$&lt;br&gt;其中 $H(x)$ 表示 $x$ 所有质因子的乘积（去重后）。$n\leq 10 ^ 9$，$T(T\leq 5)$ 组数据，满足 $\sum n\leq 2\times 10 ^ 9$。20s。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="平衡规划" scheme="https://mydcwfy.github.io/tags/%E5%B9%B3%E8%A1%A1%E8%A7%84%E5%88%92/"/>
    
    <category term="复杂度分析" scheme="https://mydcwfy.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
    <category term="Min_25 筛" scheme="https://mydcwfy.github.io/tags/Min-25-%E7%AD%9B/"/>
    
  </entry>
  
  <entry>
    <title>ARC Round#123</title>
    <link href="https://mydcwfy.github.io/2022/09/23/ARC-Round-123/"/>
    <id>https://mydcwfy.github.io/2022/09/23/ARC-Round-123/</id>
    <published>2022-09-23T13:57:11.000Z</published>
    <updated>2022-09-25T12:06:27.025Z</updated>
    
    <content type="html"><![CDATA[<p>已改 ABCD，E 太难写了 /tuu</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定 $a, b, c$ 三个数，操作一次可以对一个数 +1，问多少次操作后能变为一个等差数列。</p><p>考虑如果 $2b &gt; a + c$，显然只能提升 $c$ 来达成，否则提升 $b$ 是更优秀的选择。处理一下边界即可。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定 $a, b, c$ 三个长度为 $n$ 序列，要求任意序列内重排吗，使得满足 $a_i &lt; b_i &lt; c_i$ 的 $i$ 尽量多。求最大值。$n\leq 10 ^ 5$。</p><p>贪心即可，取最小的 $b_i &gt; a_i$，然后又取最小的 $c_i &gt; b_i$，没有就直接退出。</p><p>时间复杂度 $O(n\log n)$。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定一个数，他是好的当且仅当十进制下所有数都是 1、2、3 中的一个。给定 $n$，问 $n$ 最少可以由多少个好的数加起来构成。$T(T\leq 1000)$ 组数据，$n\leq 10 ^ {18}$。</p><p>场上 yy 的，好像和题解做法不太像。</p><p>假设我们先不考虑进位问题，那么对于每一位来说，都有一个取数个数的范围，也就是 $[\lceil\dfrac x3\rceil, x]$。如果这些区间交不为空，那么就取其中的最小值。容易发现不进位合法时一定是最小的情况。</p><p>下面考虑一下进位的问题。注意到我们一旦要从上一位偷一个 1 过来，到这里变成了 10，这样的话，这个取数个数的范围至少都是 4 了，这样就可以和前面的有交了。</p><p>直接暴力递归计算即可，时间复杂度应该是 $O(\log ^ 2 n)$ 的，反正很快就是了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">10</span>) <span class="keyword">return</span> (n + <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line">LL pre = <span class="built_in">solve</span>(n / <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (pre &gt; n % <span class="number">10</span>) <span class="keyword">return</span> std::<span class="built_in">max</span>(<span class="built_in">solve</span>(n / <span class="number">10</span> - <span class="number">1</span>), (n % <span class="number">10</span> + <span class="number">12</span>) / <span class="number">3</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> std::<span class="built_in">max</span>(pre, (n % <span class="number">10</span> + <span class="number">2</span>) / <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：将一个序列 $a$ 拆成两个序列 $b, c$ 的和，$b$ 不减，$c$ 不增，问这 $2n$ 个数绝对值的最小值。$n\leq 2\times 10 ^ 5$。</p><p>首先我们考虑假设已经知道了 $b_1, c_1$，如何按序构造出后面的项。</p><blockquote><p>如果 $a_i \geq a_{i - 1}$，则 $c_i$ 不变，$b_i$ 增加，否则 $b_i$ 不变，$c_i$ 减少。</p></blockquote><p>容易发现这样构造一定是最优的，因为如果 $a_i\geq a_{i - 1}$，让 $b_i$ 增加，$c_i$ 减少，这样肯定不会使绝对值变小，所以不优。</p><p>那么我们现在发现 $b_1, c_1$ 确定的时候我们可以找到一个合法的解。如果我们把 $b_1$ 看作变量并把 $b_1 = 0$ 带入计算得到 $b, c$，那么这就是一个 $2n$ 个绝对值相加的函数，具体的，就是 $\sum_{i = 1} ^ n |x + b_i| + |-x + c_i|$。</p><p>赛时 sb 了，我用一个 <code>std::map</code> 维护斜率和截距的实时变化。其实直接找到中位数做一做就好了。这就放一个赛时代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LL = <span class="type">__int128_t</span>;</span><br><span class="line"></span><br><span class="line">std::map&lt;LL, LL&gt; kmp, bmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">c[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt; a[i - <span class="number">1</span>]) b[i] = b[i - <span class="number">1</span>], c[i] = a[i] - b[i];</span><br><span class="line"><span class="keyword">else</span> c[i] = c[i - <span class="number">1</span>], b[i] = a[i] - c[i];</span><br><span class="line">LL del = <span class="number">1e25</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">kmp[-INF] -= <span class="number">1</span>, kmp[-b[i]] += <span class="number">2</span>, bmp[-INF] -= b[i], bmp[-b[i]] += <span class="number">2</span> * b[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">kmp[-INF] -= <span class="number">1</span>, kmp[c[i]] += <span class="number">2</span>, bmp[-INF] += c[i], bmp[c[i]] -= <span class="number">2</span> * c[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = std::<span class="built_in">next</span>(kmp.<span class="built_in">begin</span>()); iter != kmp.<span class="built_in">end</span>(); iter ++) &#123;</span><br><span class="line">iter-&gt;second += std::<span class="built_in">prev</span>(iter)-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = std::<span class="built_in">next</span>(bmp.<span class="built_in">begin</span>()); iter != bmp.<span class="built_in">end</span>(); iter ++) &#123;</span><br><span class="line">iter-&gt;second += std::<span class="built_in">prev</span>(iter)-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [x, k] : kmp) <span class="built_in">chkmin</span>(del, k * x + bmp[x]);</span><br><span class="line">std::cout &lt;&lt; del &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;已改 ABCD，E 太难写了 /tuu&lt;/p&gt;</summary>
    
    
    
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>ARC Round#127</title>
    <link href="https://mydcwfy.github.io/2022/09/23/ARC-Round-127/"/>
    <id>https://mydcwfy.github.io/2022/09/23/ARC-Round-127/</id>
    <published>2022-09-23T02:49:17.000Z</published>
    <updated>2022-09-23T13:47:22.165Z</updated>
    
    <content type="html"><![CDATA[<p>已改 ABCDE。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：记 $f(x)$ 表示 $x$ 十进制下前缀 1 的个数，给定 $n$，求 $\sum_{i = 1} ^ n f(i)$。$n\leq 10 ^ {15}$。</p><p>大概是数位 DP 模板题罢（</p><p>首先加上位数小于 $n$ 的位数的所有答案，容易发现可以预处理。</p><p>然后对于每一位考虑计算，假设前面 $n$ 的高位都是 1，如果当位为 0，那么这一位及更低的位都不可能出现前缀 1 了。</p><p>如果当位比 1 大的话，容易发现此时此位和低位的和已经可以计算了，而且和 $n$ 无关。具体的，其实就是所有 $t$ 位的答案。</p><p>时间复杂度 $O(\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> bit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">qpow</span>(<span class="number">10</span>, bit) &lt;= n) bit ++;</span><br><span class="line">LL cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bit; ++ i) cur += <span class="built_in">qpow</span>(<span class="number">10</span>, i);</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bit - <span class="number">1</span>; ++ i) res += a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, flag = <span class="literal">true</span>; i &lt;= bit; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="built_in">qpow</span>(<span class="number">10</span>, bit - i)) <span class="keyword">break</span>;</span><br><span class="line">flag &amp;= n &lt; <span class="number">2</span> * <span class="built_in">qpow</span>(<span class="number">10</span>, bit - i);</span><br><span class="line">n %= <span class="built_in">qpow</span>(<span class="number">10</span>, bit - i);</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="keyword">return</span> res + a[bit - i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (flag) res += (n + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定 $n, l$，需要构造 $3n$ 个长度为 $l$ 的字符串，满足 $\forall i\in [1, l]$，$3n$ 个字符串中 $s_i$ 是 <code>0, 1, 2</code> 的各占 $n$ 个，并且不存在两个字符串相同。另外需要保证字典序最大的字符串字典序最小。$l\leq 15, 3n\leq 3 ^ l$。</p><p>容易发现我们只需要构造开头为 2 的 $n$ 个长度为 $l$ 的字符串，按序推一下就可以相应的得到开头为 0 和 1 的字符串了。</p><p>那么现在问题就是我们需要 $n$ 个字符串使得字典序最大的最小，且不存在两两相同。直接 3 进制拆分即可，当然直接模拟也可以。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：有 $1\sim 2 ^ n - 1$ 的数二进制转换后按照字典序排列，问第 $x$ 个是哪个数。$x$ 和输出的数都使用二进制。$n\leq 10 ^ 6$。</p><p>首先考虑 $n = 3$ 的序列：<code>1, 10, 100, 101, 11, 110, 111</code>，一共有 7 个。注意到第二位的分布：第一个没有后面的位数，$2\sim 2 ^ {n - 1}$ 第二位是 0，$2 ^ {n - 1} - 1\sim 2 ^ n - 1$ 的第二位是 1。</p><p>注意到我们确定了第二位后，我们可以递归下去处理后面的位数。递归的方式如下：</p><ol><li>没有后面的位数，直接退出。</li><li>第二位是 0，对 $x$ 减 1，然后递归。</li><li>第二位是 1，对 $x$ 减 $2 ^ {n - 1}$，然后递归。</li></ol><p>注意到 $x$ 是二进制给出的，也就是说减 $2 ^ {n - 1}$ 是好做的，直接删除首位。但是减 1 没有好办法，但是我们发现暴力的复杂度是正确的，因为每在 $t$ 位（从低到高从 0 编号）退 1 的话，过 $O(2 ^ t)$ 次之后才可能再次贡献。也就是减 $n$ 次的复杂度是 $O(n)$ 的。</p><p>最后考虑如何判断第二位是什么。容易发现减完 1 / $2 ^ {n - 1}$ 之后为 0 了，直接退出就可以处理上述的第一种情况。另外，如果 $x = 2 ^ {n - 1}$，也可以直接退出。判断为 0 的方法就是维护最后一个非 0 位即可。</p><p>时间复杂度 $O(n)$。细节 yy 一下就差不多了（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">std::string s, res = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">s = std::<span class="built_in">string</span>(n - s.<span class="built_in">size</span>(), <span class="string">&#x27;0&#x27;</span>) + s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">while</span> (j &gt;= i &amp;&amp; s[j] == <span class="string">&#x27;0&#x27;</span>) -- j;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; j == i) &#123;</span><br><span class="line">res += <span class="string">&#x27;0&#x27;</span>, res += std::<span class="built_in">string</span>(n - i - <span class="number">2</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">res += <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">s[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span> ((++ j) &lt; n) s[j] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">j = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (j &gt;= i &amp;&amp; s[j] == <span class="string">&#x27;0&#x27;</span>) -- j;</span><br><span class="line"><span class="keyword">if</span> (j == i - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">res += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定两个长度为 $n$ 的数组 $a, b$，求：<br>$$<br>\sum_{i = 1} ^ n \sum_{j = i + 1} ^ n \min(a_i\oplus a_j, b_i\oplus b_j)<br>$$<br>$n\leq 2.5\times 10 ^ 5$，$a_i, b_i &lt; 2 ^ {18}$。</p><p>看题解其实感觉比较板，但是赛时 C 花了太久了，几乎没怎么想就 vp 结束了。</p><p>容易发现我们肯定是需要知道什么时候 $a_i\oplus a_j$ 小，什么时候 $b_i\oplus b_j$ 小。如果找到他们最高的不同位就好做了，我们判断一下就好了。又发现 $a_i\oplus a_j$ 和 $b_i \oplus b_j$ 最高的不同位就是 $a_i\oplus b_i\oplus a_j\oplus b_j$ 的最高位。</p><p>现在我们就可以把 $i, j$ 分离，令 $c_i = a_i\oplus b_i$，我们就是找 $c_i\oplus c_j$ 的最高不同位。现在我们比较 $c_i, c_j$ 的最高位是 0 还是 1，都是 0 的我们考虑递归，都是 1 的同理。也就是说只需要处理 $c_i, c_j$ 最高位不同的情况，也就是现在我们已经能区分 $a_i\oplus a_j$，$b_i\oplus b_j$ 的大小关系了。</p><p>我们考虑把数按照 $c_i$ 的最高位和 $a_i$ 的最高位分成 4 类。这样很容易区分出哪些是 $a_i\oplus a_j$ 更小，哪些是 $b_i\oplus b_j$ 更小。</p><p>现在我们已经去除了 $\min$，只需要考虑给定一个数组，就两两异或和。拆位贡献可做到 $O(n\log a)$。</p><p>最后分析复杂度，考虑每一个 $(a_i, b_i)$ 的 <code>std::pair</code>，会被使用 $O(\log a)$ 次，每次使用都是 $O(\log a)$ 的复杂度，时间复杂度 $O(n\log ^ 2 a)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; v1, std::vector&lt;<span class="type">int</span>&gt; v2, <span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v1.<span class="built_in">empty</span>() || v2.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cnt1[<span class="number">18</span>], cnt2[<span class="number">18</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">18</span>; ++ i) cnt1[i] = cnt2[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : v1)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> bit = <span class="number">0</span>; bit &lt; <span class="number">18</span>; ++ bit)</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;&gt; bit &amp; <span class="number">1</span>) cnt1[bit] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : v2)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> bit = <span class="number">0</span>; bit &lt; <span class="number">18</span>; ++ bit)</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;&gt; bit &amp; <span class="number">1</span>) cnt2[bit] ++;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = v1.<span class="built_in">size</span>(), m = v2.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> bit = <span class="number">0</span>; bit &lt; <span class="number">18</span>; ++ bit)</span><br><span class="line">res += ((LL) cnt1[bit] * (m - cnt2[bit]) + (LL) cnt2[bit] * (n - cnt1[bit])) &lt;&lt; bit;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; v, <span class="type">int</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (bit &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">calc</span>(v, v, a) / <span class="number">2</span>;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; to[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : v)</span><br><span class="line">to[c[i] &gt;&gt; bit &amp; <span class="number">1</span>][a[i] &gt;&gt; bit &amp; <span class="number">1</span>].<span class="built_in">push_back</span>(i);</span><br><span class="line">LL res = <span class="built_in">calc</span>(to[<span class="number">0</span>][<span class="number">0</span>], to[<span class="number">1</span>][<span class="number">0</span>], a) + <span class="built_in">calc</span>(to[<span class="number">0</span>][<span class="number">1</span>], to[<span class="number">1</span>][<span class="number">1</span>], a)</span><br><span class="line">+ <span class="built_in">calc</span>(to[<span class="number">0</span>][<span class="number">0</span>], to[<span class="number">1</span>][<span class="number">1</span>], b) + <span class="built_in">calc</span>(to[<span class="number">0</span>][<span class="number">1</span>], to[<span class="number">1</span>][<span class="number">0</span>], b);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : to[<span class="number">0</span>][<span class="number">1</span>]) to[<span class="number">0</span>][<span class="number">0</span>].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : to[<span class="number">1</span>][<span class="number">1</span>]) to[<span class="number">1</span>][<span class="number">0</span>].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">return</span> res + <span class="built_in">solve</span>(to[<span class="number">0</span>][<span class="number">0</span>], bit - <span class="number">1</span>) + <span class="built_in">solve</span>(to[<span class="number">1</span>][<span class="number">0</span>], bit - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>给定一个 $A + B$ 的序列，有 $A$ 个 1 和 $B$ 个 2，初始有一个空的集合 $s$。你需要对 $A$ 个 $1$ 分配一个 $[1, A]$ 的值使得不存在两个位置相等。对于每一个 1，你需要向 $s$ 中插入分配的值；否则你需要删除集合中最大的元素。问最后得到的集合 $s$ 有多少种可能，答案对 998244353 取模。$A\leq 5000$，$ B &lt; A$。</p><p>一个显然的想法是对每一个集合 $s$，判断其是否合法。</p><blockquote><p>假设能得到的最大的集合为 $t$，则集合合法的充要条件是 $s\leq t$（严格小于等于）。</p><p>证明：首先证明其必要性。容易发现如果不满足的话肯定是无法构造的，因为我们已经构造了最大的集合了。</p><p>然后证明其充分性。没看懂题解，但似乎是可以感性理解的（？</p></blockquote><p>有了上面的结论，我们先要找到最大的集合。容易发现我们肯定把更小的放前面，这样被删除的也偏小，留下的就自然更大了，于是就是在第 $i$ 个 1 的位置放 $i$ 即可得到最大的集合。</p><p>得到最大的集合过后，我们相当于是求合法的序列，有两个限制：$x_i &lt; x_{i + 1}$，$x_i\leq a_i$。这个显然是可以 $O(na)$ DP 完成的。</p><p>时间复杂度 $O(A ^ 2)$，代码不放了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;已改 ABCDE。&lt;/p&gt;</summary>
    
    
    
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P8541 「Wdoi-2」死亡之后愈发愉悦</title>
    <link href="https://mydcwfy.github.io/2022/09/13/Luogu-P8541/"/>
    <id>https://mydcwfy.github.io/2022/09/13/Luogu-P8541/</id>
    <published>2022-09-13T09:01:35.000Z</published>
    <updated>2022-09-13T09:23:18.827Z</updated>
    
    <content type="html"><![CDATA[<p>题意：交互题。定义 $f(x)$ 为严格大于 $x$ 的最小完全平方数，$g(x)$ 为小于等于 $x$ 的最大完全平方数。你需要猜一个 $\in[1, 10 ^ {12}]$ 中的一个数 $a$，用少于 64 次的询问得到答案，单次你给出 $t(t\in [0, 10 ^ 9])$，会返回 $a + t$ 是否满足 $x - g(x) &lt; f(x) - x$。$T(T\leq 2\times 10 ^ 3)$ 组数据，2s。</p><span id="more"></span><p>首先发现 $[i ^ 2, (i + 1) ^ 2)$ 中恰好有 $i + 1$ 个满足条件的数，$i$ 个不满足条件的数，分界线为 $i(i + 1)$（该数满足）。</p><p>然后考虑找到第一个不和 $a$ 性质相同的位置。如何找到呢？注意到我们其实并不知道上界，但是我们有一个关键的性质：如果 $a$ 和 $a + t$ 在同一段，那么 $a + 2t$ 和 $a$ 中间最多只有一个分界线。具体证明可以考虑段长不降的性质。于是我们可以靠这个进行倍增，找到最小的 $b$ 使得 $a + 2 ^ b$ 和 $a + 2 ^ {b + 1}$ 性质不同。这中间显然只有一个分界线，于是我们直接在这个区间进行二分即可。</p><p>如果我们找到这个分界线的位置，显然就可以求出 $a$ 了。根据上面的结论，我们可以类似地找到下一个分界线的位置即可，这样就可以询问 $4\log \sqrt a$ 次得到答案，需要 $\approx 80$ 次，还差一点。</p><p>注意到我们已经得到了最小的 $b$，也就是说这一段的长度肯定 $&gt; 2 ^ b$，我们没必要又从 1 开始倍增，直接从 $2 ^ b$ 即可。当然也可以使用上一段的长度倍增来寻找这一段的长度，参考代码是这种写法。容易发现这两个都只需要询问 $3\log \sqrt a$ 次，恰好通过。</p><p>实现的时候比较繁琐，可以用 <code>5, 7, 16, 30</code> 等几个数据调试，似乎能卡掉大部分 corner case。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mp.<span class="built_in">count</span>(x)) <span class="keyword">return</span> mp[x];</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; x &lt;&lt; std::endl, std::cin &gt;&gt; t;</span><br><span class="line"><span class="built_in">assert</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= (<span class="type">int</span>) <span class="number">1e9</span>);</span><br><span class="line"><span class="keyword">if</span> (!~t) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> mp[x] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mp.<span class="built_in">clear</span>();</span><br><span class="line"><span class="type">bool</span> st = <span class="built_in">query</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> mid, l, r, j1, j2, bit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">query</span>(<span class="number">1</span>) ^ st) j1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">query</span>(<span class="number">1</span> &lt;&lt; bit) == st) bit ++;</span><br><span class="line">l = <span class="number">1</span> &lt;&lt; (bit - <span class="number">1</span>), r = (<span class="number">1</span> &lt;&lt; bit) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">query</span>(mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ^ st) r = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid;</span><br><span class="line">&#125;</span><br><span class="line">j1 = l;</span><br><span class="line">&#125;</span><br><span class="line">j1 ++;</span><br><span class="line">bit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">query</span>((j1 &lt;&lt; bit) + j1) ^ st) bit ++;</span><br><span class="line">l = (bit == <span class="number">0</span> ? <span class="number">0</span> : (j1 &lt;&lt; (bit - <span class="number">1</span>))) + j1, r = (j1 &lt;&lt; bit) + j1 - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">query</span>(mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ^ st) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">j2 = l - j1 + <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;! &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (!st) -- j2, std::cout &lt;&lt; (LL) j2 * j2 - j1 &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">else</span> std::cout &lt;&lt; j2 * (j2 + <span class="number">1LL</span>) - j1 + <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：交互题。定义 $f(x)$ 为严格大于 $x$ 的最小完全平方数，$g(x)$ 为小于等于 $x$ 的最大完全平方数。你需要猜一个 $\in[1, 10 ^ {12}]$ 中的一个数 $a$，用少于 64 次的询问得到答案，单次你给出 $t(t\in [0, 10 ^ 9])$，会返回 $a + t$ 是否满足 $x - g(x) &amp;lt; f(x) - x$。$T(T\leq 2\times 10 ^ 3)$ 组数据，2s。&lt;/p&gt;</summary>
    
    
    
    
    <category term="倍增" scheme="https://mydcwfy.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
    <category term="二分" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>ARC148E ≥K</title>
    <link href="https://mydcwfy.github.io/2022/09/13/ARC148E/"/>
    <id>https://mydcwfy.github.io/2022/09/13/ARC148E/</id>
    <published>2022-09-13T08:09:57.000Z</published>
    <updated>2022-09-13T08:58:52.753Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一个长度为 $n$ 的序列，问有多少个重排序列的方案使得相邻两个数的和都 $\geq k$。$n\leq 2\times 10 ^ 5$，$a_i, k\leq 10 ^ 9$。</p><span id="more"></span><p>神仙构造 + 组合数学，只能复述题解了。</p><p>首先考虑如何生成这样的一个合法序列。考虑对序列排序，给定两个指针 $l, r$，使得 $[l, r]$ 里面的数都没有填入新的序列 $B$，其他的已经填入了。</p><p>我们分两种情况：如果 $A_l + A_r &lt; k$，就将 $A_l$ 插入 $B$，否则 $A_r$ 插入 $B$。两边的指针相应移动。</p><p>首先容易发现的结论是 $A_l &lt; \dfrac k2, A_r\geq \dfrac k2$。</p><p>假设 $A_l + A_r &lt; k$ 即插入 $l$ 的话，我们需要考虑哪些位置可以插入。假设满足 $\max\{B_{i}, B_{i + 1}\} + A_l\geq k$ 的位置有 $s$ 个。</p><blockquote><p>结论 1：满足 $\max\{B_i, B_{i + 1}\} + A_r\geq k$ 的数也恰好有 $s$ 个。</p><p>证明：假设 $A_l = \dfrac k2 - d(d &gt; 0)$，那么 $A_r \geq \dfrac k2 + d$（注意我们现在需要插入 $r$，一定满足 $A_l + A_r\geq k$），如果 $B_i$ 和 $B_{i + 1}$ 中间存在一个数 $&lt; \dfrac k2 - d$，那么不可能满足 $B_i + A_l \geq k$，同时也不满足 $B_i + A_r\geq k$（注意 $B_i$ 不可能等于 $A_l$，因为在插入第一个 $A_l$ 之前一定会先插入 $A_r$）。满足 $B_i + A_l\geq k$ 的一定满足 $B_i + A_r\geq k$，这个显然。</p></blockquote><p>那么我们就证明到了不管是 $A_l$ 还是 $A_r$ 插入，都恰好有 $s$ 个可插入的位置。</p><blockquote><p>结论 2：插入 $A_l$ 后会导致可插入位置 -1，插入 $A_r$ 后会导致可插入位置 +1。</p><p>首先证明除了插入位置外，其他位置的可插入性是不改变的。容易发现 $l$ 增加的话，一定是 $A_l + A_r &lt; k$ 了，那么原来合法的一定还合法，由于不合法的时候一定存在一个 $B_i$ 使得 $B_i \leq A_l$，因为 $A_l + A_r &lt; k$，所以不会再合法了。而如果 $r$ 减少的话，一定是满足 $A_l + A_r\geq k$，原来合法的一定还合法，原来不合法的一定满足 $B_i + A_r &lt; k$，所以也永远不合法。</p><p>现在考虑插入位置附近。容易发现 $A_l$ 插入后两边不能再插入，因为 $A_l + A_r &lt; k$ 了。而 $A_r$ 插入后两边都可以再插入，因为 $A_l + A_r \geq k$。</p></blockquote><p>有了上面的结论，我们很容易写出第一部分代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = n, c = <span class="number">1</span>; i &lt;= j;)</span><br><span class="line"><span class="keyword">if</span> (a[i] + a[j] &lt; lim) res = (LL) res * c -- % Mod, i ++;</span><br><span class="line"><span class="keyword">else</span> res = (LL) res * c ++ % Mod, j --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来考虑和原问题的对应关系。</p><p>注意到我们现在相当于求的是整个 $B$ 的生成过程有多少种。我们暂且把它称为三角阵。现在我们需要知道的就是一个三角阵会对应多少个 $B$。</p><p>我们考虑从一个合法的序列 $B$ 删除来得到三角阵。容易发现我们只需要找到距离 $\dfrac k2$ 最近的值删除一个即可（如果存在两个值距离相同，显然选大的）。注意到这和三角阵的生成过程恰好是逆序的。</p><p>注意到一个合法的 $B$ 每次删除值的时候值都是一定的，主要在于删除哪一个值。显然单次会删除 $cnt$ 个中的一个，然后 <code>cnt --</code>。</p><p>那么我们就是需要将刚刚得到的答案除以所有数字出现次数的逆元即可。时间复杂度 $O(n\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; lim;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = n, c = <span class="number">1</span>; i &lt;= j;)</span><br><span class="line"><span class="keyword">if</span> (a[i] + a[j] &lt; lim) res = (LL) res * c -- % Mod, i ++;</span><br><span class="line"><span class="keyword">else</span> res = (LL) res * c ++ % Mod, j --;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, ls = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (a[i] != a[i - <span class="number">1</span>]) res = (LL) res * infact[i - ls] % Mod, ls = i;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一个长度为 $n$ 的序列，问有多少个重排序列的方案使得相邻两个数的和都 $\geq k$。$n\leq 2\times 10 ^ 5$，$a_i, k\leq 10 ^ 9$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="结论" scheme="https://mydcwfy.github.io/tags/%E7%BB%93%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>ARC Round#148</title>
    <link href="https://mydcwfy.github.io/2022/09/13/ARC-Round-148/"/>
    <id>https://mydcwfy.github.io/2022/09/13/ARC-Round-148/</id>
    <published>2022-09-13T06:11:26.000Z</published>
    <updated>2022-09-13T08:09:26.920Z</updated>
    
    <content type="html"><![CDATA[<p>靠着 D 猜到结论好不容易上分了，第三次上黄（</p><p>赛后改题：All Accepted。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定 $n$ 个数，要你选择一个模数 $M$，问每个数 $\bmod M$ 过后不同的数最少都多少个，$M$ 不能选择 1。</p><p>容易发现当 $M = 2$ 的时候答案不超过 2。这是一个关键入口。</p><p>判断答案能不能为 1 是好判断的，差分数组的 $\gcd$ 不为 1 的话就存在。</p><p>否则答案一定为 2。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定一个长度为 $n$ 的只包含 <code>dp</code> 的字符串，你可以选择一个区间 $[l, r]$ 将该子串翻转。翻转的定义是 <code>d</code> 变 <code>p</code>，<code>p</code> 变 <code>d</code>，然后 <code>std::reverse</code>。问翻转后字典序最小是哪个串。$n\leq 5000$。</p><p>容易发现我们的翻转起始点就是第一个 <code>p</code> 的位置，我们将他变为 <code>d</code>，这样肯定比不变化该位置更优。另外我们把起始点设在该 <code>p</code> 前面的话，那么翻转区间的最后一定是一堆 <code>p</code>，否则不优。如果是一堆 <code>p</code> 的话，两端相当于没有交换，其实还是从 <code>p</code> 开始的。</p><p>这样可能的串就只有 $O(n)$ 个了，找到最小的即可，时间复杂度 $O(n ^ 2)$。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定一棵 $n$ 个点的无边权有根树，根为 1，每个点有一个正反面的硬币，翻转一个硬币会导致子树内的硬币都会翻转，代价为 1。$q$ 次询问，每次给定一个大小为 $m$ 的点集，求将集合内的硬币都翻转而不改变其他点状态的最小代价。$n, q, \sum m\leq 2\times 10 ^ 5$。</p><p>据说数据很水，最坏 $O(nq)$ 的直接过了（</p><p>容易发现一个点最多只会产生 1 的代价（注意这个点可能不在给定点集里）。</p><p>假设先不考虑上面的结论，我们直接翻转，假设集合只有 1 个点的话，我们需要对他本身和他的所有儿子都翻转一次，答案为 $1 + son(x)$。而多个点相较于 1 个点的差别在于如果一个集合内的点的父亲也在集合内的话，那么这个点原来应该翻转 2 次，现在不再需要翻转了，就可以减 2。</p><p>于是题目转化成了一个给定点集求父子关系对数。枚举儿子查父亲即可。时间复杂度 $O(n + \sum m)$ 或 $O(n + \sum m\log m)$。</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定 $2n$ 个数，Alice 和 Bob 分别任取其中的一个数，如果最后 Alice 取的数的和和 Bob 的和在 $\bmod m$ 意义下相同的话，Bob 胜，否则 Alice 胜。问最优情况下谁会胜利。$n\leq 2\times 10 ^ 5$。</p><p>先不考虑模意义，如果是和相同怎么做。容易发现每个数出现的次数必须是偶数，这样 Bob 才能获胜，否则 Alice 获胜。考虑证明，由于 Alice 取的时候，至少有两个数没有配对，Alice 取走一个过后，剩下的就和 Bob 取配对游戏，最后 Bob 一定会取到另外一个没有配对的数。这样两人的和并不同，Alice 胜。</p><p>现在我们需要考虑增加了模意义有什么变化。如果每个数出现次数是偶数的话，仍然还是 Bob 胜，但剩下的情况不太对劲。我们先给出一个 Hack：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 6</span><br><span class="line">1 4 2 5</span><br></pre></td></tr></table></figure><p>手玩一下，容易发现这个时候一定会是 Bob 胜利。</p><p>为什么呢？因为在 $\bmod m$ 意义下，$m$ 如果是偶数的话，并且 $\geq \dfrac m2$ 的数是偶数个的话，两个人最后拿到 $\geq \dfrac m2$ 的个数的奇偶性一定是相同的，而这就代表着只考虑 $\dfrac M2$ 的话两个人 $\bmod m$ 是相同的。这样我们就不能 $\bmod m$ 意义下了，而应该在$\bmod \dfrac m2$ 意义下做上面的结论了。</p><p>剩下的没有其他的情况需要特判了，简单的证一下。</p><ol><li>$m$ 是奇数：容易发现这时 Alice 最后一次选择的时候一定剩 2 个不同的数，选择一个数后会产生一个差值 $d$，而反过来选择差值就是 $m - d$。$d$ 和 $m - d$ 不相同，那么不可能两个数都是满足加上后变成 0 的，于是此时 Alice 胜。</li><li>$\geq \dfrac m2$ 有奇数个：让所有 $\geq \dfrac m2$ 的数都减去 $\dfrac m2$，我们只需要让 Alice 和 Bob 在 $\bmod m$ 意义下差值 $&lt; \dfrac m2$ 即可。这显然是容易办到的，而两个人选择的 $\geq \dfrac m2$ 的数的奇偶性不同，所以 Alice 一定胜利。</li></ol><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>咕咕咕。</p><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：提交答案题。给定一个计算器，有 26 个 <code>unsigned long long</code> 的存储功能，标号为 <code>A</code> 到  <code>Z</code>。满足的功能有 $a + b\to c$，$a\times b\to c$，$a\bmod 998244353\to c$。注意这里面的 $a, b$ 可以为给定常数。现在有两个数分别存储在 <code>A</code> 和 <code>B</code>，要求给定命令使得最后 <code>C</code> 存储的是 $a\times b\bmod 10 ^ 9 + 7$。</p><p>复述题解。</p><p>这个是完全不懂了，先给出一个 AT 的官方链接 <a href="https://en.wikipedia.org/wiki/Montgomery_modular_multiplication">Montgomery multiplication (Wikipedia)</a>。</p><p>令 $P_1 = 998244353, P_2 = 10 ^ 9 + 7$。</p><p>直接使用这个算法，我们相当于是可以在 $\bmod 2 ^ {64}$ 和 $\bmod P_1$ 下做乘法运算，现在需要求 $\bmod P_2$ 下的乘法。</p><p>直接给出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ULL = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P1 = <span class="number">998244353</span>, P2 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> _MP = P1 - <span class="built_in">qpow</span>(P2, P1 - <span class="number">2</span>, P1), M2 = (ULL) P1 * P1 % P2;</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">reduce</span><span class="params">(ULL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ULL ret = (x + (x % P1 * _MP % P1) * N) / P1;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= P2) x -= P2;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">mul</span><span class="params">(ULL a, ULL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = <span class="built_in">reduce</span>(a * M2), b = <span class="built_in">reduce</span>(b * M2);</span><br><span class="line">ULL c = a * b;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reduce</span>(<span class="built_in">reduce</span>(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_MP</code> 记为 $P_m$，满足 $P_mP_2\equiv -1\pmod {P_1}$，<code>M2</code> 满足 $M_2 = P_1 ^ 2\bmod P_2$。</p><p>原理不清楚，目前所知就是 <code>reduce(x)</code> 会返回 $xP_1 ^ {-1}\bmod P_2$，反正是这样了呢。现在考虑如何使用这段代码。</p><p>难点主要有两个：一是如何实现 $x / P_1$，二是如何实现 <code>if</code> 语句。</p><h4 id="实现-x-P-1"><a href="#实现-x-P-1" class="headerlink" title="实现 $x / P_1$"></a>实现 $x / P_1$</h4><p>假设我们把 <code>x + (x % P1 * _MP % P1) * P2</code> 在 $\bmod P_1$ 意义下，我们容易发现这个 $\bmod P_1$ 余 0 的。那么相当于就是直接除，而直接除可以使用乘 $P_1$ 在 $2 ^ {64}$ 的逆元完成。</p><h4 id="实现-if-语句"><a href="#实现-if-语句" class="headerlink" title="实现 if 语句"></a>实现 <code>if</code> 语句</h4><p>这个是难实现的，但是我们发现（？）执行该语句的次数很少，而且肯定不超过 $2N$。这样的话可以证明不超过 2 次执行 <code>reduce</code> 就可以代替该 <code>if</code> 语句了。</p><p>于是整个的就可以写作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">reduce</span>(a * M2), b = <span class="built_in">reduce</span>(b * M2);</span><br><span class="line">c = <span class="built_in">reduce</span>(<span class="built_in">reduce</span>(c));</span><br><span class="line">c *= M2, c = <span class="built_in">reduce</span>(<span class="built_in">reduce</span>(c));</span><br></pre></td></tr></table></figure><p>改成给的语言即可。代码附调试功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ULL = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> s128 = <span class="type">__int128_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Mod1 = <span class="number">998244353</span>, Mod2 = <span class="number">1e9</span> + <span class="number">7</span>, _MP = <span class="number">4915446</span>, M2 = <span class="number">320946142</span>;</span><br><span class="line"><span class="type">const</span> ULL Mul = <span class="number">996491785301655553ULL</span>;</span><br><span class="line">ULL a[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExGcd</span><span class="params">(s128 a, s128 b, s128 &amp;x, s128 &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, <span class="built_in">void</span>();</span><br><span class="line"><span class="built_in">ExGcd</span>(b, a % b, y, x), y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reduce</span><span class="params">(<span class="type">char</span> t)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*ULL ret = (t + (t % Mod1 * _MP % Mod1) * Mod2) / Mod1;</span></span><br><span class="line"><span class="comment">// if (ret &gt;= Mod2) ret -= Mod2;</span></span><br><span class="line"><span class="comment">t = ret;*/</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;rem Z &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[<span class="number">25</span>] = a[t - <span class="string">&#x27;A&#x27;</span>] % Mod1;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mul Z Z &quot;</span> &lt;&lt; _MP &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[<span class="number">25</span>] = a[<span class="number">25</span>] * _MP % Mod1;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;rem Z Z\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mul Z Z &quot;</span> &lt;&lt; Mod2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[<span class="number">25</span>] = a[<span class="number">25</span>] * Mod2;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;add Z Z &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[<span class="number">25</span>] += a[t - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mul &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot; Z &quot;</span> &lt;&lt; Mul &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[t - <span class="string">&#x27;A&#x27;</span>] = a[<span class="number">25</span>] * Mul;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; a[<span class="number">0</span>] &gt;&gt; a[<span class="number">1</span>];</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;40\nmul A A &quot;</span> &lt;&lt; M2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; <span class="string">&quot;mul B B &quot;</span> &lt;&lt; M2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[<span class="number">0</span>] *= M2, a[<span class="number">1</span>] *= M2;</span><br><span class="line"><span class="built_in">reduce</span>(<span class="string">&#x27;A&#x27;</span>), <span class="built_in">reduce</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mul C A B\n&quot;</span>;</span><br><span class="line">a[<span class="number">2</span>] = a[<span class="number">0</span>] * a[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">reduce</span>(<span class="string">&#x27;C&#x27;</span>), <span class="built_in">reduce</span>(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mul C C &quot;</span> &lt;&lt; M2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[<span class="number">2</span>] *= M2;</span><br><span class="line"><span class="built_in">reduce</span>(<span class="string">&#x27;C&#x27;</span>), <span class="built_in">reduce</span>(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">std::cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;靠着 D 猜到结论好不容易上分了，第三次上黄（&lt;/p&gt;
&lt;p&gt;赛后改题：All Accepted。&lt;/p&gt;</summary>
    
    
    
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>LOJ3276 「JOISC 2020 Day2」遗迹</title>
    <link href="https://mydcwfy.github.io/2022/09/13/LOJ3276/"/>
    <id>https://mydcwfy.github.io/2022/09/13/LOJ3276/</id>
    <published>2022-09-13T03:06:32.000Z</published>
    <updated>2022-09-13T04:29:22.787Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一个长度为 $2n$ 的序列，其中 $[1, n]$ 各出现 2 次，对序列一直操作直到不再变化：从前向后操作每一个数，如果这个数不为 0 并且在其后面存在一个和其相等的数，则将这个数减 1。可以证明最后存在 $n$ 个数不为 0。先给出这 $n$ 个位置，求有多少个序列满足操作后剩这些位置。$n\leq 600$。</p><span id="more"></span><p>这个的性质并不是很优美，我们考虑直接暴力 DP。</p><p>把这个序列 reverse 一下。</p><p>记 $f(i, j)$ 表示处理了前 $i$ 个，且前面 $[1, j]$ 在操作后已经存在的方案数（暗示 $j + 1$ 操作后不会存在）。注意到我们无法对 $[j + 2, n]$ 的出现情况压进状态，所以我们考虑如果出现了 $[j + 2, n]$ 的数，我们先视而不见，后面需要用到的时候再将其加入，因为他还用不到。</p><p>考虑转移，如果这一位最后剩的 0，那么这个数开始必须是 $[1, j]$。考虑计算 $[1, j]$ 中有多少个。注意一个问题是我们现在不好区分这个是第一还是第二，那么我们考虑<strong>对于所有相同的数假设不相同，最后再除以阶乘</strong>。假设前面有 $c$ 个位置最后不剩 0（包含 $i$），那么所有 $2j$ 个数已经被占领了 $i - 1 - c$，剩下的就都可以选择。</p><p>如果最后剩的 1，那么考虑两个情况：</p><ol><li>这个数最后剩的不是 $j + 1$。按照前面的理论，我们先不计算他的贡献。</li><li>最后剩的是 $j + 1$。假设现在变成了 $[1, j + k]$，那么 $[j + 2, j + k]$ 的所有数都需要在前面完成，并且 $i$ 位置最后必须剩 $j + 1$。注意到我们需要从剩下的 $c - j - 1$ 个数中选取 $k - 1$ 个数，并且让他最后覆盖 $[j + 2, j + k]$。容易发现这个式子只与 $k - 1$ 有关，假设为 $add_{k - 1, k - 1}$。剩下的 $i$ 位置，只能填 $[j + 1, k]$ 的数，我们可以从剩下的 $2k - (k - 1) = k + 1$ 个数中选择。于是可以得到转移方程为：</li></ol><p>$$<br>dp_{i - 1, j}\times \binom{c - j - 1}{k - 1} add_{k - 1, k - 1}(k + 1) \to dp_{i, j + k}<br>$$</p><p>最后一个问题就是如何计算 $add_{k, k}$。首先发现这个等价于计算 $k$ 个数，任意满足 $\in [i, k]$ 的数都 $\geq k - i + 1$，也就是满足 $[1, i]$ 的数都 $\leq i$。注意到一个数只能选择两次，考虑直接 DP。$add_{i, j}(j\leq i)$ 表示选择了 $[1, i]$ 的数，并且选了 $j$ 个的序列数。枚举 $i$ 是选择了 0、1、2 个容易得到转移方程：<br>$$<br>add_{i, j} = add_{i - 1, j} + 2j\times add_{i - 1, j - 1} + j(j - 1)\times add_{i - 1, j - 2}<br>$$<br>该部分复杂度 $O(n ^ 2)$。</p><p>主 DP 复杂度 $O(n ^ 3)$，总复杂度即为 $O(n ^ 3)$。注意我们开始把任意两个相同的数当作不同了，于是需要除以 $2 ^ n$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> x, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), key[<span class="number">2</span> * n - x + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">add[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = add[i][<span class="number">0</span>] = <span class="number">1</span>; j &lt;= i; ++ j) &#123;</span><br><span class="line">add[i][j] = (add[i - <span class="number">1</span>][j] + add[i - <span class="number">1</span>][j - <span class="number">1</span>] * <span class="number">2LL</span> * j) % Mod;</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">1</span>) add[i][j] = (add[i][j] + add[i - <span class="number">1</span>][j - <span class="number">2</span>] * (j - <span class="number">1LL</span>) * j) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (key[i]) &#123;</span><br><span class="line">++ cnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; ++ j) <span class="keyword">if</span> (f[i - <span class="number">1</span>][j])</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> nxt = <span class="number">1</span>; nxt + j &lt;= cnt; ++ nxt)</span><br><span class="line">f[i][j + nxt] = (f[i][j + nxt] + (LL) f[i - <span class="number">1</span>][j] * C[cnt - j - <span class="number">1</span>][nxt - <span class="number">1</span>] % Mod</span><br><span class="line">* add[nxt - <span class="number">1</span>][nxt - <span class="number">1</span>] % Mod * (nxt + <span class="number">1</span>)) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; ++ j)</span><br><span class="line"><span class="built_in">adj</span>(f[i][j] += f[i - <span class="number">1</span>][j] - Mod);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= cnt; ++ j)</span><br><span class="line">f[i][j] = (LL) f[i - <span class="number">1</span>][j] * (j - (i - <span class="number">1</span> - cnt)) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; (LL) f[<span class="number">2</span> * n][n] * <span class="built_in">qpow</span>(<span class="number">2</span>, Mod - <span class="number">1</span> - n) % Mod &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一个长度为 $2n$ 的序列，其中 $[1, n]$ 各出现 2 次，对序列一直操作直到不再变化：从前向后操作每一个数，如果这个数不为 0 并且在其后面存在一个和其相等的数，则将这个数减 1。可以证明最后存在 $n$ 个数不为 0。先给出这 $n$ 个位置，求有多少个序列满足操作后剩这些位置。$n\leq 600$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>UOJ710 【北大集训2021】魔塔 OL</title>
    <link href="https://mydcwfy.github.io/2022/08/30/UOJ710/"/>
    <id>https://mydcwfy.github.io/2022/08/30/UOJ710/</id>
    <published>2022-08-30T12:45:09.000Z</published>
    <updated>2022-08-30T13:16:18.568Z</updated>
    
    <content type="html"><![CDATA[<p>按序给出 $m$ 次操作或询问：</p><ol><li>新增元素 $(x, y, z)$，新给一个编号，获得他需要消耗 $a$ 点血量，获得他后可以获得 $b$ 点血量。</li><li>编号为 $k$ 的元素被删除了。保证不会重复利用或重复删除编号。</li><li>给定三元组 $(x, y, z)$，问要获得所有严格小于等于 $(x, y, z)$ 的元素需要开始时有多少血量才不会出现血量 $&lt; 0$ 的情况。</li></ol><p>元素和询问次数都不超过 $50000$，$x, y, z\leq 10000$，$a, b\leq 10 ^ 9$，2s。</p><span id="more"></span><p>首先我们需要考虑的问题是如果已经给出了所有严格小于等于的元素，如何排布使得开始的血量最少。</p><p>直接对这些元素排序，考虑微调来判断谁在前面，因为微调不会影响其他元素。假设当前 $(a_1, b_1)$ 和 $(a_2, b_2)$ 需要比较，那么假设 $a_1$ 在前，最少血量就是 $\max(a_1, a_1 + a_2 - b_1)$，$a_2$ 在前也是一样。比较这两个就可以了。</p><p>注意到这个判断先后顺序的是满足 <code>std::sort</code> 的要求（严格弱序）。我们可以观察到如果 $a_1 &lt; b_1$ 和 $a_2 &lt; b_2$ 不相同的话，是可以严格排序的（显然 $a &lt; b$ 的在前面）。而如果都是 $a &lt; b$ 的话，那么就是比较 $a_1$ 和 $a_2$。如果都是 $a \geq b$ 的话，就是比 $a_1 + a_2 - b_1$ 和 $a_1 + a_2 - b_2$ 也就是 $b_1$ 和 $b_2$。容易发现都是严格弱序的。</p><p>这样我们就解决了第一个问题，如何找到最小的方案。那么现在我们将所有元素按照该排序方式排序，离线询问，现在需要解决的问题就是如何找到所有满足严格小于等于的存在的元素。注意到存在其实也是时间轴上的偏序，于是就是解决偏序问题。</p><p>高维偏序问题，显然的 <code>std::bitset</code> 解法，复杂度 $O(\dfrac {n ^ 2}w)$ 也很对，但是注意到我们还是需要把每个元素取出来然后选择他，这样复杂度可能退化。考虑分块，我们每 $B$ 个一块，然后对一块所有可能的选择情况都预处理出来。然后再对于所有询问，这样就可以直接使用了。</p><p>假设 $n, m$ 同阶，复杂度显然是 $O(\dfrac {n2 ^ B}B + \dfrac{n ^ 2}B)$，取 $B = O(\log n)$ 即可得到复杂度为 $O(\dfrac{n ^ 2}{\log n})$。复杂度虽然比较奇怪，但事实是这算法能过。</p><p><strong>所有偏序需要一个一个加入统计答案的可以使用分块做到 $O(\dfrac{n ^ 2}{\log n})$。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> high(x) (31 - __builtin_clz(x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">LL nd, sum;</span><br><span class="line">Node <span class="keyword">operator</span> +(Node t) <span class="type">const</span> &#123;</span><br><span class="line">LL ret = std::<span class="built_in">max</span>(nd, nd - sum + t.nd);</span><br><span class="line"><span class="keyword">return</span> &#123;ret, ret + t.sum + sum - nd - t.nd&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Monster</span> &#123;</span><br><span class="line"><span class="type">int</span> st, ed, x, y, z;</span><br><span class="line">Node add;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(Monster t) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">min</span>(-add.nd, -add.nd + add.sum - t.add.nd)</span><br><span class="line">&gt; std::<span class="built_in">min</span>(-t.add.nd, -t.add.nd + t.add.sum - add.nd);</span><br><span class="line">&#125;</span><br><span class="line">&#125; mon[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y, z, at;</span><br><span class="line">Node res;</span><br><span class="line">&#125; q[N];</span><br><span class="line"><span class="type">int</span> m, n, Q, havx[S], havy[S], havz[S];</span><br><span class="line">Node ans[<span class="number">1</span> &lt;&lt; B | <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; len); ++ i)</span><br><span class="line">ans[i] = ans[i ^ (<span class="number">1</span> &lt;&lt; <span class="built_in">high</span>(i))] + mon[<span class="built_in">high</span>(i) + l].add;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; ++ i) havx[i] = havy[i] = havz[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l, id; i &lt;= r; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">havx[mon[i].x] |= <span class="number">1</span> &lt;&lt; (id = i - l);</span><br><span class="line">havy[mon[i].y] |= <span class="number">1</span> &lt;&lt; id, havz[mon[i].z] |= <span class="number">1</span> &lt;&lt; id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; S; ++ i)</span><br><span class="line">havx[i] |= havx[i - <span class="number">1</span>], havy[i] |= havy[i - <span class="number">1</span>], havz[i] |= havz[i - <span class="number">1</span>];</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">id1</span><span class="params">(r - l + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++ i) id1[i - l] = i;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">id2</span><span class="params">(id1)</span></span>;</span><br><span class="line">std::<span class="built_in">sort</span>(id1.<span class="built_in">begin</span>(), id1.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> mon[x].st &lt; mon[y].st; &#125;);</span><br><span class="line">std::<span class="built_in">sort</span>(id2.<span class="built_in">begin</span>(), id2.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> mon[x].ed &lt; mon[y].ed; &#125;);</span><br><span class="line"><span class="keyword">auto</span> iter1 = id1.<span class="built_in">begin</span>(), iter2 = id2.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, hav = <span class="number">0</span>; i &lt;= Q; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (iter1 != id1.<span class="built_in">end</span>() &amp;&amp; mon[*iter1].st &lt;= q[i].at) hav ^= <span class="number">1</span> &lt;&lt; (*(iter1 ++) - l);</span><br><span class="line"><span class="keyword">while</span> (iter2 != id2.<span class="built_in">end</span>() &amp;&amp; mon[*iter2].ed &lt;= q[i].at) hav ^= <span class="number">1</span> &lt;&lt; (*(iter2 ++) - l);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; (hav &amp; havx[q[i].x] &amp; havy[q[i].y] &amp; havz[q[i].z]) &lt;&lt; &#x27; &#x27; &lt;&lt; hav &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">q[i].res = q[i].res + ans[hav &amp; havx[q[i].x] &amp; havy[q[i].y] &amp; havz[q[i].z]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; m;</span><br><span class="line"><span class="type">char</span> op[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, id, t = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line"><span class="keyword">if</span> (*op == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">++ n, <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %lld %lld&quot;</span>, &amp;mon[n].x, &amp;mon[n].y, &amp;mon[n].z, &amp;mon[n].add.nd, &amp;mon[n].add.sum), mon[n].st = ++ t;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*op == <span class="string">&#x27;-&#x27;</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;id), mon[id].ed = ++ t;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*op == <span class="string">&#x27;?&#x27;</span>) ++ Q, <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;q[Q].x, &amp;q[Q].y, &amp;q[Q].z), q[Q].at = t;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!mon[i].ed) mon[i].ed = m + <span class="number">1</span>;</span><br><span class="line">std::<span class="built_in">sort</span>(mon + <span class="number">1</span>, mon + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) <span class="built_in">solve</span>(l, r = std::<span class="built_in">min</span>(n, l + B - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, q[i].res.nd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;按序给出 $m$ 次操作或询问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新增元素 $(x, y, z)$，新给一个编号，获得他需要消耗 $a$ 点血量，获得他后可以获得 $b$ 点血量。&lt;/li&gt;
&lt;li&gt;编号为 $k$ 的元素被删除了。保证不会重复利用或重复删除编号。&lt;/li&gt;
&lt;li&gt;给定三元组 $(x, y, z)$，问要获得所有严格小于等于 $(x, y, z)$ 的元素需要开始时有多少血量才不会出现血量 $&amp;lt; 0$ 的情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;元素和询问次数都不超过 $50000$，$x, y, z\leq 10000$，$a, b\leq 10 ^ 9$，2s。&lt;/p&gt;</summary>
    
    
    
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="分块" scheme="https://mydcwfy.github.io/tags/%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P5605 小A与两位神仙</title>
    <link href="https://mydcwfy.github.io/2022/08/29/Luogu-P5605/"/>
    <id>https://mydcwfy.github.io/2022/08/29/Luogu-P5605/</id>
    <published>2022-08-29T13:15:00.000Z</published>
    <updated>2022-08-30T12:42:17.058Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定模数 $m$ 和 $T$ 次询问，每次询问给定 $x, y$，问是否 $z$ 满足存在 $x ^ z\equiv y\pmod m$。$m\leq 10 ^ {18}, T\leq 2\times 10 ^ 4$，保证 $m$ 是奇质数的次幂，$\gcd(x, m) = \gcd(y, m) = 1$，3s。</p><span id="more"></span><p>首先考虑如何判断。仍然使用原根，令 $x = g ^ a$，$y = g ^ b$，那么就是问是否存在 $z$ 满足 $az\equiv b\pmod {\varphi(m)}$。那么显然合法的条件是 $b\bmod \gcd(a, \varphi(m)) = 0$。这样你就可以在单次 $O(\sqrt m)$ 的时间（？）求出，容易发现显然寄了。</p><p>注意到我们其实并不需要知道 $a, b$，我们其实只需要知道 $\gcd(a, \varphi(m))$ 和 $\gcd(b, \varphi(m))$ 即可。这个和什么有关呢？注意到 $x ^ {\frac m{\gcd(a, \varphi(m))}}$ 一定是 1，而且是最小的循环节。这样就是阶啊！显然我们需要使得 $\gcd(b, \varphi(m)) \bmod \gcd(a, \varphi(m)) = 0$，那么就是 $\dfrac m{\gcd(a, \varphi(m))} \bmod \dfrac m{\gcd(b, \varphi(m))} = 0$，也就是 $y$ 的阶整除 $x$ 的阶即可，记作 $\text{ord}(y) | \text{ord}(x)$。</p><p>现在问题转化为求阶了。一个显然的办法是枚举所有因数，看是否满足条件。这之前需要我们算出 $\varphi(m)$ 和他的分解。这个都需要使用 Pollard-Rho 算法，单次求解还是问题不大。然后枚举所有因数，复杂度为 $O(T\omega(n)\log n)$（检验需要快速幂），无法通过。</p><p>注意到一个数满足 $x ^ a\equiv 1\pmod m$，那么 $a$ 的所有倍数都满足。我们就可以每次试除每一个质因数即可，时间复杂度 $O(T\log ^ 2 n)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;LL&gt; <span class="title">Pollard_Rho</span><span class="params">(LL n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL m, T, p, ti = <span class="number">0</span>, tmp, x, y;</span><br><span class="line">std::cin &gt;&gt; m &gt;&gt; T;</span><br><span class="line">p = <span class="built_in">Pollard_Rho</span>(m).<span class="built_in">front</span>();</span><br><span class="line">tmp = m;</span><br><span class="line"><span class="keyword">while</span> (tmp % p == <span class="number">0</span>) tmp /= p, ti ++;</span><br><span class="line"><span class="keyword">if</span> (ti) pr.<span class="built_in">push_back</span>(&#123;p, ti - <span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">auto</span> vec = <span class="built_in">Pollard_Rho</span>(p - <span class="number">1</span>);</span><br><span class="line">tmp = p - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (LL &amp;x : vec)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (tmp % x == <span class="number">0</span>) t ++, tmp /= x;</span><br><span class="line">pr.<span class="built_in">push_back</span>(&#123;x, t&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> getord = [&amp;](LL x) &#123;</span><br><span class="line">LL ans = m / p * (p - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [p, cnt] : pr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (t &lt; cnt &amp;&amp; <span class="built_in">qpow</span>(x, ans / p, m) == <span class="number">1</span>) ++ t, ans /= p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">while</span> (T --) <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;x, &amp;y), <span class="built_in">puts</span>(<span class="built_in">getord</span>(x) % <span class="built_in">getord</span>(y) ? <span class="string">&quot;No&quot;</span> : <span class="string">&quot;Yes&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定模数 $m$ 和 $T$ 次询问，每次询问给定 $x, y$，问是否 $z$ 满足存在 $x ^ z\equiv y\pmod m$。$m\leq 10 ^ {18}, T\leq 2\times 10 ^ 4$，保证 $m$ 是奇质数的次幂，$\gcd(x, m) = \gcd(y, m) = 1$，3s。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="离散对数" scheme="https://mydcwfy.github.io/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"/>
    
    <category term="结论" scheme="https://mydcwfy.github.io/tags/%E7%BB%93%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>CF103102H AND = OR</title>
    <link href="https://mydcwfy.github.io/2022/08/29/CF103102H/"/>
    <id>https://mydcwfy.github.io/2022/08/29/CF103102H/</id>
    <published>2022-08-29T12:41:05.000Z</published>
    <updated>2022-08-29T13:08:10.640Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一个长度为 $n$ 的序列，$q$ 次给出 $l, r$，问 $[l, r]$ 区间能否拆成两个集合使得第一个集合的 OR 是第二个集合的 AND。$n, q\leq 10 ^ 5$，$0\leq a_i &lt; 2 ^ {30}$，3s，1GB。</p><span id="more"></span><p>首先考虑一个结论：</p><blockquote><p>如果合法，假设两个集合 OR/AND 的值 $mid$ 满足 $|mid| = x$，则一定存在一种方案，使得 $|v| &lt; x$ 的所有 $v$（$|v|$ 表示 $v$ 中 1 的个数）都放在 OR 里面，$|v| &gt; x$ 的所有 $v$ 都放在 AND 里面。</p><p>证明：容易发现如果 $|v| &gt; x$ 的放在 OR 里面，那么 OR 的结果一定 满足 $|v| &gt; x$，就不可能合法。$|v| &lt; x$ 放在 AND 同理。</p></blockquote><p>那么对于每次询问，考虑枚举 $x$，那么按照该方式，所有 $|v|&lt; x$ 的都放在 OR 里面。求出这些所有的 OR 可以把每个数按照 $|v|$ 放入对应的线段树，然后查一下前缀即可。AND 同理。</p><p>最后注意一下细节即可。一个可能的合法方案是枚举 $x$，$|v| &lt; x$ 的 OR 和 $|v| \geq x$ 的 AND 相同。另外一种方案是 $|v|\leq x$ 的 OR 和 $|v|\geq x$ 的 AND 相同，并且 $|v| = x$ 的个数不少于两个。容易发现如果满足前面的条件，所有满足 $|v| = x$ 的 $v$ 都相同。于是上面这个是对的。</p><p>用线段树维护一下即可。时间复杂度 $O(n\log ^ 2n + q\log ^ 2 n)$，空间复杂度 $O(n\log n)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> le[<span class="number">31</span>], ri[<span class="number">31</span>], prehav[<span class="number">31</span>], sufhav[<span class="number">31</span>], hav[<span class="number">31</span>];</span><br><span class="line">le[<span class="number">0</span>] = orseg[<span class="number">0</span>].<span class="built_in">query</span>(l, r), prehav[<span class="number">0</span>] = havseg[<span class="number">0</span>].<span class="built_in">query</span>(l, r);</span><br><span class="line">ri[<span class="number">30</span>] = andseg[<span class="number">30</span>].<span class="built_in">query</span>(l, r), sufhav[<span class="number">30</span>] = havseg[<span class="number">30</span>].<span class="built_in">query</span>(l, r);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++ i)</span><br><span class="line">le[i] = le[i - <span class="number">1</span>] | orseg[i].<span class="built_in">query</span>(l, r), prehav[i] = prehav[i - <span class="number">1</span>] | (hav[i] = havseg[i].<span class="built_in">query</span>(l, r));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">29</span>; ~i; -- i)</span><br><span class="line">ri[i] = ri[i + <span class="number">1</span>] &amp; andseg[i].<span class="built_in">query</span>(l, r), sufhav[i] = sufhav[i + <span class="number">1</span>] | hav[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &amp;&amp; prehav[i - <span class="number">1</span>] &amp;&amp; sufhav[i] &amp;&amp; le[i - <span class="number">1</span>] == ri[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">auto</span> iter = std::<span class="built_in">lower_bound</span>(app[i].<span class="built_in">begin</span>(), app[i].<span class="built_in">end</span>(), l);</span><br><span class="line"><span class="keyword">if</span> (iter == app[i].<span class="built_in">end</span>() || *iter &gt; r || nxt[i][iter - app[i].<span class="built_in">begin</span>()] &lt;= r) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> ccnt = std::<span class="built_in">upper_bound</span>(app[i].<span class="built_in">begin</span>(), app[i].<span class="built_in">end</span>(), r) - iter;</span><br><span class="line"><span class="keyword">if</span> (le[i] == ri[i] &amp;&amp; ccnt &gt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cerr &lt;&lt; std::<span class="built_in">abs</span>(&amp;mem1 - &amp;mem2) / <span class="number">1048576.</span> &lt;&lt; <span class="string">&quot; MB\n&quot;</span>;</span><br><span class="line"><span class="type">int</span> q, l = <span class="number">2</span>, r = n - <span class="number">1</span>;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) app[__builtin_popcount(a[i])].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++ i) &#123;</span><br><span class="line">nxt[i].<span class="built_in">resize</span>(app[i].<span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">if</span> (!app[i].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">nxt[i].<span class="built_in">back</span>() = n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = app[i].<span class="built_in">size</span>() - <span class="number">2</span>; ~j; -- j)</span><br><span class="line"><span class="keyword">if</span> (a[app[i][j]] != a[app[i][j + <span class="number">1</span>]]) nxt[i][j] = app[i][j + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> nxt[i][j] = nxt[i][j + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++ i) orseg[i].<span class="built_in">build</span>(n), andseg[i].<span class="built_in">build</span>(n), havseg[i].<span class="built_in">build</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;x : app[i]) orseg[i].<span class="built_in">modify</span>(x, a[x]), andseg[i].<span class="built_in">modify</span>(x, a[x]), havseg[i].<span class="built_in">modify</span>(x, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line"><span class="built_in">puts</span>(<span class="built_in">query</span>(l, r) ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一个长度为 $n$ 的序列，$q$ 次给出 $l, r$，问 $[l, r]$ 区间能否拆成两个集合使得第一个集合的 OR 是第二个集合的 AND。$n, q\leq 10 ^ 5$，$0\leq a_i &amp;lt; 2 ^ {30}$，3s，1GB。&lt;/p&gt;</summary>
    
    
    
    
    <category term="线段树" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="结论" scheme="https://mydcwfy.github.io/tags/%E7%BB%93%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2219 数论之神</title>
    <link href="https://mydcwfy.github.io/2022/08/29/BZOJ2219/"/>
    <id>https://mydcwfy.github.io/2022/08/29/BZOJ2219/</id>
    <published>2022-08-29T11:27:18.000Z</published>
    <updated>2022-08-29T12:36:54.645Z</updated>
    
    <content type="html"><![CDATA[<p>题意：求 $x ^ a \equiv b\pmod p$ 的解数，$a, b, p$ 给定。$a, b, p\leq 10 ^ 9 + 1$，$p$ 是奇数，$T(T\leq 1000)$ 组数据。</p><span id="more"></span><p>容易发现单纯的 $p$ 不好做，于是显然根据中国剩余定理拆成 $p ^ k(p\in P)$ 做，然后直接把各部分的答案乘起来即可。</p><p>下面直接讨论 $x ^ a\equiv b\pmod {p ^ k}$ 的解数。</p><h4 id="Case-1：-b-0"><a href="#Case-1：-b-0" class="headerlink" title="Case 1：$b = 0$"></a>Case 1：$b = 0$</h4><p>容易发现只要 $x$ 在 $p$ 的次幂至少是 $\left\lceil\dfrac ka \right\rceil$ 即可。于是此时的贡献就是 $p ^ {k - \lceil\frac ka\rceil}$。</p><h4 id="Case-2：-b-bmod-p-0-land-b-not-0"><a href="#Case-2：-b-bmod-p-0-land-b-not-0" class="headerlink" title="Case 2：$b\bmod p = 0\land b\not= 0$"></a>Case 2：$b\bmod p = 0\land b\not= 0$</h4><p>此时假设 $b = c \times p ^ t$，那么此时 $x$ 在 $p$ 的次幂一定是 $\dfrac ta$（注意一定整除，否则无解），然后可以对两边同时除以 $p ^ t$，那么方程就变为了 $x ^ a\equiv c\pmod {p ^ {k - t}}$。注意到 $\bmod p ^ {k - t}$ 映射到 $\bmod p ^ k$ 时，由于需要乘上 $p ^ {\frac ta}$，所以剩下的 $k - (k - t) - \dfrac ta = t - \dfrac ta$ 次幂是完全定义域扩大的，所以需要乘上 $p ^ {t - \frac ta}$。剩下的是第三种情况，就可以解决这个问题了。</p><h4 id="Case-3：-b-bmod-p-not-0"><a href="#Case-3：-b-bmod-p-not-0" class="headerlink" title="Case 3：$b\bmod p \not= 0$"></a>Case 3：$b\bmod p \not= 0$</h4><p>这个可以使用离散对数（知道奇数的作用了吗？），假设 $b = g ^ t$，那么就是 $x ^ a \equiv g ^ t \pmod {p ^ k}$，容易发现如果 $t\bmod \gcd(\varphi(p ^ k), a)\not= 0$，说明不可能凑出 $t$，这样的话就返回 0。</p><p>然后考虑有解的情况有多少个。假设 $x = g ^ y$，那么就是 $ay\equiv t\pmod {\varphi(p ^ k)}$。容易发现此时当找到一个解时，$+\dfrac{\text{lcm}(\varphi(p ^ k), a)}{a}$ 也是一个解，而且是最小周期。除一下，一共就有 $\gcd(\varphi(p ^ k), a)$ 个解。</p><p>把所有的乘起来即可。时间复杂度 $O(\sqrt p\log p)$ 或 $O(\sqrt p)$，瓶颈在求离散对数的 BSGS 上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BSGS</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> Mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">1</span> || Mod == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; H;</span><br><span class="line"><span class="type">int</span> cur = b, K = std::<span class="built_in">sqrt</span>(Mod) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; K; ++ i, cur = (LL) cur * a % Mod) H[cur] = i;</span><br><span class="line"><span class="type">int</span> ak = cur = <span class="built_in">qpow</span>(a, K, Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= K; ++ i, cur = (LL) cur * ak % Mod)</span><br><span class="line"><span class="keyword">if</span> (H.<span class="built_in">count</span>(cur)) <span class="keyword">return</span> i * K - H[cur];</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findrt</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> pk = <span class="built_in">qpow</span>(p, k);</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; fac;</span><br><span class="line"><span class="type">int</span> n = pk - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; ++ i)</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">fac.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n ^ <span class="number">1</span>) fac.<span class="built_in">push_back</span>(n);</span><br><span class="line"><span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> g) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : fac)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">qpow</span>(g, pk / p * (p - <span class="number">1</span>) / x, pk) == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; pk; ++ i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(i)) <span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> pk = <span class="built_in">qpow</span>(p, k);</span><br><span class="line">b %= pk;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; a &lt;&lt; &#x27; &#x27; &lt;&lt; b &lt;&lt; &#x27; &#x27; &lt;&lt; p &lt;&lt; &#x27; &#x27; &lt;&lt; k &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">qpow</span>(p, k - (k + a - <span class="number">1</span>) / a);</span><br><span class="line"><span class="keyword">if</span> (b % p == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b % p == <span class="number">0</span>) b /= p, ++ t;</span><br><span class="line"><span class="keyword">if</span> (t % a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">solve</span>(a, b, p, k - t) * <span class="built_in">qpow</span>(p, t - t / a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> g = <span class="built_in">findrt</span>(p, k), _b = <span class="built_in">BSGS</span>(g, b, pk);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; pk &lt;&lt; &#x27; &#x27; &lt;&lt; g &lt;&lt; &#x27; &#x27; &lt;&lt; b &lt;&lt; &#x27; &#x27; &lt;&lt; _b &lt;&lt; &#x27; &#x27; &lt;&lt; Gcd(a, pk / p * (p - 1)) &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">if</span> (_b % <span class="built_in">Gcd</span>(a, pk / p * (p - <span class="number">1</span>))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Gcd</span>(a, pk / p * (p - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a, b, p, res = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;p), p = <span class="number">2</span> * p + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= p / i; ++ i)</span><br><span class="line"><span class="keyword">if</span> (p % i == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p % i == <span class="number">0</span>) ++ t, p /= i;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;Solve &quot; &lt;&lt; a &lt;&lt; &#x27; &#x27; &lt;&lt; b &lt;&lt; &#x27; &#x27; &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; t &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">res *= <span class="built_in">solve</span>(a, b, i, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p ^ <span class="number">1</span>) res *= <span class="built_in">solve</span>(a, b, p, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：求 $x ^ a \equiv b\pmod p$ 的解数，$a, b, p$ 给定。$a, b, p\leq 10 ^ 9 + 1$，$p$ 是奇数，$T(T\leq 1000)$ 组数据。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="离散对数" scheme="https://mydcwfy.github.io/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>TopCoder12004 SetAndSet</title>
    <link href="https://mydcwfy.github.io/2022/08/29/TopCoder12004/"/>
    <id>https://mydcwfy.github.io/2022/08/29/TopCoder12004/</id>
    <published>2022-08-29T10:58:53.000Z</published>
    <updated>2022-08-29T11:16:44.402Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定 $n$ 个数，要求把他们分成红蓝两组，要求都不为空，使得红组的 AND 和蓝组的 AND 相同，求划分方案。$n\leq 50, a &lt; 2 ^ {20}$。</p><span id="more"></span><p>容易发现不管怎么 DP 都是至少 $O(a ^ 2n)$ 的，不可接受。</p><p>考虑朴素容斥，假设某一位不相同，那么所有该位为 1 的数都应该在同一组，容斥这一位不相同，那么将所有该位为 1 的数同并查集合并，然后最后看有几组，答案就是 $2 ^ {cnt} - 2$。</p><p>注意如果一个位置一个该位为 1 的数都没有，那么不能对该位进行容斥。用个 dfs 搜一搜即可。复杂度 $O(na)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SetAndSet</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; f;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; all[<span class="number">20</span>];</span><br><span class="line">LL res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">find</span>(f[x]); &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(u) == <span class="built_in">find</span>(v)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> f[<span class="built_in">find</span>(v)] = <span class="built_in">find</span>(u), <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> bit, <span class="type">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bit == <span class="number">20</span>) &#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) cnt += f[i] == i;</span><br><span class="line">res += op * ((<span class="number">1LL</span> &lt;&lt; cnt) - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(bit + <span class="number">1</span>, op);</span><br><span class="line"><span class="keyword">if</span> (all[bit].<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> bac = f;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="type">int</span>) all[bit].<span class="built_in">size</span>(); ++ i)</span><br><span class="line"><span class="built_in">merge</span>(all[bit][i], all[bit][<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">dfs</span>(bit + <span class="number">1</span>, -op);</span><br><span class="line">f = bac;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">LL <span class="title">countandset</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n = a.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">f.<span class="built_in">resize</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) f[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> bit = <span class="number">0</span>; bit &lt; <span class="number">20</span>; ++ bit)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!(a[i] &gt;&gt; bit &amp; <span class="number">1</span>)) all[bit].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">1</span>), res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定 $n$ 个数，要求把他们分成红蓝两组，要求都不为空，使得红组的 AND 和蓝组的 AND 相同，求划分方案。$n\leq 50, a &amp;lt; 2 ^ {20}$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>NOI2022 游记</title>
    <link href="https://mydcwfy.github.io/2022/08/28/NOI-2022/"/>
    <id>https://mydcwfy.github.io/2022/08/28/NOI-2022/</id>
    <published>2022-08-28T10:31:58.000Z</published>
    <updated>2022-08-29T13:01:13.219Z</updated>
    
    <content type="html"><![CDATA[<p>挂 18pts 送走 Au，rk65 Ag。</p><span id="more"></span><p>现在来写，感觉很多有意义的细节已经忘记的差不多了，只能记得一个大概的框架了，所以游记总是看起来干巴巴的。由于我又没有赛时写游记的习惯，看来以后得先记录一点有意义的事情了。</p><p>以 8.23 为 Day 1。</p><h3 id="Day-10（8-12）"><a href="#Day-10（8-12）" class="headerlink" title="Day -10（8.12）"></a>Day -10（8.12）</h3><p>突然听说要提前 7 天到苏州，吓了一跳，赶忙飞去上海然后高铁到昆山。没住在 CCF 建议的酒店，说找一个安静点的地方。熟悉了一下环境，结果碰上了成外的（</p><p>和 CSYZ 一起训练，他们明天才来，所以模拟赛没来，于是可以光明正大的颓，结果被教练评价为“效率怎么这么低下啊”。</p><p>条件还行，手机电脑被收后，晚上看点奇怪的电视剧，不知不觉就睡着了。</p><h3 id="Day-9（8-13）-Day-3（8-19）"><a href="#Day-9（8-13）-Day-3（8-19）" class="headerlink" title="Day -9（8.13）- Day -3（8.19）"></a>Day -9（8.13）- Day -3（8.19）</h3><p>CSYZ 的来了，模拟赛也来了（悲</p><p>天天在酒店里颓，但是还是被强制做模拟赛。结果几场模拟赛一次排名比一次低，是不是 NOI 就要垫底了 /ll</p><p>地方特别偏，想找一点能吃的菜简直不太可能，就连外卖的 5km 以内都没有几家，一周显然就都吃遍了，然后就没得吃了（</p><p>8.14 晚上 AGC 直接自闭，啥题不会，最后在 170 min 的时候终于过了 A /kk，不过排名没变化，还是掉大分。第二天发现自己的 B 和正解一模一样，不知道为什么赛时没过样例呢？当时又把 B 的代码删了，更不知道哪里错了，于是又重码了一遍赛时写的，就过了 /fn</p><p>8.16 晚上 CF Div1，A 一直猜贪心，WA 了两发才发现哪里没对，结果是一个 sb DP，做了半个小时。B 没想到有一个唯一分解（其实推式子的过程中证明到了，但是没写）用了一个奇奇怪怪的东西，写了半个小时多，WA 了两发，终于过了。C 一个一眼题，直接维护所有因数的答案即可，突然感觉过不去，把因数换为质因数就好了，又写了半个小时，罚时一车，不过还是上分了。</p><h3 id="Day-2（8-20）"><a href="#Day-2（8-20）" class="headerlink" title="Day -2（8.20）"></a>Day -2（8.20）</h3><p>进校力！（不过教练因为没报名字上去，进不了 /kk，比较离谱）</p><p>发现是一个 nb 学校，感觉非常宽敞，所有建筑都是西式风格的，在我们那地很少见。被分到了一个两人间的宿舍，居然没有上下铺，一人一弹簧床、一个书桌，独立洗手间、洗漱台，感觉是星级酒店而不是一个学校的宿舍欸。不过听说到这里的学费，实在是震惊到了，但是这学费也值啊，天天住宾馆，实在是条件不错 /se</p><p>由于不认识几个人，跟着多头去逛了一圈，在签名墙上写下了自己的 id（诶话说这么大个签名墙，写个 id 真有人能看到吗），然后就溜回寝室颓了。</p><p>午饭也是全自助，挺好吃的 /se</p><p>一直颓颓颓，无事可干捏。由于我们教练进不来 /ll，只好像探监一样把我们叫过去，问一下近期的情况，自然是应付一下，不过确实也不知道自己状态到底如何，只好开摆。</p><p>晚上颓。</p><h3 id="Day-1（8-21）"><a href="#Day-1（8-21）" class="headerlink" title="Day -1（8.21）"></a>Day -1（8.21）</h3><p>早上去领胸牌，结果要去 4 个地方按顺序排队，第二个位置特别慢，导致那个位置的人特别多，其他位置几乎人都没有，让我清楚的认识到了水桶效应（一开始差点由于人多直接排第二个位置了）。我不清楚为啥不在那里多安排几个人呢？看到几个志愿者议论了半天，结果也没人去帮忙。另外为什么不集中到一个地方直接同意统一领呢？表示问号。不过反正排队也是颓，也没太在意。</p><p>拿到徽章后和多头换了一个，又去领了背包，感觉良好。遇到了 CSYZ 的几个，换了徽章，然后回寝室了。</p><p>据说 ZJ 和 CQ 都在 D4，晚上和 RuSun 去面了 dX 和 feecle6418，结果都只有 1 个徽章了 /kk，不过我们两个还是都给他们了（）</p><p>晚上斗地主 / 看别人斗地主。</p><h3 id="Day-0（8-22）"><a href="#Day-0（8-22）" class="headerlink" title="Day 0（8.22）"></a>Day 0（8.22）</h3><p>下午要笔试了，早上只好开始复习，不过看不进去，因为这个笔试有 whk 的感觉。过了几遍感觉差不多就行了，然后开始颓。</p><p>下午笔试，先发了一个去年 NOIp 的题目，就写了一下练练手，结果发现 T3 还是不会，T4 还是只会暴力。如果叫我现在去考去年的 NOIp，能不能考到我当时的分数还是问题呢 /kk。随便写了 T1 和 T2，幸运的是没怎么调试就对了，本想开始写 T3 的退火，结果发现 14:58 了，遂弃。</p><p>笔试竟然是内网提交答案，和我想象的方式（写成程序提交）不太像，不过这样就不会题号错误，还是不错。结果第五个就不太确定（记不到题目是什么了），中间要好一些，然后 46 47 连着两个全选，47 能不能登陆系统把我给不会了，但是转念一想，不是不能碰键盘吗？不碰键盘怎么登陆？差点就变成 bot  了，哈哈。</p><p>据说以前考完就出成绩了，不过今年的系统考完后 15:31 就关了。那多久出成绩呢？表示问号。</p><p>本想接着写 NOIp T3 的，但是发现旁边的人走了一大半，于是果断弃掉跑路。</p><h3 id="Day-1（8-23）"><a href="#Day-1（8-23）" class="headerlink" title="Day 1（8.23）"></a>Day 1（8.23）</h3><p>早上本身没改原来 7：00 的闹钟，但是同宿舍 CDQZ 的 6：40 就起来了，于是我也起来了（</p><p>先吃饭，后洗漱，虽然有些奇怪，但是教练要求的，不管了。差不多 7：40 进去的，结果只带了一个士力架，感觉亏大了 /ll。不过还发了一些吃的，于是进场了。</p><p>8：00 准时开题，看到 T1 是一个 sb 摩尔投票，因为当时做 CF 好像做到一个，所以记忆比较深刻。感觉 T1 简单，一会来写，又看 T2。T2 的题目很简洁，但是感觉性质很不优美，开始看成了操作一是每次恰好减少两个，发现完全不可做。过了一会发现是至少减少两个，然后发现还是不可做（，于是去看 T3。T3 “这是一道交互题”和 6 页的题面，已经难懂的定义让人想起了 lxl 欸，不过好像是 zx 出的（。看了一圈，大概半个小时才看懂题，发现连 $O(n ^ 2)-O(1)$ 都不会，只会一个链的猫树分治 10pts。不过 T3 一脸不可做，也没人写更多分吧（</p><p>回过头去写 T1，发现需要维护原序列以及摩尔投票的结果，开始觉得只需要线段树合并就可以了，于是写了，发现没法删除最后一个，想了半天发现可以平衡树合并维护序列（我怎么没想到启发式呢？），不需要线段树合并，差点把线段树合并删了，不过还是忍住了放在 backup。果然过了一会写完平衡树合并后才发现没法判断一个数是否真的是绝对众数，于是又想起了线段树（，然后复制过来，前前后后 1.5h 过去了，写了 200 行的代码总算过了大样例。这常数能过就离谱了，不过我当时没想到更好的办法，于是跳了。</p><p>懒得写对拍，9：45 开 T2，我不相信 3h 拿不下 T2，毕竟每年 D1 队线都是 200+。但赛后看来我的思路就是错的，因为我一直想找到一个比较优美的结论来表示。但事实是这个题需要 DP 刻画合法性。赛时想到了 DP，但是发现每个区间的操作次数复杂度上天，于是弃掉了。其实当时如果认真想还是可做的，只不过我被“有一个优美的结论”的思维禁锢住了，没有仔细思考。</p><p>这样前前后后到了 11:40，我连 $k = 0, l_i = r_i$ 都不会做，心里有点慌了，于是写了爆搜 15pts 跳 T3。T3 下发了 grader.o 和 checker.o 是我第一次见识，还是挺 nb 的。能用就是了，主要是没有 checker 源码，不知道为啥错，猫树分治都调了半个多小时，总算调出来了。想了想暴力怎么写，结果搞了很久，想了多个算法，全部假了。</p><p>回过头来看 T2，还是一点不会。遂弃掉，慢悠悠的检查了三个题能不能编译通过，于是罚坐 15min，结束了。</p><p>出来听说估分 125pts 的人很多，但是 125pts 以上的比较少，只要不挂分，应该还是可以翻盘的。不过盘是什么？我也不知道。</p><p>吃了饭睡了午觉过去查成绩，发现没挂，$100 + 15 + 10 = 125$。CSYZ 的似乎都有多多少少的挂分，惨惨。据说队线在 130-140之间，心态稳健，多头 T2 直接场切，我直接 orz。</p><p>下午和 XJ 的学生聊，他 D1 130（不过好像 D2 爆炸了，Ag 走人了，惨），他把题看成了操作区间长度 $\geq 2$，这个比原问题 $\geq 3$ 可做一些，但是他写了很久，直到最后一个小时才发现，然后就寄了。不过至少还是会并能写完 $k = 0, l_i = r_i$ 的部分。他讲了一遍 T3 的暴力，可我还是没怎么听懂（</p><p>晚上讲课大概听懂了 T2，发现是一个神秘 DP 套 DP，瞎搜一下可达的状态救就可以了，T3 神仙数据结构，暴力都好阴间 /kk。回去斗地主。</p><h3 id="Day-2（8-24）"><a href="#Day-2（8-24）" class="headerlink" title="Day 2（8.24）"></a>Day 2（8.24）</h3><p>说好的社会活动呢？</p><p>好像有一个什么猜谜游戏，不过听说比较专业，就没参加。上午无事可干，想看几道题，结果 ABC 都不会（，心态爆炸，于是不看了，开始颓。</p><p>下午开幕式，印象最深的当属 dzd 的讲话和无人机表演。无人机的背景音乐是 AW 的 <code>Hello World</code>，有点寓意阿。</p><p>晚上颓。</p><h3 id="Day-3（8-25）"><a href="#Day-3（8-25）" class="headerlink" title="Day 3（8.25）"></a>Day 3（8.25）</h3><p>其实应该是 D2（</p><p>8：00 开题，一眼觉得 T2 是 Itst 出的（赛后发现他出的是 D2T3），部分分比较良心，争取多拿点（总所周知 D2T2 不可做）。T1 树哈希，题面明摆着不会特意卡，那随便搞搞，感觉比较简单。T3 神仙题，显然不会，但不知道爆搜多少分。</p><p>T1 想了一会可以直接暴力枚举哈希值不同的如何匹配，复杂度上界是 $O(k! \times n)$，看样子可以过，于是直接开写，细节还行，差不多 9：30 过大样例，然后随便造了几组 <code>Yes</code> 的数据（似乎不好写对拍），发现是对的，于是跑路。</p><p>9：45 开 T2，先做 A 发现有一个显然的 $O(n ^ 3)$ DP，想了一想转移方程可以使用单调队列优化到 $O(n ^ 2)$（自始至终没有想过贪心 /kk），先不忙写，又开 B 性质，盲猜一下没填的是不降的，于是又可以 $O(n ^ 2)$ DP，想了一下会证明了，感觉 C 也是这么做的。大概 10：20 开始写，单调队列比较难写，主要是不断平移比较麻烦（赛后发现好像可以记录 0 的个数而不是 1 的个数就不需要平移了 /jy），写了半个多小时才过样例。B 好写一些，发现这个过不了 C，于是摆，然后又胡了个爆搜，应该 56 pts。</p><p>11：45 左右开 T3，$k = 3$ 容易贪心选 2 即可，很好做；$k = 4$ 不太会，又写了个爆搜，想尽奇奇怪怪的方法优化，但是 $n = 50$ 根本过不了，于是期望 27 pts 跑路。感觉这么多分 + D1 的 125 应该够队线了吧，就没有继续想其他部分分了（伏笔）。简单的检查了一下就结束了。</p><p>一出来就听到有人会 T2，难道 D2T2 比 D1T2 简单？表示问号。不过出来就听到 CSYZ 的教练给我们说马上回去，不是还有两天吗？一查，苏州一个无症状感染者，没必要这么紧张呗。不过还是回去把东西收好了。</p><p>下午 2：30 就看到一车人去查分，也去一看，$100 + 48 + 17 = 165$，挂了 18 pts。</p><p>先看 T2，发现是暴力挂了 8pts，反倒是 A、B 两个难写的性质都对了。想起了当时我需要在一段区间的右端点判断一段区间的最小值是否是给定的时候，我为了运行效率，把一个右端点的限制按照左端点排序，然后指针扫过去。结果排序的时候把 $n$ 写成 $m$ 了 /kk，然后暴力挂了一半。当时想过要不要这样，因为数据不好检查写对没有，结果一想应该没问题，就略过了，然后就挂了 /ll</p><p>然后看 T3，发现 $k = 3$ 的点全挂了，10pts，仔细一看，多测不清空，爆零两行泪。怎么过的 $k = 3$ 的大样例呢？小编也觉得很惊讶，但事实就是这样。</p><p>出来几乎没有讨论就出校了，路上和教练讨论了一会。一路上有各种奇奇怪怪的队线，不知道该听谁的。</p><p>似乎确实是一个不完整的 NOI 欸。</p><h3 id="Day-4（8-26）"><a href="#Day-4（8-26）" class="headerlink" title="Day 4（8.26）"></a>Day 4（8.26）</h3><p>出总分和排名了，$100 + 100 + 15 + 10 + 100 + 48 + 17 + 0 = 390$，rk65 Ag。</p><p>回收伏笔，确实当时估计的 $100 + 125 + 183 = 408$ 也可以进队的，不过挂分了。不过确实实力不够呗，这直接导致容错的区间太小了，我一旦任何一个地方挂了，都不可能进队。一旦多会 20pts，这样的话，挂一点分还是可接受的。现在确实一点不能挂，但谁能保证总计 10h 的 NOI 一分不挂呢？显然是一件难事啊。</p><p>没进队有遗憾啊，不然我写这游记的时候心情也就完全不一样了，就可能是 feecle6418 和 dottle 的心情了。不过好像还是可以参加 CTT/se</p><p>接下来的一年，除需要提升实力外，这些挂分我们需要一些总结，比如将可能挂分的方式写在代码里，过完样例后逐一检查。这些问题可能是易避免的，也有可能是难发现的。检查出样例无法检查到的错误可能也是实力的一部分吧！</p><p>来年再战！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;挂 18pts 送走 Au，rk65 Ag。&lt;/p&gt;</summary>
    
    
    
    
    <category term="游记" scheme="https://mydcwfy.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
</feed>
