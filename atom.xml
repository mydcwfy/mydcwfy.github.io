<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mydcwfy&#39;s Blog</title>
  
  
  <link href="https://mydcwfy.github.io/atom.xml" rel="self"/>
  
  <link href="https://mydcwfy.github.io/"/>
  <updated>2022-04-09T05:59:25.359Z</updated>
  <id>https://mydcwfy.github.io/</id>
  
  <author>
    <name>mydcwfy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CF643G</title>
    <link href="https://mydcwfy.github.io/2022/04/09/CF643G/"/>
    <id>https://mydcwfy.github.io/2022/04/09/CF643G/</id>
    <published>2022-04-09T03:43:26.000Z</published>
    <updated>2022-04-09T05:59:25.359Z</updated>
    
    <content type="html"><![CDATA[<p>线段树 + 众数的好题。</p><span id="more"></span><p>题意：给定长度为 $n$ 的序列和常数 $p$，$q$ 次操作，区间赋值或是查询区间出现次数大于 $p\%$ 的数。可以有无关输出，但总数不能超过 $\left\lfloor\dfrac{100}p \right\rfloor$。$20\leq p\leq 100, n, q\leq 1.5\times 10 ^ 5$。</p><p>考虑 $p &gt; 50$ 怎么做。维护一个 <code>(x, cnt)</code>，表示一个数和当前数出现次数减去非当前数的出现次数。显然 $cnt &gt; 0$ 的数最多只有一个，也就是说，我们只需要维护一个 <code>pair</code> 即可。来了新的一个数时，如果等于当前数，显然 <code>cnt ++</code>，否则 <code>cnt --</code>。如果当前的 $cnt$ 已经 $\leq 0$ 了，说明这个数是不优的，一定不可能成为答案，我们就删除这个 <code>pair</code>。如果新来一个数时 <code>pair</code> 是空的，我们直接设置为 <code>(x, 1)</code> 即可。</p><p>考虑证明可行。显然一个数 $x$ 如果出现频率大于 $50\%$，那么到最后的时候，他一定没有被其他数所换下，因为即使所有数都攻击 $x$ 的 $cnt$，最后仍然 $cnt &gt; 0$，也就是不会被弹出。至此我们证明的这一定是可行的。</p><p>扩展该做法，维护 $\left\lfloor\dfrac{100}p \right\rfloor$ 个 <code>(x, cnt)</code>，如果来了一个数是其中的某一个数，直接对这个 <code>(x, cnt)</code> 加一。否则对每一个 <code>(x, cnt)</code> 减一，如果有 $cnt = 0$，则删除。显然如不满 $\left\lfloor\dfrac{100}p \right\rfloor$ 个的话，我们就设置一个 <code>(x, 1)</code> 即可。</p><p>考虑正确性。如果这个数被弹出仅当至少出现了 $\left\lfloor\dfrac{100}p \right\rfloor$ 个和他互不相同的数，并且这个数仅出现了一次，如果再出现这个数也至少有 $\left\lfloor\dfrac{100}p \right\rfloor$ 个和他不同的数，说明这个数的出现频率不可能达到 $p%$，得证。</p><p>区间操作直接直接使用线段树维护即可，合并信息的时候可以将一边的数按照 <code>cnt</code> 次出现计算，暴力加入另外一边（显然没有出现在左右的 <code>pair</code> 中则不可能出现在最终的 <code>pair</code> 中）。假设 $k = \left\lfloor\dfrac{100}p \right\rfloor$，则时间复杂度为 $O(k ^ 2n\log n)$。</p><p>题外话：可不可以使用这个维护区间众数呢？欢迎在评论区留言。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Major</span> &#123;</span></span><br><span class="line">    PII dat[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">Major</span>() &#123;  &#125;</span><br><span class="line">    <span class="built_in">Major</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> cnt) &#123; dat[<span class="number">0</span>] = &#123;x, cnt&#125;; &#125;</span><br><span class="line">    PII&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> dat[x]; &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">int</span> k; <span class="comment">// 维护 k 个 pair</span></span><br><span class="line"></span><br><span class="line">Major <span class="keyword">operator</span> +(Major a, Major b) <span class="comment">// 合并两边的 pair</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = b[i].first, cnt = b[i].second, flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k &amp;&amp; !flag; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (a[j].first == x) flag = <span class="number">1</span>, a[j].second += cnt;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k &amp;&amp; !flag; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (!a[j].first) a[j] = &#123;x, cnt&#125;, flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">1e9</span>, pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">chkmin</span>(mx, a[j].second)) pos = j;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; a[pos].second)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++ j) a[j].second -= cnt;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++ j) a[j].second -= mx;</span><br><span class="line">            a[pos] = &#123;x, cnt - mx&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;线段树 + 众数的好题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="线段树" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>CF653G</title>
    <link href="https://mydcwfy.github.io/2022/04/07/CF653G/"/>
    <id>https://mydcwfy.github.io/2022/04/07/CF653G/</id>
    <published>2022-04-07T08:28:48.000Z</published>
    <updated>2022-04-09T00:26:38.185Z</updated>
    
    <content type="html"><![CDATA[<p>一道埃筛 + 组合数学的题目。</p><span id="more"></span><p>题意：给定一个序列 $\{a\}$，执行以下的操作直到所有数相等：乘一个质数或除一个质数。求所有子序列最少操作次数的和，对 $10 ^ 9 + 7$ 取模。$n, a_i\leq 3\times 10 ^ 5$，5 s。可以加强到 $n, a_i\leq 2\times 10 ^ 7$。</p><p>容易发现每一个质数是独立的，可以分开计算贡献。另外，显然当取质数次数的中位数是最优的策略。</p><p>对每一个质数分别考虑，假设当前按质数次数降序排名为 $i$ 的数次数为 $x_i$，中位数为 $x$，那么答案为 $|x_i - x|$。</p><p>如果我们将整个展开，发现 $\dfrac n2$ 个数 $x$ 的贡献是负，$\dfrac n2$ 个数 $x$ 的贡献是正，那么我们只需要考虑 $x_i$ 的贡献。</p><p>假设排名小于 $i$ 的选了 $a$ 个（$0\leq a&lt; i$），大于 $i$ 的选了 $b$ 个（$0\leq b&lt; n - i + 1$），那么根据 $a$ 和 $b$ 的大小可以分为：</p><ol><li>$a &lt; b$，则 $x_i$ 贡献为正。</li><li>$a = b$，则 $x_i$ 贡献为 0。</li><li>$a &gt; b$，则 $x_i$ 贡献为负。</li></ol><p>$a, b$ 的相对关系看起来不好枚举，我们换做 $i - 1 - a + b$ 与 $i - 1$ 的大小关系可能更好枚举。于是我们可以得到下面的式子：<br>$$<br>\sum_{j = i} ^ {n - 1} \binom{n - 1}{j} - \sum_{j = 0} ^ {i - 2} \binom{n - 1}{j}<br>$$</p><p>我们可以预处理 $f(k) = \sum_{i = k}^{n - 1} \binom{n - 1}i - \sum_{i = 0}^{k - 2}\binom{n - 1}i$，可能会更好求。</p><p>发现 $x_i$ 一样的段，贡献是连续的，也就是 $f(k)$ 是一段的和。假设枚举次幂 $t$，设 $x_i\geq t$ 的个数为 $a$，$x_i &gt; t$ 的个数为 $b$，那么 $t$ 的贡献就是：<br>$$<br>t\sum_{i = b + 1} ^ a f(i)<br>$$<br>再次前缀和 $g(i) = \sum_{j = 1} ^ i f(j)$，那么这个贡献也可以 $O(1)$ 计算。那么瓶颈在于计算 $x_i\geq t$ 的个数。这个可以通过埃筛来计算。</p><p>具体来说，我们直接考虑枚举质数 $p$，然后对于他的次幂，暴力计算次幂的倍数有多少个。据说时间复杂度是 $O(n\log\log n)$ 的，实测 $4\times 10 ^ 7$ 也只要 0.5s（不算读入）。有好心人发一下证明吗？</p><p>代码比较简短。放一个主函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++ j) <span class="built_in">adj</span>(pre[j] = pre[j - <span class="number">1</span>] + <span class="built_in">C</span>(n - <span class="number">1</span>, j) - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, tmp; i &lt;= n; ++ i)</span><br><span class="line"><span class="built_in">adj</span>(ans[i] = ans[i - <span class="number">1</span>] + <span class="built_in">adj</span>(<span class="built_in">adj</span>(tmp = pre[n - <span class="number">1</span>] - pre[i - <span class="number">1</span>]) -= (i == <span class="number">1</span> ? <span class="number">0</span> : pre[i - <span class="number">2</span>])) - Mod);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= mx; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (j = i &lt;&lt; <span class="number">1</span>; j &lt;= mx; j += i) st[j] = <span class="literal">true</span>;</span><br><span class="line">LL k = i;</span><br><span class="line"><span class="keyword">for</span> (cntp[j = <span class="number">1</span>] = <span class="number">0</span>; k &lt;= mx; cntp[++ j] = <span class="number">0</span>, k *= i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = k; l &lt;= mx; l += k) cntp[j] += cnt[l];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = j - <span class="number">1</span>, tmp; l; -- l)</span><br><span class="line">res = (res + (LL)<span class="built_in">adj</span>(tmp = ans[cntp[l]] - ans[cntp[l + <span class="number">1</span>]]) * l) % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一道埃筛 + 组合数学的题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>CF843D</title>
    <link href="https://mydcwfy.github.io/2022/04/06/CF843D/"/>
    <id>https://mydcwfy.github.io/2022/04/06/CF843D/</id>
    <published>2022-04-06T13:50:25.000Z</published>
    <updated>2022-04-09T03:44:30.220Z</updated>
    
    <content type="html"><![CDATA[<p>Dijkstra 的好题。</p><span id="more"></span><p>题意：给定一张图，可能询问某点到 1 的最短距离或是给 $c$ 条边的边权加 1。$n, m\leq 10 ^ 5, q\leq 2000, \sum c\leq 10 ^ 6$。</p><p>直接考虑朴素的 Dijkstra，每次我们加边的时候，都暴力重构长度。时间复杂度 $O(mq\log n)$，很卡。<del>标算都卡的很，这还能过？</del></p><p>另一种方法是用 SPFA 代替，时间复杂度 $O(kmq)$，<del>好像被构造卡了</del>。</p><p>10 s 的时间，看样子不是什么特别优的算法，应该是 $O(mq)$。</p><p>似乎只有 BFS 可以做到这个复杂度，01 双端队列似乎可以解决！</p><p>但是我们没有考虑原来的边的边权，这个显然是有问题的，因为对于边权非 1 的情况会处理错误。那么有什么方法呢？</p><p>考虑 Dijkstra 的算法流程：</p><blockquote><ol><li>找到当前未扩展的点中，距离起点最近的点。</li><li>松弛其他点到起点的距离。</li></ol></blockquote><p>在标准的 Dijkstra 算法中，我们使用了一个堆实时维护。我们是否可以找到另外的替代呢？直接考虑最暴力的桶，于是我们得到了一个 $O(m + W)$ 的做法，其中 $W$ 是指最短路的值域范围。</p><p>每次加 $c$ 条边的边权时，到其他所有点的距离变化一定不超过 $\min\{c, n - 1\}$（最短路不超过 $n - 1$ 条边），这启示我们可以使用桶 - Dijkstra 的算法来计算增量。</p><p>但是在一般的认知中，是没有办法求最短路的增量的。可以考虑类似 Johnson 全源最短路的做法，我们设置一条边的新权值为 $e(u, v)’ = e(u, v) + dis(u) - dis(v)$。类似 Johnson 的证明，我们三角不等式易得边权仍然是非负的。而我们走到一个点的时候，他的势能加上他的新图上的距离就是原图上的最短路。而新图的距离是好求的，于是我们可以得到单次 $O(m + W) = O(m)$ 的做法了。总时间复杂度 $O(m\log m + mq)$（开始必须跑一遍 Dijkstra</p><p>注意仍然比较卡常，注意实现细节的错误可能导致 TLE。放一个代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="keyword">int</span>&gt; q[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> Lim = n - <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Lim; ++ i)</span><br><span class="line"><span class="keyword">while</span> (!q[i].<span class="built_in">empty</span>()) q[i].<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) now[i] = n;</span><br><span class="line">q[<span class="number">0</span>].<span class="built_in">push</span>(<span class="number">1</span>), now[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, x; l &lt;= mx; ++ l)</span><br><span class="line"><span class="keyword">while</span> (!q[l].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">x = q[l].<span class="built_in">front</span>();</span><br><span class="line">q[l].<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (now[x] &lt; l) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[i, v] : g[x])</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">chkmin</span>(now[v], <span class="built_in"><span class="keyword">int</span></span>(now[x] + w[i] + d[x] - d[e[i]])) &amp;&amp; now[v] &lt;= Lim)</span><br><span class="line">q[now[v]].<span class="built_in">push</span>(v), <span class="built_in">chkmax</span>(mx, now[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (d[i] &lt; (INF &gt;&gt; <span class="number">1</span>)) d[i] += now[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Dijkstra 的好题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="图论" scheme="https://mydcwfy.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>P7843</title>
    <link href="https://mydcwfy.github.io/2022/04/04/P7843/"/>
    <id>https://mydcwfy.github.io/2022/04/04/P7843/</id>
    <published>2022-04-04T13:28:17.000Z</published>
    <updated>2022-04-04T14:18:33.529Z</updated>
    
    <content type="html"><![CDATA[<p>分治的妙妙题。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给定 $m$ 个双向的 2-SAT 限制（即 $u_i$ 选了 $x_i$ 则 $v_i$ 要选 $y_i$，同样 $v_i$ 选了 $y_i$ 则 $u_i$ 要选$x_i$），$q$ 次询问 $[l, r]$ 最少能划分成多少段有解的 2-SAT 限制。</p><p>$n\leq 10 ^ 5, m\leq 6\times 10 ^ 5, q\leq 10 ^ 6$，时限 2.5 s。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>首先考虑如何判定 2-SAT 限制是否有解，发现这个 Tarjan 实质是在求联通分量（因为有双向边，联通分量一定是强连通分量）。</p><p>那么，我们可以使用一个并查集维护联通性，如果一次之后出现了 $u_i$ 和 $u_i$ 的反面在一个强连通分量，则不合法。</p><p>如何求一个区间最少划分成多少个有解的 2-SAT 问题？这个可以简单的贪心，预处理每一个限制一直向右扩展到哪一处开始不合法（显然不合法之后不可能再合法），前面的显然划为一段，如此贪心。这个贪心过程可以使用倍增优化，也就是说，如果我们能找到从一个限制一直向右扩展到哪一处开始不合法，我们可以倍增跳，做到 $O(q\log n)$ 的复杂度，显然已经足够了。问题在于如何求哪一处开始不合法。</p><p>记 $f(i)$ 为极短的 $[i, f(i)]$ 为无解的限制，这个就类似一个 DP 了。我们发现似乎没有什么方法可以做到比较优的复杂度，因为这个和一般的 DP 又不尽相同。</p><p>考虑 $f(i)$ 的性质，我们发现，$f(i)$ 显然是具有单调性的，这启示我们向 DP 的决策单调性的方向思考。</p><p>类似于决策单调性的求法，我们考虑二分，<code>solve(l, r, sl, sr)</code> 表示处理 $[l, r]$ 之间的$f(i)$，已知答案区间为 $[sl, sr]$。直接计算 $f(mid)$，然后向下递归即可。</p><p>如何计算 $f(mid)$，如果我们暴力向右扩展的话，其实复杂度是错误的。回顾决策单调性的写法与时间复杂度的证明，我们取的时候，必须只能在 $[sl, sr]$ 之间计算，也就是说，我们的时间复杂度应只与 $sr - sl$ 有关。但是这个题，我们发现，如果 $mid &lt; sl$，即使我们知道答案不会出现在这一段区间，我们还是得扫一遍，为后面判断做铺垫，而这造成了错误，使得复杂度不对。如何处理他呢？</p><p>感觉上，这个东西应该是留给上一层计算才对，于是我们强制要求<strong>在 $[r + 1, sl - 1]$ 之间的限制已经被加入并查集了</strong>。这样才能保证我们计算的时候，不会进入多余的无用的计算。递归结束时显然要撤回，所以用可撤销并查集，预处理时间复杂度 $O(m\log m\log n)$，总时间复杂度为 $O(m\log m\log n + q\log n)$。至于为什么不将 $[mid, sl - 1]$ 或是 $[l, sl - 1]$ 加入并查集，是因为这不是 $[l, r]$ 所有节点所必需的，所以先不管。具体在实现部分讲。</p><h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h2><p>这个题由于要保证 $[r + 1, sl - 1]$ 的在进入该层前已经加入了并查集了，所以我们注意我们如果要计算 $f(mid)$，要先将 $[mid, \min{r, sl - 1}]$ 的加入，然后再从 $sl$ 向右扫。如果要向左区间递归，那么 $[mid, sl - 1]$ 的保留（因为向 $[l, mid - 1]$ 递归），所以我们要将第一次加入的边保留。而向右区间，则是 $[r, f(mid) - 1]$，这个直接实现即可。</p><p>考虑复杂度，同整体二分，$O(m\log m)$，加上可撤销并查集，$O(m\log m\log n)$，可以通过。</p><p>注意可能前面上层的就已经不合法了，所以要将前面是否合法并向下递归。还要注意判断自相矛盾的情况。可能比较难写，放一个二分的代码。（到底是什么二分 / 分治呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span> &#123;</span>  &#125; dsu ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> dsu.<span class="built_in">find</span>(x) != dsu.<span class="built_in">find</span>(x ^ <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> sl, <span class="keyword">int</span> sr, <span class="keyword">bool</span> frm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// printf(&quot;Solve [%d, %d] : [%d, %d]\n&quot;, l, r, sl, sr);</span></span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (sl == sr) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++ i) f[i] = sl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, now = frm, st = dsu.top;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &lt;= r &amp;&amp; i &lt; sl; ++ i) &#123;</span><br><span class="line">dsu.<span class="built_in">merge</span>(opt[i].first, opt[i].second);</span><br><span class="line">dsu.<span class="built_in">merge</span>(opt[i].first ^ <span class="number">1</span>, opt[i].second ^ <span class="number">1</span>);</span><br><span class="line">now &amp;= <span class="built_in">check</span>(opt[i].first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> bac = dsu.top, ls = now;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = std::<span class="built_in">max</span>(sl, mid); i &lt;= sr; ++ i) &#123;</span><br><span class="line">dsu.<span class="built_in">merge</span>(opt[i].first, opt[i].second);</span><br><span class="line">dsu.<span class="built_in">merge</span>(opt[i].first ^ <span class="number">1</span>, opt[i].second ^ <span class="number">1</span>);</span><br><span class="line">now &amp;= <span class="built_in">check</span>(opt[i].first);</span><br><span class="line"><span class="keyword">if</span> (!now) &#123;</span><br><span class="line">f[mid] = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (now) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &lt;= r; ++ i) f[i] = m + <span class="number">1</span>;</span><br><span class="line">dsu.<span class="built_in">back</span>(bac);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">solve</span>(l, mid - <span class="number">1</span>, sl, sr, ls), dsu.<span class="built_in">back</span>(st);</span><br><span class="line">&#125;</span><br><span class="line">dsu.<span class="built_in">back</span>(bac), <span class="built_in">solve</span>(l, mid - <span class="number">1</span>, sl, f[mid], ls);</span><br><span class="line">dsu.<span class="built_in">back</span>(st), now = frm;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = std::<span class="built_in">max</span>(sl, r + <span class="number">1</span>); i &lt; f[mid]; ++ i) &#123;</span><br><span class="line">dsu.<span class="built_in">merge</span>(opt[i].first, opt[i].second);</span><br><span class="line">dsu.<span class="built_in">merge</span>(opt[i].first ^ <span class="number">1</span>, opt[i].second ^ <span class="number">1</span>);</span><br><span class="line">now &amp;= <span class="built_in">check</span>(opt[i].first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">solve</span>(mid + <span class="number">1</span>, r, f[mid], sr, now), dsu.<span class="built_in">back</span>(st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>, m, <span class="number">1</span>, m + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;分治的妙妙题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="分治" scheme="https://mydcwfy.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="并查集" scheme="https://mydcwfy.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>高精度模板</title>
    <link href="https://mydcwfy.github.io/2022/04/04/high-precision/"/>
    <id>https://mydcwfy.github.io/2022/04/04/high-precision/</id>
    <published>2022-04-04T10:36:39.000Z</published>
    <updated>2022-04-04T11:07:17.566Z</updated>
    
    <content type="html"><![CDATA[<p>暂不支持负数，可以支持 NTT 加速。</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Polynomial &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">21</span> | <span class="number">10</span>, Mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> rev[N], wn[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x += x &gt;&gt; <span class="number">31</span> &amp; Mod; &#125;</span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL a, LL k = Mod - <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = a * a % Mod)</span><br><span class="line">(k &amp; <span class="number">1</span>) &amp;&amp; (res = res * a % Mod);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poly_bit</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (len &lt;&lt; <span class="number">1</span>)) bit ++;</span><br><span class="line"><span class="keyword">return</span> bit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poly_rev</span><span class="params">(<span class="keyword">int</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; bit); ++ i)</span><br><span class="line">rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> bit, <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">poly_rev</span>(bit);</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &lt; rev[i]) std::<span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LL ak = <span class="built_in">qpow</span>(inv == <span class="number">1</span> ? <span class="number">3</span> : (Mod + <span class="number">1</span>) / <span class="number">3</span>, (Mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">wn[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mid; ++ i) wn[i] = wn[i - <span class="number">1</span>] * ak % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> *a1 = a + i, *a2 = a + i + mid, *w = wn, *ed = a2; a1 &lt; ed; ++ a1, ++ a2, ++ w)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = *a1, y = *a2 * <span class="built_in">LL</span>(*w) % Mod;</span><br><span class="line">*a1 = <span class="built_in">adj</span>(x + y - Mod), *a2 = <span class="built_in">adj</span>(x - y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inv == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">LL Inv = <span class="built_in">qpow</span>(tot);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = a[i] * Inv % Mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Cannot calculate negative numbers</span></span><br><span class="line"><span class="comment">/// using mul(), qpow() (calculated using NTT) when necesary, otherwise use operator *, pow()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigNumber</span> &#123;</span></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> a[x]; &#125;</span><br><span class="line"><span class="built_in">BigNumber</span>() &#123;  &#125;</span><br><span class="line"><span class="built_in">BigNumber</span>(LL x) &#123; <span class="keyword">while</span> (x) a.<span class="built_in">push_back</span>(x % <span class="number">10</span>), x /= <span class="number">10</span>; <span class="keyword">if</span> (a.<span class="built_in">empty</span>()) a.<span class="built_in">push_back</span>(<span class="number">0</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">len</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a.<span class="built_in">size</span>(); &#125;</span><br><span class="line"><span class="keyword">friend</span> BigNumber <span class="keyword">operator</span> +(BigNumber a, BigNumber b)</span><br><span class="line">&#123;</span><br><span class="line">BigNumber res;</span><br><span class="line">res.a.<span class="built_in">resize</span>(std::<span class="built_in">max</span>(a.<span class="built_in">len</span>(), b.<span class="built_in">len</span>()) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>, sz = a.<span class="built_in">len</span>() + b.<span class="built_in">len</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++ i)</span><br><span class="line">t += a[i] + b[i], res[i] = t % <span class="number">10</span>, t /= <span class="number">10</span>;</span><br><span class="line"><span class="built_in">assert</span>(!t);</span><br><span class="line"><span class="keyword">while</span> (res.<span class="built_in">len</span>() &gt; <span class="number">1</span> &amp;&amp; !res.a.<span class="built_in">back</span>()) res.a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> BigNumber <span class="keyword">operator</span> +(LL a, BigNumber b) &#123; <span class="keyword">return</span> <span class="built_in">BigNumber</span>(a) + b; &#125;</span><br><span class="line"><span class="keyword">friend</span> BigNumber <span class="keyword">operator</span> +(BigNumber b, LL a) &#123; <span class="keyword">return</span> <span class="built_in">BigNumber</span>(a) + b; &#125;</span><br><span class="line">BigNumber&amp; <span class="keyword">operator</span> +=(BigNumber b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> + b; &#125;</span><br><span class="line">BigNumber&amp; <span class="keyword">operator</span> +=(LL b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> + b; &#125;</span><br><span class="line"><span class="keyword">friend</span> BigNumber <span class="keyword">operator</span> *(BigNumber a, BigNumber b)</span><br><span class="line">&#123;</span><br><span class="line">BigNumber res;</span><br><span class="line">res.a.<span class="built_in">resize</span>(a.<span class="built_in">len</span>() + b.<span class="built_in">len</span>() + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">len</span>(); ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.<span class="built_in">len</span>(); ++ j)</span><br><span class="line">res[i + j] += a[i] * b[j];</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">len</span>(); ++ i) t += res[i], res[i] = t % <span class="number">10</span>, t /= <span class="number">10</span>;</span><br><span class="line"><span class="built_in">assert</span>(!t);</span><br><span class="line"><span class="keyword">while</span> (res.<span class="built_in">len</span>() &gt; <span class="number">1</span> &amp;&amp; !res.a.<span class="built_in">back</span>()) res.a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> BigNumber <span class="keyword">operator</span> *(BigNumber a, LL b) &#123; <span class="keyword">return</span> a * <span class="built_in">BigNumber</span>(b); &#125;</span><br><span class="line">BigNumber&amp; <span class="keyword">operator</span> *=(BigNumber b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> * b; &#125;</span><br><span class="line">BigNumber&amp; <span class="keyword">operator</span> *=(LL b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> * <span class="built_in">BigNumber</span>(b); &#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(BigNumber a, BigNumber b) &#123; <span class="keyword">return</span> a.a == b.a; &#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(BigNumber a, BigNumber b) &#123;</span><br><span class="line"><span class="keyword">if</span> (a.<span class="built_in">len</span>() ^ b.<span class="built_in">len</span>()) <span class="keyword">return</span> a.<span class="built_in">len</span>() &lt; b.<span class="built_in">len</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = a.<span class="built_in">len</span>() - <span class="number">1</span>; ~j; -- j)</span><br><span class="line"><span class="keyword">if</span> (a[j] ^ b[j]) <span class="keyword">return</span> a[j] &lt; b[j];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;(BigNumber a, BigNumber b) &#123; <span class="keyword">return</span> b &lt; a; &#125;</span><br><span class="line"><span class="keyword">friend</span> BigNumber <span class="keyword">operator</span> -(BigNumber a, BigNumber b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(a &gt; b || a == b);</span><br><span class="line">BigNumber res;</span><br><span class="line">res.a.<span class="built_in">resize</span>(a.<span class="built_in">len</span>()), b.a.<span class="built_in">resize</span>(a.<span class="built_in">len</span>());</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">len</span>(); ++ i)</span><br><span class="line">t += a[i] - b[i], t += <span class="number">1000</span>, res[i] = t % <span class="number">10</span>, t /= <span class="number">10</span>, t -= <span class="number">100</span>;</span><br><span class="line"><span class="built_in">assert</span>(!t);</span><br><span class="line"><span class="keyword">while</span> (res.<span class="built_in">len</span>() &gt; <span class="number">1</span> &amp;&amp; !res.a.<span class="built_in">back</span>()) res.a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">BigNumber <span class="keyword">operator</span> -(LL b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> - <span class="built_in">BigNumber</span>(b); &#125;</span><br><span class="line">BigNumber&amp; <span class="keyword">operator</span> -=(BigNumber b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> - b; &#125;</span><br><span class="line">BigNumber&amp; <span class="keyword">operator</span> -=(LL b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> - <span class="built_in">BigNumber</span>(b); &#125;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> BigNumber <span class="title">mul</span><span class="params">(BigNumber a, BigNumber b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Polynomial;</span><br><span class="line"><span class="keyword">int</span> bit = <span class="built_in">poly_bit</span>(std::<span class="built_in">max</span>(a.<span class="built_in">len</span>(), b.<span class="built_in">len</span>()) + <span class="number">1</span>), tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">a.a.<span class="built_in">resize</span>(tot), b.a.<span class="built_in">resize</span>(tot), <span class="built_in">NTT</span>(a.a.<span class="built_in">data</span>(), bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b.a.<span class="built_in">data</span>(), bit, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = (LL)a[i] * b[i] % Mod;</span><br><span class="line"><span class="built_in">NTT</span>(a.a.<span class="built_in">data</span>(), bit, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">len</span>(); ++ i) t += a[i], a[i] = t % <span class="number">10</span>, t /= <span class="number">10</span>;</span><br><span class="line"><span class="built_in">assert</span>(!t);</span><br><span class="line"><span class="keyword">while</span> (a.a.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; !a.a.<span class="built_in">back</span>()) a.a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">friend</span> BigNumber <span class="title">pow</span><span class="params">(BigNumber a, LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">BigNumber <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>, a = a * a)</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) res = res * a;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">friend</span> BigNumber <span class="title">qpow</span><span class="params">(BigNumber a, LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">BigNumber <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>, a = <span class="built_in">mul</span>(a, a))</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) res = <span class="built_in">mul</span>(res, a);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) ;</span><br><span class="line">a.<span class="built_in">push_back</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) a.<span class="built_in">push_back</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">std::<span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">len</span>() - <span class="number">1</span>; ~j; -- j) <span class="built_in">putchar</span>(a[j] | <span class="number">48</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span> &gt;&gt;(std::istream &amp;is, BigNumber &amp;t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> &amp;a = t.a;</span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ((is &gt;&gt; c, c) &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) ;</span><br><span class="line">a.<span class="built_in">push_back</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> ((is &gt;&gt; c, c) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) a.<span class="built_in">push_back</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">std::<span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt;(std::ostream &amp;os, BigNumber t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l = t.<span class="built_in">len</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; ~i; -- i) os &lt;&lt; t[i];</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;暂不支持负数，可以支持 NTT 加速。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>狄利克雷生成函数</title>
    <link href="https://mydcwfy.github.io/2022/04/02/Dirichlet-generating-function/"/>
    <id>https://mydcwfy.github.io/2022/04/02/Dirichlet-generating-function/</id>
    <published>2022-04-01T23:40:53.000Z</published>
    <updated>2022-04-02T02:53:17.838Z</updated>
    
    <content type="html"><![CDATA[<p>解决数论函数的有利武器。</p><span id="more"></span><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>定义一个数列的<strong>狄利克雷生成函数</strong>（DGF）为：<br>$$<br>\tilde F(x) = \sum_{i\geq 1} \dfrac{f_i}{i^x}<br>$$<br>我们如果将 ${f_i}$ 看作是一个从 $\mathbb N _ +$ 到 $\mathbb Z$ 的一个函数，那么该生成函数就与一个数论函数相对应。一般来说，$f_1 = 1$。下文默认 $f_1 = 1$。</p><p>如果该函数是积性的，即满足 $\forall i\bot j, f(ij) = f(i) \times f(j)$，那么 $\tilde F(x)$ 的表达可以由质数以及质数的幂的值来表达，记作（设 $P$ 表示全体质数集合）：<br>$$<br>\tilde F(x) = \prod_{p\in P}(1 + \dfrac {f(p)}{p ^ x} + \dfrac{f(p) ^ 2}{p ^ {2x}} + …)<br>$$</p><h2 id="2-狄利克雷函数的卷积"><a href="#2-狄利克雷函数的卷积" class="headerlink" title="2. 狄利克雷函数的卷积"></a>2. 狄利克雷函数的卷积</h2><p>就是一个简单的定义。</p><p>定义：<br>$$<br>\tilde F(x)\tilde G(x) = \sum_{ij}\dfrac {f(i)g(j)}{ij}<br>$$<br>这个和 $(f * g)(x) = \sum_{d | x}f(d)g(\dfrac xd)$ 是相同的。</p><h2 id="3-常见函数"><a href="#3-常见函数" class="headerlink" title="3. 常见函数"></a>3. 常见函数</h2><h3 id="1）常值函数"><a href="#1）常值函数" class="headerlink" title="1）常值函数"></a>1）常值函数</h3><p>在数论中，我们常见到 $I(x) = 1$ 的函数，即 ${1, 1, 1, …}$ 的数列。他的 DGF 为<strong>黎曼函数</strong>，记作 $\zeta (x)$。</p><p>常值函数显然也是积性函数，我们尝试使用质数及质数的幂的值来表达，即：<br>$$<br>\tilde F(x) = \prod_{p\in P}(1 + \dfrac 1{p ^ x} + \dfrac 1{p ^ {2x}} + …)<br>$$<br>我们将质数内部的用等比数列求和展开，公比 $p^{-x}$，即为：<br>$$<br>1 + \dfrac 1{p ^ x} + \dfrac 1{p ^ {2x}} + … = \dfrac{-1}{p ^ {-x} - 1} = \dfrac 1{1 - p^{-x}}<br>$$<br>那么，我们得到黎曼函数的另外的表达方式：<br>$$<br>\zeta(x) = \prod_{p\in P}\dfrac 1{1 - p ^ {-x}}<br>$$</p><h3 id="2）标号函数"><a href="#2）标号函数" class="headerlink" title="2）标号函数"></a>2）标号函数</h3><p>（记不得叫什么了</p><p>定义 $id(x) = x$，那么我们来探究一下 ${1, 2, 3\dots}$ 的 DGF。</p><p>还是根据积性函数的性质，我们可以得到：<br>$$<br>\tilde F(x) = \prod_{p\in P}(1 + \dfrac{p}{p ^ x} + \dfrac{p ^ 2}{p ^ {2x}}+ \dots)<br>$$<br>等比数列求和，可以得到：<br>$$<br>\tilde F(x) = \prod_{p\in P}\dfrac 1{1 - p ^ {1 - x}}<br>$$<br>而这个由可以表示成黎曼函数：<br>$$<br>\tilde F(x) = \zeta(x - 1)<br>$$<br>如果我们将这个换成 $id ^ k(x) = x ^ k$，那么答案就是：<br>$$<br>\tilde F(x) = \prod_{p\in P}\dfrac 1{1 - p ^ {k - x}} = \zeta(x - k)<br>$$</p><h3 id="3）莫比乌斯函数"><a href="#3）莫比乌斯函数" class="headerlink" title="3）莫比乌斯函数"></a>3）莫比乌斯函数</h3><p>对于一般的函数，我们通常讨论在质数点的取值来得到 DGF。<br>$$<br>\tilde F(x) = \prod_{p\in P}(1 + \dfrac{-1}{p ^ x}) = \prod_{p\in P}\dfrac{p ^ x - 1}{p ^ x}<br>$$<br>这个怎样用黎曼函数表示呢？</p><p>发现 $\displaystyle \dfrac 1{\tilde F(x)} = \prod_{p\in P}\dfrac{p ^ x}{p ^ x - 1} = \prod_{p\in P}\dfrac 1{1 - p ^ {-x}} = \zeta(x)$，所以 $\tilde F(x) = \dfrac 1{\zeta(x)}$。</p><h3 id="4）欧拉函数"><a href="#4）欧拉函数" class="headerlink" title="4）欧拉函数"></a>4）欧拉函数</h3><p>同样，直接上式子：<br>$$<br>\tilde F(x) = \prod_{p\in P}(1 + \dfrac{p - 1}{p ^ x} + \dfrac{p(p - 1)}{p ^ {2x}} + \dfrac{p ^ 2(p - 1)}{p ^ {3x}} + \dots)<br>$$<br>我们直接考虑先改成封闭形式：<br>$$<br>\begin{aligned}<br>\tilde F(x) &amp;= \prod_{p\in P}(1 + \dfrac{p}{p ^ x} + \dfrac{p ^ 2}{p ^ {2x}} + \dots - \dfrac{1}{p ^ x} (1 + \dfrac{p}{p ^ x} + …))<br>\\&amp;= \prod_{p\in P}(\dfrac 1{1 - p ^ {1 - x}} - \dfrac{p ^ {-x}}{1 - p ^ {1 - x}}) \\ &amp;= \prod_{p\in P}\dfrac{1 - p ^ {-x}}{1 - p ^ {1 - x}}<br>\\ &amp;= \dfrac{\zeta(x - 1)}{\zeta(x)}<br>\end{aligned}<br>$$<br>那么，这个和 $id^0 = I$ 卷积，就可以得到：$\dfrac{\zeta(x - 1)}{\zeta(x)} * \zeta(x) = \zeta(x - 1)$。这对应着 $id(x)$。</p><h3 id="5）约数-k-次幂"><a href="#5）约数-k-次幂" class="headerlink" title="5）约数 k 次幂"></a>5）约数 k 次幂</h3><p>首先定义 $\sigma_0(x) = \sum_{d | x}$，表示约数个数。而 $\sigma_k(x) = \sum_{d | x}d ^ k$。这里给出 $\sigma_1(k)$ 的推导。<br>$$<br>\begin{aligned}<br>\tilde F(x) &amp;= \prod_{p\in P}(1 + \dfrac{p ^ 2 - 1}{p ^ x(p - 1)} + \dfrac{p ^ 3 - 1}{p ^ {2x}(p - 1)} + \dots)<br>\\ &amp;= \prod_{p\in P}\dfrac 1{p - 1}((\dfrac{p}{p ^ {0x}} + \dfrac{p ^ 2}{p ^ x} + \dots) - (\dfrac{1}{p ^ {0x}} + \dfrac{1}{p ^ {x}} + \dots))<br>\\ &amp;= \prod_{p \in P}\dfrac 1{p - 1}(\dfrac{p}{1 - p ^ {1 - x}} - \dfrac{1}{1 - p ^ {-x}})<br>\\ &amp;= \prod_{p\in P}\dfrac 1{p - 1}\dfrac{p - 1}{(1 - p ^ {1 - x})(1 - p ^ {-x})}<br>\\ &amp;= \prod_{p\in P}\dfrac{1}{(1 - p^{-x})(1 - p^{1 - x})}<br>\\ &amp;= \zeta(x)\zeta(x - 1)<br>\end{aligned}<br>$$<br>而对于 $\sigma_k(x) = \sum_{d | x}d ^ k$，我们有：$\tilde F(x) = \zeta(x)\zeta(x - k)$。本处证明略去。</p><h3 id="6）乘上-x-k"><a href="#6）乘上-x-k" class="headerlink" title="6）乘上  $x^k$"></a>6）乘上  $x^k$</h3><p><strong>结论：</strong>若 $f(x)$ 的 DGF 是 $\tilde F(x)$，那么 $g(x) = f(x)\times x ^ k$ 的 DGF 是 $\tilde G(x) = \tilde F(x - k)$。这个可以通过改变质数处的取值得到。证明略去。</p><h2 id="4-例题"><a href="#4-例题" class="headerlink" title="4. 例题"></a>4. 例题</h2><h3 id="T1：简单的数学题"><a href="#T1：简单的数学题" class="headerlink" title="T1：简单的数学题"></a>T1：简单的数学题</h3><p>求 $\sum_{i = 1}^n i ^ 2\varphi(i)$，使用杜教筛。</p><p>直接使用 $\tilde F(x) = \dfrac{\zeta(x - 3)}{\zeta(x - 2)}$，那么 $f(i) * id^2(i) = id^3(i)$。直接筛就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">get_sphi</span><span class="params">(LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; N) <span class="keyword">return</span> sphi[n];</span><br><span class="line"><span class="keyword">if</span> (Sphi.<span class="built_in">find</span>(n) != Sphi.<span class="built_in">end</span>()) <span class="keyword">return</span> Sphi[n];</span><br><span class="line">LL ans = <span class="built_in">sum3</span>(n);</span><br><span class="line"><span class="keyword">for</span> (ll l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">ans = (-(<span class="built_in">sum2</span>(r) - <span class="built_in">sum2</span>(l - <span class="number">1</span>)) * <span class="built_in">get_sphi</span>(n / l) % Mod + ans + Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Sphi[n] = ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;解决数论函数的有利武器。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>NOI Online 2022 游记</title>
    <link href="https://mydcwfy.github.io/2022/04/01/NOI-Online-2022/"/>
    <id>https://mydcwfy.github.io/2022/04/01/NOI-Online-2022/</id>
    <published>2022-04-01T10:25:26.000Z</published>
    <updated>2022-04-01T23:46:30.026Z</updated>
    
    <content type="html"><![CDATA[<p>考的似乎比较套路，没有去年的思维 / 数学。</p><span id="more"></span><p>以考试当天为 Day 0。</p><h2 id="Day-？"><a href="#Day-？" class="headerlink" title="Day ？"></a>Day ？</h2><p>很早就报名了，都快忘记这件事了（</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>在学校考试。</p><p>校内又说什么要占机房考试，好不容易在 8：20 的时候才到机房安心坐下来。</p><p>8：30 开题，还好没咕，不像 NOI 线上，一个小时还没拿到题。</p><p>结果盯着 T1 发呆了许久，满脑子里都是二维数点 $O(n\log^2 n)$，根本做不了这题。半个小时过去了，没有任何收获。</p><p>意识到事情没对，马上开 T2，发现是一个输出一个方案即可的题，似乎哪年 NOI 考过这样的题，还是随机化过去的？</p><p>tg 应该不是这类题目，推了推性质，发现可以按 <code>size</code> 分类，相同 <code>size</code> 的只可能不交或是完全相同，否则一定合法。</p><p>胡了一个只用判 <code>size</code> 相邻的做法，发现没对，可以按 <code>size</code> 倒序插入，用桶维护哪个点被那个集合覆盖，如果新来的一个集合覆盖的颜色不止一种，一定合法。</p><p>赛时没想清楚，随便输出一个颜色，考后才发现要输出不同颜色中 <code>size</code> 最小的。</p><p>写完 T2，过样例，由于不会造数据，只好跳过。此时 10：10。</p><p>发现 T3 似乎是一个简单题，拆一拆贡献，记录每一个位置的数被统计为最大值 / 最小值了多少次，发现剩下的是一个三维偏序（才没想什么还可以转化为二维偏序的方法），可以 $O(n\log^2 n)$，做 8 次，感觉有点卡。</p><p>马上开始码，还算顺利，没调多久就过了所有样例，极限数据 1.79 s，感觉很稳。</p><p>回过头来看 T1，已是 10：50。大力猜一手结论，应该是直接找到后面第一个比自己大的，然后如果颜色相同一直向前跳，扫描线处理询问，可以做到 $O(n\log n)$（不算向前跳的假的复杂度）。</p><p>发现要码 2 个线段树，心态不好，看到自己只有 30 min 左右的时间了，结果写完死活过不了大样例，此时已经是 11：40 了。</p><p>发现中间有一步不应该将因颜色相同而跳过的点删去，改了过后，过了大样例，还只要 0.5 s，马上交上去，11：47。</p><p>跳了过程可以用并查集优化，快速码了一个，11：51，<del>发现自己 AK 了</del>，<strong>交不上去了！</strong></p><p>最后 10 min 中，在狂躁之中度过，发现一点转机都没有，守到 12 点，唉声叹气地走了。</p><p>出来议论，发现一些人做出来 T1 了，连低一个年级的同学都有人做出来。可惜我没交上去（悲</p><p>但是大家似乎没做出来 T3，似乎随便写写，得了个暴力 + 部分分。赶紧去食堂吃饭了。</p><p>下午还得考试，又回到机房，12：28，了转反，<strong>考试延期了半个小时！</strong></p><p>确认一下是不是真的，马上将自己的 T1 交了上去。不知道自己怎么样了呢。</p><p>水了一会，又去看各大 OJ 有没有测的，发现 InfOJ 可以测，<del>但是已经排了 24 页的提交记录了</del>。</p><p>13：30 左右，lg 可以测了，发现 T1，T2，T3 都过了，心态很不错。看到 T2 有人说要取 <code>size</code> 最小的，没在意。</p><p>等到看到 InfOJ 可以测 T2 时，发现只有 Subtask 2 没过，连 Subtask 6 都过了，80 pts。我相信 CCF 的数据应该不强（flag</p><p>lg 加强了几次 T2 数据，结果随便就过了，不知道该相信哪边（<del>事后看显然是 InfOJ</del></p><p>等 CCF 数据。</p><h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><p>看到 CCF 出了一个“成绩公示”，结果什么都是访问异常，啥也看不到。</p><p>看到有人说用另外的网址可以看到成绩，<strong>开幕雷击</strong>，一车人直接 AK 了！</p><p>发现 CCF 数据实在是强，直接 10 个点卡了我四个点，T2 直接 60 pts，和随机化寻找一个分了（<del>我可是写挂了正解呀</del></p><p>$100 + 60 + 100 = 260$。</p><p>结果 lg 上一车人说数据过水，痛苦面具。水一点该多好啊，<del>难得接近 AK 一次</del>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于这种偏结论或乱搞的题目，感觉自己很多细节没有想清楚，这种东西赛时很难检查到，赛后后悔也来不及了。还是多做这种结论题吧。</p><p>还有，怎么没考 DP？一考大概率裂开。</p><p>等联合省选。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;考的似乎比较套路，没有去年的思维 / 数学。&lt;/p&gt;</summary>
    
    
    
    
    <category term="游记" scheme="https://mydcwfy.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF Round#775</title>
    <link href="https://mydcwfy.github.io/2022/03/08/CF-Round-775/"/>
    <id>https://mydcwfy.github.io/2022/03/08/CF-Round-775/</id>
    <published>2022-03-08T10:30:50.000Z</published>
    <updated>2022-03-08T12:38:20.701Z</updated>
    
    <content type="html"><![CDATA[<p>状态不错，F 只想得到线段树，思路还没清晰，就结束了……</p><p>比赛记录：ABCDE Accepted，Scores：6328，Rank #7，Rating 1663 -&gt; 1962。</p><p>改题进度：ABCDE Accepted。</p><p><a href="https://codeforces.com/contest/1649/">比赛传送门</a></p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h3><p>题意不描述了。</p><p>签到题，从左端点一直向右走，从右端点一直向左走，遇上了就是 0，否则答案就是两点距离。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n &amp;&amp; a[i]) i ++;</span><br><span class="line"><span class="keyword">if</span> (i &gt; n) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j = n;</span><br><span class="line"><span class="keyword">while</span> (j &amp;&amp; a[j]) j --;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, j - i + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B."></a>B.</h3><p>题意：有 $n$ 个人传球，已知每个人传出的次数，可以拿到球后不传，问至少要多少个球。</p><p>考虑贪心，要满足传出次数最多的人，就让剩下的人都传给他，如果还不能满足，剩余的传出次数，每一个都要一个球。否则一个球就可以完成。</p><p>注意特判全是 0 的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) flag |= !!a[i];</span><br><span class="line"><span class="keyword">if</span> (!flag) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">LL sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) sum += a[i];</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">LL</span>(*std::<span class="built_in">max_element</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>)) &lt;&lt; <span class="number">1</span>) &lt;= sum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="number">2LL</span> * (*std::<span class="built_in">max_element</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>)) - sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h3><p>题意：给出 $n\times m$ 的矩形，每个点有一个颜色，求所有颜色相同的点两两之间的曼哈顿距离和。$n\times m \leq 10^5,c_{i, j}\leq 10^5$。</p><p>也许我的做法劣一些，但是也不慢，多一只 $\log$。</p><p>考虑将所有颜色相同的点按 $x$ 排序，统计答案的时候，由 $y$ 的情况分为两种：$y \leq y_{now}, y &gt; y_{now}$。分别用树状数组维护即可，时间复杂度 $O(nm\log m)$。</p><p>似乎可以直接拆贡献计算做到 $O(nm)$？没管。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span>  &#125; f, g, cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt; N; ++ c)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : al[c]) &#123;</span><br><span class="line">res += (LL)cnt.<span class="built_in">ask</span>(p.y) * (p.x + p.y) + f.<span class="built_in">ask</span>(p.y);</span><br><span class="line">res += (LL)(cnt.<span class="built_in">ask</span>(m) - cnt.<span class="built_in">ask</span>(p.y)) * (p.x - p.y) + (g.<span class="built_in">ask</span>(m) - g.<span class="built_in">ask</span>(p.y));</span><br><span class="line">f.<span class="built_in">add</span>(p.y, -p.x - p.y), g.<span class="built_in">add</span>(p.y, p.y - p.x), cnt.<span class="built_in">add</span>(p.y, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : al[c]) &#123;</span><br><span class="line">f.<span class="built_in">add</span>(p.y, p.x + p.y), g.<span class="built_in">add</span>(p.y, p.x - p.y), cnt.<span class="built_in">add</span>(p.y, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D."></a>D.</h3><p>题意：判断一个集合是否满足 $\forall x, y\in S\land x\geq y, s.t. \left\lfloor\dfrac xy \right\rfloor \in S$。$|S|\leq 10^6, \forall x \in S, x\leq 10^6$。</p><p>暴力枚举显然是 $O(n ^ 2)$ 的。</p><p>我们可以考虑枚举 $x$ 和 $\left\lfloor\dfrac yx\right\rfloor = k$，如果 $x$ 存在，$[kx, (k + 1)x)$ 中间也有数，那么 $k$ 必须存在，否则不合法。</p><p>看似是 $O(n ^ 2)$ 的，但是我们发现对于每个 $x$，需要枚举的 $k$ 仅为 $\dfrac{C}{x}$，其中 $C$ 为最大的数。</p><p>所以时间复杂度为 $O(C + \dfrac C2 + \dfrac C3 + …)$，为调和级数，$O(C\ln C)$。</p><p>至于怎么统计一个区间出现过没有数，直接前缀和即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++ i) h[i] += h[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++ i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = i, r, j = <span class="number">0</span>; l &lt;= c; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (h[i] == h[i - <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">r = std::<span class="built_in">min</span>(c, l + i - <span class="number">1</span>), j ++;</span><br><span class="line"><span class="keyword">if</span> (h[r] == h[l - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (h[j] == h[j - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E."></a>E.</h3><p>题意：给定由数字组成的字符串 $s$ 和 $t$，求有多少种重排后的 $s$ 满足 $s$ 的字典序小于 $t$，答案对 998244353 取模。$|s|, |t|\leq 2\cdot 10^5, s_i, t_i\leq 2\cdot 10^5$。</p><p>比较思维的一个组合计数，但不是特别难。</p><p>考虑类似数位 DP 的方法，枚举出现差异为第 $i$ 位，那么前 $i - 1$ 项都是相同的。</p><p>假设我们暴力的话，我们枚举 $i$ 填入的数，显然填入的数 $x &lt; b_i$，那么剩下的位置就可以随意组织了。因为有重复元素，不直接是阶乘，而是：<br>$$<br>ans = \dfrac{(n - i)!}{cnt_1!cnt_2!cnt_3!…}<br>$$<br>现在我们考虑快速将所有填入的 $x$ 的答案全部统计了。</p><p>假设我们不限制这一位，答案是：<br>$$<br>ans = \dfrac{(n - i + 1)!}{cnt_1!cnt_2!…cnt_x!…}<br>$$<br>限制之后，答案是：<br>$$<br>ans = \dfrac{(n - i)!}{cnt_1!cnt_2!…(cnt_x - 1)!…}<br>$$<br>所以我们要在原来的基础上乘以 $\dfrac{cnt_x}{n - i + 1}$。</p><p>所以我们直接维护 $cnt_x$ 的前缀和，用树状数组就可以在 $O(\log n)$ 的时间内维护。</p><p>至于如何维护不限制情况下的答案，我们也可以使用类似的办法。</p><p>填这一位之前：<br>$$<br>ans = \dfrac{(n - i + 1)!}{cnt_1!cnt_2!…cnt_x!…}<br>$$<br>假设 $b_i = x$，也就是我们要填入 $x$，那么答案变为了：<br>$$<br>ans = \dfrac{(n - i)!}{cnt_1!cnt_2!…(cnt_x - 1)!…}<br>$$<br>所以答案乘上了 $\dfrac{cnt_x}{n - i + 1}$，先维护每个数的逆元就可以 $O(1)$ 维护了。</p><p>可能无法在 $i$ 处填入 $b_i$，注意要快速退出。</p><p>注意如果 $n &lt; m$ 且前 $n$ 个都可以填入，答案要加 1（因为前面一样，长度小的排前面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span>  &#125; bt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = std::<span class="built_in">min</span>(n, m);</span><br><span class="line">LL res = <span class="number">0</span>, now = fact[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cnt[a[i]] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) now = now * infact[cnt[i]] % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) bt.<span class="built_in">add</span>(i, cnt[i]);</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">res = (res + bt.<span class="built_in">ask</span>(b[i] - <span class="number">1</span>) * now % Mod * inv[n - i + <span class="number">1</span>]) % Mod;</span><br><span class="line"><span class="keyword">if</span> (!cnt[b[i]]) &#123;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">bt.<span class="built_in">add</span>(b[i], <span class="number">-1</span>), now = now * inv[n - i + <span class="number">1</span>] % Mod * (cnt[b[i]] --) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (res + ((n &lt; m) &amp;&amp; flag)) % Mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;状态不错，F 只想得到线段树，思路还没清晰，就结束了……&lt;/p&gt;
&lt;p&gt;比赛记录：ABCDE Accepted，Scores：6328，Rank #7，Rating 1663 -&amp;gt; 1962。&lt;/p&gt;
&lt;p&gt;改题进度：ABCDE Accepted。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1649/&quot;&gt;比赛传送门&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>CF Round#773</title>
    <link href="https://mydcwfy.github.io/2022/02/25/CF-Round-773/"/>
    <id>https://mydcwfy.github.io/2022/02/25/CF-Round-773/</id>
    <published>2022-02-25T11:55:12.000Z</published>
    <updated>2022-02-25T13:54:48.552Z</updated>
    
    <content type="html"><![CDATA[<p>Div 2 当场降智，直接变成了 SpeedForces 了。</p><p>比赛记录：ABC Accepted，Scores：2247，Rank：872。</p><p>改题进度：ABCF Accepted。</p><span id="more"></span><h4 id="A"><a href="#A" class="headerlink" title="A"></a>A</h4><p>题意：给一个三角形，求不能通过不穿过三角形的直线到达 y 轴的线段长度。</p><p>显然如果想要不能到达 y 轴，一定是平行于 y 轴的线才有可能。</p><p>如果第三个点在这两个点的上方，答案也显然是 0：</p><img src="/2022/02/25/CF-Round-773/A.png" class=""><p>按 y 坐标排序即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PDD p[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++ i)</span><br><span class="line">std::cin &gt;&gt; p[i].first &gt;&gt; p[i].second;</span><br><span class="line">std::<span class="built_in">sort</span>(p, p + <span class="number">3</span>, [](PDD a, PDD b) &#123; <span class="keyword">return</span> a.second &lt; b.second ;&#125;);</span><br><span class="line"><span class="keyword">if</span> (p[<span class="number">1</span>].second != p[<span class="number">2</span>].second) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>, std::<span class="built_in">abs</span>(p[<span class="number">1</span>].first - p[<span class="number">2</span>].first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B"><a href="#B" class="headerlink" title="B"></a>B</h4><p>题意：给一个长度为 $n$ 的数组，对于每一个 $k\in[1, n]$，求出划分为 $k$ 个集合后，求每一个集合的不同元素的个数总和的最小值。</p><p>显然我们将相同的元素放在一起，答案也至少是这个数组中数的不同的个数 $j$。</p><p>显然答案 $\geq k$。尝试证明答案 $ans_k = \max(k, j)$。</p><p>当 $k &lt; j$ 的时候，我们将相同的放在一起，会出现 $j$ 个集合，然后任意合并一些，答案不变，所以 $ans_k = j$。</p><p>当 $k \geq j$ 的时候，我们仍然将相同的放在一起，然后操作 $k - j$ 次，每一次分裂一个集合。显然答案每次加 1，总答案为 $j + (k - j) = k$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (a[i] != a[i - <span class="number">1</span>]) cnt ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, cnt);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cnt + <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br></pre></td></tr></table></figure><h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><p>题意：定义一个数列是好的，为可以划分为 $\dfrac n2$ 对（显然 $n$ 为偶数），每一对中两数之商为 $x$。给一个序列，添加最少的数使得序列是好的。$n\leq 2\cdot 10^5,2\leq x \leq10^6$。</p><p>我们直接找到可以匹配的最大对数，让剩下的每一个都加一个数与之匹配即可。问题转化为求最大匹配数。</p><p>直接将所有数扔入一个 <code>multiset</code>，然后从小向大枚举。如果还没有匹配的话，说明不能和小的匹配，直接找一个 $a_i \cdot x$，看一下有没有，有就删一个。</p><p>最后直接输出 <code>multiset</code> 的 <code>size()</code> 即可。</p><p>注意如果只删一个数，应该写为 <code>erase(find(x))</code> 而不是 <code>erase(x)</code>，那样会删掉所有的相同元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::multiset&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>(); iter ++)</span><br><span class="line">&#123;</span><br><span class="line">LL now = *iter;</span><br><span class="line"><span class="keyword">auto</span> t = a.<span class="built_in">find</span>(now * x);</span><br><span class="line"><span class="keyword">if</span> (t != a.<span class="built_in">end</span>()) a.<span class="built_in">erase</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in"><span class="keyword">int</span></span>(a.<span class="built_in">size</span>()));</span><br></pre></td></tr></table></figure><h4 id="F"><a href="#F" class="headerlink" title="F"></a>F</h4><p>给定 $n$ 个长度为 $m$ 的数组，每个数组有一个权值 $w$，找到两个数组使得数字没有重复，求这两个数组权值和的最小值。$n \leq 10^5, m\leq 5$，保证一个数组内数字没有重复。</p><p>比赛直接降智，胡了个错误的 Tarjan，没想到暴力就过去了……</p><p>笔者也不会题解主要介绍的方法 $O(n2^m)$，但是 $O(\dfrac{n^2m}\omega)$ 的算法就是香啊！</p><p>我们直接考虑暴力怎么做：直接枚举每一个数，将包含这个数的所有数组互相都设为不可用。即开一个二维 <code>boolean</code> 数组，$a[i][j]$ 表示 $i, j$ 数组能不能选在一起。枚举每一个数时，设包含这个数的数组集合为 $S$，则 $[i \in S][j \in S] a[i][j] \leftarrow 0$。</p><p>看到我们只用枚举每个数，我们可以先存下来每一个数对应的 $S$（？，然后枚举到一个数组的时候，直接 &amp;$S$ 即可。时空复杂度均为 $O(\dfrac{n^2m}\omega)$，然后就成功 MLE（还不是最惨的，我加了些优化，变为了 $O(\dfrac {n^2}\omega)$）：</p><img src="/2022/02/25/CF-Round-773/F_submission.png" class=""><p>怎么办呢？</p><p>我们发现，有很多 $S$ 只有一两个位置有 $1$，但是我们却存了不知多少个 0。我们直接考虑设定阈值 $T$，当 $\mid S \mid \leq T$ 时我们直接让 $S$ 暴力更新即可。可以发现，最多有 $\dfrac {nm}T$ 个数我们要开 $\text{bitset}$，所以空间复杂度为 $O(nm + \dfrac{n^2m}{T\omega})$，时间复杂度为 $O(nmT + \dfrac{n^2m}{w})$，取 $T = 500\sim 1000$ 比较合适的样子。（但是我开的 50 也过了</p><p>注意指针等的使用，可能有些难写，给出整个代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, Block = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arr</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>], w;</span><br><span class="line">&#125; c[N];</span><br><span class="line">std::bitset&lt;N&gt; bt[<span class="number">505</span>], tmp, *bk[N &lt;&lt; <span class="number">3</span>], *it = bt;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; al, ha[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">al.<span class="built_in">reserve</span>(n * m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i].a[j]);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i].w);</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(c + <span class="number">1</span>, c + n + <span class="number">1</span>, [&amp;](<span class="keyword">const</span> Arr &amp;c1, <span class="keyword">const</span> Arr &amp;c2) &#123; <span class="keyword">return</span> c1.w &lt; c2.w; &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">al.<span class="built_in">push_back</span>(c[i].a[j]);</span><br><span class="line">std::<span class="built_in">sort</span>(al.<span class="built_in">begin</span>(), al.<span class="built_in">end</span>());</span><br><span class="line">al.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(al.<span class="built_in">begin</span>(), al.<span class="built_in">end</span>()), al.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">int</span> sz = al.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">c[i].a[j] = std::<span class="built_in">lower_bound</span>(al.<span class="built_in">begin</span>(), al.<span class="built_in">end</span>(), c[i].a[j]) - al.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) ha[c[i].a[j]].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (ha[i].<span class="built_in">size</span>() &lt;= Block) <span class="keyword">continue</span>;</span><br><span class="line">bk[i] = it ++, bk[i]-&gt;<span class="built_in">set</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> pos : ha[i]) bk[i]-&gt;<span class="built_in">reset</span>(pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">2e9</span> + <span class="number">7</span>, t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">std::bitset&lt;N&gt; now;</span><br><span class="line">now.<span class="built_in">set</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line"><span class="keyword">if</span> (ha[c[i].a[j]].<span class="built_in">size</span>() &lt;= Block)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> pos : ha[c[i].a[j]]) now[pos] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> now &amp;= *bk[c[i].a[j]];</span><br><span class="line"><span class="keyword">if</span> ((t = now._Find_next(<span class="number">0</span>)) &lt;= n) ans = std::<span class="built_in">min</span>(ans, c[i].w + c[t].w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Div 2 当场降智，直接变成了 SpeedForces 了。&lt;/p&gt;
&lt;p&gt;比赛记录：ABC Accepted，Scores：2247，Rank：872。&lt;/p&gt;
&lt;p&gt;改题进度：ABCF Accepted。&lt;/p&gt;</summary>
    
    
    
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>Min_25 筛</title>
    <link href="https://mydcwfy.github.io/2022/02/13/Min-25-Sieve/"/>
    <id>https://mydcwfy.github.io/2022/02/13/Min-25-Sieve/</id>
    <published>2022-02-13T04:57:51.000Z</published>
    <updated>2022-02-15T23:54:32.011Z</updated>
    
    <content type="html"><![CDATA[<p>非常 NB 的一个筛法，虽然复杂度可能会趋近线性 $O(n ^ {1 - \epsilon})$，但是在 OI 范围内非常不错。</p><span id="more"></span><h2 id="1-算法介绍"><a href="#1-算法介绍" class="headerlink" title="1. 算法介绍"></a>1. 算法介绍</h2><p>要么是 $O(\dfrac{n ^ {\frac34}}{\log n})$，还有一种是 $O(n ^ {1 - \epsilon})$，反正可以在 $10^{10}$ 范围内跑 1s 左右。</p><h2 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2. 算法流程"></a>2. 算法流程</h2><p>感觉比杜教筛更好构造。</p><p>假设 $f(x)$ 的前缀和是我们要求的。</p><p>分为两步：先求出在当 $x \in P$（表示 $x$ 是质数）的 $f(x)$ 的前缀和，第二步通过质数的前缀和求出整个的前缀和。</p><h3 id="1）求-g-x-f-x-x-in-P-的前缀和"><a href="#1）求-g-x-f-x-x-in-P-的前缀和" class="headerlink" title="1）求 $g(x) = f(x)[x \in P]$  的前缀和"></a>1）求 $g(x) = f(x)[x \in P]$  的前缀和</h3><p>我们找到一个多项式 $g(x)$，使得 $x \in P$ 的时候 $f(x) = g(x)$。</p><p>定义 $\text{lpf}(x)$ 是 $x$ 的最小质因数，$p_x$ 表示第 $x$ 个质数。</p><p>先将多项式拆为多个 $x ^ k$，这样的话 $g(x)$ 就是一个完全积性函数了，即满足 $g(ab) = g(a) \cp g(b)$。</p><p>我们定义 $h(n, k) = \sum_{i = 1}^n [i \in P \lor \text{lpf}(i) &gt; p_k]g(i)$。</p><p><del>（显然状态数比 $n$ 还大）</del></p><p>我们考虑从 $h(…, k - 1)$ 转移到 $h(n, k)$。</p><p>考虑 $h(n, k - 1)$ 变为 $h(n, k)$，需要减去 $\text{lpf}(x) = p_k$ 的数。</p><p>如果我们将 $x$ 除以 $p_k$，又怎么样呢？</p><p>那么剩下的变为 $\text{lpf}(\dfrac x{p_k})\geq p_k$。至于为什么是 $\geq$，是因为可能有单个数可能有多个 $p_k$ 质因子。</p><p>这不和 $h(\dfrac n{p_k}, k - 1)$ 定义很像了吗！</p><p>对比一下：<br>$$<br>\begin{aligned}<br>h(\dfrac n{p_k}, k - 1) &amp;= \sum_{i = 1}^{\frac n{p_k}}[i \in P \lor \text{lpf}(i) \geq p_k]g(i)\\<br>&amp;= \sum_{i = 1}^{\frac n{p_k}}[\text{lpf}(i) \geq p_k]g(i) + h(p_{k - 1}, p_{k - 1})<br>\end{aligned}<br>$$<br>其中为什么要加 $h(p_{k - 1}, p_{k - 1})$ 呢？因为 $h(\dfrac n{p_k}, k - 1)$ 包含了 $[1, \dfrac{n}{p_k}]$ 所有质数，而小于 $p_k$ 的质数我们前面的是没有计算到的，所以要加上 $[1, p_{k - 1}]$ 的所有质数的函数值，显然 $g(p_{k - 1}, p_{k - 1})$ 就可以满足要求。这样我们就可以得出：<br>$$<br>\begin{aligned}<br>\sum_{i = 1}^{\frac n{p_k}}[\text{lpf}(i) \geq p_k]g(i) = h(\dfrac n{p_k}, k - 1) - h(p_{k - 1}, p_{k - 1})<br>\end{aligned}<br>$$<br>又由于 $g$ 是完全积性函数（记得前面我们拆开多项式的目的吗？），我们可以得到这样的递推式：<br>$$<br>\begin{aligned}<br>h(n, k) &amp;= h(n, k - 1) - \sum_{i = 1}^n [\text{lpf}(i) = p_k] g(i)\\<br>&amp;= h(n, k - 1) - g(p_k)\sum_{i = 1}^{\frac n{p_k}} [\text{lpf}(i) \geq p_k]g(i)\\<br>&amp;= h(n, k - 1) - g(p_k)(h(\dfrac n{p_k}, k - 1) - h(p_{k - 1}, k - 1))<br>\end{aligned}<br>$$<br>按照这个递推，最后我们就可以得到所有质数位置的值的前缀和，即为 $h(n, k)$，其中 $p_k &gt; \sqrt n$。</p><h3 id="2）根据质数点的值求整个的前缀和"><a href="#2）根据质数点的值求整个的前缀和" class="headerlink" title="2）根据质数点的值求整个的前缀和"></a>2）根据质数点的值求整个的前缀和</h3><p>现在我们经过第一步的计算，已经知道了只有质数点的值 $g(x) = [x \in P]f(x)$ 的前缀，记为 $r(x)$。</p><p>我们定义 $S(n, k)$ 表示 $\displaystyle \sum_{i = 2}^n [\text{lpf}(i) &gt; p_k]f(k)$。</p><p>类似刚刚推导 $h(n, k)$ 的方法，我们可以较为简单的求，注意是积性函数而不是完全积性函数。</p><p>我们考虑最小的质因数 $p_v &gt; p_k$，然后枚举 $p_v$ 的指数。如是就可以从 $S(\dfrac n{p_v^e}, v)$ 转移，因为剩下的质因数都得大于 $p_v$。</p><p>注意我们的 $S(n, k)$ 没有定义 1，所以我们还要先加上 $&gt; p_k$ 的质数的所有的和，这样我们就可以直接使用 $r(n) - h(p_k, k)$ 代替。</p><p>注意如果 $e \not= 1$，$p_v^e$ 本身就是合数，没有包含在 $r(n) - h(p_k, k)$ 中，所以我们要加上他们。</p><p>根据积性函数的定义，我们可以得到：<br>$$<br>\begin{aligned}<br>S(n, k) = r(n) - h(p_k, k) + \sum_{v = i + 1}^{p_v \leq n}\sum_{e = 1}^{p_v^e \leq n} f(p_v^e)(S(\dfrac n{p_e^v}, v) + [v\not= 1])<br>\end{aligned}<br>$$</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p>显然，如果一个数不是质数，那么 $\text{lpf}(n) \leq \sqrt n$，所以我们计算 $h(n, k)$ 的时候可以直接处理 $[1, \sqrt n]$ 的所有质数就可以了。</p><p>但是我们如果直接循环 $h(i, k)(i \in [1, n], p_k \leq \sqrt n)$，那么肯定暴力都跑不过。</p><p>可以发现，除了 $h(p_{k - 1}, k - 1)$，其余都是和 $n$ 有关。又有一个整除的小定理：<br>$$<br>\left\lfloor\dfrac{\left\lfloor\dfrac na\right\rfloor}{b}\right\rfloor = \left\lfloor\dfrac n{ab}\right\rfloor<br>$$<br>这说明，不管我们除什么，前面的 $h(n, k), h(\dfrac n{p_k}, k - 1)$ 都只会访问到 $\dfrac ni(i \in [1, n])$，而这个最多只有 $O(\sqrt n)$ 个取值。</p><p>这个实现可以直接整除分块，将可以访问到的值存到两个数组，可以表示为：<br>$$<br>id(x) =<br>\begin{cases}<br>id1(x) (x \leq \sqrt n)\\<br>id2(\left\lfloor\dfrac nx\right\rfloor) (x &gt; \sqrt n)<br>\end{cases}<br>$$<br>当然偷懒的话可以多一个 $\log$ 的 <code>map</code>，但是似乎也不难，直接写整除分块了（本身算法就有点卡，还是不要给自己添麻烦吧 qwq</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_id</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x &lt;= sq ? id1[x] : id2[n / x];&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (LL l = <span class="number">1</span>, r, t; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = n / (n / l), t = n / r;</span><br><span class="line">a[++ tot] = t;<span class="comment">//a 存的是这个位置存的是哪个数</span></span><br><span class="line"><span class="keyword">if</span> (t &lt;= sq) id1[t] = tot;</span><br><span class="line"><span class="keyword">else</span> id2[n / t] = tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接着简单的分析复杂度：枚举质数 $O(\dfrac{\sqrt n}{\ln \sqrt n})$，枚举 $O(\sqrt n)$ 个数，前面时间复杂度为 $O(\dfrac n{\ln \sqrt n})$，显然跑不进 1s。</p><p>我们还有一个优化：在枚举 $h(n, k)$ 的时候，我们可以发现 $h(\dfrac n{p_k}, k - 1) - h(p_{k - 1}, k - 1)$ 有贡献时，肯定需要满足 $\dfrac{n}{p_k} \geq p_k$，否则 $h(\dfrac n{p_k}, k - 1)$ 就全是质数，并且只有 $[1, p_k)$ 中的质数，也就是 $h(p_{k - 1}, k - 1)$，那么后面贡献就是 0。所以我们只需枚举 $n$ 到 $p_k ^ 2$。</p><p>另外，$h(p_{k - 1}, k - 1)$ 最多也只有 $O(\dfrac{\sqrt n}{\ln \sqrt n})$ 个，我们直接预处理就可以了。这个我们记为 $sp_{k - 1}$。</p><p>（代码用的是 $g(n, k)$ 表示 $h(n, k)$，且只开了一维数组，因为访问的时候一定是标号小（即对应的 <code>a[]</code> 大）的从小的转移，可以用标号从小到大）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">LL le = (LL)prime[i] * prime[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; a[j] &gt;= le; ++ j)</span><br><span class="line">g[j] -= g[<span class="built_in">get_id</span>(a[j] / prime[i])] - sp[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于后面是同样的，我们计算 $S(n, k)$ 时，如果 $p_v^2 &gt; n$，只能枚举 $e = 1$，那么 $[e \not= 1] = 0$，$S(\dfrac{n}{p_v}, v)$ 由于 $\dfrac n{p_v} &lt; p_v$ 所以就为 0，我们就无需枚举。</p><p>反正后面 $S(n, k)$ 是不需要记忆化的（跑得还挺快</p><p>最后注意 $S(n, 0) = \sum_{i = 2}^n f(i)$，返回这个，需要加 $f(1)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">S</span><span class="params">(LL n, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (prime[i] &gt;= n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> now = <span class="built_in">get_id</span>(n);</span><br><span class="line">LL res = (f[now] - sp[i] + Mod) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nw = i + <span class="number">1</span>; nw &lt; cnt &amp;&amp; ((LL)prime[nw]) * prime[nw] &lt;= n; ++ nw)</span><br><span class="line"><span class="keyword">for</span> (LL now = prime[nw], k = <span class="number">1</span>; now &lt;= n; k ++, now *= prime[nw])&#123;</span><br><span class="line">LL t = now % Mod;</span><br><span class="line">res = (res + <span class="built_in">f</span>(now) % Mod * ((<span class="built_in">S</span>(n / now, nw) + (k != <span class="number">1</span>)) % Mod) % Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-例题"><a href="#4-例题" class="headerlink" title="4. 例题"></a>4. 例题</h2><h4 id="T1：区间素数个数"><a href="#T1：区间素数个数" class="headerlink" title="T1：区间素数个数"></a>T1：区间素数个数</h4><p><a href="https://loj.ac/p/6235">题目传送门 LOJ</a></p><p>观察到这个函数并不是积性函数，所以我们似乎没法使用杜教筛等算法求解。</p><p><del>观察标题可得，</del>我们可以发现，$h(n, x)(p_x &gt; \sqrt n)$ 就是 $\sum_{i = 1}^n[i \in P]g(i)$，我们直接让 $g(x) = 1$，即可求出 $[1, n]$ 的质数个数即可。</p><details><summary> 点击查看代码 </summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> id1[N], id2[N], tot, prime[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line">LL g[N], n, sq, a[N], sp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">st[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) prime[cnt ++] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; i * prime[j] &lt; N; ++ j)</span><br><span class="line">&#123;</span><br><span class="line">st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_id</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x &lt;= sq ? id1[x] : id2[n / x];&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this problem has a times 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solveg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i) sp[i] = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) g[i] = a[i] - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">LL le = (LL)prime[i] * prime[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; a[j] &gt;= le; ++ j)</span><br><span class="line">g[j] -= g[<span class="built_in">get_id</span>(a[j] / prime[i])] - sp[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line">sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="built_in">sieve</span>(sq + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (LL l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">a[++ tot] = n / r;</span><br><span class="line"><span class="keyword">if</span> (n / r &lt;= sq) id1[n / r] = tot;</span><br><span class="line"><span class="keyword">else</span> id2[n / (n / r)] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">solveg</span>();</span><br><span class="line">std::cout &lt;&lt; g[<span class="built_in">get_id</span>(n)] &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h4 id="T2：简单的函数"><a href="#T2：简单的函数" class="headerlink" title="T2：简单的函数"></a>T2：简单的函数</h4><p><a href="https://loj.ac/p/6053">题目传送门 LOJ</a></p><p>首先有一个小学老师教的结论：偶质数只有 2。</p><p>那么，$f(i) = i\oplus 1 (i \in P)$ 就是：<br>$$<br>\begin{cases}<br>i - 1 (i \not= 2)\\<br>i - 1 + 2 (i = 2)<br>\end{cases}<br>$$<br>我们就可以通过先筛 $g(i) = i,g(i) = 1$ 来得到 $f(i)(i \in P)$。</p><p>最后，我们计算 $\sum_{i = 1}^n f(i)$ 的时候，由于 $f(2) = 3$，所以我们在筛到 $2$ 的时候应该加上 2。</p><p>具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">S</span><span class="params">(LL n, <span class="keyword">int</span> x)</span><span class="comment">//x 从 0  开始标号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (prime[x] &gt;= n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">LL res = (f[<span class="built_in">get_id</span>(n)] - sp[x] + Mod + <span class="number">2</span> * (x == <span class="number">-1</span> &amp;&amp; n &gt; <span class="number">1</span>)) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nw = x + <span class="number">1</span>; (LL)prime[nw] * prime[nw] &lt;= n &amp;&amp; nw &lt; cnt; ++ nw)</span><br><span class="line"><span class="keyword">for</span> (LL k = <span class="number">1</span>, pk = prime[nw]; pk &lt;= n; ++ k, pk *= prime[nw])</span><br><span class="line">res += (prime[nw] ^ k) * (<span class="built_in">S</span>(n / pk, nw) + (k != <span class="number">1</span>)) % Mod;</span><br><span class="line"><span class="keyword">return</span> res % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3：DIVCNTK"><a href="#T3：DIVCNTK" class="headerlink" title="T3：DIVCNTK"></a>T3：DIVCNTK</h4><p><a href="https://www.spoj.com/problems/DIVCNTK/">题目传送门 SPOJ</a></p><p>要求 $\sum_{i = 1}^n d(i ^ k)\bmod 2^{64}$，其中 $d(x)$ 代表 $x$ 的约数个数。</p><p>我们可以简单的发现，$d(x ^ k)$ 是积性函数：$d(a^kb^k) = d(a^k)d(b^k) (a \perp b)$。</p><p>令 $f(x) = d(x ^ k)$，我们再尝试推一下 $f(p ^ c) = c(k + 1)$。发现这是一个简单的多项式，我们尝试拆开 $f(p^c) = c$，Min_25 筛即可。</p><p>代码不给了，留作练习题<del>（逃</del></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;非常 NB 的一个筛法，虽然复杂度可能会趋近线性 $O(n ^ {1 - \epsilon})$，但是在 OI 范围内非常不错。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>AGC016F 题解</title>
    <link href="https://mydcwfy.github.io/2022/02/07/AGC016F/"/>
    <id>https://mydcwfy.github.io/2022/02/07/AGC016F/</id>
    <published>2022-02-07T13:28:46.000Z</published>
    <updated>2022-02-07T13:32:49.745Z</updated>
    
    <content type="html"><![CDATA[<p>$SG$ 函数的妙用。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给定一个有向图，其中边都是小编号向大编号连边。现在 Alice 和 Bob 交替移动两个石子。两个石子最开始在 1 和 2。</p><p>现在要求只保留一些边，求在剩下的图中 Alice 能胜的情况个数。答案模 $1e9 + 7$。</p><h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2. 题解"></a>2. 题解</h2><p>很明显，我们需要求 $sg(1) != sg(2)$ 的方案数，这个可以简单的用总数减 $sg(1) = sg(2)$  的方案数。</p><p>怎么做呢？</p><p>我们枚举点集 $S$，让这些点的 $sg(x) = 0$，设剩下的点集为 $T$。</p><p>明显，$S$ 之间没有边，$T$ 中的点都有至少一条边连向 $S$。</p><p>然后，我们如果将 $S$ 删去，那么 $sg(x), x\in T$ 都会减 1。于是就可以从 $f(T)$ 转移到 $f(S \cup T)$。</p><p>题目给的限制就是 $1, 2$ 被分在同一个集合里了。</p><p>我们暴力枚举 $S$，枚举子集的时间复杂度为 $O(3 ^ n)$，可以通过。</p><p><strong>总结：删掉 $sg = 0$ 的状态，所有状态 $sg$ 减一。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">out[-- u] |= (<span class="number">1</span> &lt;&lt; -- v);</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j; j = (j - <span class="number">1</span>) &amp; i)&#123;</span><br><span class="line"><span class="keyword">if</span> ((i &amp; <span class="number">1</span>) ^ (i &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> ((j &amp; <span class="number">1</span>) ^ (j &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">LL now = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++ k)</span><br><span class="line"><span class="keyword">if</span> ((i ^ j) &gt;&gt; k &amp; <span class="number">1</span>) now = now * (pw[cnt[out[k] &amp; j]] - <span class="number">1</span>) % Mod;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j &gt;&gt; k &amp; <span class="number">1</span>) now = now * (pw[cnt[out[k] &amp; (i ^ j)]]) % Mod;</span><br><span class="line">f[i] = (f[i] + f[i ^ j] * now) % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;$SG$ 函数的妙用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="SG 函数" scheme="https://mydcwfy.github.io/tags/SG-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF566C</title>
    <link href="https://mydcwfy.github.io/2022/01/24/CF566C/"/>
    <id>https://mydcwfy.github.io/2022/01/24/CF566C/</id>
    <published>2022-01-24T12:37:14.000Z</published>
    <updated>2022-04-04T13:32:18.912Z</updated>
    
    <content type="html"><![CDATA[<p>求导的思想找极值点挺不错的，还有点分治降低树的高度。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p><a href="https://www.luogu.com.cn/problem/CF566C">题目传送门 Luogu</a></p><p><a href="https://codeforces.com/problemset/problem/566/C">题目传送门 Codeforces</a></p><p>求有点权、边的长度的树的重心，距离定义为 $(\sum w)^{\frac32}$，注意要求落在点上，并且求出该点到其他点的距离和。</p><p>$n\leq 2 \times 10 ^ 5$。</p><h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2. 题解"></a>2. 题解</h2><p>首先，暴力 $O(n ^ 2)$ 可以 TLE。</p><p>假设距离和函数为 $f(x) = \sum_{i = 1}^n d(i, x)^\frac32$。</p><p>我们考虑假设退化成一条链的情况：这个一定是一个下凸函数，我们可以直接三分答案，每一次求 $f(x)$ 为 $O(n)$ 的，总复杂度为 $O(n \log n)$。</p><p>可不可以不用三分呢？</p><p>观察到这个函数是一个多项式，我们可以对其求导。</p><p>最开始，这个导函数一直是负，突然到了最优解 $u$ 附近的时候，边为了正，很明显，我们可以先得到导函数，再对导函数二分查找第一次变为正的位置。</p><p>但是我们来到树上的时候，不能一步跳很远，只能单步跳，时间复杂度明显和高度 $h$ 有关，为 $O(nh)$，怎么办呢？</p><p>相信你已经想到了，直接<strong>点分治重构树</strong>！</p><p>我们看一下哪棵子树的导函数是小于 0 的，有小于 0 的向那边跳就是了。</p><p>同时有前面的理论，我们可以发现，树的重心一定只有一个（可能不在点上而在边上），他向四周扩散都是变大的。</p><p>我们层层逼近，一定只有 $\log n$ 层，时间复杂度为 $O(n \log n)$，可以通过。</p><p><strong>总结：求导逼近极值点；点分治降低树高度</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">double</span> &amp;dev, <span class="keyword">int</span> nowd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// if (vis[x]) return;</span></span><br><span class="line">sum += <span class="built_in">pow</span>(nowd, <span class="number">1.5</span>) * a[x], dev += <span class="number">1.5</span> * <span class="built_in">sqrt</span>(nowd) * a[x];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (e[i] != fa) <span class="built_in">dfs</span>(e[i], x, dev, nowd + w[i]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[x]) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">get_wc</span>(x, <span class="number">-1</span>, <span class="built_in">get_size</span>(x, <span class="number">-1</span>), x);<span class="comment">//求重心</span></span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> sumd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line">dv[e[i]] = <span class="number">0</span>, <span class="built_in">dfs</span>(e[i], x, dv[e[i]], w[i]), sumd += dv[e[i]];<span class="comment">//求导数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum &lt; res) res = sum, ansu = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sumd - <span class="number">2</span> * dv[e[i]] &lt;= <span class="number">0</span>)&#123;<span class="comment">//这里是一步推导，我们如果向这边的话，其他的导数为正，这个为负，也就是总和减去两倍当前的导数</span></span><br><span class="line"><span class="built_in">work</span>(e[i]);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;求导的思想找极值点挺不错的，还有点分治降低树的高度。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数据结构" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="分治" scheme="https://mydcwfy.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="点分治和点分树" scheme="https://mydcwfy.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB%E5%92%8C%E7%82%B9%E5%88%86%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>UOJ671诡异操作 题解</title>
    <link href="https://mydcwfy.github.io/2022/01/24/UOJ671/"/>
    <id>https://mydcwfy.github.io/2022/01/24/UOJ671/</id>
    <published>2022-01-24T11:40:42.000Z</published>
    <updated>2022-02-22T14:06:18.232Z</updated>
    
    <content type="html"><![CDATA[<p>思想值得借鉴。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p><a href="https://uoj.ac/problem/671">题目传送门 UOJ</a></p><p>给定长度为 $n$ 的数组，最大为 $2^{128} - 1$，要求支持以下操作：</p><ol><li>$\forall i \in [l, r],\  a(i):= \dfrac{a(i)}{v}$。</li><li>$\forall i \in [l, r],\ a(i) := a(i)$ &amp; $v$。</li><li>求 $\sum_{i = l}^r a(i)$，答案对 $2^{128}$ 取模。</li></ol><p>$n\leq 3\times10^5, q\leq 2 \times 10 ^ 5$，时限 3s，空间 1GB。</p><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><p>$a(i)$ 用 <code>__uint128_t</code> 存储，可能常数有<del>亿</del>点大。</p><p>首先观察 $a(i)$ 在操作中不断减小，所以最多被除 $\log a(i)$ 次，存一下该区间有没有非 0 的数，没有的话直接退出。时间复杂度易得为 $O(q(\log n + \log a(i)))$。</p><p>对于第二个操作，我们可以先在这个区间上打一个标记，然后可以用一个 128 的数组存下来每一位出现了多少次，然后 &amp;v 的时候直接将对应的 1 位赋值为 0，更新答案即可。时间复杂度为 $O(q\log n\log a(i))$。<del>（然后你会发现 5000 的点都要跑 1s+）</del></p><p>怎么优化呢？</p><p>我们只要考虑压缩 128 的数组。这个数组每一个数都不大于 $len$，用 short 就可以存下来，显然信息密度不够。</p><p>我们考虑<strong>将 128 数组里的每一个位里存的数二进制拆分，然后将答案存入一个 $\log len$ 的数组。</strong></p><p>具体来说，比如有一个 $2^5$ 出现了 5 次，那么我们就在 $cnt[0]$ 和 $cnt[2]$ 插入 $2^5$。这样就可以实现一个 $\log a_i$ 向 $\log len$ 的方向转变。</p><p>我们再来看，如果 &amp;v 的时候怎么样呢？之间每一位都 &amp;v 就可以了，因为每一位存的是出现 $2^i$ 次的数的总和，而又不会互相干扰。</p><p>求和的时候，直接 $\sum cnt(i) \times 2^i$ 就可以了，时间复杂度同样是 $\log len$。</p><p>所以我们就可以得到复杂度为 $O(\log n \log len) = O(\log^2 n)$。</p><p>总时间复杂度为 $O(q(\log a(i) + \log^2 n))$，空间复杂度 $O(n \log n)$，卡一卡就可以过了。（但是有些 Hack 数据真的毒瘤，$cnt$ 数组用 <code>vector</code> 实现就 T 了，必须使用数组。</p><p><strong>总结：可以将一个 $\log a$ 长但存的数不大的数组通过二进制拆分的手段压缩为 $\log len$。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) (x &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) (x &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="keyword">using</span> u128 = <span class="keyword">__uint128_t</span>;</span><br><span class="line"><span class="keyword">const</span> u128 Mand = <span class="number">-1</span>;<span class="comment">//明显任意一个数 &amp;Mand 不变</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[x].any = tr[<span class="built_in">l</span>(x)].any | tr[<span class="built_in">r</span>(x)].any;</span><br><span class="line">u128 now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tr[x].sz; ++ i)&#123;</span><br><span class="line">u128 le = i &lt; tr[<span class="built_in">l</span>(x)].sz ? tr[<span class="built_in">l</span>(x)].cnt[i] : <span class="number">0</span>,</span><br><span class="line">ri = i &lt; tr[<span class="built_in">r</span>(x)].sz ? tr[<span class="built_in">r</span>(x)].cnt[i] : <span class="number">0</span>;</span><br><span class="line">tr[x].cnt[i] = (le ^ ri) ^ now;</span><br><span class="line">now = (le &amp; ri) | ((le ^ ri) &amp; now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_and</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">const</span> u128 &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[x].lt &amp;= v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tr[x].sz; ++ i) tr[x].cnt[i] &amp;= v;</span><br><span class="line">tr[x].any = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tr[x].sz; ++ i) tr[x].any |= (tr[x].cnt[i] &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].lt == Mand) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">update_and</span>(<span class="built_in">l</span>(x), tr[x].lt), <span class="built_in">update_and</span>(<span class="built_in">r</span>(x), tr[x].lt);</span><br><span class="line">tr[x].lt = Mand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_div</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">const</span> u128 &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tr[x].any) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l == tr[x].r)</span><br><span class="line">&#123;</span><br><span class="line">tr[x].cnt[<span class="number">0</span>] /= v, tr[x].any = (tr[x].cnt[<span class="number">0</span>] &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="built_in">update_div</span>(<span class="built_in">l</span>(x), v), <span class="built_in">update_div</span>(<span class="built_in">r</span>(x), v);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_and</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">const</span> u128 &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> <span class="built_in">update_and</span>(x, v);</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="keyword">int</span> mid = (tr[x].l + tr[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify_and</span>(<span class="built_in">l</span>(x), l, r, v);</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify_and</span>(<span class="built_in">r</span>(x), l, r, v);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_div</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">const</span> u128 &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> <span class="built_in">update_div</span>(x, v);</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="keyword">int</span> mid = (tr[x].l + tr[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify_div</span>(<span class="built_in">l</span>(x), l, r, v);</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify_div</span>(<span class="built_in">r</span>(x), l, r, v);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;思想值得借鉴。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="线段树" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>最小圆覆盖</title>
    <link href="https://mydcwfy.github.io/2022/01/20/mininum-circle/"/>
    <id>https://mydcwfy.github.io/2022/01/20/mininum-circle/</id>
    <published>2022-01-20T10:31:26.000Z</published>
    <updated>2022-01-20T11:58:39.381Z</updated>
    
    <content type="html"><![CDATA[<p>还是一个计算几何。</p><span id="more"></span><h2 id="1-性质"><a href="#1-性质" class="headerlink" title="1. 性质"></a>1. 性质</h2><h3 id="1）唯一性"><a href="#1）唯一性" class="headerlink" title="1）唯一性"></a>1）唯一性</h3><p>明显，如果我们能找到两个圆的话，他们的交也一定是可以的。我们可以尝试构造以相交的弦为直径构造一个圆，很明显会更小。</p><img src="/2022/01/20/mininum-circle/%E5%94%AF%E4%B8%80%E6%80%A7.png" class=""><h3 id="2）"><a href="#2）" class="headerlink" title="2）"></a>2）</h3><p><strong>如果 $P$ 不在集合 $S$ 的最小覆盖圆的内部，则 $P$ 在 ${P}\cup S$ 的最小覆盖圆的边上。</strong></p><p>首先，一个最小覆盖圆肯定会经过集合内的至少三个点。（在集合点数 $\geq 3$ 的时候）</p><p>反证：假设 $P$ 不在 ${P}\cup S$ 的最小覆盖圆的边上，那么 ${P}\cup S$ 的最小覆盖圆就是 $S$ 的最小覆盖圆。</p><p>但是 $S$ 的最小覆盖圆是无法覆盖到 $P$ 的，所以就会导致 ${P}\cup S$ 的最小圆覆盖无法覆盖到 $P$，矛盾，故原命题成立。</p><h2 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2. 算法流程"></a>2. 算法流程</h2><p>首先随机化，防止复杂度退化。</p><p>接着，我们将圆设置为 $(p(1), 0)$，表示圆心和半径。</p><p>然后，我们枚举每一个点，如果当前点 $p(i)$ 不在最小覆盖圆里的话，那么，我们由前面的性质得到，$p(i)$ 一定在 ${1, …, i}$ 的最小圆覆盖的边上。</p><p>现在，我们将圆设置为 $(p(i), 0)$，然后再暴力枚举前面的点。</p><p>如果如果 $p(j)$ 不在圆内的话，那么 $p(j)$ 在 ${1, …, j}\cup{i}$ 的最小圆覆盖的边上。同时，由于 $p(i)$ 不在 ${1, …, i - 1}$ 的最小圆覆盖里，那么一定导致 $p(i)$ 不在 ${1, …, j}$ 的最小覆盖圆上。</p><p>那么，我们就可以得到，$p(i), p(j)$ 都在 ${1, …, j}\cup {i}$ 的圆的边上。</p><p>因为找一个圆需要 $3$ 个点才能确定，所以我们再去寻找一个点。</p><p>我们将圆设置为 $p(i), p(j)$ 为直径的圆，再从前循环 $p(k)$，寻找到 $p(k)$ 不在 $p(i), p(j)$ 为直径的圆上。仿照前面的证明，我们就可以得到 $p(k), p(i), p(j)$ 都在圆上，我们就是求出了 ${1, …, k} \cup{i, j}$ 的最小圆覆盖。</p><p>最后我们一直循环，直到最后覆盖到了 ${1, …, i - 1}\cup{i}$ 也就是 ${1, …, i}$ 的圆覆盖。</p><h2 id="3-复杂度"><a href="#3-复杂度" class="headerlink" title="3. 复杂度"></a>3. 复杂度</h2><p>看似有 $O(n ^ 3)$，但是两步判断都是 $\dfrac{3}{n}$ 的概率，我们就可以得到时间复杂度为 $O(n)$。（感觉特别玄学</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">get_point</span><span class="params">(Point p1, Point k1, Point p2, Point k2)</span></span>&#123;</span><br><span class="line">Point u = p1 - p2;</span><br><span class="line"><span class="keyword">double</span> t = (k2 * u) / (k1 * k2);</span><br><span class="line"><span class="keyword">return</span> p1 + k1 * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Circle <span class="title">circle_by_point</span><span class="params">(Point a, Point b, Point c)</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> l1 = <span class="built_in">get_line</span>(a, b), l2 = <span class="built_in">get_line</span>(a, c);</span><br><span class="line">Point o = <span class="built_in">get_point</span>(l1.first, l1.second, l2.first, l2.second);</span><br><span class="line"><span class="keyword">return</span> &#123;o, <span class="built_in">dist2</span>(a, o)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Circle <span class="title">min_circle</span><span class="params">(Point *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">random_shuffle</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line">Circle ans = &#123;p[<span class="number">1</span>], <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">in_circle</span>(ans, p[i])) <span class="keyword">continue</span>;</span><br><span class="line">ans = &#123;p[i], <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++ j)&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">in_circle</span>(ans, p[j])) <span class="keyword">continue</span>;</span><br><span class="line">ans = &#123;(p[i] + p[j]) / <span class="number">2</span>, <span class="built_in">dist2</span>((p[i] + p[j]) / <span class="number">2</span>, p[i])&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; j; ++ k)</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">in_circle</span>(ans, p[k])) ans = <span class="built_in">circle_by_point</span>(p[i], p[j], p[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans.r = <span class="built_in">sqrt</span>(ans.r);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;还是一个计算几何。&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算几何" scheme="https://mydcwfy.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>凸包与旋转卡壳</title>
    <link href="https://mydcwfy.github.io/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/"/>
    <id>https://mydcwfy.github.io/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/</id>
    <published>2022-01-19T10:37:25.000Z</published>
    <updated>2022-01-21T12:51:18.703Z</updated>
    
    <content type="html"><![CDATA[<p>前置知识：计算几何。</p><span id="more"></span><h2 id="1-凸包"><a href="#1-凸包" class="headerlink" title="1. 凸包"></a>1. 凸包</h2><p>直接理解为我们用一条橡皮筋围住这些点。</p><p>我们就不再介绍 Javis 算法，直接介绍两个时间复杂度更优的 Graham 和 Andrew 算法。</p><h3 id="1）Graham-算法"><a href="#1）Graham-算法" class="headerlink" title="1）Graham 算法"></a>1）Graham 算法</h3><p>我们首先选择最左下方的点，注意到这个点一定是凸包上的点。假设这个点为 A。</p><p>接着，我们按照 A 点与这些点的连线与水平线的夹角排序。注意到如果夹角相同，将最远的点放在最前面。</p><p>接着，我们扫描整个数组，同时维护一个栈，记录当前的凸包里的点。</p><p>我们要加入一个点的时候，如果当前的栈里的点会和这个点形成一个顺时针的转角的话，我们就将栈顶弹出。</p><img src="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/%E5%87%B8%E5%8C%851.png" class=""><p>看到这个图，我们现在要将红线上面的点加入，容易发现红线下面这个点是一定不需要的，我们直接弹出即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Point &amp;t1, <span class="keyword">const</span> Point &amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t1 - p[<span class="number">1</span>]) * (t2 - p[<span class="number">1</span>]) &gt; eps || (<span class="built_in">fabs</span>((t1 - p[<span class="number">1</span>]) * (t2 - p[<span class="number">1</span>])) &lt; eps &amp;&amp; <span class="built_in">dist</span>(p[<span class="number">1</span>], t1) &gt; <span class="built_in">dist</span>(p[<span class="number">1</span>], t2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    <span class="keyword">if</span> (p[i].y &lt; p[t].y || (<span class="built_in">fabs</span>(p[i].y - p[t].y) &lt; eps &amp;&amp; p[i].x &lt; p[t].x)) t = i;</span><br><span class="line"><span class="built_in">swap</span>(p[<span class="number">1</span>], p[t]);</span><br><span class="line"><span class="built_in">sort</span>(p + <span class="number">2</span>, p + n + <span class="number">1</span>, cmp);</span><br><span class="line">stk[++ top] = p[<span class="number">1</span>], stk[++ top] = p[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; (stk[top] - stk[top - <span class="number">1</span>]) * (p[i] - stk[top]) &lt; -eps) top --;</span><br><span class="line">    stk[++ top] = p[i];</span><br><span class="line">&#125;</span><br><span class="line">stk[++ top] = p[<span class="number">1</span>];<span class="comment">//第一个点进入两次，便于计算周长面积</span></span><br></pre></td></tr></table></figure><h3 id="2）Andrew-算法"><a href="#2）Andrew-算法" class="headerlink" title="2）Andrew 算法"></a>2）Andrew 算法</h3><p>我们不再按照夹角排序，直接使用 x 坐标排序，结果又如何呢？</p><p>我们这么遍历，发现只会走到一半的凸壳。</p><p>于是，我们再会过来遍历一次，就可以把另一半的凸壳遍历到了！</p><p>这个算法避免的一些复杂的夹角的计算，常数略小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2)</span></span>&#123;<span class="keyword">return</span> (p1.x == p2.x) ? (p1.y &lt; p2.y) : p1.x &lt; p2.x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Andrew</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; (p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> ((p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt; <span class="number">0</span>) usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> top --;</span><br><span class="line">usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">usd[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (usd[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; (p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> ((p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt; <span class="number">0</span>) usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> top --;</span><br><span class="line">usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）例题"><a href="#3）例题" class="headerlink" title="3）例题"></a>3）例题</h3><h4 id="T1：信用卡凸包"><a href="#T1：信用卡凸包" class="headerlink" title="T1：信用卡凸包"></a>T1：信用卡凸包</h4><p><a href="https://www.luogu.com.cn/problem/P3829">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2938/">题目传送门 AcWing</a></p><p>我们可以发现，一个凸多边形的外角是 $360^{\circ}$。</p><p>那么，圆形一定贡献的是一个周角的大小。剩下的，我们发现可以向内平移到圆心的位置。按圆心凸包即可。</p><img src="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/%E5%87%B8%E5%8C%852.png" class=""><p>可以发现，黑直线的长度就是红线的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %lf %lf %lf&quot;</span>, &amp;n, &amp;a, &amp;b, &amp;R);</span><br><span class="line">a -= <span class="number">2</span> * R, b -= <span class="number">2</span> * R;</span><br><span class="line"><span class="keyword">double</span> x, y, th;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf&quot;</span>, &amp;x, &amp;y, &amp;th);</span><br><span class="line">x += eps, y += eps, th += eps;</span><br><span class="line">p[(i &lt;&lt; <span class="number">2</span>) - <span class="number">3</span>] = (Point)&#123;x, y&#125; + <span class="built_in">rotate</span>(&#123;b / <span class="number">2</span>, a / <span class="number">2</span>&#125;, th);</span><br><span class="line">p[(i &lt;&lt; <span class="number">2</span>) - <span class="number">2</span>] = (Point)&#123;x, y&#125; + <span class="built_in">rotate</span>(&#123;-b / <span class="number">2</span>, a / <span class="number">2</span>&#125;, th);</span><br><span class="line">p[(i &lt;&lt; <span class="number">2</span>) - <span class="number">1</span>] = (Point)&#123;x, y&#125; + <span class="built_in">rotate</span>(&#123;-b / <span class="number">2</span>, -a / <span class="number">2</span>&#125;, th);</span><br><span class="line">p[(i &lt;&lt; <span class="number">2</span>)] = (Point)&#123;x, y&#125; + <span class="built_in">rotate</span>(&#123;b / <span class="number">2</span>, -a / <span class="number">2</span>&#125;, th);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Andrew</span>(n &lt;&lt; <span class="number">2</span>);</span><br><span class="line"><span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; ++ i)</span><br><span class="line">res += <span class="built_in">dist</span>(p[stk[i]], p[stk[i + <span class="number">1</span>]]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>, res + <span class="number">2</span> * <span class="built_in">acos</span>(<span class="number">-1</span>) * R);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-半平面交"><a href="#2-半平面交" class="headerlink" title="2. 半平面交"></a>2. 半平面交</h2><p>我们介绍一种办法（我似乎并不知道是什么算法），能在 $O(n \log n)$ 的时间求出围住的凸多边形（注意好像不能判断无解的情况）。</p><p>为了方便，我们定义半平面存储为一条有向直线，在这条直线逆时针（可以理解为左边）的部分即为半平面。</p><h3 id="1）算法流程"><a href="#1）算法流程" class="headerlink" title="1）算法流程"></a>1）算法流程</h3><p>我们首先按照每条线与 $x$ 轴的夹角排序，如果相同，说明是平行的，我们按照从左至右的顺序。</p><p>然后，我们顺次插入每一个半平面。我们维护一个如此的双端队列来表示当前的半平面。</p><img src="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A41.png" class=""><p>接着，我们插入的时候，看一下有没有在当前半平面外面的交点，也就是判断有没有在直线顺时针的点，有的话就删除。</p><img src="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A42.png" class=""><p>比如蓝点在新加入的蓝线右边，所以肯定会导致最后加入的黑线被弹出队尾。</p><p>注意有可能线的方向不定导致会弹出队首，所以前后都要判断。</p><p>最后的时候，我们再用队首来尝试弹出队尾，队尾尝试弹出队首。</p><p>注意我们求夹角的时候，可以使用 <code>atan2(x, y)</code>，这样可以防止出现 <code>nan</code> 的情况，因为他会判断 $y$ 是否等于 0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">get_point_</span><span class="params">(Point p1, Point k1, Point p2, Point k2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point u = p1 - p2;</span><br><span class="line"><span class="keyword">double</span> t = (k2 * u) / (k1 * k2);</span><br><span class="line"><span class="keyword">return</span> &#123;t * k1.x + p1.x, t * k1.y + p1.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">get_point</span><span class="params">(<span class="keyword">const</span> Line &amp;l1, <span class="keyword">const</span> Line &amp;l2)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">get_point_</span>(l1.st, l1.ed - l1.st, l2.st, l2.ed - l2.st);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">on_right</span><span class="params">(<span class="keyword">const</span> Line &amp;a, <span class="keyword">const</span> Line &amp;b, <span class="keyword">const</span> Line &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point t = <span class="built_in">get_point</span>(b, c);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sgn</span>((a.ed - a.st) * (t - a.st)) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">half_plane</span><span class="params">(Line l[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(l + <span class="number">1</span>, l + n + <span class="number">1</span>, lcmp);</span><br><span class="line">hh = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; !<span class="built_in">cmp</span>(<span class="built_in">angle</span>(l[i]), <span class="built_in">angle</span>(l[i - <span class="number">1</span>]))) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[i], l[q[tt - <span class="number">1</span>]], l[q[tt]])) tt --;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[i], l[q[hh]], l[q[hh + <span class="number">1</span>]])) hh ++;</span><br><span class="line">q[++ tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[q[hh]], l[q[tt - <span class="number">1</span>]], l[q[tt]])) tt --;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[q[tt]], l[q[hh]], l[q[hh + <span class="number">1</span>]])) hh ++;</span><br><span class="line">q[++ tt] = q[hh];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）例题"><a href="#2）例题" class="headerlink" title="2）例题"></a>2）例题</h3><h4 id="T2：-JLOI-2013-赛车"><a href="#T2：-JLOI-2013-赛车" class="headerlink" title="T2：[JLOI 2013]赛车"></a>T2：[JLOI 2013]赛车</h4><p><a href="https://www.luogu.com.cn/problem/P3256">题目传送门 Luogu</a></p><p>半平面交的模板题，注意用 <code>long double</code>，并且把精度调高一点。</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> LD;</span><br><span class="line"><span class="keyword">const</span> LD eps = <span class="number">1e-18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">LD x, y;</span><br><span class="line">Point <span class="keyword">operator</span> +(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x + t.x, y + t.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Point <span class="keyword">operator</span> -(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">LD <span class="keyword">operator</span> *(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * t.y - y * t.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">Point st, ed;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; id;</span><br><span class="line">&#125;l[N];</span><br><span class="line"><span class="keyword">int</span> q[N], hh, tt;</span><br><span class="line"><span class="keyword">int</span> ki[N], vi[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> angle = [](<span class="keyword">const</span> Line &amp;l)&#123;<span class="keyword">return</span> <span class="built_in">atan2</span>(l.ed.y - l.st.y, l.ed.x - l.st.x);&#125;;</span><br><span class="line"><span class="keyword">auto</span> sgn = [](LD x)&#123;<span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">fabs</span>(x) &lt; eps) ? <span class="number">0</span> : (x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>);&#125;;</span><br><span class="line"><span class="keyword">auto</span> cmp = [](LD x, LD y)&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>(x - y);&#125;;</span><br><span class="line"><span class="keyword">auto</span> lcmp = [](<span class="keyword">const</span> Line &amp;l1, <span class="keyword">const</span> Line &amp;l2)&#123;</span><br><span class="line">LD A = <span class="built_in">angle</span>(l1), B = <span class="built_in">angle</span>(l2);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cmp</span>(A, B) == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">sgn</span>((l1.ed - l1.st) * (l2.ed - l1.st)) &lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> A &lt; B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">get_point_</span><span class="params">(Point p1, Point k1, Point p2, Point k2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point del = p1 - p2;</span><br><span class="line">LD t = (k2 * del) / (k1 * k2);</span><br><span class="line"><span class="keyword">return</span> &#123;t * k1.x + p1.x, t * k1.y + p1.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">get_point</span><span class="params">(<span class="keyword">const</span> Line &amp;l1, <span class="keyword">const</span> Line &amp;l2)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">get_point_</span>(l1.st, l1.ed - l1.st, l2.st, l2.ed - l2.st);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">on_right</span><span class="params">(<span class="keyword">const</span> Line &amp;a, <span class="keyword">const</span> Line &amp;b, <span class="keyword">const</span> Line &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point t = <span class="built_in">get_point</span>(b, c);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sgn</span>((t - a.st) * (a.ed - a.st)) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">half_plane</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(l + <span class="number">1</span>, l + n + <span class="number">1</span>, lcmp);</span><br><span class="line">hh = <span class="number">1</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; !<span class="built_in">cmp</span>(<span class="built_in">angle</span>(l[i]), <span class="built_in">angle</span>(l[i - <span class="number">1</span>]))) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[i], l[q[tt - <span class="number">1</span>]], l[q[tt]])) tt --;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[i], l[q[hh]], l[q[hh + <span class="number">1</span>]])) hh ++;</span><br><span class="line">q[++ tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[q[tt]], l[q[hh]], l[q[hh + <span class="number">1</span>]])) hh ++;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[q[hh]], l[q[tt - <span class="number">1</span>]], l[q[tt]])) tt --;</span><br><span class="line">q[++ tt] = q[hh];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = hh; i &lt; tt; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : l[q[i]].id) ans.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : ans) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;PII, vector&lt;<span class="keyword">int</span>&gt; &gt; ids;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">l[++ cnt] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">10000</span>, <span class="number">0</span>&#125;, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>)&#125;;</span><br><span class="line">l[++ cnt] = &#123;&#123;<span class="number">0</span>, <span class="number">10000</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>)&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; ki[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; vi[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">ids[&#123;ki[i], vi[i]&#125;].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : ids)</span><br><span class="line">l[++ cnt] = &#123;&#123;<span class="number">0</span>, c.first.first&#125;, &#123;<span class="number">1</span>, c.first.first + c.first.second&#125;, c.second&#125;;</span><br><span class="line"><span class="built_in">half_plane</span>(cnt);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="3-三维凸包"><a href="#3-三维凸包" class="headerlink" title="3. 三维凸包"></a>3. 三维凸包</h2><h3 id="1）三维空间向量"><a href="#1）三维空间向量" class="headerlink" title="1）三维空间向量"></a>1）三维空间向量</h3><h4 id="a-加减、数乘、模长"><a href="#a-加减、数乘、模长" class="headerlink" title="a. 加减、数乘、模长"></a>a. 加减、数乘、模长</h4><p>与二维向量相同，不再赘述。</p><h4 id="b-点乘"><a href="#b-点乘" class="headerlink" title="b. 点乘"></a>b. 点乘</h4><p>得到是一个数。</p><p>$(x1, y1, z1) \cdot (x2, y2, z2) = x1x2 + y1y2 + z1z2$。</p><p>注意满足 $|A||B|\cos&lt;A, B&gt; = A \cdot B$。</p><h4 id="c-叉乘"><a href="#c-叉乘" class="headerlink" title="c. 叉乘"></a>c. 叉乘</h4><p>得到不是数，是一个行列式的结果。<br>$$<br>det\left(<br>\begin{matrix}<br>i &amp; j &amp; k\<br>x1 &amp; y1 &amp; z1\<br>x2 &amp; y2 &amp; z2<br>\end{matrix}<br>\right)<br>$$<br>注意 $i, j, k$ 是空间单位向量，得到的明显也是一个三位向量。</p><p>展开行列式，可以得到：$(x1, y1, z1) \times (x2, y2, z2) = (y1z2 - y2z1, x2z1 - x1z2, x1y2 - x2y1)$。</p><h4 id="d-多面体欧拉定理"><a href="#d-多面体欧拉定理" class="headerlink" title="d. 多面体欧拉定理"></a>d. 多面体欧拉定理</h4><p>点数 - 棱数 + 面数 = 2。</p><h4 id="e-平面的法向量"><a href="#e-平面的法向量" class="headerlink" title="e. 平面的法向量"></a>e. 平面的法向量</h4><p>法向量是指垂直于</p><p>任意取两个向量</p><h3 id="2）三维凸包-增量法"><a href="#2）三维凸包-增量法" class="headerlink" title="2）三维凸包 - 增量法"></a>2）三维凸包 - 增量法</h3><p>其实是一个暴力算法，时间复杂度为 $O(n ^ 2)$。</p><p>我们首先找到任意不共面的 4 个点，使得可以形成一个凸包。</p><p>然后，我们尝试加入每一个点。</p><p>如果它在凸包里，则跳过；否则我们考虑加入。</p><p>假设这个点是一个太阳，那么一定会有一些面是“白天”，还有一些棱是“晨昏线”。</p><p>我们将”白天“全部删除，并且将”晨昏线“与新加的点相连，形成新的凸包。</p><p>具体看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Convex_3d</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> bitset&lt;N&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, ncnt = <span class="number">0</span>;</span><br><span class="line">pl[++ cnt] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, pl[++ cnt] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">ncnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++ j)&#123;</span><br><span class="line"><span class="keyword">bool</span> t = pl[j].<span class="built_in">above</span>(p[i]);</span><br><span class="line"><span class="keyword">if</span> (!t) np[++ ncnt] = pl[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++ k)</span><br><span class="line">g[pl[j].v[k]][pl[j].v[(k + <span class="number">1</span>) % <span class="number">3</span>]] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++ k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a = pl[j].v[k], b = pl[j].v[(k + <span class="number">1</span>) % <span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span> (g[a][b] &amp;&amp; !g[b][a]) np[++ ncnt] = &#123;a, b, i&#125;;</span><br><span class="line">&#125;</span><br><span class="line">cnt = ncnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++ j) pl[j] = np[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-旋转卡壳"><a href="#4-旋转卡壳" class="headerlink" title="4. 旋转卡壳"></a>4. 旋转卡壳</h2><p>其实不是一种模板或者算法，而是一种思想或者是做题的技巧。</p><h3 id="1）思想"><a href="#1）思想" class="headerlink" title="1）思想"></a>1）思想</h3><p>我们定义<strong>对踵点</strong>为任意两条平行的直线，向中间靠拢的时候碰到的点。</p><img src="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B31.png" class=""><p>很明显，我们的对踵点的个数是 $O(n)$ 级别的，所以我们并不需要枚举每一条平行的直线。我们可以考虑直接枚举与凸包边平行的边。</p><p>下面假设我们要寻找直径，也就是最长的线段。</p><p>我们先确定 $p(i)$ 为对踵点的一端，我们怎样才能寻找到与之相对的对踵点呢？</p><p>很明显，我们可以暴力枚举，但时间复杂度是 $O(n ^ 2)$，不优。</p><p>我们可以发现，随着我们的 $p(i)$ 一直都是顺时针（或者逆时针）旋转的，$p(j)$ 也一定是顺时针旋转的。</p><p>所以，我们可以使用双指针算法，可以做到 $O(n)$，瓶颈在前面的凸包，时间复杂度为 $O(n \log n)$。</p><p>怎样判断哪个点是最远的呢？我们回顾<strong>叉积</strong>的定义，发现是三角形的面积。我们再拉一个 $p(i + 1)$ 过来，就可以求面积了，同时这条直线就是 $p(i), p(i + 1)$。</p><p>具体看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">2</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ((s[i + <span class="number">1</span>] - s[i]) * (s[j] - s[i]) &lt; (s[i + <span class="number">1</span>] - s[i]) * (s[j + <span class="number">1</span>] - s[i])) j = (j + <span class="number">1</span>) % n;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(<span class="built_in">dist2</span>(s[i], s[j]), <span class="built_in">dist2</span>(s[i + <span class="number">1</span>], s[j])));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2）例题-1"><a href="#2）例题-1" class="headerlink" title="2）例题"></a>2）例题</h3><h4 id="T1：求最远点距离"><a href="#T1：求最远点距离" class="headerlink" title="T1：求最远点距离"></a>T1：求最远点距离</h4><p><a href="https://www.luogu.com.cn/problem/P1452">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/description/2941/">题目传送门 AcWing</a></p><p>刚才讲到的，直接上代码。</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    Point <span class="keyword">operator</span> -(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    LL <span class="keyword">operator</span> *(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (LL)x * t.y - (LL)y * t.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="keyword">int</span> stk[N], top, n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> cmp = [](Point t1, Point t2)&#123;</span><br><span class="line">    <span class="keyword">return</span> t1.x == t2.x ? t1.y &lt; t2.y : t1.x &lt; t2.x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dist2</span><span class="params">(Point p1, Point p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Andrew</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> usd[N];</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; (p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt;= <span class="number">0</span>)</span><br><span class="line">            usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line">        usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    usd[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (usd[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; (p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt; <span class="number">0</span>)</span><br><span class="line">            usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line">        usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    top --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">get_dist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">dist2</span>(p[stk[<span class="number">1</span>]], p[stk[<span class="number">2</span>]]);</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">2</span>; i &lt;= top; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ((p[stk[i + <span class="number">1</span>]] - p[stk[i]]) * (p[stk[j]] - p[stk[i]]) &lt; (p[stk[i + <span class="number">1</span>]] - p[stk[i]]) * (p[stk[j + <span class="number">1</span>]] - p[stk[i]]))</span><br><span class="line">            j = j % top + <span class="number">1</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(<span class="built_in">dist2</span>(p[stk[i + <span class="number">1</span>]], p[stk[j]]), <span class="built_in">dist2</span>(p[stk[i]], p[stk[j]])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">    <span class="built_in">Andrew</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">get_dist</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h4 id="T2：最小矩形覆盖"><a href="#T2：最小矩形覆盖" class="headerlink" title="T2：最小矩形覆盖"></a>T2：最小矩形覆盖</h4><p><a href="https://www.luogu.com.cn/problem/P3187">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2144/">题目传送门 AcWing</a></p><p>先搁着 qwq</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> INF = <span class="number">1e20</span>, eps = <span class="number">1e-12</span>, Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point <span class="keyword">operator</span> +(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + t.x, y + t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> -(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> *(<span class="keyword">double</span> t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x * t, y * t&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> /(<span class="keyword">double</span> t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x / t, y / t&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> *(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * t.y - y * t.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> &amp;(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * t.x + y * t.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N], ans[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> stk[N], top, n;</span><br><span class="line"><span class="keyword">double</span> mxa = INF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(x) &lt; eps ? <span class="number">0</span> : (x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>(x - y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">(Point a)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(a &amp; a);&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">(Point a, Point b, Point c)</span></span>&#123;<span class="keyword">return</span> (b - a) * (c - a);&#125;</span><br><span class="line"><span class="function">Point <span class="title">normal</span><span class="params">(Point t)</span></span>&#123;<span class="keyword">return</span> t / <span class="built_in">len</span>(t);&#125;</span><br><span class="line"><span class="function">Point <span class="title">rotate</span><span class="params">(Point a, <span class="keyword">double</span> th)</span></span>&#123;<span class="keyword">return</span> &#123;a.x * <span class="built_in">cos</span>(th) + a.y * <span class="built_in">sin</span>(th), a.y * <span class="built_in">cos</span>(th) - a.x * <span class="built_in">sin</span>(th)&#125;;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pcmp</span><span class="params">(Point a, Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">project</span><span class="params">(Point a, Point b, Point c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((b - a) &amp; (c - a)) / <span class="built_in">len</span>(b - a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Andrew</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> usd[N];</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, pcmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">area</span>(p[stk[top - <span class="number">1</span>]], p[stk[top]], p[i]) &gt;= <span class="number">0</span>)</span><br><span class="line">            usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line">        usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    usd[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (usd[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">area</span>(p[stk[top - <span class="number">1</span>]], p[stk[top]], p[i]) &gt;= <span class="number">0</span>)</span><br><span class="line">            usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line">        usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(stk + <span class="number">1</span>, stk + top + <span class="number">1</span>);</span><br><span class="line">    top --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_ju</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">3</span>, k = <span class="number">2</span>, l = <span class="number">3</span>; i &lt;= top; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        Point d = p[stk[i]], e = p[stk[i + <span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cmp</span>(<span class="built_in">area</span>(d, e, p[stk[j]]), <span class="built_in">area</span>(d, e, p[stk[j + <span class="number">1</span>]])) &lt; <span class="number">0</span>)</span><br><span class="line">            j = j % top + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cmp</span>(<span class="built_in">project</span>(d, e, p[stk[k]]), <span class="built_in">project</span>(d, e, p[stk[k + <span class="number">1</span>]])) &lt; <span class="number">0</span>)</span><br><span class="line">            k = k % top + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) l = j;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cmp</span>(<span class="built_in">project</span>(d, e, p[stk[l]]), <span class="built_in">project</span>(d, e, p[stk[l + <span class="number">1</span>]])) &gt; <span class="number">0</span>)</span><br><span class="line">            l = l % top + <span class="number">1</span>;</span><br><span class="line">        Point x = p[stk[j]], y = p[stk[k]], z = p[stk[l]];</span><br><span class="line">        <span class="keyword">double</span> h = <span class="built_in">area</span>(d, e, x) / <span class="built_in">len</span>(e - d),</span><br><span class="line">               w = ((y - z) &amp; (e - d)) / <span class="built_in">len</span>(e - d);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; h &lt;&lt; &#x27; &#x27; &lt;&lt; w &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (h * w &lt; mxa)&#123;</span><br><span class="line">            mxa = h * w;</span><br><span class="line">            ans[<span class="number">0</span>] = d + <span class="built_in">normal</span>(e - d) * <span class="built_in">project</span>(d, e, y);</span><br><span class="line">            ans[<span class="number">3</span>] = d + <span class="built_in">normal</span>(e - d) * <span class="built_in">project</span>(d, e, z);</span><br><span class="line">            Point t = <span class="built_in">normal</span>(<span class="built_in">rotate</span>(e - d, -Pi / <span class="number">2</span>));</span><br><span class="line">            ans[<span class="number">1</span>] = ans[<span class="number">0</span>] + t * h;</span><br><span class="line">            ans[<span class="number">2</span>] = ans[<span class="number">3</span>] + t * h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">    <span class="built_in">Andrew</span>();</span><br><span class="line">    <span class="comment">// cout &lt;&lt; top &lt;&lt; endl, exit(0);</span></span><br><span class="line">    <span class="built_in">find_ju</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.5lf\n&quot;</span>, mxa);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cmp</span>(ans[i].y, ans[k].y) &lt; <span class="number">0</span> || !<span class="built_in">cmp</span>(ans[i].y, ans[k].y) &amp;&amp; <span class="built_in">cmp</span>(ans[i].x, ans[k].x) &lt; <span class="number">0</span>)</span><br><span class="line">            k = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i, k ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">4</span>) k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> x = ans[k].x + eps, y = ans[k].y + eps;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt; eps) x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(y) &lt; eps) y = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.5lf %.5lf\n&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;前置知识：计算几何。&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算几何" scheme="https://mydcwfy.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
    <category term="凸包" scheme="https://mydcwfy.github.io/tags/%E5%87%B8%E5%8C%85/"/>
    
    <category term="旋转卡壳" scheme="https://mydcwfy.github.io/tags/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/"/>
    
  </entry>
  
  <entry>
    <title>计算几何基础</title>
    <link href="https://mydcwfy.github.io/2022/01/19/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://mydcwfy.github.io/2022/01/19/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/</id>
    <published>2022-01-19T06:28:54.000Z</published>
    <updated>2022-01-19T12:32:46.419Z</updated>
    
    <content type="html"><![CDATA[<p>需要的初高中几何知识是比较多的。</p><span id="more"></span><h2 id="1-数学基础"><a href="#1-数学基础" class="headerlink" title="1. 数学基础"></a>1. 数学基础</h2><p>$$<br>\begin{aligned}<br>\pi &amp;= \arccos(-1)\\<br>c^2 &amp;= a^2 + b^2 - 2ab\cos\theta<br>\end{aligned}<br>$$</p><p>第一个的原理来自于：$\cos \pi = -1$。</p><p>第二个是一个余弦定理。</p><h2 id="2-关于浮点数"><a href="#2-关于浮点数" class="headerlink" title="2. 关于浮点数"></a>2. 关于浮点数</h2><p>比如我们比较两个数的时候，他们可能因为计算的误差而不同。所以我们必须定义一个 $\epsilon$，表示两个的差别，如果在 $\epsilon$ 中的话，我们就认为这两个数相等。$\epsilon$ 可以定义为 $10^{-8}, 10^{-9}$ 等等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_equal</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(x - y) &lt; eps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，如果比较两个数的大小，我们同样也要使用 $\epsilon$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x - y) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-向量"><a href="#3-向量" class="headerlink" title="3. 向量"></a>3. 向量</h2><p>首先，简单的向量加减不再展开。</p><p>我们先介绍点乘：$a \cdot b = |a||b|\cos&lt;a, b&gt;$。</p><p>如果在二维点坐标下计算，就是 $(a, b) \cdot (c, d) = ac + bd$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dot</span><span class="params">(Point a, Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们计算一个向量的模的时候，可以直接计算就是了，也可以 $|a| = \sqrt{a \cdot a}$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">(Point a)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">dot</span>(a, a));&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用点乘来计算两个之间的夹角。</p><p>$\cos&lt;a, b&gt; = \dfrac{a\cdot b}{|a||b|}$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_angle</span><span class="params">(Point a, Point b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">acos</span>(<span class="built_in">dot</span>(a) / <span class="built_in">length</span>(a) / <span class="built_in">length</span>(b));&#125;</span><br></pre></td></tr></table></figure><p>还有一种乘法，是叉乘：$a\times b = |a||b|\sin&lt;a, b&gt;$。</p><p>如果是二维点坐标，就是 $(a, b)\times (c, d) = ad - bc$。</p><p>如果叉乘大于 0 的话，那么 $a$ 向量在 $b$ 向量的顺时针的方向。注意叉乘没有交换性。一般将叉乘重载为乘法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Point a, Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个，我们转一个角。</p><p>直接写出公式，证明可以使用和差角公式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">rotate</span><span class="params">(Point a, <span class="keyword">double</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;a.x * <span class="built_in">cos</span>(c) - a.y * <span class="built_in">sin</span>(c), a.x * <span class="built_in">sin</span>(c) + a.y * <span class="built_in">cos</span>(c)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-计算几何"><a href="#4-计算几何" class="headerlink" title="4. 计算几何"></a>4. 计算几何</h2><p>似乎能写的似乎不多……</p><p>我们简单的看几个比较常用的。</p><h3 id="1）直线相交"><a href="#1）直线相交" class="headerlink" title="1）直线相交"></a>1）直线相交</h3><p>首先，判断两个直线是否相交：$a\times b \not= 0$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_cross</span><span class="params">(Point a, Point b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">cross</span>(a, b) != <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="2）线段相交"><a href="#2）线段相交" class="headerlink" title="2）线段相交"></a>2）线段相交</h3><p>分为两步：快速排斥实验和跨立实验。</p><p>快速排斥实验是指如果两个线段所在的矩形如果不相交，那么两条线段一定不相交。</p><img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C.png" class=""><p>如果两个线段所在的矩形是相交的，也不说明两条线段是相交的。</p><img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C2.png" class=""><p>我们需要判断两个线段相交的话，需要判断一个线段的两个点是否在另外一个线段所在直线的两侧。</p><p>具体来说，就是判断 $(p3 - p1) \times (p2 - p1)$ 与 $(p4 - p1) \times (p2 - p1)$ 是否异号。</p><p>另外，我们可以直接对这两条线段都这么计算，可以省去第一步。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cross_seg</span><span class="params">(Point p1, Point p2, Point p3, Point p4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (((p1 - p3) * (p4 - p3)) * ((p2 - p3) * (p4 - p3)) &gt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (((p3 - p1) * (p2 - p1)) * ((p4 - p1) * (p2 - p1)) &gt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）判断一个点是否在多边形内"><a href="#3）判断一个点是否在多边形内" class="headerlink" title="3）判断一个点是否在多边形内"></a>3）判断一个点是否在多边形内</h3><p>注意不一定是凸多边形。</p><p>有一个结论：<strong>经过凸多边形的边奇数次，就在凸多边形内。</strong></p><p>很明显，没经过一次边，就会导致从外到内，或者从内到外。最后一定是在外部，所以奇数次的话该点就在里面。</p><p>注意这个结论在经过某一个顶点或者射线与边重合时并不适用，所以我们随机一个在凸多边形外部的点判断就可以了。</p><p>（不保证代码正确</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in_polygon</span><span class="params">(Point *p, Point a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p[n + <span class="number">1</span>] = p[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>((p[<span class="number">1</span>] - p[i]) * (p[i + <span class="number">1</span>] - p[i])) &lt; eps &amp;&amp;</span><br><span class="line"><span class="built_in">dot</span>(p[<span class="number">1</span>] - p[i], p[i + <span class="number">1</span>] - p[i]) &gt; eps &amp;&amp; <span class="built_in">dot</span>(p[i + <span class="number">1</span>] - p[<span class="number">1</span>], p[i + <span class="number">1</span>] - p[i]) &gt; eps)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Point c = &#123;(<span class="keyword">double</span>)<span class="built_in">rand</span>(), (<span class="keyword">double</span>)<span class="built_in">rand</span>()&#125;;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; !flag; ++ i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>((c - a) * (p[i] - a)) &lt; eps &amp;&amp; <span class="built_in">fabs</span>((c - a) * (p[i + <span class="number">1</span>] - a)) &lt; eps)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">flag ^= <span class="built_in">cross_seg</span>(a, c, p[i], p[i + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4）多边形面积"><a href="#4）多边形面积" class="headerlink" title="4）多边形面积"></a>4）多边形面积</h3><p>这是一个结论，我们就不证明了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sum_area</span><span class="params">(Point *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++ i)</span><br><span class="line">res += (p[i + <span class="number">1</span>] - p[<span class="number">1</span>]) * (p[i] - p[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-例题"><a href="#5-例题" class="headerlink" title="5. 例题"></a>5. 例题</h2><h3 id="T1：玩具"><a href="#T1：玩具" class="headerlink" title="T1：玩具"></a>T1：玩具</h3><p><a href="http://poj.org/problem?id=2318">题目传送门 POJ</a></p><p>我们二分，找到第一个在该点左边的隔板。判断这个点是否在线段的右边（这里是顺时针方向），直接用叉乘即可。</p><details><summary>完整代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">LL x, y;</span><br><span class="line">Point <span class="keyword">operator</span> +(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x + t.x, y + t.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Point <span class="keyword">operator</span> -(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">LL <span class="keyword">operator</span> *(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * t.y - y * t.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;L, R, now, up[N], dn[N];</span><br><span class="line"><span class="keyword">int</span> n, m, cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> is_fir = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %lld %lld %lld %lld&quot;</span>, &amp;m, &amp;L.x, &amp;R.y, &amp;R.x, &amp;L.y);</span><br><span class="line">up[<span class="number">0</span>] = &#123;L.x, L.y&#125;, dn[<span class="number">0</span>] = &#123;L.x, R.y&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;dn[i].x, &amp;up[i].x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) up[i].y = L.y, dn[i].y = R.y;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) cnt[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!is_fir) <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cse = <span class="number">1</span>; cse &lt;= m; ++ cse)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;now.x, &amp;now.y);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((now - up[mid]) * (dn[mid] - up[mid]) &gt; <span class="number">0</span>) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cnt[l] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>, i, cnt[i]);</span><br><span class="line">is_fir = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;需要的初高中几何知识是比较多的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算几何" scheme="https://mydcwfy.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>P3321</title>
    <link href="https://mydcwfy.github.io/2021/12/27/P3321/"/>
    <id>https://mydcwfy.github.io/2021/12/27/P3321/</id>
    <published>2021-12-27T13:58:09.000Z</published>
    <updated>2021-12-27T14:30:15.756Z</updated>
    
    <content type="html"><![CDATA[<p>比较难想，但其实是一个套路。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给定匹配串 $a$ 和原串 $b$，要求像 KMP 一样匹配，但是有通配符（指和每一个都可以匹配），给出所有的起点可以匹配。</p><p>$|a|,|b|\leq 10 ^ 5 $。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>（以下字符串默认从 0 开始）</p><p>首先，肯定不是暴力枚举每一个通配符的匹配字符。</p><p>其中，对于一个字符串 $s$，构造<br>$$<br>F(x) = \sum_{i = 0}^{|s| - 1} [s(i) == ‘*’]\times s(i) \ x ^ i<br>$$<br>表示如果是通配符的话，就是 0，否则就是原字符本身。</p><p>我们现在假设要求 $k$ 这个位置能否匹配。</p><p>我们考虑构造：<br>$$<br>H_k = \sum_{i = 0}^{m - 1} A(i) \times B(i + k - 1) \times (A(i) - B(i + k - 1)) ^ 2\ x ^ i<br>$$<br>那么，$[x^i]H(x)$ 为 0 的话，有 3 种情况：</p><ol><li>$A(i) = 0$</li><li>$B(i) = 0$</li><li>$A(i) = B(i + x - 1)$</li></ol><p>可以发现，这三种情况正好对应的有通配符的情况下的匹配。</p><p>由于每一项非负，所以只要有一项不是 0，所以整个就不是 0。</p><p>那么，我们展开一下：<br>$$<br>H_k = \sum_{i = 0}^{m - 1} (A(i)^3B(i + k - 1) - 2A(i)^2B(i + k - 1) ^ 2 + A(i)B(i + k - 1) ^ 3)<br>$$<br>那么，我们就只需要求出所有的 $H(x)$，每一位都是 $H_k$，只需要统计 0 的个数就可以了。<br>$$<br>H(x) = \sum_{k = 0}^{n - 1}\sum_{i = 0}^{m - 1} (A(i)^3B(i + k - 1) - 2A(i)^2B(i + k - 1) ^ 2 + A(i)B(i + k - 1) ^ 3)<br>$$<br>这个很明显是一个差相等的会放到一个 $H_k$ 中，根据套路，我们把它翻转一个。<br>$$<br>H(x) = \sum_{k = 0}^{n - 1}\sum_{i = 0}^{m - 1} (A(m - i - 1)^3B(i + k - 1) - 2A(m - i - 1)^2B(i + k - 1) ^ 2 + A(m - i - 1)B(i + k - 1) ^ 3)<br>$$<br>直接 NTT 就可以了。注意每一项都要 NTT，而不是一次 NTT 直接计算。</p><p>注意<a href="https://www.luogu.com.cn/discuss/303076">有人卡 998244353</a>，直接把原根换成 5 或者模数换为 167772161 就可以了。但是确实可以被卡。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">Match</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">char</span> *s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; mat;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">strlen</span>(s1), n = <span class="built_in">strlen</span>(s2);</span><br><span class="line">    <span class="built_in">reverse</span>(s1, s1 + m);</span><br><span class="line">    <span class="keyword">static</span> LL f[N], g[N], h[N], a[N], b[N];</span><br><span class="line">    <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (n + m + <span class="number">1</span>)) bit ++;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) h[i] = f[i] = g[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s1[i] == <span class="string">&#x27;*&#x27;</span>) f[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> f[i] = s1[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s2[i] == <span class="string">&#x27;*&#x27;</span>) g[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> g[i] = s2[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//H(i - j) += F(i) * G(j) * (F(i) - G(j)) ^ 2</span></span><br><span class="line">    <span class="comment">//H(i + j - m - 1) += F(i) * G1(m - j - 1) * (F(i) - G1(j)) ^ 2</span></span><br><span class="line">    <span class="comment">/*for (int i = 0; i &lt; tot; ++ i)</span></span><br><span class="line"><span class="comment">        f[i] = (qpow(f[i], 3) * g[i] % Mod - qpow(f[i] * g[i] % Mod, 2) * 2 % Mod + qpow(g[i], 3) * f[i] % Mod + Mod) % Mod;*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = f[i] * f[i] * f[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) b[i] = g[i];</span><br><span class="line">    <span class="built_in">NTT</span>(a, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) h[i] = (h[i] + a[i] * b[i]) % Mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = f[i] * f[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) b[i] = g[i] * g[i];</span><br><span class="line">    <span class="built_in">NTT</span>(a, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) h[i] = (h[i] + (Mod - <span class="number">2</span>) * a[i] % Mod * b[i]) % Mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = f[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) b[i] = g[i] * g[i] * g[i];</span><br><span class="line">    <span class="built_in">NTT</span>(a, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) h[i] = (h[i] + a[i] * b[i]) % Mod;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NTT</span>(h, bit, <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// for (int i = m - 1; i &lt; n; ++ i) cout &lt;&lt; h[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line">    <span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (h[i] == <span class="number">0</span>) mat.<span class="built_in">push_back</span>(i - m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;比较难想，但其实是一个套路。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>二次剩余与 Cipolla 算法</title>
    <link href="https://mydcwfy.github.io/2021/12/26/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%E4%B8%8E-Cipolla-%E7%AE%97%E6%B3%95/"/>
    <id>https://mydcwfy.github.io/2021/12/26/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%E4%B8%8E-Cipolla-%E7%AE%97%E6%B3%95/</id>
    <published>2021-12-26T07:24:45.000Z</published>
    <updated>2022-04-01T23:42:19.096Z</updated>
    
    <content type="html"><![CDATA[<p>虽说比较困难，但是代码实现十分简单。</p><span id="more"></span><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>我们求解 $x ^ 2 \equiv n \pmod p$，其中 $n, p$ 给定，$p$ 是质数。就是二次剩余，可以记为 $x = \sqrt n$。</p><p>一般使用 Cipolla 算法，时间复杂度是玄学，期望是 $O(\log n)$，一般也比较稳定。</p><h2 id="2-推导过程"><a href="#2-推导过程" class="headerlink" title="2. 推导过程"></a>2. 推导过程</h2><p>首先，证明一下<strong>在 $\bmod p$ 意义下的有 $\sqrt n$ 的 $n$ 的个数有 $\dfrac{p - 1}{2}$ 个。</strong></p><p>首先，我们容易发现，$x$ 与 $p - x$ 在 $\bmod p$ 意义下是相等的。于是我们只需要判断 $x\in[1, \dfrac{p - 1}{2}]$ 的 $x ^ 2$ 是不相同的。这样的话，对于 $\dfrac{p - 1}{2}$ 个 $n$ 都有两个不同的二次剩余对应它。</p><p>使用反证法，我们假设 $x_1,x_2\in[1, \dfrac{p - 1}{2}]$ 的平方是一样的，那么可以得到 $(x_2 +x_1)(x_2 - x_1)\equiv 0\pmod p$。但是 $x_2 + x_1$ 和 $x_2 - x_1$ 都是不可能相等的，所以不可能存在这样的 $x_1$ 和 $x_2$。</p><p>第二个，我们有一个定理：<strong>如果 $n^{\frac{p - 1}{2}}\equiv 1\pmod p$，那么 $n$ 在 $\bmod p$ 下是有二次剩余的。</strong></p><p>这一个比较难证，这里就略过了。但是一个可以明确的地方是 $\forall n, n^{\frac{p - 1}2}\bmod p\in {1, p - 1}$。因为 $n^{p - 1}\bmod p = 1$。</p><p>第三个，我们找到一个 $a$，使得 $a^2 - n$ 是一个非二次剩余。找到 $a$ 的话，我们使用随机化算法，在 $[0, p - 1]$ 中随机，然后判断 $(a ^ 2 - n)^{\frac{p - 1}2}$ 是否等于 $-1\bmod p$。由于有 $\dfrac{p - 1}{2}$ 个数不是二次剩余，所以我们期望 2 次就可以找到一个 $a ^ 2 - n$。这一步的期望是 $O(\log n)$。</p><p>设 $w = a ^ 2 - n$。</p><p>最后一步，我们定义一个二维向量 $(a, b)$，表示 $a + b\sqrt w$。</p><p>我们可以得到第三个结论：<strong>将二维向量当作一个数来乘，$\sqrt n = (a, 1) ^{\frac{p - 1}{2}}$。</strong></p><p>其中，$(a, 1)$ 表示 $a + \sqrt w$ 这个数，我们将这个数 $\dfrac{p - 1}{2}$ 次方，实部就是 $\sqrt n$。</p><p>证明也太难了，我们就不讲了。</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p>首先，我们将向量直接看做复数封装好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    ll x, y;</span><br><span class="line">&#125;;</span><br><span class="line">ll w;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">mul</span><span class="params">(Complex t1, Complex t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(t1.x * t2.x % p + t1.y * t2.y % p * w % p) % p, (t1.x * t2.y % p + t1.y * t2.x % p) % p&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">qpow_com</span><span class="params">(Complex a, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Complex res = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = <span class="built_in">mul</span>(res, a);</span><br><span class="line">        a = <span class="built_in">mul</span>(a, a);</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>qpow_com</code> 表示复数快速幂，其实是比较简单的。</p><p>然后就可以直接实现了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="built_in">rand</span>() % p;</span><br><span class="line">        w = (a * a % p - n + p) % p;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">qpow</span>(w, (p - <span class="number">1</span>) / <span class="number">2</span>) == p - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow_com</span>(&#123;a, <span class="number">1</span>&#125;, (p + <span class="number">1</span>) / <span class="number">2</span>).x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完全版。</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cipolla</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    LL x, y;</span><br><span class="line">&#125;;</span><br><span class="line">LL w, Mod;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">mul</span><span class="params">(Complex a, Complex b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(a.x * b.x % Mod + a.y * b.y % Mod * w % Mod) % Mod, (a.x * b.y + a.y * b.x) % Mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">qpow_com</span><span class="params">(Complex a, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Complex res = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = <span class="built_in">mul</span>(res, a);</span><br><span class="line">        a = <span class="built_in">mul</span>(a, a);</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL a, LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * a % Mod;</span><br><span class="line">        a = a * a % Mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cipolla</span>(<span class="keyword">int</span> _Mod = <span class="number">998244353</span>) : <span class="built_in">Mod</span>(_Mod) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Mod_Sqrt</span><span class="params">(LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL a;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="built_in">rand</span>() % Mod;</span><br><span class="line">        w = (a * a - n + Mod) % Mod;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">qpow</span>(w, (Mod - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) == Mod - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow_com</span>(&#123;a, <span class="number">1</span>&#125;, (Mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>).x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽说比较困难，但是代码实现十分简单。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>P7590</title>
    <link href="https://mydcwfy.github.io/2021/12/26/P7590/"/>
    <id>https://mydcwfy.github.io/2021/12/26/P7590/</id>
    <published>2021-12-26T05:00:01.000Z</published>
    <updated>2021-12-26T05:01:58.637Z</updated>
    
    <content type="html"><![CDATA[<p>单调队列。</p><span id="more"></span><h2 id="0-前置知识-amp-废话"><a href="#0-前置知识-amp-废话" class="headerlink" title="0. 前置知识 &amp; 废话"></a>0. 前置知识 &amp; 废话</h2><p>说实话，出题人的办法我没太看懂，于是就想了另外一种方法。</p><p>本题解需要你掌握：单调队列</p><p><a href="https://www.luogu.com.cn/problem/P1886">本算法位置</a></p><p>时间复杂度仍为 $O(n)$，但常数较标程略大，故需要点 <del>玄学优化</del>。</p><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给你一个环，每一个点都可以加一定的权值 x，从一个点到下一个点都要减少一定的权值，要保证随时都要 $x\geq0$，可以在一个点时恰好为 0。</p><p>从每一个点开始时，权值都等于 0。</p><p>如果有一个点可以运动 1 周，输出最小编号，否则输出 “Failed!”。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>出题人的方法我确实没看懂。</p><h3 id="1）朴素"><a href="#1）朴素" class="headerlink" title="1）朴素"></a>1）朴素</h3><p>首先考虑朴素算法。</p><p>定义<br>$$<br>d[x]=a[x]-b[x],sum[x]=\sum_{i=1}^{x}d[i]<br>$$<br>所以如果从 i 可以到 i+1，需要满足：<br>$$<br>a[i]=sum[i+1]-sum[i]\geq 0<br>$$<br>我们可以考虑将环拆成 2 倍的链。</p><p>如果从 i 可以的话，需要满足：<br>$$<br>\forall j\in [i,i+n-1],sum[j]\geq sum[i-1]<br>$$<br>时间复杂度为 $O(n^2)$，期望得分 30 分。</p><p><a href="https://www.luogu.com.cn/paste/oewr50t0">代码放置处</a></p><p>实际打代码时，我们可以以它为对拍代码。</p><h3 id="2）堆优化"><a href="#2）堆优化" class="headerlink" title="2）堆优化"></a>2）堆优化</h3><p>其实，我们不难发现，对于该式，我们可以使用堆优化。</p><p>时间复杂度 $O(n\log n)$，期望得分 70 分。</p><p>不放代码了 <del>逃</del>。</p><h3 id="3）单调队列"><a href="#3）单调队列" class="headerlink" title="3）单调队列"></a>3）单调队列</h3><p>我们进一步挖掘性质，可以发现，我们需要的是 $[i,i+n-1]$ 的最小值，且 i 不断变大。</p><p>这难道不是和单调队列相似吗？</p><p>那么就可以了。</p><p>如果 $j&lt;k,sum[j]&gt;sum[k]$，那么 j 不可能成为某个点的最小值。</p><p>维护一个单调队列，使其保持递增的顺序。</p><p>队头是最小值。</p><p>那么就可以了 吗？ <del>雾</del>。</p><p>单调队列虽然是 $O(n)$,但常数相对于标程更大，而最大 $\sum n=2\times 10^7$，很可能超时。</p><h2 id="3-常数优化"><a href="#3-常数优化" class="headerlink" title="3. 常数优化"></a>3. 常数优化</h2><ol><li>我开始 scanf+O2 竟然超时了，所以快读是时候了。</li><li>听说 register 可以加快，用一用也不错。</li></ol><p>这样一阵 <del>玄学</del> 优化后，我们就不用 O2 最大点也可以只用 600ms 就过了。</p><h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll d[<span class="number">2</span>*N],sum[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">int</span> hh,tt,q[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (hh&lt;=tt&amp;&amp;sum[q[tt]]&gt;=sum[x]) tt--;</span><br><span class="line">q[++tt]=x;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((c=<span class="built_in">getchar</span>())&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) ;</span><br><span class="line">    x=c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c=<span class="built_in">getchar</span>())&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// freopen(&quot;randdata.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">// freopen(&quot;myans.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">re <span class="keyword">int</span> cas,n,x;</span><br><span class="line"><span class="built_in">get</span>(cas);</span><br><span class="line"><span class="keyword">while</span> (cas--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">get</span>(n);</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">get</span>(x),d[i]=x;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">get</span>(x);</span><br><span class="line">d[i]-=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) d[i+n]=d[i];</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;++i) sum[i]=sum[i<span class="number">-1</span>]+d[i];<span class="comment">//,cout&lt;&lt;sum[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">hh=<span class="number">1</span>;tt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">insert</span>(i);</span><br><span class="line">re <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (hh&lt;=tt&amp;&amp;q[hh]&lt;i) hh++;</span><br><span class="line"><span class="built_in">insert</span>(i+n<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// printf(&quot;%d %d\n&quot;,hh,tt);</span></span><br><span class="line"><span class="keyword">if</span> (sum[i<span class="number">-1</span>]&lt;=sum[q[hh]])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="built_in">puts</span>(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;单调队列。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="单调队列" scheme="https://mydcwfy.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>P7225</title>
    <link href="https://mydcwfy.github.io/2021/12/26/P7225/"/>
    <id>https://mydcwfy.github.io/2021/12/26/P7225/</id>
    <published>2021-12-26T04:58:34.000Z</published>
    <updated>2021-12-26T04:59:15.412Z</updated>
    
    <content type="html"><![CDATA[<p>极为简单的交互题目。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>你站在一个格子，你可以移动到相邻的格子（如果相邻的格子不是障碍物的话）。</p><p>现在你需要回答走能走到的格子有哪些。</p><h2 id="2-关于交互题"><a href="#2-关于交互题" class="headerlink" title="2. 关于交互题"></a>2. 关于交互题</h2><p>请确保你知道交互题的评测方式与做法。</p><p>其实，大概的意思就是你和另外一个程序同时运行，并交换数据。</p><p>本蒟蒻由于没做过几道交互题，只能讲到这个地步啦。</p><h2 id="3-本题"><a href="#3-本题" class="headerlink" title="3. 本题"></a>3. 本题</h2><p>主要有两种思路：bfs 和 dfs。</p><p>注意观察 bfs 的性质：他是走到一个位置后，一会在进行扩展。</p><p>但是，本题中，我们希望的是他走的时候，是连续的，并且有回溯过程。</p><p>看到原题，他只会给你当前格子的信息，不会给你其他格子的。</p><p>所以，我们采用 dfs 进行搜索，并时刻记录有没有被访问。</p><p>由于每一个格子访问次数是常数，所以复杂度为 $O(n^2)$。</p><h2 id="4-AC-代码"><a href="#4-AC-代码" class="headerlink" title="4.AC 代码"></a>4.AC 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(i,j) (i-1)*n+j-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> check(i,j) (i&gt;1&amp;&amp;j&gt;1&amp;&amp;i&lt;n&amp;&amp;j&lt;n&amp;&amp;m[i][j]==-1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">705</span>][<span class="number">705</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,n,m[<span class="number">705</span>][<span class="number">705</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">4</span>]=&#123;<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;W&#x27;</span>&#125;;</span><br><span class="line">string ans;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">bool</span> <span class="title">move_to</span><span class="params">(<span class="keyword">char</span> position)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(x+dx[i],y+dy[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">move_to</span>(op[i])) m[x+dx[i]][y+dy[i]]=<span class="number">0</span>,<span class="built_in">dfs</span>(x+dx[i],y+dy[i]),<span class="built_in">move_to</span>(op[<span class="number">3</span>-i]);</span><br><span class="line">            <span class="keyword">else</span> m[x+dx[i]][y+dy[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">string <span class="title">find_out_map</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    ans=<span class="string">&quot;&quot;</span>;n=N;</span><br><span class="line">    <span class="built_in">memset</span>(m,<span class="number">-1</span>,<span class="keyword">sizeof</span> m);</span><br><span class="line">    <span class="built_in">dfs</span>(x,y);</span><br><span class="line">    ans=<span class="string">&quot;&quot;</span>;m[x][y]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (m[i][j]==<span class="number">0</span>) ans+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> ans+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-半个交互库"><a href="#5-半个交互库" class="headerlink" title="5. 半个交互库"></a>5. 半个交互库</h2><p>我自己做的时候，由于没有交互库，无法得知自己是否正确。</p><p>自己手写的代码，算半个交互库，希望对你有所帮助。</p><p>（同时是本题的非交互写法）。</p><p>也增添了评测。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(i,j) (i-1)*n+j-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> check(i,j) (i&gt;1&amp;&amp;j&gt;1&amp;&amp;i&lt;n&amp;&amp;j&lt;n&amp;&amp;m[i][j]==-1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">705</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,n,m[N][N],nowx,nowy;</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">4</span>]=&#123;<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;W&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ansmap[N][N],tot;</span><br><span class="line">string ans,stdans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">move_to</span><span class="params">(<span class="keyword">char</span> position)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++tot&gt;=<span class="number">5e5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Too many operations!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position==<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ansmap[nowx+<span class="number">1</span>][nowy])</span><br><span class="line">        &#123;</span><br><span class="line">            nowx++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ansmap[nowx][nowy<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            nowy--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position==<span class="string">&#x27;W&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ansmap[nowx<span class="number">-1</span>][nowy])</span><br><span class="line">        &#123;</span><br><span class="line">            nowx--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ansmap[nowx][nowy+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            nowy++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(x+dx[i],y+dy[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">move_to</span>(op[i])) m[x+dx[i]][y+dy[i]]=<span class="number">0</span>,<span class="built_in">dfs</span>(x+dx[i],y+dy[i]),<span class="built_in">move_to</span>(op[<span class="number">3</span>-i]);</span><br><span class="line">            <span class="keyword">else</span> m[x+dx[i]][y+dy[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">find_out_map</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*put your code here</span></span><br><span class="line"><span class="comment">      this is mine*/</span></span><br><span class="line">    ans=<span class="string">&quot;&quot;</span>;n=N;</span><br><span class="line">    <span class="built_in">memset</span>(m,<span class="number">-1</span>,<span class="keyword">sizeof</span> m);</span><br><span class="line">    <span class="built_in">dfs</span>(x,y);</span><br><span class="line">    ans=<span class="string">&quot;&quot;</span>;m[x][y]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (m[i][j]==<span class="number">0</span>) ans+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> ans+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;nowx&gt;&gt;nowy&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;stdans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (stdans[<span class="built_in">get</span>(i,j)]!=<span class="string">&#x27;0&#x27;</span>) ansmap[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> ansmap[i][j]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//put in the stdmap</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find_out_map</span>(nowx,nowy,n)==stdans) <span class="built_in">puts</span>(<span class="string">&quot;Accepted.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Wrong Answer!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;极为简单的交互题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
</feed>
