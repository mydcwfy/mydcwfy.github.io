<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mydcwfy&#39;s Blog</title>
  
  
  <link href="https://mydcwfy.github.io/atom.xml" rel="self"/>
  
  <link href="https://mydcwfy.github.io/"/>
  <updated>2022-08-07T07:23:59.157Z</updated>
  <id>https://mydcwfy.github.io/</id>
  
  <author>
    <name>mydcwfy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UOJ559 [NOI2020]命运</title>
    <link href="https://mydcwfy.github.io/2022/08/07/UOJ559/"/>
    <id>https://mydcwfy.github.io/2022/08/07/UOJ559/</id>
    <published>2022-08-07T06:27:16.000Z</published>
    <updated>2022-08-07T07:23:59.157Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一棵 $n$ 个点的有根树和 $m$ 条直上直下的链，问有多少种给每条边赋值 0 或 1 的方案数使得 $m$ 条链至少有一个 1。$n, m\leq 5\times 10 ^ 5$，2s，1024 MB。</p><span id="more"></span><p>题意明摆着叫你容斥，那么我们就容斥呗（但是好像有简单 DP 做法？）。暴力容斥，钦定一些链必须全部为 0，然后乘上 $(-1) ^ x$ 贡献到答案。直接做是 $O(2 ^ m n)$，用 DP 优化，考虑设 $f_{i, j}$ 表示 $i$ 为根的子树内已经选好，且从 $i$ 到 $j$ 链（$j$ 是 $i$ 的祖先）已经全部被钦定为 0 了的方案数。这样就可以写出转移：<br>$$<br>\begin{aligned}<br>f_{x, \min(j, k)} \leftarrow&amp; f_{v, j} f_{x, k} \\<br>f_{x, x} \leftarrow&amp; 2f_{v, v}\\<br>f_{x, u_i} \leftarrow&amp; -f_{x, x}[x = v_i]\\<br>f_{x, x} \leftarrow&amp; 1<br>\end{aligned}<br>$$<br>$j, k$ 按照 $dep$ 比较，$u, v$ 是一条直上直下的链。这样直接做是 $O(n ^ 2)$ 的，仍然无法通过。</p><p>我们观察转移，注意到非 0 项的个数其实并不多，产生一个非零项的方法只有从 $f_{x, x}$ 和从 $-f_{x, x}\rightarrow f_{x, u_i}$ 两个部分。容易发现产生的总 0 项的个数是 $O(n + m)$ 级别的。其余都是在不同的 $x$ 之间转移，于是这个可以使用线段树合并转移，时空复杂度均为 $O((n + q)\log n)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="built_in">adj</span>(tr[x].sum = tr[tr[x].lc].sum + tr[tr[x].rc].sum - Mod); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">tr[x].sum = (LL) tr[x].sum * c % Mod;</span><br><span class="line">tr[x].lt = (LL) tr[x].lt * c % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].lt == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">update</span>(tr[x].lc, tr[x].lt), <span class="built_in">update</span>(tr[x].rc, tr[x].lt);</span><br><span class="line">tr[x].lt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> sump, <span class="type">int</span> sumq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="built_in">update</span>(q, sump), q;</span><br><span class="line"><span class="keyword">if</span> (!q) <span class="keyword">return</span> <span class="built_in">update</span>(p, sumq), p;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">tr[p].sum = ((LL) (tr[p].sum + sump) * tr[q].sum + (LL) sumq * tr[p].sum) % Mod;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(p), <span class="built_in">pushdown</span>(q);</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, rp = tr[tr[p].rc].sum, rq = tr[tr[q].rc].sum;</span><br><span class="line">tr[p].lc = <span class="built_in">merge</span>(tr[p].lc, tr[q].lc, l, mid,</span><br><span class="line"><span class="built_in">adj</span>(rp = sump + rp - Mod), <span class="built_in">adj</span>(rq = sumq + rq - Mod));</span><br><span class="line">tr[p].rc = <span class="built_in">merge</span>(tr[p].rc, tr[q].rc, mid + <span class="number">1</span>, r, sump, sumq);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pushup</span>(p), p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x || ql &gt; r || qr &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> tr[x].sum;</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(tr[x].lc, ql, qr, l, mid)</span><br><span class="line">+ <span class="built_in">query</span>(tr[x].rc, ql, qr, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pos, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x) x = ++ nodecnt;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in">void</span>(<span class="built_in">adj</span>(tr[x].sum += c - Mod));</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (pos &lt;= mid) <span class="built_in">modify</span>(tr[x].lc, l, mid, pos, c);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">modify</span>(tr[x].rc, mid + <span class="number">1</span>, r, pos, c);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rdfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::<span class="built_in">sort</span>(con[x].<span class="built_in">begin</span>(), con[x].<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">con[x].<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(con[x].<span class="built_in">begin</span>(), con[x].<span class="built_in">end</span>()), con[x].<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span> (con[x].<span class="built_in">size</span>())</span><br><span class="line"><span class="built_in">modify</span>(rt[x], <span class="number">1</span>, n, con[x][<span class="number">0</span>], Mod - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">modify</span>(rt[x], <span class="number">1</span>, n, dep[x], <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">rdfs</span>(v, x);</span><br><span class="line"><span class="type">int</span> extra = <span class="built_in">query</span>(rt[v], dep[v], dep[v], <span class="number">1</span>, n);</span><br><span class="line"><span class="built_in">modify</span>(rt[v], <span class="number">1</span>, n, dep[v], Mod - extra);</span><br><span class="line"><span class="built_in">modify</span>(rt[v], <span class="number">1</span>, n, dep[x], extra * <span class="number">2</span> % Mod);</span><br><span class="line">rt[x] = <span class="built_in">merge</span>(rt[x], rt[v], <span class="number">1</span>, n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for (int i = 1; i &lt;= dep[x]; ++ i) std::cout &lt;&lt; query(rt[x], i, i, 1, n) &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; &#x27;\n&#x27;;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">g[u].<span class="built_in">push_back</span>(v), g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pre_dfs</span>(<span class="number">1</span>);</span><br><span class="line">std::cin &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">con[v].<span class="built_in">push_back</span>(dep[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">rdfs</span>(<span class="number">1</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">query</span>(rt[<span class="number">1</span>], <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, n) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一棵 $n$ 个点的有根树和 $m$ 条直上直下的链，问有多少种给每条边赋值 0 或 1 的方案数使得 $m$ 条链至少有一个 1。$n, m\leq 5\times 10 ^ 5$，2s，1024 MB。&lt;/p&gt;</summary>
    
    
    
    
    <category term="树相关" scheme="https://mydcwfy.github.io/tags/%E6%A0%91%E7%9B%B8%E5%85%B3/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="线段树合并" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>LOJ2268 [SDOI2017]苹果树</title>
    <link href="https://mydcwfy.github.io/2022/08/06/LOJ2268/"/>
    <id>https://mydcwfy.github.io/2022/08/06/LOJ2268/</id>
    <published>2022-08-05T23:54:20.000Z</published>
    <updated>2022-08-06T09:30:45.225Z</updated>
    
    <content type="html"><![CDATA[<p>题意：有一棵 $n$ 个点的有根树，每个点有 $a_i$ 个苹果，在 $i$ 处选一个苹果的价值是 $v_i$，一个节点能选苹果当且仅当他的父亲也选了至少一个。假设选的最大深度是 $d$，选了 $t$ 个苹果，要求 $t - d\leq k$，$k$ 给定。求能获得的最大价值。$T(T\leq 5)$ 组数据，$n\leq 2\times 10 ^ 4$，$ k\leq 5\times 10 ^ 5$，$nk\leq 2.5\times 10 ^ 7$，$1\leq v_i\leq 100$，5s。</p><span id="more"></span><p>容易发现题目直接给了个 $nk\leq 2.5\times 10 ^ 7$，那么显然复杂度就是 $O(nk)$，在多重背包的时候还必须使用单调队列优化。另外，不能使用任何的背包合并，因为复杂度为 $O(k ^ 2)$，唯一能合并的只是最后我们只需要一个答案，可以在 $O(k)$ 时间合并。那么我们必须找到两个背包合并得到答案。</p><p>首先容易发现一个事实：我们肯定会去选叶子节点。因为我们不选的话，让他任意选择一个儿子一定不劣。然后我们会发现一个树被我们用这一条根到叶子的链划分成了三部分：</p><ol><li>根到叶子的链</li><li>该链的左边</li><li>该链的右边</li></ol><p>这个左右暂且不好定义，我们先放在这里。容易发现我们根到叶子的链如果都只选择一个的话，这条链本身是免费的（不需要代价），如果要多选的话，我们可以考虑把这个点建一个新儿子，存放 $a_i - 1$ 个苹果。这个节点一定在链的左边或者右边（废话），那么就当作其他节点计算了。容易发现这个贡献方法是正确的。</p><p>首先我们考虑如何表示该链的左边和右边。这里巧妙的运用到了 <code>dfn</code> 序。考虑正向遍历邻接表和逆向遍历邻接表的后序遍历：</p><img src="/2022/08/06/LOJ2268/dfs1.png" class=""><img src="/2022/08/06/LOJ2268/dfs2.png" class=""><p>（注意这里没有新加的一个儿子）</p><p>假设我们考虑第一个图中 <code>dfn</code> 序为 2 的点，容易发现他的左边的点就是 <code>dfn</code> 序为 $[1, 1]$ 的区间。在第二个图中的 <code>dfn</code> 序为 4，$[1, 3]$ 区间的点就是他右边的点。</p><p>现在我们对树的左边和右边的定义就比较清晰了，我们预处理出这两个背包，然后 $O(k)$ 合并即可。</p><p>最后一个问题就是怎样求一段区间 <code>dfn</code> 序的树上背包。对于一个节点，可以强制至少选一个，否则的话需要跳过一个整的子树。这个是一个多重背包，显然 $O(nk)$ 即可。</p><p>综上，时间复杂度 $O(nk)$，可以通过，但比较卡常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">chkpack</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;f, std::vector&lt;<span class="type">int</span>&gt; &amp;g)</span> </span>&#123; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lim; ++ i) <span class="built_in">chkmax</span>(f[i], g[i]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backpack</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;f, <span class="type">int</span> w, <span class="type">int</span> v, <span class="type">bool</span> flag = <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!w) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;backPack &quot; &lt;&lt; w &lt;&lt; &#x27; &#x27; &lt;&lt; v &lt;&lt; std::endl;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> q[M];</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(lim + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">1</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lim; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt &amp;&amp; i - q[hh] &gt; w) hh ++;</span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt) &#123;</span><br><span class="line"><span class="keyword">if</span> (flag) tmp[i] = f[q[hh]] + (i - q[hh]) * v;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">chkmax</span>(tmp[i], f[q[hh]] + (i - q[hh]) * v);</span><br><span class="line"><span class="comment">// chkmax(f[i], f[q[hh]] + (i - q[hh]) * v);</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag) tmp[i] = -INF;</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt &amp;&amp; f[q[tt]] - q[tt] * v &lt; f[i] - i * v) tt --;</span><br><span class="line">q[++ tt] = i;</span><br><span class="line">&#125;</span><br><span class="line">f.<span class="built_in">swap</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> pre = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sz[x] = <span class="number">1</span>, sum[x] = (pre += val[x]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x]) <span class="built_in">dfs1</span>(v, pre), sz[x] += sz[v];</span><br><span class="line">nw1[dfn1[x] = ++ *dfn1] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x]) <span class="built_in">dfs2</span>(v);</span><br><span class="line">nw2[dfn2[x] = ++ *dfn2] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; lim;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;fa[i], &amp;a[i], &amp;val[i]);</span><br><span class="line"><span class="type">int</span> _n = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">fa[++ _n] = i, a[_n] = a[i] - <span class="number">1</span>, val[_n] = val[i], a[i] = <span class="number">1</span>;</span><br><span class="line">pren = n, n = _n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) g[i].<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) g[fa[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">*dfn1 = <span class="number">0</span>, <span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) std::<span class="built_in">reverse</span>(g[i].<span class="built_in">begin</span>(), g[i].<span class="built_in">end</span>());</span><br><span class="line">*dfn2 = <span class="number">0</span>, <span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">pre1[<span class="number">0</span>].<span class="built_in">assign</span>(lim + <span class="number">1</span>, -INF), pre2[<span class="number">0</span>].<span class="built_in">assign</span>(lim + <span class="number">1</span>, -INF);</span><br><span class="line">pre1[<span class="number">0</span>][<span class="number">0</span>] = pre2[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="built_in">backpack</span>(pre1[i] = pre1[i - <span class="number">1</span>], a[nw1[i]], val[nw1[i]], <span class="literal">true</span>), <span class="built_in">chkpack</span>(pre1[i], pre1[i - sz[nw1[i]]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="built_in">backpack</span>(pre2[i] = pre2[i - <span class="number">1</span>], a[nw2[i]], val[nw2[i]], <span class="literal">true</span>), <span class="built_in">chkpack</span>(pre2[i], pre2[i - sz[nw2[i]]]);</span><br><span class="line"><span class="comment">/*for (int i = 1; i &lt;= n; ++ i) std::cout &lt;&lt; nw1[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt;= n; ++ i, std::cout &lt;&lt; &#x27;\n&#x27;)</span></span><br><span class="line"><span class="comment">for (int j = 0; j &lt;= lim; ++ j) std::cout &lt;&lt; pre1[i][j] &lt;&lt; &#x27; &#x27;;*/</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= pren; ++ i)</span><br><span class="line"><span class="keyword">if</span> (g[i].<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= lim; ++ j) <span class="built_in">chkmax</span>(res, sum[i] + pre1[dfn1[i] - <span class="number">2</span>][j] + pre2[dfn2[i] - <span class="number">1</span>][lim - j]);</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：有一棵 $n$ 个点的有根树，每个点有 $a_i$ 个苹果，在 $i$ 处选一个苹果的价值是 $v_i$，一个节点能选苹果当且仅当他的父亲也选了至少一个。假设选的最大深度是 $d$，选了 $t$ 个苹果，要求 $t - d\leq k$，$k$ 给定。求能获得的最大价值。$T(T\leq 5)$ 组数据，$n\leq 2\times 10 ^ 4$，$ k\leq 5\times 10 ^ 5$，$nk\leq 2.5\times 10 ^ 7$，$1\leq v_i\leq 100$，5s。&lt;/p&gt;</summary>
    
    
    
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="树相关" scheme="https://mydcwfy.github.io/tags/%E6%A0%91%E7%9B%B8%E5%85%B3/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>LOJ2290 [THUWC2017]随机二分图</title>
    <link href="https://mydcwfy.github.io/2022/08/06/LOJ2290/"/>
    <id>https://mydcwfy.github.io/2022/08/06/LOJ2290/</id>
    <published>2022-08-05T23:35:47.000Z</published>
    <updated>2022-08-07T06:26:05.831Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定左右各 $n$ 个点的二分图和 $m$ 种边，每一种边有三种情况：</p><ol><li>这种边只有一条，有 $50\%$ 的概率出现。</li><li>这种边有两条，同时出现或者不出现，概率均为 $50\%$。</li><li>这种边有两条，分别出现，概率均为 $50\%$。</li></ol><p>求完美匹配的期望数量，对 $10 ^ 9 + 7$ 取模。$n\leq 15$。</p><span id="more"></span><p>首先考虑拆期望贡献，变为每一种完美匹配的出现概率之和。</p><p>我们直接考虑 DP，记 $f(S, T)$ 表示左边已选集合为 $S$，右边已选集合为 $T$ 的时候的期望数量。枚举不在 $S$ 中的最小元素和谁匹配即可，如果出现 2、3 类边，直接暴力转移。复杂度 $O(2 ^ {2n})$，实际由于 $S$ 的情况很少，可以通过。</p><p>这个做法看似很对，但是在处理 2 和 3 类边的时候会出现一些问题。具体的，虽然我们可能同时出现了两条边，但是在最后的完美匹配中的边可能只有一条，这样的话这种方法就不太可行。</p><p>我们容易发现如果我们只考虑两条边中的一条，他的出现概率就是 $50\%$，只不过会在两条边同时出现的时候出现一些问题。我们先不管这个条件，按照 1 类边的表针任意选择两条边，这样在不选边和选一条边都是正确的。唯一不正确的就是当两条边同时存在时，这个概率并不是 $25 \%$。2 类边是 $50\%$ 的概率，所以我们钦定强制选这两条边，并钦定同时出现的概率为 $25\%$。3 类边同理。</p><p>这样我们可以在 $O(2 ^ {2n})$ 的时间内解决该问题，用记忆化搜索可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dp</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S == tot &amp;&amp; T == tot) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (mp[S].<span class="built_in">count</span>(T)) <span class="keyword">return</span> mp[S][T];</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>, le = __builtin_ctz(S ^ tot);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ri = <span class="number">0</span>; ri &lt; n; ++ ri)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((T &gt;&gt; ri &amp; <span class="number">1</span>) || typ[le][ri] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; S &lt;&lt; &#x27; &#x27; &lt;&lt; T &lt;&lt; &#x27; &#x27; &lt;&lt; (S | (1 &lt;&lt; le)) &lt;&lt; &#x27; &#x27; &lt;&lt; (T | (1 &lt;&lt; ri)) &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">res = (res + <span class="built_in">Dp</span>(S | (<span class="number">1</span> &lt;&lt; le), T | (<span class="number">1</span> &lt;&lt; ri)) * (Mod + <span class="number">1LL</span>) / <span class="number">2</span>) % Mod;</span><br><span class="line"><span class="keyword">auto</span> [u, v] = pr[le][ri];</span><br><span class="line"><span class="keyword">if</span> (u == le || v == ri || (S &gt;&gt; u &amp; <span class="number">1</span>) || (T &gt;&gt; v &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; S &lt;&lt; &#x27; &#x27; &lt;&lt; T &lt;&lt; &#x27; &#x27; &lt;&lt; (S | (1 &lt;&lt; le) | (1 &lt;&lt; u)) &lt;&lt; &#x27; &#x27; &lt;&lt; (T | (1 &lt;&lt; ri) | (1 &lt;&lt; v)) &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">if</span> (typ[le][ri] == <span class="number">1</span>)</span><br><span class="line">res = (res + <span class="built_in">Dp</span>(S | (<span class="number">1</span> &lt;&lt; le) | (<span class="number">1</span> &lt;&lt; u), T | (<span class="number">1</span> &lt;&lt; ri) | (<span class="number">1</span> &lt;&lt; v)) * (Mod + <span class="number">1LL</span>) / <span class="number">4</span>) % Mod;</span><br><span class="line"><span class="keyword">if</span> (typ[le][ri] == <span class="number">2</span>)</span><br><span class="line">res = (res + <span class="built_in">Dp</span>(S | (<span class="number">1</span> &lt;&lt; le) | (<span class="number">1</span> &lt;&lt; u), T | (<span class="number">1</span> &lt;&lt; ri) | (<span class="number">1</span> &lt;&lt; v)) * (Mod - (Mod + <span class="number">1LL</span>) / <span class="number">4</span>)) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mp[S][T] = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定左右各 $n$ 个点的二分图和 $m$ 种边，每一种边有三种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这种边只有一条，有 $50\%$ 的概率出现。&lt;/li&gt;
&lt;li&gt;这种边有两条，同时出现或者不出现，概率均为 $50\%$。&lt;/li&gt;
&lt;li&gt;这种边有两条，分别出现，概率均为 $50\%$。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;求完美匹配的期望数量，对 $10 ^ 9 + 7$ 取模。$n\leq 15$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>LOJ6179 Pyh 的求和</title>
    <link href="https://mydcwfy.github.io/2022/08/05/LOJ6179/"/>
    <id>https://mydcwfy.github.io/2022/08/05/LOJ6179/</id>
    <published>2022-08-05T13:10:13.000Z</published>
    <updated>2022-08-05T13:37:29.819Z</updated>
    
    <content type="html"><![CDATA[<p>题意：求 $\sum_{i = 1} ^ n \sum_{j = 1} ^ m \varphi(ij)\bmod 998244353$。$T(T\leq 10 ^ 5)$ 组数据，$n, m\leq 10 ^ 5$，4s，64MB。</p><span id="more"></span><p>首先一个容易发现的性质是 $\varphi(ij) = \dfrac{\varphi(i) \varphi(j) \gcd(i, j)}{\varphi(\gcd(i, j))}$。考虑每个质因数的贡献即可。</p><p>那么一阵推导（默认 $n\leq m$）：<br>$$<br>\begin{aligned}<br>ans =&amp; \sum_{i = 1} ^ n \sum_{j = 1} ^ m \dfrac{\varphi(i) \varphi(j) \gcd(i, j)}{\varphi(\gcd(i, j))}\\<br>=&amp; \sum_{d = 1} ^ n \dfrac d{\varphi(d)} \sum_{i = 1} ^ {\frac nd} \sum_{j = 1} ^ {\frac md} [\gcd(i, j) = 1] \varphi(id) \varphi(jd)\\<br>=&amp; \sum_{d = 1} ^ n \dfrac d{\varphi(d)} \sum_{i = 1} ^ {\frac nd} \sum_{j = 1} ^ {\frac md} \varphi(id) \varphi(jd) \sum_{k | i, k | j} \mu(k)\\<br>=&amp; \sum_{d = 1} ^ n \dfrac d{\varphi(d)} \sum_{k = 1} ^ {\frac nd} \mu(k) \sum_{i = 1} ^ {\frac n{dk}}\sum_{j = 1} ^ {\frac m{dk}} \varphi(idk) \varphi(jdk)\\<br>=&amp; \sum_{T = 1} ^ n (\sum_{i = 1} ^ {\frac nT} \varphi(iT)) (\sum_{j = 1} ^ {\frac mT} \varphi(jT)) \sum_{d | T} \dfrac {d\mu(\dfrac Td)}{\varphi(d)}<br>\end{aligned}<br>$$<br>容易发现后面的 $\sum_{d | T} \dfrac {d\mu(\dfrac Td)}{\varphi(d)}$ 可以在 $O(n\log n)$ 的时间预处理，如果求出了前面的一坨，容易单次 $O(\sqrt n)$ 整除分块计算。问题在于前面的这两个不是很好和整除分块一起计算。</p><p>考虑有两种处理办法：</p><ol><li>预处理 $f(n, m, T) = \sum_{i = 1} ^ n \sum_{j = 1} ^ m  \varphi(iT) \varphi(jT)$ 并使用前缀和，这样就可以使用整除分块。</li><li>预处理 $g(n, T) = \sum_{i = 1} ^ n f(iT)$，不使用前缀和和整除分块。</li></ol><p>两个可以平衡规划一下，考虑到神秘的空间限制，大概确定一个阈值即可， $\dfrac mT$ 小于他的使用预处理整除分块，否则使用暴力。时间限制比较宽松，只要平衡规划一般能通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, B = <span class="number">50</span>, Mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">phi[<span class="number">1</span>] = mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) prime[++ cnt] = i, phi[i] = i - <span class="number">1</span>, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++ j)</span><br><span class="line">&#123;</span><br><span class="line">st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">phi[i * prime[j]] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">mu[i * prime[j]] = -mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">adj</span>(mu[i]), invphi[i] = <span class="built_in">qpow</span>(phi[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d * i &lt;= n; ++ d)</span><br><span class="line">g[i * d] = (g[i * d] + (LL) d * invphi[d] % Mod * mu[i]) % Mod;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> T = <span class="number">1</span>; T &lt;= n; ++ T)</span><br><span class="line">&#123;</span><br><span class="line">f[T].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, tmp; i * T &lt;= n; ++ i)</span><br><span class="line">f[T].<span class="built_in">push_back</span>(<span class="built_in">adj</span>(tmp = f[T].<span class="built_in">back</span>() + phi[i * T] - Mod));</span><br><span class="line">cnt += f[T].<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s1 = <span class="number">1</span>; s1 &lt;= B; ++ s1)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s2 = <span class="number">1</span>; s2 &lt;= B; ++ s2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> &amp;v = S[s1][s2];</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, ed = std::<span class="built_in">min</span>(n / s1, n / s2); i &lt;= ed; ++ i)</span><br><span class="line">v.<span class="built_in">push_back</span>((v.<span class="built_in">back</span>() + (LL) f[i][s1] * f[i][s2] % Mod * g[i]) % Mod);</span><br><span class="line">cnt += v.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line">std::cerr &lt;&lt; (cnt * <span class="number">4</span> + std::<span class="built_in">abs</span>(&amp;mem1 - &amp;mem2)) / <span class="number">1048576.</span> &lt;&lt; <span class="string">&quot; MB\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m, res = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">if</span> (n &gt; m) std::<span class="built_in">swap</span>(n, m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m / B; ++ i)</span><br><span class="line">res = (res + (LL) g[i] * f[i][n / i] % Mod * f[i][m / i]) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = m / B + <span class="number">1</span>, r, tn, tm; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = std::<span class="built_in">min</span>(n / (tn = n / l), m / (tm = m / l));</span><br><span class="line"><span class="built_in">adj</span>(<span class="built_in">adj</span>(res += S[tn][tm][r] - Mod) -= S[tn][tm][l - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sieve</span>(<span class="number">1e5</span> + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">std::cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T --) <span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：求 $\sum_{i = 1} ^ n \sum_{j = 1} ^ m \varphi(ij)\bmod 998244353$。$T(T\leq 10 ^ 5)$ 组数据，$n, m\leq 10 ^ 5$，4s，64MB。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="平衡规划" scheme="https://mydcwfy.github.io/tags/%E5%B9%B3%E8%A1%A1%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>51Nod1965 奇怪的式子</title>
    <link href="https://mydcwfy.github.io/2022/07/25/51Nod1965/"/>
    <id>https://mydcwfy.github.io/2022/07/25/51Nod1965/</id>
    <published>2022-07-25T06:36:33.000Z</published>
    <updated>2022-07-25T08:26:22.148Z</updated>
    
    <content type="html"><![CDATA[<p>题意：求 $\prod_{i = 1} ^ n \sigma_0(i) ^ {i + \mu(i)}$。$n\leq 10 ^ {11}$，对 $10 ^ {12} + 39$ 取模，$T(T\leq 3)$ 组数据，15s。</p><span id="more"></span><p><a href="/2022/02/13/Min-25-Sieve/">前置知识</a>，即使会也可以看看里面的一些定义，下文会用到~</p><p>离谱模数 + 奇怪卡常题，不过 Min_25 的应用是非常不错的。</p><p>首先我们容易发现 $i + \mu(i)$ 似乎没有任何性质，考虑拆开计算。那么分别计算 $\sigma_0(i) ^ i$ 和 $\sigma_0(i) ^ {\mu(i)}$。</p><h3 id="1-正常的-Min-25-筛"><a href="#1-正常的-Min-25-筛" class="headerlink" title="1. 正常的 Min_25 筛"></a>1. 正常的 Min_25 筛</h3><hr><h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h4><p>直接考虑 Min_25 筛，考虑计算 $\prod\sigma_0(i) ^ i$。假设我们已经知道了一些 $x$ 的 $\prod \sigma_0(x) ^ x$，考虑怎样在这些数上所有乘 $p$（$p$ 是一个质数，$s$ 和 $p$ 都互质）。直接推式子：<br>$$<br>\begin{aligned}<br>&amp;\prod \sigma_0(p\times x) ^ {p\times x}\\<br>=&amp; \prod \sigma_0(p) ^ {p\times x} \times \prod \sigma_0(x) ^ {p\times x}\\<br>=&amp; (\sigma_0(p) ^ p) ^ {\sum x} \times (\prod \sigma_0(x) ^ x) ^ p<br>\end{aligned}<br>$$<br>容易发现我们还需要计算 $\sum x$，这个在 Min_25 递归过程中很容易计算。$p$ 也可以换成 $p ^ k$，和上面的推导是相同的，可以直接使用。</p><h4 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h4><p>下面考虑 $\prod\sigma_0(i) ^ {\mu(i)}$。首先一个比较重要的性质为我们只需要管 $p_1p_2 \dots p_k$ 类似的数，因为 $\mu(i)$ 为 0 的话就没有贡献。而写成这样，我们又可以表示 $\sigma_0(i)$ 为 $2 ^ {d(i)}$，其中 $d(i)$ 表示 $i$ 的质因子个数。那么只需要计算 $\sum d(i)\mu(i)$ 即可。</p><p>还是考虑 Min_25 筛的递归过程，我们只需要枚举次幂 $k = 1$ 即可。继续计算时，还是会遇到类似合并两个答案的问题。</p><p>假设前面我们已经算好了一些 $\sum d(x) \mu(x)$，现在考虑对这些所有数乘上一个 $p$。还是直接推式子：<br>$$<br>\begin{aligned}<br>&amp;\sum d(x\times p)\mu(x\times p)\\<br>=&amp; \sum (d(x) + 1)(-\mu(x))\\<br>=&amp; -\sum d(x)\mu(x) - \sum \mu(x)<br>\end{aligned}<br>$$<br>递归的过程需要同时计算 $\mu(x)$，这个是容易的。</p><hr><p>那么我们就得到了一个使用递归 Min_25 筛的做法。</p><details><summary>递归代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> LL Mod1 = <span class="number">1000000000039LL</span>, Mod2 = <span class="number">1000000000038LL</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LPow</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> B = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    LL sk[B], bk[B];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sk[<span class="number">0</span>] = bk[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; B; ++ i) sk[i] = sk[i - <span class="number">1</span>] * x % Mod1;</span><br><span class="line">        bk[<span class="number">1</span>] = sk[B - <span class="number">1</span>] * x % Mod1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; B; ++ i) bk[i] = (s128) bk[i - <span class="number">1</span>] * bk[<span class="number">1</span>] % Mod1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">LL <span class="title">lpow</span><span class="params">(LL n)</span> </span>&#123; <span class="keyword">return</span> n %= Mod2, (s128) bk[n &gt;&gt; <span class="number">20</span>] * sk[n &amp; <span class="number">1048575</span>] % Mod1; &#125;</span><br><span class="line">&#125; lp[<span class="number">25</span>];</span><br><span class="line"><span class="type">bool</span> mem2;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL a, LL k = Mod1 - <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = (s128) a * a % Mod1)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (s128) res * a % Mod1;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) prime[++ cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getid</span><span class="params">(LL x)</span> </span>&#123; <span class="keyword">return</span> x &lt;= sq ? id1[x] : id2[n / x]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveg1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) g[i] = a[i] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) sp[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        LL le = (LL) prime[i] * prime[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; a[j] &gt;= le; ++ j)</span><br><span class="line">            g[j] -= g[<span class="built_in">getid</span>(a[j] / prime[i])] - sp[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; g[1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveg2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) g[i] = ((s128) a[i] * (a[i] + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>) % Mod2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) sp[i] = sp[i - <span class="number">1</span>] + prime[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        LL le = (LL) prime[i] * prime[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; a[j] &gt;= le; ++ j)</span><br><span class="line">            g[j] = (g[j] + (s128) (g[<span class="built_in">getid</span>(a[j] / prime[i])] - sp[i - <span class="number">1</span>] + Mod2)</span><br><span class="line">                * (Mod2 - prime[i])) % Mod2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; g[1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PLL <span class="title">S1</span><span class="params">(LL n, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prime[i] &gt;= n) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    LL res = -g[<span class="built_in">getid</span>(n)] + sp[i], tot = res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nw = i + <span class="number">1</span>; nw &lt;= cnt &amp;&amp; (LL) prime[nw] * prime[nw] &lt;= n; ++ nw)</span><br><span class="line">    &#123;</span><br><span class="line">        PLL frm = <span class="built_in">S1</span>(n / prime[nw], nw);</span><br><span class="line">        res -= frm.first + frm.second, tot -= frm.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;res, tot&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PLL <span class="title">S2</span><span class="params">(LL n, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prime[i] &gt;= n) <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    LL res = lp[<span class="number">2</span>].<span class="built_in">lpow</span>(g[<span class="built_in">getid</span>(n)] - sp[i] + Mod2), tot = g[<span class="built_in">getid</span>(n)] - sp[i] + Mod2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nw = i + <span class="number">1</span>; nw &lt;= cnt &amp;&amp; (LL) prime[nw] * prime[nw] &lt;= n; ++ nw)</span><br><span class="line">    &#123;</span><br><span class="line">        LL cur = prime[nw];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; cur &lt;= n; cur *= prime[nw], ++ k)</span><br><span class="line">        &#123;</span><br><span class="line">            PLL frm = <span class="built_in">S2</span>(n / cur, nw);</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="number">1</span>) frm.second ++;</span><br><span class="line">            LL mul, t = (s128) cur * frm.second % Mod2;</span><br><span class="line">            <span class="keyword">if</span> (k + <span class="number">1</span> &lt; <span class="number">25</span>) mul = lp[k + <span class="number">1</span>].<span class="built_in">lpow</span>(t);</span><br><span class="line">            <span class="keyword">else</span> mul = <span class="built_in">qpow</span>(k + <span class="number">1</span>, t);</span><br><span class="line">            res = (s128) res * mul % Mod1 * <span class="built_in">qpow</span>(frm.first, cur) % Mod1;</span><br><span class="line">            tot = (tot + (s128) frm.second * cur) % Mod2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;res, tot&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    sq = std::<span class="built_in">sqrt</span>(n), tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">1</span>, r, t; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t = n / l, r = n / t;</span><br><span class="line">        a[++ tot] = t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt;= sq) id1[t] = tot;</span><br><span class="line">        <span class="keyword">else</span> id2[r] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solveg1</span>();</span><br><span class="line">    <span class="keyword">auto</span> res1 = <span class="built_in">S1</span>(n, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; (res1.first + Mod2 * 10) % Mod2 &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    <span class="built_in">solveg2</span>();</span><br><span class="line">    <span class="keyword">auto</span> res2 = <span class="built_in">S2</span>(n, <span class="number">0</span>);</span><br><span class="line">    LL res = (s128) <span class="built_in">qpow</span>(<span class="number">2</span>, res1.first + Mod2 * <span class="number">10</span>) * res2.first % Mod1;</span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="2-迭代的-Min-25-筛"><a href="#2-迭代的-Min-25-筛" class="headerlink" title="2. 迭代的 Min_25 筛"></a>2. 迭代的 Min_25 筛</h3><p>如果认真观察一些 Min_25 的题目的话，会发现一个事实：如果带递归的 Min_25，一般只能跑 $10 ^ {10}$，但是如果只有第一部分迭代的话，一般可以跑 $10 ^ {11}$，不过时限略大。本题中，上面给出的代码在单组 $10 ^ {11}$ 的情况下需要跑 1min 的时间，很明显的印证了上面所说到的这一点。（递归中还带快速幂，显然无法接受）</p><p>考虑使用迭代的方法计算这两部分。可能就和正常理解的 Min_25 不太相同。</p><hr><h4 id="第二部分-1"><a href="#第二部分-1" class="headerlink" title="第二部分"></a>第二部分</h4><p>先看第二部分罢。</p><p>注意到这个部分递归的时候，$p$ 的次幂都是 $k = 1$，考虑从这里入手。</p><p>还是类似于 Min_25 筛的定义，设 $S(n, i)$ 为所有满足 $\mathrm{lpf}(x) &gt; p_i\lor i\in P$ 的数的 $\sum d(x)\mu(x)$ 的和，其中 $\mathrm{lpf}(x)$ 表示 $x$ 的最小质因子，$p_i$ 是第 $i$ 个质数，$P$ 是质数集合。</p><p>考虑直接迭代求 $G(n, i)$。和 Min_25 筛第一部分不同的地方在于，我们现在求的是 $G(n, 0)$ 而不是 $G(n, k)$（保证 $p_k &gt; \sqrt n$），所以我们应该倒序枚举 $i$。</p><p>注意到我们迭代的时候也用到了 $\sum \mu(i)$，设 $H(n, k)$ 为满足条件的 $\mu(x)$ 的和。</p><p>大力推式子，可以得到：<br>$$<br>\begin{aligned}<br>G(n, i - 1) =&amp; G(n, i) - (G(\dfrac n{p_i}, i) + i) - (H(\dfrac n{p_i}, i) + i)\\<br>H(n, i - 1) =&amp; H(n, i) - (H(\dfrac n{p_i}, i) + i)<br>\end{aligned}<br>$$<br>$+i$ 的原因是我们要把 $p_{1\dots i}$ 的贡献除去，每个的 $d(i)\mu(i)$ 和 $\mu(i)$ 都是 -1，所以减掉贡献应该 $+i$。</p><p>那么按照这个式子计算，最后 $G(n, 0)$ 就是答案。这个计算过程类似于 Min_25 第一步，并不需要滚动数组。</p><h4 id="第一部分-1"><a href="#第一部分-1" class="headerlink" title="第一部分"></a>第一部分</h4><p>那么再来看第一部分。这个就和上面那一个优化思路就不同了，因为枚举的 $p$ 的次幂不一定是 1 了。</p><p>从朴素的方向出发，我们考虑计算每一个质因子的贡献。大力推式子：<br>$$<br>\begin{aligned}<br>\prod_{i = 1} ^ n \sigma_0(i) ^ i =&amp; \prod_{p\in P} \prod_{k} (k + 1) ^ {\sum_{i = 1} ^ n [p ^ k \mid i\land p ^ {k + 1}\nmid i] i}<br>\end{aligned}<br>$$<br>指数上的一坨我们展开一下：<br>$$<br>\begin{aligned}<br>&amp;\sum_{i = 1} ^ n [p ^ k \mid i \land p ^ {k + 1} \nmid i]\\<br>=&amp; \sum_{i = 1} ^ n [p ^ k | i]i - \sum_{i = 1} ^ n [p ^ {k + 1} | i] i\\<br>=&amp; p ^ k \sum_{i = 1} ^ {\frac n{p ^ k}}i - p ^ {k + 1} \sum_{i = 1} ^ {\frac n{p ^ {k + 1}}} i\\<br>=&amp; p ^ k \mathrm{sum}(\dfrac n{p ^ k}) - p ^ {k + 1} \mathrm{sum} (\dfrac n{p ^ {k + 1}})<br>\end{aligned}<br>$$<br>其中 $\mathrm{sum}(x)$ 表示 $\sum_{i = 1} ^ x i$，为 $\dfrac {x\times (x + 1)}2$。</p><p>这么多 $(p, k)$ 并不好计算，但是注意到 $p &gt; \sqrt n$ 的时候，$k = 1$，似乎是一个不错的办法。</p><p>首先计算 $p\leq \sqrt n$。直接暴力计算即可，时间复杂度并不高，反正很快。</p><p>下面来看 $p &gt; \sqrt n$ 的情况。注意到 $k = 1$ 的情况是很好表示的，我们可以马上写出式子：<br>$$<br>\prod_{p\in P\land p &gt; \sqrt n} 2 ^ {p \times \mathrm{sum}(\lfloor \frac np\rfloor )}<br>$$<br>注意到我们需要对 $\dfrac np$ 进行整除分块，然后需要求出区间素数的和。这个是直接使用 Min_25 第一部分就可以很快得到的（类似 区间素数问题），那么我们也可以只通过迭代计算第一部分的答案了。</p><hr><p>通过对 Min_25 的改造，对式子的推导，我们最终还是通过简单的 Min_25 第一部分的迭代就可以计算这个答案了。时间复杂度不太会算，据说都是 $O(n ^ {\frac 34})$ 的。新算法能在 3s 左右得到 $10 ^ {11}$ 的答案的，可见还是比递归写法快不少的。</p><p>代码实现方面，注意是 $\bmod P$ 还是 $\bmod \varphi(P)$ 是需要注意的。好像不能使用 <code>__int128_t</code>，那就写 <code>long double</code> 乘法罢。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> LL Mod1 = <span class="number">1000000000039LL</span>, Mod2 = <span class="number">1000000000038LL</span>;</span><br><span class="line"><span class="function">LL <span class="title">mul1</span><span class="params">(LL a, LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> x = (<span class="type">long</span> <span class="type">double</span>) a * b;</span><br><span class="line">    <span class="keyword">return</span> (a * b - (LL) (x / Mod1) * Mod1 + Mod1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">mul2</span><span class="params">(LL a, LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> x = (<span class="type">long</span> <span class="type">double</span>) a * b;</span><br><span class="line">    <span class="keyword">return</span> (a * b - (LL) (x / Mod2) * Mod2 + Mod2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL a, LL k = Mod1 - <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = <span class="built_in">mul1</span>(a, a))</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = <span class="built_in">mul1</span>(res, a);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) prime[++ cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getid</span><span class="params">(LL x)</span> </span>&#123; <span class="keyword">return</span> x &lt;= sq ? id1[x] : id2[n / x]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">sum1</span><span class="params">(LL x)</span> </span>&#123; <span class="keyword">return</span> x &amp; <span class="number">1</span> ? <span class="built_in">mul2</span>(x, (x + <span class="number">1</span>) / <span class="number">2</span>) : <span class="built_in">mul2</span>(x / <span class="number">2</span>, x + <span class="number">1</span>); &#125;</span><br><span class="line"><span class="function">LL&amp; <span class="title">adj</span><span class="params">(LL &amp;x)</span> </span>&#123; <span class="keyword">return</span> x += x &gt;&gt; <span class="number">63</span> &amp; Mod2; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveg1</span><span class="params">()</span> <span class="comment">// sigma(i) * i</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) g[i] = <span class="built_in">sum1</span>(a[i]) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) h[i] = a[i] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) sp[i] = sp[i - <span class="number">1</span>] + prime[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) sph[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        LL le = (LL) prime[i] * prime[i], tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>, id; j &lt;= tot &amp;&amp; a[j] &gt;= le; ++ j)</span><br><span class="line">            g[j] = (g[j] + (Mod2 - <span class="built_in">adj</span>(tmp = g[id = <span class="built_in">getid</span>(a[j] / prime[i])] - sp[i - <span class="number">1</span>]))</span><br><span class="line">                 * prime[i]) % Mod2,</span><br><span class="line">            h[j] -= h[id] - sph[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; g[1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveg2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) h[i] = Mod2 - h[i], g[i] = h[i];</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; g[1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cnt; i; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        LL le = (LL) prime[i] * prime[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; a[j] &gt;= le; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nid = <span class="built_in">getid</span>(a[j] / prime[i]);</span><br><span class="line">            <span class="built_in">adj</span>(<span class="built_in">adj</span>(h[j] -= h[nid]) -= i);</span><br><span class="line">            g[j] = (g[j] - h[nid] - i - g[nid] - i + <span class="number">4</span> * Mod2) % Mod2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; g[1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    sq = std::<span class="built_in">sqrt</span>(n) + <span class="number">1</span>, tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">1</span>, r, t; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t = n / l, r = n / t;</span><br><span class="line">        a[++ tot] = t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt;= sq) id1[t] = tot;</span><br><span class="line">        <span class="keyword">else</span> id2[r] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">solveg1</span>();</span><br><span class="line">    <span class="type">int</span> lim = <span class="number">1</span>;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; a[lim + <span class="number">1</span>] &gt;= sq; ++ lim) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime[i] &gt; a[lim]) <span class="keyword">break</span>;</span><br><span class="line">        LL cur = prime[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; cur &lt;= n; k ++, cur *= prime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            LL mul = (<span class="built_in">mul2</span>(cur, <span class="built_in">sum1</span>(n / cur))</span><br><span class="line">                + <span class="built_in">mul2</span>((Mod2 - cur) * prime[i] % Mod2, <span class="built_in">sum1</span>(n / cur / prime[i]))) % Mod2;</span><br><span class="line">            res = <span class="built_in">mul1</span>(res, <span class="built_in">qpow</span>(k + <span class="number">1</span>, mul));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL mul = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">1</span>, r, t; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t = n / l, r = n / t;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getid</span>(r) &gt; lim) <span class="keyword">continue</span>;</span><br><span class="line">        mul = (mul + <span class="built_in">mul2</span>(g[<span class="built_in">getid</span>(r)] - g[std::<span class="built_in">min</span>(lim, <span class="built_in">getid</span>(l - <span class="number">1</span>))] + Mod2, <span class="built_in">sum1</span>(t))) % Mod2;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">mul1</span>(res, <span class="built_in">qpow</span>(<span class="number">2</span>, mul));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">solveg2</span>();</span><br><span class="line">    res = <span class="built_in">mul1</span>(res, <span class="built_in">qpow</span>(<span class="number">2</span>, g[<span class="number">1</span>]));</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; g[1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; res % Mod1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：求 $\prod_{i = 1} ^ n \sigma_0(i) ^ {i + \mu(i)}$。$n\leq 10 ^ {11}$，对 $10 ^ {12} + 39$ 取模，$T(T\leq 3)$ 组数据，15s。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Min_25" scheme="https://mydcwfy.github.io/tags/Min-25/"/>
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>HDU4997 Biconnected</title>
    <link href="https://mydcwfy.github.io/2022/07/23/HDU4997/"/>
    <id>https://mydcwfy.github.io/2022/07/23/HDU4997/</id>
    <published>2022-07-22T23:30:21.000Z</published>
    <updated>2022-07-22T23:56:48.722Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一个 $n$ 个点 $m$ 条边的无向图，问有多少个 $m$ 条边组成的集合使得只有这些边存在让 $n$ 个点构成一个边双连通分量。$n\leq 10$，对 $10 ^ 9 + 7$ 取模。</p><span id="more"></span><p>其实这个很难计数，因为我们不好实时判断一个边双联通分量是否存在。考虑对其进行容斥。</p><p>首先考虑一个简单的问题：让 $n$ 个点构成连通图的方案数。这个可以通过状态压缩 + 容斥解决，对于每一个集合 $S$，记连通图方案数为 $g(S)$，枚举编号最小的那个点（其实哪个点都行）所在的集合，然后就可以得到以下式子：<br>$$<br>g(S) = f(S) - \sum_{T\subsetneq S, id\in T} g(T) * f(S / T)<br>$$<br>$f(S)$ 代表任意连边的方案数，即为 $\displaystyle 2 ^ {\sum[(u, v)\in E\land u\in S\land v\in S]}$。</p><p>这样我们可以在 $O(3 ^ n)$ 时间内求出所有的 $g(S)$，还是可以接受的。</p><p>然后我们类似于上面这种方法，计算 $h(S)$，表示 $S$ 集合内部组成一个双连通分量的方案数。</p><p>我们直接模仿上面的方法，枚举 $T$ 为最小编号所在集合，然后其他的只需要满足是连通图就可以了。但是这会带来一个问题，就是 $T$ 和 $S/T$ 之间的连边不好确定，因为需要保证 $T$ 和 $S / T$ 联通，但是 $T$ 不会和 $S / T$ 中的任何部分组成边双连通。</p><p>$n \leq 10$ 非常小，我们可以直接考虑枚举点双集合，这需要一个 Bell 数枚举所有集合划分。连通图缩点后一定是一个树，那么我们可以考虑对这个生成树进行计数。对这个生成树计数就显得更为可做，我们预先知道两两之间的连边条数，用矩阵树定理即可求解。想知道两两连边条数，我们可以直接暴力预处理计算，也可以在特定位置 +1，使用集合幂级数，或者是预处理一个点到集合的连边数，都是可以的。</p><p>时间复杂度不好估量，大概是 $O(\mathrm{Bell}(n)n ^ 3)$，可以通过就是了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">det</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; ++ j)</span><br><span class="line"><span class="keyword">if</span> (a[j][i]) &#123;</span><br><span class="line">t = j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!~t) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i ^ t) x ^= <span class="number">1</span>, std::<span class="built_in">swap</span>(a[i], a[t]);</span><br><span class="line">res = (LL) res * a[i][i] % Mod;</span><br><span class="line">LL Inv = <span class="built_in">qpow</span>(a[i][i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; ++ j) a[i][j] = (LL) a[i][j] * Inv % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = n; k &gt;= i; -- k)</span><br><span class="line">a[j][k] = (a[j][k] + (LL) (Mod - a[i][k]) * a[j][i]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x ? <span class="built_in">adj</span>(res = -res) : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; all)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (all.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> m = all.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line"><span class="keyword">if</span> (i != j) a[i][j] = bew[all[i - <span class="number">1</span>]][all[j - <span class="number">1</span>]];</span><br><span class="line"><span class="keyword">else</span> a[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) t += a[i][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line"><span class="keyword">if</span> (a[i][j]) a[i][j] = Mod - a[i][j];</span><br><span class="line">a[i][i] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for (int i = 1; i &lt;= m; ++ i, puts(&quot;&quot;))</span></span><br><span class="line"><span class="comment">for (int j = 1; j &lt;= m; ++ j)</span></span><br><span class="line"><span class="comment">printf(&quot;%d &quot;, a[i][j]);*/</span></span><br><span class="line"><span class="type">int</span> ans = <span class="built_in">det</span>(m - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;x : all) ans = (LL) ans * g[x] % Mod;</span><br><span class="line"><span class="comment">/*for (int x : all) printf(&quot;%d &quot;, x);</span></span><br><span class="line"><span class="comment">printf(&quot;: %d\n&quot;, ans);*/</span></span><br><span class="line"><span class="built_in">adj</span>(res += ans - Mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s, std::vector&lt;<span class="type">int</span>&gt; &amp;all)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="built_in">solve</span>(all);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; s &lt;&lt; &#x27; &#x27; &lt;&lt; all.size() &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">all.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">ctz</span>(s);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s2 = s; s2; s2 = (s2 - <span class="number">1</span>) &amp; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!(s2 &gt;&gt; t &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">all.<span class="built_in">back</span>() = s2;</span><br><span class="line"><span class="built_in">dfs</span>(s ^ s2, all);</span><br><span class="line">&#125;</span><br><span class="line">all.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">ban.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line"><span class="keyword">if</span> (u &gt; v) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">ban.<span class="built_in">insert</span>(&#123;-- u, -- v&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line"><span class="keyword">if</span> (i &gt;= j || ban.<span class="built_in">count</span>(&#123;i, j&#125;)) a[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> a[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s) ins[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s1 = <span class="number">0</span>; s1 &lt; (<span class="number">1</span> &lt;&lt; n); ++ s1)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s2 = <span class="number">0</span>; s2 &lt; (<span class="number">1</span> &lt;&lt; n); ++ s2) bew[s1][s2] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line"><span class="keyword">if</span> (a[i][j]) ins[(<span class="number">1</span> &lt;&lt; i) | (<span class="number">1</span> &lt;&lt; j)] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++ j)</span><br><span class="line">bew[<span class="number">1</span> &lt;&lt; i][<span class="number">1</span> &lt;&lt; j] = bew[<span class="number">1</span> &lt;&lt; j][<span class="number">1</span> &lt;&lt; i] = a[j][i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s1 = <span class="number">0</span>; s1 &lt; (<span class="number">1</span> &lt;&lt; n); ++ s1)</span><br><span class="line"><span class="keyword">if</span> (s1 &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s2 = <span class="number">0</span>; s2 &lt; (<span class="number">1</span> &lt;&lt; n); ++ s2)</span><br><span class="line">bew[s1][s2] += bew[s1 ^ (<span class="number">1</span> &lt;&lt; i)][s2];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s2 = <span class="number">0</span>; s2 &lt; (<span class="number">1</span> &lt;&lt; n); ++ s2)</span><br><span class="line"><span class="keyword">if</span> (s2 &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s1 = <span class="number">0</span>; s1 &lt; (<span class="number">1</span> &lt;&lt; n); ++ s1)</span><br><span class="line">bew[s1][s2] += bew[s1][s2 ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line"><span class="keyword">if</span> (s &gt;&gt; i &amp; <span class="number">1</span>) ins[s] += ins[s ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line">&#123;</span><br><span class="line">f[s] = pw2[ins[s]];</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">ctz</span>(s);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s2 = s &amp; (s - <span class="number">1</span>); s2; s2 = (s2 - <span class="number">1</span>) &amp; s)</span><br><span class="line"><span class="keyword">if</span> (s2 &gt;&gt; t &amp; <span class="number">1</span>) f[s] = (f[s] + (LL) (Mod - f[s2]) * pw2[ins[s ^ s2]]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line">res = <span class="number">0</span>, <span class="built_in">dfs</span>(s, tmp), <span class="built_in">adj</span>(g[s] = f[s] - res);</span><br><span class="line"><span class="comment">// for (int s = 1; s &lt; (1 &lt;&lt; n); ++ s) printf(&quot;%d &quot;, g[s]);</span></span><br><span class="line">std::cout &lt;&lt; g[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一个 $n$ 个点 $m$ 条边的无向图，问有多少个 $m$ 条边组成的集合使得只有这些边存在让 $n$ 个点构成一个边双连通分量。$n\leq 10$，对 $10 ^ 9 + 7$ 取模。&lt;/p&gt;</summary>
    
    
    
    
    <category term="集合幂级数" scheme="https://mydcwfy.github.io/tags/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"/>
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="矩阵树定理" scheme="https://mydcwfy.github.io/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>TopCoder12141 SweetFruits</title>
    <link href="https://mydcwfy.github.io/2022/07/22/TopCoder12141/"/>
    <id>https://mydcwfy.github.io/2022/07/22/TopCoder12141/</id>
    <published>2022-07-22T13:46:10.000Z</published>
    <updated>2022-07-22T23:57:53.594Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给出 $n$ 个点，每个点有一个权值，$a_i\geq 0$ 表示这个点是好的，否则是不好的。任意构造一棵生成树，定义和至少一个好点连边的点是非常好的。求所有非常好的点权值和 $\leq lim$ 的方案数。$n\leq 40$，$-1\leq a_i\leq 2.5\times 10 ^ 8$，$lim\leq 10 ^ 9$。</p><span id="more"></span><p>首先一个比较明显的特征为权值和 $\leq lim$，但是 $lim$ 又是不可压缩的级别。注意到 $n = 40 = 2\times 20$，我们可以使用 meet-in-the-middle 把所有满足权值和 $\leq lim$ 的方案求出来。</p><p>然后注意到一个事实为一旦我们知道了非常好的点的数量，其实他们到底是谁并不重要，我们只需要求出该数量有多少个合法的生成树即可。</p><p>考虑枚举 $k(k\in [0, n])$，计算非常好的点恰好有 $k$ 个的方案数。一个显然的想法是这 $k$ 个点只能和不好的点连边，好的点和好不好的点都可以连边。然后直接使用矩阵树定理就可以求出生成树的数量。</p><p>但是我们又发现了一个问题：这样只能保证好的点一定不是非常好的点，但是无法保证钦定的非常好的点一定就是非常好的点。</p><p>我们可以考虑容斥，假设一个只有 $i$ 个非常好的点的生成树，那么他会在我钦定非常好的点的时候计算 $\displaystyle \binom ki$ 次，那么我们就可以得到以下式子：<br>$$<br>f(k) = \det(k) - \sum_{i = 0} ^ {k - i} f(i) \binom ki<br>$$<br>$\det(k)$ 表示矩阵树定理得到的答案。</p><p>直接计算即可，时间复杂度 $O(2 ^ {\frac n2} + n ^ 4)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">det</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; ++ j)</span><br><span class="line"><span class="keyword">if</span> (a[j][i]) &#123;</span><br><span class="line">t = j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!~t) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i != t) std::<span class="built_in">swap</span>(a[i], a[t]), x ^= <span class="number">1</span>;</span><br><span class="line">LL Inv = <span class="built_in">qpow</span>(a[i][i]);</span><br><span class="line">res = (LL) res * a[i][i] % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; ++ j) a[i][j] = (LL) a[i][j] * Inv % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line"><span class="keyword">if</span> (a[j][i])</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = n; k &gt;= i; -- k)</span><br><span class="line">a[j][k] = (a[j][k] + (LL) (Mod - a[i][k]) * a[j][i]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x ? <span class="built_in">adj</span>(res = -res) : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> ed, <span class="type">int</span> cur, <span class="type">int</span> ct, std::vector&lt;<span class="type">int</span>&gt; *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (id &gt; ed) <span class="keyword">return</span> v[ct].<span class="built_in">push_back</span>(cur);</span><br><span class="line"><span class="built_in">dfs</span>(id + <span class="number">1</span>, ed, cur, ct, v);</span><br><span class="line"><span class="keyword">if</span> (cur + abl[id] &lt;= lim)</span><br><span class="line"><span class="built_in">dfs</span>(id + <span class="number">1</span>, ed, cur + abl[id], ct + <span class="number">1</span>, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; i &lt; N; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = C[i][<span class="number">0</span>] = <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line"><span class="built_in">adj</span>(C[i][j] = C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j] - Mod);</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vl[N]&#123;&#125;, vr[N]&#123;&#125;;</span><br><span class="line"><span class="type">int</span> ok[N]&#123;&#125;, ans[N]&#123;&#125;;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (v[i] &gt;= <span class="number">0</span>) abl[++ cnt] = v[i];</span><br><span class="line"><span class="type">int</span> lcnt = cnt / <span class="number">2</span>, rcnt = cnt - cnt / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>, cnt / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, vl), <span class="built_in">dfs</span>(cnt / <span class="number">2</span> + <span class="number">1</span>, cnt, <span class="number">0</span>, <span class="number">0</span>, vr);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lcnt; ++ i) std::<span class="built_in">sort</span>(vl[i].<span class="built_in">begin</span>(), vl[i].<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= rcnt; ++ i) std::<span class="built_in">sort</span>(vr[i].<span class="built_in">begin</span>(), vr[i].<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lcnt; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= rcnt; ++ j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> r = vr[j].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;x : vl[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (r &gt;= <span class="number">0</span> &amp;&amp; vr[j][r] + x &gt; lim) r --;</span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">adj</span>(ok[i + j] += r + <span class="number">1</span> - Mod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ncnt = <span class="number">0</span>; ncnt &lt;= cnt; ++ ncnt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) a[i][j] = i != j;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt - ncnt; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt - ncnt; ++ j) a[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt - ncnt; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++ j) a[i][j] = a[j][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) t += a[i][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line"><span class="keyword">if</span> (a[i][j]) a[i][j] = Mod - a[i][j];</span><br><span class="line">a[i][i] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for (int i = 1; i &lt;= n; ++ i, puts(&quot;&quot;))</span></span><br><span class="line"><span class="comment">for (int j = 1; j &lt;= n; ++ j) printf(&quot;%d &quot;, a[i][j]);*/</span></span><br><span class="line">ans[ncnt] = <span class="built_in">det</span>(n - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; ncnt &lt;&lt; &#x27; &#x27; &lt;&lt; ans[ncnt] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ex = <span class="number">0</span>; ex &lt; ncnt; ++ ex)</span><br><span class="line">ans[ncnt] = (ans[ncnt] + (LL) (Mod - ans[ex]) * C[ncnt][ex]) % Mod;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; ncnt &lt;&lt; &#x27; &#x27; &lt;&lt; ok[ncnt] &lt;&lt; &#x27; &#x27; &lt;&lt; ans[ncnt] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">res = (res + (LL) ans[ncnt] * ok[ncnt]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SweetFruits</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">countTrees</span><span class="params">(std::vector&lt;<span class="type">signed</span>&gt; val, <span class="type">signed</span> _lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n = val.<span class="built_in">size</span>(), lim = _lim;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) v[i] = val[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">work</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给出 $n$ 个点，每个点有一个权值，$a_i\geq 0$ 表示这个点是好的，否则是不好的。任意构造一棵生成树，定义和至少一个好点连边的点是非常好的。求所有非常好的点权值和 $\leq lim$ 的方案数。$n\leq 40$，$-1\leq a_i\leq 2.5\times 10 ^ 8$，$lim\leq 10 ^ 9$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="矩阵树定理" scheme="https://mydcwfy.github.io/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"/>
    
    <category term="暴力" scheme="https://mydcwfy.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>TopCoder13444 CountTables</title>
    <link href="https://mydcwfy.github.io/2022/07/22/TopCoder13444/"/>
    <id>https://mydcwfy.github.io/2022/07/22/TopCoder13444/</id>
    <published>2022-07-22T13:32:21.000Z</published>
    <updated>2022-07-22T13:42:55.721Z</updated>
    
    <content type="html"><![CDATA[<p>题意：问在 $n\times m$ 的网格上染 $c$ 种颜色，问满足任意两行都不相同、任意两列都不相同的方案数。$n, m\leq 4000$，对 $10 ^ 9 + 7$ 取模。</p><span id="more"></span><p>首先如果我们只满足任意两列都不相同是容易做的，答案就是从 $c ^ n$ 种染法中依次选择 $m$ 种不相同的染色方案了，答案显然为 $\displaystyle \binom{c ^ n}m m!$。</p><p>对于任意两行都不相同，这个是不好做的，我们考虑容斥。设 $f_i$ 表示只考虑 $i\times m$ 网格的答案。假设最后有 $j$ 个互不相同的，那么这个的贡献就是 $f_j$。另外，我们需要把 $i$ 个行划分为 $j$ 个不相同的数，这个其实就是 $\displaystyle i\brace j$。</p><p>这样预处理第二类斯特林数即可，时间复杂度 $O(nm + n ^ 2)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountTables</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = s[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; i &lt; N; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line">s[i][j] = (s[i - <span class="number">1</span>][j - <span class="number">1</span>] + (LL) j * s[i - <span class="number">1</span>][j]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; n - m; -- i) cur = (LL) cur * i % Mod;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">howMany</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">f[i] = <span class="built_in">A</span>(<span class="built_in">qpow</span>(c, i), m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++ j)</span><br><span class="line">f[i] = (f[i] + (LL) (Mod - f[j]) * s[i][j]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：问在 $n\times m$ 的网格上染 $c$ 种颜色，问满足任意两行都不相同、任意两列都不相同的方案数。$n, m\leq 4000$，对 $10 ^ 9 + 7$ 取模。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="斯特林数" scheme="https://mydcwfy.github.io/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3864 Hero meet devil</title>
    <link href="https://mydcwfy.github.io/2022/07/22/BZOJ3864/"/>
    <id>https://mydcwfy.github.io/2022/07/22/BZOJ3864/</id>
    <published>2022-07-22T13:10:21.000Z</published>
    <updated>2022-07-22T13:29:39.254Z</updated>
    
    <content type="html"><![CDATA[<p>题意：有一个字符集为 <code>A, C, G, T</code> 的字符串 $S$，问有多少个长度为 $n$ 的字符串 $T$ 满足 $\mathrm{LCS}(S, T) = i$。你需要输出所有 $i\in [0, |S|]$ 的答案。$|S|\leq 15$，$n\leq 1000$。</p><span id="more"></span><p>DP of DP 模板题。</p><p>首先考虑如果我们已经知道了 $T$，怎么计算 $\mathrm{LCS}(S, T)$。DP 过程不再赘述，这个 DP 过程结果可以由 $|S|$ 个数来代表，分别为每一个前缀和 $T$ 的 $\mathrm{LCS}$。</p><p>注意到一旦我们知道了这 $|S|$ 个数，前面的 $T$ 如何我们其实是不关心的。也就是说，我们可以把这 $|S|$ 个数变成状态，然后枚举 $T$ 的下一个字符，直接转移就可以做完。</p><p>但是注意到一个问题是这 $|S|$ 个数可能都比较大，不好压入状态。但是 $\mathrm{LCS}$ 的特殊性质告诉我们 $dp_i\leq dp_{i - 1} + 1$。因为一旦 $dp_i$ 匹配到了一个 $&gt;dp_{i - 1} + 1$ 的东西，删掉最后一个数就可以得到 $dp_i - 1$ 更新 $dp_{i - 1}$。</p><p>这样我们就可以把差分数组压入状态，容易发现最多只有 $2 ^ {|S|}$ 种状态，就可以计算了，时间复杂度 $O(n 2^{|S|} \sum)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; s &gt;&gt; m;</span><br><span class="line">n = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; (<span class="number">1</span> &lt;&lt; n); ++ sta)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++ j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> f[N], g[N];</span><br><span class="line">f[<span class="number">0</span>] = sta &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) f[i] = f[i - <span class="number">1</span>] + (sta &gt;&gt; i &amp; <span class="number">1</span>);</span><br><span class="line">g[<span class="number">0</span>] = f[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (s[<span class="number">0</span>] == ch[j]) <span class="built_in">chkmax</span>(g[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">g[i] = g[i - <span class="number">1</span>], <span class="built_in">chkmax</span>(g[i], f[i]);</span><br><span class="line"><span class="keyword">if</span> (s[i] == ch[j]) <span class="built_in">chkmax</span>(g[i], f[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> to = g[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (g[i] != g[i - <span class="number">1</span>]) to |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line"><span class="comment">/*std::cout &lt;&lt; &quot;Check &quot; &lt;&lt; sta &lt;&lt; &#x27; &#x27; &lt;&lt; j &lt;&lt; &#x27; &#x27; &lt;&lt; to &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; n; ++ i) printf(&quot;%d &quot;, g[i]);</span></span><br><span class="line"><span class="comment">puts(&quot;&quot;);*/</span></span><br><span class="line">trs[sta][j] = to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; (<span class="number">1</span> &lt;&lt; n); ++ sta) f[<span class="number">0</span>][sta] = !sta;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; (<span class="number">1</span> &lt;&lt; n); ++ sta) f[i &amp; <span class="number">1</span>][sta] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; (<span class="number">1</span> &lt;&lt; n); ++ sta)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++ j)</span><br><span class="line"><span class="built_in">adj</span>(f[i &amp; <span class="number">1</span>][trs[sta][j]] += f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][sta] - Mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> ans[N + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) ans[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line"><span class="built_in">adj</span>(ans[__builtin_popcount(s)] += f[m &amp; <span class="number">1</span>][s] - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：有一个字符集为 &lt;code&gt;A, C, G, T&lt;/code&gt; 的字符串 $S$，问有多少个长度为 $n$ 的字符串 $T$ 满足 $\mathrm{LCS}(S, T) = i$。你需要输出所有 $i\in [0, |S|]$ 的答案。$|S|\leq 15$，$n\leq 1000$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>CF1114F Please, another Queries on Array?</title>
    <link href="https://mydcwfy.github.io/2022/07/22/CF1114F/"/>
    <id>https://mydcwfy.github.io/2022/07/22/CF1114F/</id>
    <published>2022-07-22T12:58:04.000Z</published>
    <updated>2022-07-22T13:06:11.041Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一个长度为 $n$ 的序列 $a$，修改为区间乘 $x$，询问为求 $\varphi(\prod_{i = l} ^ r a_i)$。$n\leq 4\times 10 ^ 5$，$q\leq 2\times 10 ^ 5$，$a_i, x\leq 300$。</p><span id="more"></span><p>首先考虑 $\varphi(n) = n\prod_p \dfrac{p - 1}p$，那么我们现在就相当于是需要知道所有数有没有每一个质数。我们发现 300 以内的数只有 62 个，这给了我们一定的启发。</p><p>首先线段树维护区间乘积肯定是必需的，另外，我们定义一个状态 $s$，表示包含了 $s$ 内的质数。容易发现这个修改时很好做的，也就是说我们只需要根据 $s$ 内部的状态乘上对应的 $\dfrac{p - 1}p$ 即可。</p><p>时间复杂度 $O(q\log n + (n + q)\dfrac{a}{\ln a})$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MulSegment</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line"><span class="type">int</span> res, lt;</span><br><span class="line">&#125; tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; tr[x].res = (LL) tr[x &lt;&lt; <span class="number">1</span>].res * tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].res % Mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[x] = &#123;l, r, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> tr[x].res = a[l], <span class="built_in">void</span>();</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[x].res = (LL) tr[x].res * <span class="built_in">qpow</span>(c, tr[x].r - tr[x].l + <span class="number">1</span>) % Mod;</span><br><span class="line">tr[x].lt = (LL) tr[x].lt * c % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].lt == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span>, tr[x].lt), <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tr[x].lt);</span><br><span class="line">tr[x].lt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt; r || tr[x].r &lt; l) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> <span class="built_in">update</span>(x, c);</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span>, l, r, c), <span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, c);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt; r || tr[x].r &lt; l) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> tr[x].res;</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="keyword">return</span> (LL) <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span>, l, r) * <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125; seg1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OrSegment</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line">LL res, lt;</span><br><span class="line">&#125; tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; tr[x].res = tr[x &lt;&lt; <span class="number">1</span>].res | tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].res; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[x] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, LL c)</span> </span>&#123; tr[x].res |= c, tr[x].lt |= c; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tr[x].lt) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span>, tr[x].lt), <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tr[x].lt);</span><br><span class="line">tr[x].lt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, LL c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt; r || tr[x].r &lt; l) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> <span class="built_in">update</span>(x, c);</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span>, l, r, c), <span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, c);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt; r || tr[x].r &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> tr[x].res;</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span>, l, r) | <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">&#125;</span><br><span class="line">&#125; seg2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> N = <span class="number">301</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) prime[cnt ++] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; i * prime[j] &lt; N; ++ j)</span><br><span class="line">&#123;</span><br><span class="line">st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i) invp[i] = <span class="built_in">qpow</span>(prime[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sieve</span>();</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">seg1.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n), seg2.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">LL s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; prime[j] &lt;= a[i]; ++ j)</span><br><span class="line"><span class="keyword">if</span> (a[i] % prime[j] == <span class="number">0</span>) s |= <span class="number">1LL</span> &lt;&lt; j;</span><br><span class="line">seg2.<span class="built_in">modify</span>(<span class="number">1</span>, i, i, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> l, r, x;</span><br><span class="line"><span class="keyword">while</span> (m --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, s, &amp;l, &amp;r);</span><br><span class="line"><span class="keyword">if</span> (std::<span class="built_in">string</span>(s) == <span class="string">&quot;MULTIPLY&quot;</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">LL s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; ++ j)</span><br><span class="line"><span class="keyword">if</span> (x % prime[j] == <span class="number">0</span>) s |= <span class="number">1LL</span> &lt;&lt; j;</span><br><span class="line">seg1.<span class="built_in">modify</span>(<span class="number">1</span>, l, r, x), seg2.<span class="built_in">modify</span>(<span class="number">1</span>, l, r, s);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">string</span>(s) == <span class="string">&quot;TOTIENT&quot;</span>) &#123;</span><br><span class="line"><span class="type">int</span> res = seg1.<span class="built_in">query</span>(<span class="number">1</span>, l, r);</span><br><span class="line">LL s = seg2.<span class="built_in">query</span>(<span class="number">1</span>, l, r);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">62</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (s &gt;&gt; i &amp; <span class="number">1</span>) res = (LL) res * invp[i] % Mod * (prime[i] - <span class="number">1</span>) % Mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Failed&quot;</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一个长度为 $n$ 的序列 $a$，修改为区间乘 $x$，询问为求 $\varphi(\prod_{i = l} ^ r a_i)$。$n\leq 4\times 10 ^ 5$，$q\leq 2\times 10 ^ 5$，$a_i, x\leq 300$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="线段树" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>LOJ3330 [WC2020]猜数游戏</title>
    <link href="https://mydcwfy.github.io/2022/07/22/LOJ3330/"/>
    <id>https://mydcwfy.github.io/2022/07/22/LOJ3330/</id>
    <published>2022-07-22T12:28:40.000Z</published>
    <updated>2022-07-22T12:51:34.713Z</updated>
    
    <content type="html"><![CDATA[<p>题意过于神秘，就没有简述了。</p><span id="more"></span><p>首先考虑如何判断 $a_i$ 能否表示 $a_j$。如果 $a_i$ 是 $q(p = q ^ k)$ 的话，那么容易发现不超过 $k$ 次幂就一定会变成 0，这样直接暴力查表即可，时间复杂度 $O(n\log n)$ 或者 $O(n\log ^ 2n)$。否则的话，一定可以发现 $a_i$ 可以在原根下有离散对数，这样是否有次幂就可以看作是否在模意义下有倍数，即是否存在一个 $t$ 满足 $t\times \ln a_i\equiv \ln a_j\pmod {\varphi(p)}$。这个的检验显然就是判断 $\gcd(\ln a_j, \varphi(p))$ 是否整除 $\ln a_i$。</p><p>求原根时间复杂度不计，求离散对数时间复杂度 $O(n\sqrt p)$，两两判断是 $O(n ^ 2\log n)$ 的，不过 $\log$ 是 $\gcd$ 的，比较小，可以接受。</p><p>接下来考虑如何计算至少需要的次数。如果我们把 $a_i\to a_j$ 的有向边表示 $a_i$ 能表示 $a_j$ 的话，那么相当于是统计入度为 0 的点的个数。一个显然的结论是这个图是一个传递闭包，因为 $a_i\to a_j$，$a_j\to a_k$，那么 $a_i$ 一定能表示 $a_k$。</p><p>首先我们从 DAG 入手。把每个点被选的概率分开看，那么能到达他的点一定不能被选，自己一定要选，这样就可以计算概率。</p><p>不是 DAG 的情况，直接缩点后按照上面的做法计算即可。时间复杂度 $O(n\sqrt p + n ^ 2\log n)$，可以接受，比较卡常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BSGS</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">1</span> || P == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> __gnu_pbds::gp_hash_table&lt;<span class="type">int</span>, <span class="type">int</span>&gt; H;</span><br><span class="line"><span class="keyword">if</span> (H.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cur = <span class="number">1</span>, K = std::<span class="built_in">sqrt</span>(P) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; K; ++ i, cur = (LL) cur * a % P)</span><br><span class="line">H[cur] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cur, ak, K = std::<span class="built_in">sqrt</span>(P) + <span class="number">1</span>, x, y;</span><br><span class="line">cur = ak = <span class="built_in">qpow</span>(a, K);</span><br><span class="line"><span class="built_in">ExGcd</span>(b, P, x, y), x = (x % P + P) % P, cur = (LL) cur * x % P;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= K; ++ i, cur = (LL) cur * ak % P)</span><br><span class="line"><span class="keyword">if</span> (H.<span class="built_in">find</span>(cur) != H.<span class="built_in">end</span>()) <span class="keyword">return</span> i * K - H[cur];</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Phi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; ++ i)</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">res = res / i * (i - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n != <span class="number">1</span>) res = res / n * (n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findrt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; fac;</span><br><span class="line"><span class="type">int</span> phi = <span class="built_in">Phi</span>(P), n = phi;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; ++ i)</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">fac.<span class="built_in">push_back</span>(phi / i);</span><br><span class="line"><span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n ^ <span class="number">1</span>) fac.<span class="built_in">push_back</span>(phi / n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> p : fac)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">qpow</span>(x, p) == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; phi; ++ i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(i)) <span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++ *dfn, ins[stk[++ top] = x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (!dfn[v]) <span class="built_in">tarjan</span>(v), <span class="built_in">chkmin</span>(low[x], low[v]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ins[v]) <span class="built_in">chkmin</span>(low[x], dfn[v]);</span><br><span class="line"><span class="keyword">if</span> (low[x] ^ dfn[x]) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> cur;</span><br><span class="line">++ *bel;</span><br><span class="line"><span class="keyword">do</span> ins[cur = stk[top --]] = <span class="literal">false</span>, bel[cur] = *bel, sz[*bel] ++; <span class="keyword">while</span> (cur != x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; inv = [&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line"><span class="keyword">return</span> i == <span class="number">1</span> ? <span class="number">1</span> : (LL) (Mod - Mod / i) * <span class="built_in">inv</span>(Mod % i) % Mod;</span><br><span class="line">&#125;;</span><br><span class="line">pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) <span class="built_in">adj</span>(pw[i] = pw[i - <span class="number">1</span>] * <span class="number">2</span> - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++ i) ipw[i] = <span class="built_in">inv</span>(pw[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; P;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="type">int</span> phi = <span class="built_in">Phi</span>(P), G = <span class="built_in">findrt</span>(), frm = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (; P % frm; ++ frm);</span><br><span class="line">__gnu_pbds::gp_hash_table&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (a[i] % frm) a[i] = <span class="built_in">BSGS</span>(G, a[i]);</span><br><span class="line"><span class="keyword">else</span> mp[a[i]] = i, pp[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// exit(0);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (pp[i]) &#123;</span><br><span class="line"><span class="type">int</span> cur = (LL) a[i] * a[i] % P;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; a[i] &lt;&lt; &quot; Start\n&quot;;</span></span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mp.<span class="built_in">find</span>(cur) != mp.<span class="built_in">end</span>()) g[i].<span class="built_in">push_back</span>(mp[cur]);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; cur &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">cur = (LL) cur * a[i] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;End\n&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line"><span class="keyword">if</span> (!pp[i] &amp;&amp; !pp[j] &amp;&amp; i != j &amp;&amp; a[j] % <span class="built_in">Gcd</span>(phi, a[i]) == <span class="number">0</span>)</span><br><span class="line">g[i].<span class="built_in">push_back</span>(j);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (bel[x] != bel[v])</span><br><span class="line">h[bel[v]].<span class="built_in">push_back</span>(bel[x]);</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= *bel; ++ x)</span><br><span class="line">&#123;</span><br><span class="line">std::<span class="built_in">sort</span>(h[x].<span class="built_in">begin</span>(), h[x].<span class="built_in">end</span>()), h[x].<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(h[x].<span class="built_in">begin</span>(), h[x].<span class="built_in">end</span>()), h[x].<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : h[x])</span><br><span class="line">cur = (LL) cur * ipw[sz[v]] % Mod;</span><br><span class="line">res = (res + (LL) cur * (pw[sz[x]] - <span class="number">1</span>) % Mod * ipw[sz[x]]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">res = (LL) res * pw[n] % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意过于神秘，就没有简述了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Tarjan" scheme="https://mydcwfy.github.io/tags/Tarjan/"/>
    
    <category term="期望" scheme="https://mydcwfy.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
    <category term="离散对数" scheme="https://mydcwfy.github.io/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1488 [HNOI2009]图的同构</title>
    <link href="https://mydcwfy.github.io/2022/07/20/BZOJ1488/"/>
    <id>https://mydcwfy.github.io/2022/07/20/BZOJ1488/</id>
    <published>2022-07-20T13:42:55.000Z</published>
    <updated>2022-07-21T01:01:01.635Z</updated>
    
    <content type="html"><![CDATA[<p>题意：问点数为 $n$ 的本质不同无向图个数。$n\leq 60$，对 997 取模。</p><span id="more"></span><p>本质不同，显然是群论知识了。</p><p>有没有可以使用 2 种颜色来表示，现在就相当于是无向完全图个数计数。</p><p>容易发现一共有 $n!$ 种不同的点置换。现在考虑对于每种不同的置换求不动点的个数。</p><p>对于一个置换长度为 $k$ 内部的循环，有 $\lfloor\dfrac k2\rfloor$ 种不同的等价类，画画图就知道了。</p><p>对于两个长度为 $k_1, k_2$ 的点置换之间的边，我们可以一直转的话，可以得到下面这种情况：</p><img src="/2022/07/20/BZOJ1488/sample.png" class=""><p>容易发现这样中间的 6 条边都是一个等价类。该图比较特殊，如果画一些 $k_1 = 4, k_2 = 6$ 之类的情况的话会发现有 $\gcd(k_1, k_2)$ 个等价类。</p><p>这样算下来一共等价类的个数为：<br>$$<br>\sum_k \lfloor\dfrac k2\rfloor + \sum_{k_1} \sum_{k_2} \gcd(k_1, k_2)<br>$$<br>注意上面的 $k_1, k_2$ 不能来自同一个置换。</p><p>这样直接计算是 $O(n!)$ 的，无法接受。</p><p>注意到我们只需要找到每一个循环的长度即可，然后考虑如果我们只枚举所有循环的长度如何计算。这样其实是整数划分的个数，大概为 $O(\dfrac{10 ^ {\sqrt n}}{n})$，可以接受。</p><p>如果我们已经定义了每一个长度为 $b_i$，每一个长度的循环个数为 $c_i$，那么首先每一个置换是一个圆排列，所以需要除以 $b_i$，然后不同长度的可以任意变换，需要除以 $c_i!$，那么整个的答案就是：<br>$$<br>\dfrac 1{n!} \sum_{b_1, b_2, \dots} \dfrac{n!}{\prod b_i \prod c_i!}<br>$$<br>$n!$ 可以消去，直接计算即可。时间复杂度 $O(\dfrac{10 ^ {\sqrt n}}{n}\mathrm{poly} n)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// puts(&quot;One Division&quot;);</span></span><br><span class="line"><span class="comment">// for (int i = 1; i &lt;= tot; ++ i) printf(&quot;%d cnt = %d\n&quot;, p[i], cnt[i]);</span></span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>, ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line">k += p[i] / <span class="number">2</span> * cnt[i] + p[i] * cnt[i] * (cnt[i] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= tot; ++ j)</span><br><span class="line">k += g[p[i]][p[j]] * cnt[i] * cnt[j];</span><br><span class="line">ans = <span class="built_in">qpow</span>(<span class="number">2</span>, k);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line">ans = (LL) ans * <span class="built_in">qpow</span>(p[i], Mod - <span class="number">1</span> - cnt[i]) % Mod * infact[cnt[i]] % Mod;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="built_in">adj</span>(res += ans - Mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> ls, <span class="type">int</span> rem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rem == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">solve</span>();</span><br><span class="line">++ tot;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = ls + <span class="number">1</span>; i &lt;= rem; ++ i)</span><br><span class="line"><span class="keyword">for</span> (p[tot] = i, cnt[tot] = <span class="number">1</span>; cnt[tot] * i &lt;= rem; ++ cnt[tot])</span><br><span class="line"><span class="built_in">dfs</span>(i, rem - i * cnt[tot]);</span><br><span class="line">-- tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++ j)</span><br><span class="line">g[i][j] = <span class="built_in">Gcd</span>(i, j);</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>, n);</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：问点数为 $n$ 的本质不同无向图个数。$n\leq 60$，对 997 取模。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="群论" scheme="https://mydcwfy.github.io/tags/%E7%BE%A4%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>CF908E New Year and Entity Enumeration</title>
    <link href="https://mydcwfy.github.io/2022/07/20/CF908E/"/>
    <id>https://mydcwfy.github.io/2022/07/20/CF908E/</id>
    <published>2022-07-20T12:56:42.000Z</published>
    <updated>2022-07-20T13:26:31.255Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定 $n$ 个二进制下 $m$ 位的数，问有多少个集合 $S$ 包含这 $n$ 个数并且满足取反、与运算封闭（即任意对 $S$ 集合内部元素取反或者是与运算操作得到的数都 $\in S$），问都多少个这样的 $S$。$m\leq 1000$，$n\leq 50$，对 $10 ^ 9 + 7$ 取模。</p><span id="more"></span><p>首先容易发现一个结论：或和异或操作都是可以实现的。</p><p>一顿构造得到：$a|b = \sim((\sim a)\odot (\sim b))$，$a\oplus b = (a | b)\odot (\sim(a\odot b))$。那么下面相当于 3 种基本运算都可以使用并且是封闭的。</p><p>假设一个集合 $\{x_1, x_2, \dots, x_k\}$ 在 $n$ 个数中，这些位置出现 01 是相同的（即要么都出现 0，要么都出现 1）。考虑以下一个结论：$S$ 和这样的集合划分一一对应。</p><p>首先如果一个集合内出现了一个不和别人相同的，那么比如在某一位 $x_1 = 0$，$x_2 = 1$，那么我们取反就可以得到 $x_1 = 1, x_2 = 0$ 的情况，这样下去，那么 $x_1$ 和 $x_2$ 就不是一个集合的了。</p><p>一个集合会一起出现 01 两种情况，不同集合之间随意组合，然后就可以得到 $S$ 的所有元素了。</p><p>容易发现如果两个位置在某个数出现的是不同的，那么这两个永远不可能成为一个集合。也就是说我们只需要关心每个数出现的 bit 都是相同的，这些位置的才可能被划分为一个集合。</p><p>怎样固定大小求集合划分计数呢？容易发现这个就是 Bell 数，当然其实也是第二类斯特林数一行的和。随便做做就可以 $O(m ^ 2)$ 啦。</p><p>最后复杂度不高，可以轻松通过。判断每个 bit 是不是相同显然可以压位扔到 <code>std::map</code> 里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) fact[i] = (LL) fact[i - <span class="number">1</span>] * i % Mod;</span><br><span class="line">infact[N - <span class="number">1</span>] = <span class="built_in">qpow</span>(fact[N - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = N - <span class="number">2</span>; i; -- i) infact[i] = (LL) infact[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % Mod;</span><br><span class="line">B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++ j) B[i + <span class="number">1</span>] = (B[i + <span class="number">1</span>] + (LL) <span class="built_in">C</span>(i, j) * B[j]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>, t; j &lt;= m; ++ j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>, &amp;t);</span><br><span class="line"><span class="keyword">if</span> (t) s[j] |= <span class="number">1LL</span> &lt;&lt; i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) ++ F[s[i]];</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [s, cnt] : F) res = (LL) res * B[cnt] % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定 $n$ 个二进制下 $m$ 位的数，问有多少个集合 $S$ 包含这 $n$ 个数并且满足取反、与运算封闭（即任意对 $S$ 集合内部元素取反或者是与运算操作得到的数都 $\in S$），问都多少个这样的 $S$。$m\leq 1000$，$n\leq 50$，对 $10 ^ 9 + 7$ 取模。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>CF891E Lust</title>
    <link href="https://mydcwfy.github.io/2022/07/20/CF891E/"/>
    <id>https://mydcwfy.github.io/2022/07/20/CF891E/</id>
    <published>2022-07-20T12:33:15.000Z</published>
    <updated>2022-07-20T12:52:55.550Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定长度为 $n$ 序列 $a$，每次随机选择 $i\in [1, n]$，将 $r$ 加上 $\prod_{j\ne i} a_j$，然后让 $a_i$ 减 1。问 $k$ 次操作后，$r$ 的期望。$n\leq 5000$，$k\leq 10 ^ 9$，对 $10 ^ 9 + 7$ 取模。</p><span id="more"></span><p>首先给出一个结论：<br>$$<br>r = \prod_{i = 1} ^ n a_i - \prod_{i = 1} ^ n a_i’<br>$$<br>表示前后 $a_i$ 乘积的变化量。这个可以通过分每一步看来得到，既然单步是正确的，那么合并起来也是正确的。</p><p>现在显然是求变化后的期望。</p><p>考虑使用 EGF 计算每一步改变的哪一个位置，然后合并。单个的 EGF 可以写作：$\sum_{i = 0} \dfrac{x ^ i}{i!} (a - i)$。</p><p>那么最后变化后的期望就是：<br>$$<br>\dfrac{k!}{n ^ k} [x ^ k] \prod_{i = 1} ^ n \sum_{j = 0} \dfrac{x ^ j}{j!}(a_j - x)<br>$$<br>不是封闭形式不好计算，考虑对每一个 $\sum_{i = 0} \dfrac{x ^ i} {i!} (a - i)$ 变换来尝试得到封闭形式：<br>$$<br>\begin{aligned}<br>&amp; \sum_{j = 0} \dfrac{x ^ j}{j!} (a - j)\\<br>=&amp; \sum_{j = 0} \dfrac{x ^ ja}{j!} - \sum_{j = 0} \dfrac{x ^ jj}{j!}\\<br>=&amp; ae ^ x - \sum_{j = 1} \dfrac{xx ^ {j - 1}}{(j - 1!)}\\<br>=&amp; (a - x) e ^ x<br>\end{aligned}<br>$$<br>这样就变成的封闭形式。</p><p>乘起来可以得到：<br>$$<br>\dfrac{k!}{n ^ k} [x ^ k] e ^ {nx} \prod_{i = 1} ^ n (a_i - x)<br>$$<br>后面这个式子可以 $O(n\log ^ 2 n)$ 计算，但是直接 $O(n ^ 2)$ DP 计算每一位也不是不行。</p><p>下面对后面是贡献 $x ^ t$ 时 $x ^ k$ 的系数计算：<br>$$<br>\dfrac{k!}{n ^ k} \times \dfrac{c_t n ^ {k - t}}{(k - t)!}<br>$$<br>虽然 $k$ 很大，但是 $t$ 不大，这些都可以约到 $t$ 项，而且不同的 $t$ 可以递推计算，所以这不是难事，可以在 $O(n)$ 或者 $O(n\log k)$ 的时间内求出所有 $t\in [0, n]$ 的贡献。</p><p>总时间复杂度 $O(n ^ 2)$，<del>狗都不写 MTT</del>。注意代码中的 <code>f[t]</code> 求的是 $n - t$ 的系数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) std::cin &gt;&gt; a[i];</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; ~j; -- j)</span><br><span class="line">f[j + <span class="number">1</span>] = (f[j + <span class="number">1</span>] + (LL) f[j] * a[i]) % Mod;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>, cur = k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; i &lt;= k; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>))</span><br><span class="line">res = (res + (LL) (Mod - cur) * <span class="built_in">qpow</span>(n, k - i) % Mod * f[n - i]) % Mod;</span><br><span class="line"><span class="keyword">else</span> res = (res + (LL) cur * <span class="built_in">qpow</span>(n, k - i) % Mod * f[n - i]) % Mod;</span><br><span class="line">cur = (LL) cur * (k - i) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">res = (LL) res * <span class="built_in">qpow</span>(n, Mod - <span class="number">1</span> - k) % Mod;</span><br><span class="line"><span class="comment">// adj(res = f[n] - res);</span></span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定长度为 $n$ 序列 $a$，每次随机选择 $i\in [1, n]$，将 $r$ 加上 $\prod_{j\ne i} a_j$，然后让 $a_i$ 减 1。问 $k$ 次操作后，$r$ 的期望。$n\leq 5000$，$k\leq 10 ^ 9$，对 $10 ^ 9 + 7$ 取模。&lt;/p&gt;</summary>
    
    
    
    
    <category term="生成函数" scheme="https://mydcwfy.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
    <category term="期望" scheme="https://mydcwfy.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>ARC Round#130</title>
    <link href="https://mydcwfy.github.io/2022/07/14/ARC-Round-130/"/>
    <id>https://mydcwfy.github.io/2022/07/14/ARC-Round-130/</id>
    <published>2022-07-14T10:44:53.000Z</published>
    <updated>2022-07-14T12:09:48.295Z</updated>
    
    <content type="html"><![CDATA[<p>顺风场，vp 的时候打到了 rk 27 左右，补题也还不算很困难。</p><span id="more"></span><p>A、B 略去。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定两个数位不包含 0 的数 $a, b$，要求重排后两个数的和的数位和最小。求重排后的 $a, b$。$a, b\leq 10 ^ {100000}$。</p><p>容易发现肯定是需要进位最多。进位有 3 个源头：</p><ol><li>最低位满足两个数加起来 $\geq 10$。</li><li>从低位向高位一段区间，满足两个数加起来 $\geq 9$。</li><li>$a, b$ 位数不同，假设 $b$ 更高，$b$ 从 $a$ 没有的位置开始有一段 9，且 $a$ 有的位置都产生了进位。</li></ol><p>首先容易发现不管是 $\geq 10$ 还是 $\geq 9$，我们都是一种双指针的策略贪心选取合法匹配中最小的一组。第一种情况和其他情况不同，我们暴力枚举 $a, b$ 的最低位知多少，然后高位直接贪心匹配 1 和 8，2 和 7，3 和 6……不能匹配就把后面的 +1，继续匹配。</p><p>由贪心易得正确性。不同答案的合并直接判进位次数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(std::string cura, std::string curb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::<span class="built_in">reverse</span>(cura.<span class="built_in">begin</span>(), cura.<span class="built_in">end</span>());</span><br><span class="line">std::<span class="built_in">reverse</span>(curb.<span class="built_in">begin</span>(), curb.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">while</span> (cura.<span class="built_in">size</span>() &lt; curb.<span class="built_in">size</span>()) cura += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, ls = <span class="number">0</span>; i &lt; (<span class="type">int</span>) curb.<span class="built_in">size</span>(); ++ i)</span><br><span class="line">ls = cura[i] - <span class="string">&#x27;0&#x27;</span> + curb[i] - <span class="string">&#x27;0&#x27;</span> + ls &gt;= <span class="number">10</span>, cnt += ls;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> _a, <span class="type">int</span> _b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;Solve &quot; &lt;&lt; _a &lt;&lt; &#x27; &#x27; &lt;&lt; _b &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">auto</span> ta = cnta, tb = cntb;</span><br><span class="line">std::string cura, curb;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">9</span>, j = <span class="number">1</span>; i; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= <span class="number">9</span> &amp;&amp; ta[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (i + j &lt; <span class="number">9</span>) &#123;</span><br><span class="line">++ j;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> del = std::<span class="built_in">min</span>(ta[i], tb[j]);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; j &lt;&lt; &#x27; &#x27; &lt;&lt; del &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">cura += std::<span class="built_in">string</span>(del, i | <span class="number">48</span>), curb += std::<span class="built_in">string</span>(del, j | <span class="number">48</span>);</span><br><span class="line">ta[i] -= del, tb[j] -= del;</span><br><span class="line"><span class="keyword">if</span> (!tb[j]) ++ j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">9</span>; i; -- i) cura += std::<span class="built_in">string</span>(ta[i], i | <span class="number">48</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">9</span>; i; -- i) curb += std::<span class="built_in">string</span>(tb[i], i | <span class="number">48</span>);</span><br><span class="line">std::<span class="built_in">reverse</span>(cura.<span class="built_in">begin</span>(), cura.<span class="built_in">end</span>());</span><br><span class="line">std::<span class="built_in">reverse</span>(curb.<span class="built_in">begin</span>(), curb.<span class="built_in">end</span>());</span><br><span class="line">cura.<span class="built_in">push_back</span>(_a | <span class="number">48</span>), curb.<span class="built_in">push_back</span>(_b | <span class="number">48</span>);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; cura &lt;&lt; &#x27; &#x27; &lt;&lt; curb &lt;&lt; &#x27; &#x27; &lt;&lt; getsum(cura, curb) &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">getsum</span>(cura, curb) &gt; <span class="built_in">getsum</span>(resa, resb) || resa.<span class="built_in">empty</span>()) resa = cura, resb = curb;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="type">bool</span> rev = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>()) std::<span class="built_in">swap</span>(a, b), rev = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> &amp;c : a) cnta[c &amp; <span class="number">15</span>] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> &amp;c : b) cntb[c &amp; <span class="number">15</span>] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; ++ j)</span><br><span class="line"><span class="keyword">if</span> (cnta[i] &amp;&amp; cntb[j]) &#123;</span><br><span class="line">cnta[i] --, cntb[j] --;</span><br><span class="line"><span class="built_in">solve</span>(i, j);</span><br><span class="line">cnta[i] ++, cntb[j] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!rev) std::cout &lt;&lt; resa &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; resb &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> std::cout &lt;&lt; resb &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; resa &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：要将 $[1, n]$ 的排列放入一个 $n$ 个点的树，每个点对应一个权值，使得每个点都是局部最小或最大（比相邻点都大 / 小），问有多少种方案，对 998244353 取模。$n\leq 3000$。</p><p>套路树形 DP + 背包。记录 $f(i, j, k)$ 表示 $i$ 所在子树内 $i$ 是局部最小值还是最大值（$k = 0$ 表示最小，$k = 1$ 表示最大），且 $i$ 在子树内的排名是 $j$。直接暴力合并，即可得到答案。</p><p>看似我们需要枚举 $u, v$ 在对应子树内的排名，是 $O(n ^ 3)$ 的，但是容易发现枚举的排名都是 $O(sz)$ 的。考虑每一对点对 $(x, y)$，他们都只会在 $lca$ 处枚举到，而他的代价和 $O(sz)$ 枚举的代价相同，于是原问题也是 $O(n ^ 2)$ 的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sz[x] = <span class="number">1</span>, dp[x][<span class="number">0</span>][<span class="number">1</span>] = dp[x][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v, x);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> tmp[N], sum[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz[x] + sz[v]; ++ i) tmp[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz[v] + <span class="number">1</span>; ++ i) sum[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = sz[v]; i; -- i) <span class="built_in">adj</span>(sum[i] = sum[i + <span class="number">1</span>] + dp[v][<span class="number">1</span>][i] - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz[x]; ++ i) <span class="comment">// sz[x] - i</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sz[v]; ++ j) <span class="comment">// sz[v] - j</span></span><br><span class="line">tmp[i + j] = (tmp[i + j] + (LL) dp[x][<span class="number">0</span>][i] * sum[j + <span class="number">1</span>] % Mod * <span class="built_in">C</span>(i + j - <span class="number">1</span>, i - <span class="number">1</span>)</span><br><span class="line">% Mod * <span class="built_in">C</span>(sz[x] + sz[v] - i - j, sz[x] - i)) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz[x] + sz[v]; ++ i) dp[x][<span class="number">0</span>][i] = tmp[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz[x] + sz[v]; ++ i) tmp[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz[v]; ++ i) sum[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz[v]; ++ i)</span><br><span class="line"><span class="built_in">adj</span>(sum[i] = sum[i - <span class="number">1</span>] + dp[v][<span class="number">0</span>][i] - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz[x]; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= sz[v]; ++ j)</span><br><span class="line">tmp[i + j] = (tmp[i + j] + (LL) dp[x][<span class="number">1</span>][i] * sum[j] % Mod * <span class="built_in">C</span>(i + j - <span class="number">1</span>, i - <span class="number">1</span>)</span><br><span class="line">% Mod * <span class="built_in">C</span>(sz[x] + sz[v] - i - j, sz[x] - i)) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz[x] + sz[v]; ++ i) dp[x][<span class="number">1</span>][i] = tmp[i];</span><br><span class="line"></span><br><span class="line">sz[x] += sz[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">g[u].<span class="built_in">push_back</span>(v), g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">adj</span>(res += dp[<span class="number">1</span>][<span class="number">0</span>][i] - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">adj</span>(res += dp[<span class="number">1</span>][<span class="number">1</span>][i] - Mod);</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：对一个正整数序列 $A$ 操作 $k$ 次，单次操作为把一个最小值 +1。最后得到一个长度为 $k$ 的序列 $id$，为每次 +1 的数的位置。现已知 $id$，求是否存在一个 $A$ 满足能得到 $id$，如果存在输出字典序最小的 $A$。$n, k\leq 3\times 10 ^ 5$。</p><p>和官方题解做法似乎不同，来自 jiangly 的代码。</p><p>首先有一个关键的性质：</p><blockquote><p>结论：答案序列 $A$ 在操作过程中一定出现了一次所有数都相同的时候。</p><p>证明：首先考虑至少出现了一次的数。当操作完之后，所有数一定都满足任意数差都不超过 1，因为一旦出现这种情况，小的那个数一定会在大的那个数操作第一次前就和他靠近距离，最后一定差不超过 1。而最后几次操作一定是对着 $val + 1$ 去的（设最小值为 $val$），那么消完所有的 $val + 1$ 后，都是 $val$ 了。另外，对于没有操作的数，他们至少是 $val$，否则会被操作一次；另外 $&gt; val$ 就不优了，因为 $=val$ 可以满足条件。</p></blockquote><p>容易发现如果我们找到这个时候和这个时候所有数的权值，原序列很容易求出了。</p><p>尝试对原操作序列进行分段，使得每一段操作的数的最小值相同。容易发现一段一定不包含任何重复的数字，并且区间长度等于右端点前面出现不同数字的总和。那么可以得到结论中提到的位置就是倒数第二段的右端点，而权值就是前面段数 +1（减掉段数次后还得是正整数）。</p><p>考虑逐个计算以 $i$ 结尾的段数。维护一个 $mx$ 表示倒序扫描扫到第一个重复数字的位置。容易发现最后一段划分位置不能在 $mx$ 之前。另外，转移的时候肯定是从 $i - cnt$ 划分（如果合法）。</p><p>然后从最后的 $mx$ 向后扫描，看能否找到一个合法划分的，如果能的话，找一个段数最小的，段数相同肯定位置较大的更优。找到之后模拟即可。时间复杂度线性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, id + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cur[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">ls[i] = cur[id[i]], cur[id[i]] = i;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, cnt = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">chkmax</span>(mx, ls[i]), cnt += !~ls[i];</span><br><span class="line"><span class="keyword">if</span> (mx + cnt &gt; i) cov[i] = INF;</span><br><span class="line"><span class="keyword">else</span> cov[i] = cov[i - cnt] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fin = INF, pos = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = mx; i &lt; m; ++ i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">chkmin</span>(fin, cov[i]), fin == cov[i]) pos = i;</span><br><span class="line"><span class="keyword">if</span> (fin &gt; INF / <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = fin + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = pos; i; -- i) -- a[id[i]];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：给出一个序列，令 $j = \dfrac{i + k}2$，可以把 $a_j\leftarrow \lfloor \dfrac{a_i + a_k}{2} \rfloor$，求任意操作之后得到的 $\sum a$ 的最小值。$n\leq 3\times 10 ^ 5, n\leq 10 ^ {12}$。</p><p>其实感觉很神秘的一个题目，其实似乎没有 E 难？</p><p>容易发现如果 $a_j &gt; \dfrac{a_i + a_k}{2}$，我们操作一波之后其实变成了这样：</p><img src="/2022/07/14/ARC-Round-130/ARC130F1.png" class=""><p>这样操作相当于把下凸的部分砍掉了，那么剩下的部分其实就是一个 $(i, a_i)$ 的上凸包不会被消灭。</p><p>如果是实数的话，这个题就做完了，直接计算新的这个点会落在那两个关键点之间，然后用斜率算算即可。求凸包可以直接单调栈做到线性。</p><p>问题就在于还有一个神秘的下取整。容易发现不同段之间其实还是没有影响，因为不可能把原来的关键点给弄没了的。主要就在于把区间内部的搞好。</p><p>大概目前看到的最简洁的做法是把区间内按照原来构造直接下取整的数组构造出来，差分后直接排序，再放回去前缀和。容易发现这个还是不影响段间的情况。</p><p>其实这么做的原因是由于负数除法的时候会向 0 取整，出一些锅，好像只有正数（相邻两个关键点变化量为正）时没有问题吧。没验证过，还不太清楚。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">LL x, y;</span><br><span class="line">Point <span class="keyword">operator</span> -(Point t) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;; &#125;</span><br><span class="line">LL <span class="keyword">operator</span> *(Point t) <span class="type">const</span> &#123; <span class="keyword">return</span> x * t.y - y * t.x; &#125;</span><br><span class="line">&#125; p[N];</span><br><span class="line"><span class="type">int</span> n, stk[N];</span><br><span class="line">LL a[N], b[N], del[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) std::cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) p[i] = &#123;i, a[i]&#125;;</span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; (p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top - <span class="number">1</span>]]) &lt;= <span class="number">0</span>)</span><br><span class="line">top --;</span><br><span class="line">stk[++ top] = i;</span><br><span class="line">&#125;</span><br><span class="line">b[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; top; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = stk[i] + <span class="number">1</span>; j &lt;= stk[i + <span class="number">1</span>]; ++ j)</span><br><span class="line">b[j] = a[stk[i]] + (a[stk[i + <span class="number">1</span>]] - a[stk[i]]) * (j - stk[i]) / (stk[i + <span class="number">1</span>] - stk[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) del[i] = b[i + <span class="number">1</span>] - b[i];</span><br><span class="line">std::<span class="built_in">sort</span>(del + <span class="number">1</span>, del + n);</span><br><span class="line">b[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) b[i + <span class="number">1</span>] = b[i] + del[i];</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) res += b[i];</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;顺风场，vp 的时候打到了 rk 27 左右，补题也还不算很困难。&lt;/p&gt;</summary>
    
    
    
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>ARC141F Well-defined Abbreviation</title>
    <link href="https://mydcwfy.github.io/2022/07/13/ARC141F/"/>
    <id>https://mydcwfy.github.io/2022/07/13/ARC141F/</id>
    <published>2022-07-13T13:20:33.000Z</published>
    <updated>2022-07-13T14:00:11.438Z</updated>
    
    <content type="html"><![CDATA[<p>题意：有 $n$ 个串只包含 <code>A, B, C, D</code> 的 $S_i$，问是否存在一个 $T$，经过删除 $T$ 中存在的 $S_i$ 直到不存在任意一个 $S_i$ 后，可以得到不同的串。$n, \sum |S_i|\leq 2\times 10 ^ 6$，8s。</p><span id="more"></span><p>神仙 AC 自动机 + Hash 随机化分析。</p><p>首先分析几个结论：</p><blockquote><p>结论 1：如果一个 $S_i$ 被其他串组合后完全删除，那么这个串是没有意义的。</p></blockquote><p>证明：显然如果要删这个串的话，可以删除组成他的所有串。</p><blockquote><p>结论 2：如果一个 $S_i$ 被其他串所删除但是没有完全删除，那么答案一定是 Yes。</p></blockquote><p>证明：直接取 $T = S_i$，至少会得到空串和没有完全删除的串，已经符合题目条件。</p><p>有了上面两个结论之后，我们可以通过使用 AC 自动机暴力匹配，用一个栈记录匹配过程，如果匹配到了一个串的话，直接倒回到还没有加入串前的状态。这样一定不会出现贪心匹配没有完全匹配的情况（即有其他方案使得该串被完全删除），因为一旦出现这种情况，答案就是 Yes。</p><p>下面所有的串一定不会出现一个是另一个子串的问题了。</p><p>再来一个结论：</p><blockquote><p>结论 3：如果出现两个串 $S_i$ 和 $S_j$（$i, j$ 可能相同），$S_i$ 的某个后缀和 $S_j$ 的某个前缀是相同的，并且剩余部分不同，那么答案一定是 Yes。</p></blockquote><p>证明：构造一个串为 $S_i$ 去掉相同后缀的前缀 + 共同后缀 / 前缀 + $S_j$ 去掉相同前缀的后缀。我们前面说到，不会再出现一个串是另一个子串的情况。那么 $S_i, S_j$ 分别删除后，剩下的两个串不同且无法消去，于是答案就是 Yes。</p><p>最后一个结论：</p><blockquote><p>结论 4：不满足结论 3 的条件，答案一定是 No。</p></blockquote><p>因为如果一个答案是 Yes 的话，一定出现了两个串相交的情形（否则没有相干，自己删自己的），而又不会出现子串的情形，所以肯定只有结论 3 的情况才会出现 Yes 的可能性。</p><p>下面就是需要判断 $S_i$ 的后缀和某个 $S_j$ 的前缀匹配，并且 $S_i, S_j$ 的剩余部分不同。有接着使用 AC 自动机做法，但人懒了，直接大力 Hash 做。</p><p>具体的，可以考虑枚举每一个后缀，将其 Hash 值和剩余部分的 Hash 值存下来，然后再枚举每个前缀，尝试匹配一些后缀。时间复杂度 $O(\sum |S|)$ 或 $O(\sum |S|\log \sum |S|)$。</p><p>最后一个问题就是众所周知的 Hash 冲突问题。其实一般想卡 Hash 是比较难的，因为 Hash 自选模数，自选 base，很不好卡，不同的字符串相当于是随机数对撞。注意到如果选取模数为 $P$ 的话，那么存的个数不能超过 $O(\sqrt P)$ 个，反过来，如果我们存了 $\sum |S|$ 个数，为了使不同的字符串分开，我们至少需要 $O((\sum|S|) ^ 2)$ 的 $P$，在本题中是 $10 ^ {13}$，所以一般的模数例如 998244353，$10 ^ 9 + 7$ 之类的会 WA 一些点。</p><p>写起来还是有亿点点难写，注意由于没有多测，不要看到过了一些点就觉得自己只是 corner case 没考虑到。WA 了 16 发才过……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> LL Mod = <span class="built_in">LL</span>(<span class="number">1e15</span>) + <span class="number">37</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> ch[<span class="number">4</span>], fa;</span><br><span class="line">&#125; tr[N];</span><br><span class="line"><span class="type">int</span> n, tot, len[N], edid[N];</span><br><span class="line">LL pw[N], hash[N];</span><br><span class="line"><span class="type">bool</span> hav[N];</span><br><span class="line">std::string s[N];</span><br><span class="line">std::map&lt;LL, std::vector&lt;PII&gt;&gt; mp[N];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">chkmax</span><span class="params">(T &amp;x, T y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ? x = y, <span class="number">1</span> : <span class="number">0</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, c; s[i]; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!tr[u].ch[c = s[i] - <span class="string">&#x27;A&#x27;</span>])</span><br><span class="line">len[tr[u].ch[c] = ++ tot] = i + <span class="number">1</span>;</span><br><span class="line">u = tr[u].ch[c];</span><br><span class="line">&#125;</span><br><span class="line">edid[u] = id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (tr[<span class="number">0</span>].ch[i]) q.<span class="built_in">push</span>(tr[<span class="number">0</span>].ch[i]);</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">chkmax</span>(edid[x], edid[tr[x].fa]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!tr[x].ch[i]) tr[x].ch[i] = tr[tr[x].fa].ch[i];</span><br><span class="line"><span class="keyword">else</span> tr[tr[x].ch[i]].fa = tr[tr[x].fa].ch[i], q.<span class="built_in">push</span>(tr[x].ch[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fail</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>, <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) pw[i] = pw[i - <span class="number">1</span>] * <span class="number">5</span> % Mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">LL <span class="title">gethash</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ((r &lt; <span class="number">0</span> ? <span class="number">0</span> : hash[r]) + (s128) (Mod - pw[r - l + <span class="number">1</span>]) * (l == <span class="number">0</span> ? <span class="number">0</span> : hash[l - <span class="number">1</span>])) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inithash</span><span class="params">(std::string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">hash[<span class="number">0</span>] = s[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i]; ++ i) hash[i] = (hash[i - <span class="number">1</span>] * <span class="number">5LL</span> + s[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>) % Mod;</span><br><span class="line">hash[s.<span class="built_in">size</span>()] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>(), std::cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) std::cin &gt;&gt; s[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">insert</span>(s[i].<span class="built_in">c_str</span>(), i);</span><br><span class="line"><span class="built_in">build</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> id = <span class="number">1</span>; id &lt;= n; ++ id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> stk[N];</span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>, bac = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, u = <span class="number">0</span>, c, mat; s[id][i]; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">c = s[id][i] - <span class="string">&#x27;A&#x27;</span>, u = tr[u].ch[c];</span><br><span class="line">stk[++ top] = u, mat = edid[u];</span><br><span class="line"><span class="keyword">if</span> (mat == id) mat = edid[tr[u].fa];</span><br><span class="line"><span class="keyword">if</span> (mat) bac = <span class="number">1</span>, u = stk[top -= s[mat].<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!top) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (bac) <span class="built_in">fail</span>();</span><br><span class="line">hav[id] = <span class="literal">true</span>, <span class="built_in">inithash</span>(s[id]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) s[id].<span class="built_in">size</span>(); ++ i)</span><br><span class="line">mp[s[id].<span class="built_in">size</span>() - i][<span class="built_in">gethash</span>(i, s[id].<span class="built_in">size</span>() - <span class="number">1</span>)].<span class="built_in">push_back</span>(&#123;<span class="built_in">gethash</span>(<span class="number">0</span>, i - <span class="number">1</span>), i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> id = <span class="number">1</span>; id &lt;= n; ++ id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!hav[id]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">inithash</span>(s[id]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (<span class="type">int</span>) s[id].<span class="built_in">size</span>(); ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!mp[i].<span class="built_in">count</span>(<span class="built_in">gethash</span>(<span class="number">0</span>, i - <span class="number">1</span>))) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">LL curhash = <span class="built_in">gethash</span>(i, (<span class="type">int</span>) s[id].<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> curlen = s[id].<span class="built_in">size</span>() - i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [nxthash, nxtlen] : mp[i][<span class="built_in">gethash</span>(<span class="number">0</span>, i - <span class="number">1</span>)])</span><br><span class="line"><span class="keyword">if</span> (curhash != nxthash || nxtlen != curlen) flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="built_in">fail</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：有 $n$ 个串只包含 &lt;code&gt;A, B, C, D&lt;/code&gt; 的 $S_i$，问是否存在一个 $T$，经过删除 $T$ 中存在的 $S_i$ 直到不存在任意一个 $S_i$ 后，可以得到不同的串。$n, \sum |S_i|\leq 2\times 10 ^ 6$，8s。&lt;/p&gt;</summary>
    
    
    
    
    <category term="随机化" scheme="https://mydcwfy.github.io/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"/>
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="字符串" scheme="https://mydcwfy.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="AC 自动机" scheme="https://mydcwfy.github.io/tags/AC-%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>ARC Round#141</title>
    <link href="https://mydcwfy.github.io/2022/07/13/ARC-Round-141/"/>
    <id>https://mydcwfy.github.io/2022/07/13/ARC-Round-141/</id>
    <published>2022-07-13T12:27:12.000Z</published>
    <updated>2022-07-13T14:02:41.215Z</updated>
    
    <content type="html"><![CDATA[<p>有趣的比赛，做题 + 改题一共交了 35 次……</p><span id="more"></span><p>A、B 略去。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：有一个括号序列 $S$，在 $[1, 2n]$ 的所有排列中，对应括号序列合法且最小的排列记为 $P$，对应括号序列合法且最大的排列记为 $Q$，已知 $P, Q$，求 $S$ 或报告无解。$n\leq 2\times 10 ^ 5$。</p><p>首先如果 $P_{2i - 1} &gt; P_{2i}$ 的话，那么 $S_{P_{2i - 1}}$ 一定是 <code>(</code>，而 $S_{P_{2i}}$ 一定是 <code>)</code>，否则我们一定可以交换 $P_{2i - 1}$ 和 $P_{2i}$。$Q$ 能确定的为如果 $Q_{2i - 1} &lt; Q_{2i}$ 的话，那么 $Q_{2i - 1}$ 一定是 <code>(</code>，$Q_{2i}$ 一定是 <code>)</code>，证明同理。</p><p>考虑一下结论：</p><blockquote><p>结论：如果在这时还有多个 $S$ 合法的话，那么就没有合法的 $S$。</p><p>证明：首先假设有合法的 $S$。容易发现一个括号序列一定是由一些合法的括号序列或者是合法的括号序列翻转后拼接得到的。我们先只考虑 $S$ 是合法的括号序列的情况。那么我们假设 <code>(</code> 出现的位置是 $L_{1\cdots n}$，<code>)</code> 出现的位置是 $R_{1\cdots n}$，显然有 $L_1 &lt; R_1, L_2 &lt; R_2, \cdots$，那么 $Q$ 的排列一定是 $(L_n, R_n, L_{n - 1}\cdots)$。按照刚刚的构造方法，我们可以根据 $Q$ 还原出唯一的 $S$（$L_n &lt; R_n$ 可以还原 $S_{L_n}$ 是 <code>(</code>，$S_{R_n}$ 是 <code>)</code>，一起类推）。翻转过来我们可以通过 $P$ 类似的唯一还原 $S$。</p><p>注意到一个合法括号序列一定长度是偶数，那么其实我们只需要比较 $P_{2i - 1}$ 和 $P_{2i}$，就可以维护还原 $S$。而反之如果我们不能还原唯一的 $S$，那么就一定都不合法。</p></blockquote><p>这样我们只需要根据现有的限制随便构造一组解，然后用 $S$ 还原 $P, Q$，看一下 $S$ 是否合法即可。（注意不是 $P, Q$ 分别还原 $S$ 比较）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fail</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">force</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a[pos] == (val ^ <span class="number">1</span>)) <span class="built_in">fail</span>();</span><br><span class="line">a[pos] = val;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, p + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, q + i);</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">-1</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * n; i += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> (p[i] &gt; p[i + <span class="number">1</span>]) force(p[i], <span class="number">1</span>), force(p[i + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * n; i += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> (q[i] &lt; q[i + <span class="number">1</span>]) force(q[i], <span class="number">1</span>), force(q[i + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, op = <span class="number">0</span>; i &lt;= <span class="number">2</span> * n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!~a[p[i]]) a[p[i]] = op = op ^ <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i) vis[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, tot = <span class="number">0</span>, top = <span class="number">0</span>; i &lt;= <span class="number">2</span> * n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!top) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= <span class="number">2</span> * n &amp;&amp; (vis[j] || !a[j])) ++ j;</span><br><span class="line">vis[chkp[++ tot] = j] = <span class="literal">true</span>, top ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) vis[chkp[++ tot] = i] = <span class="literal">true</span>, top += a[i] ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (p[i] != chkp[i]) <span class="built_in">fail</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i) vis[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * n, j = <span class="number">2</span> * n, tot = <span class="number">0</span>, top = <span class="number">0</span>; i; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!top) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &amp;&amp; (vis[j] || !a[j])) -- j;</span><br><span class="line">vis[chkp[++ tot] = j] = <span class="literal">true</span>, top ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) vis[chkp[++ tot] = i] = <span class="literal">true</span>, top += a[i] ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (q[i] != chkp[i]) <span class="built_in">fail</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i) <span class="built_in">putchar</span>(a[i] ? <span class="string">&#x27;(&#x27;</span> : <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定一个 $n$ 个数的集合 $S$，每一个数都 $\leq 2m$，问对于每一个数，当选定这一个数后，还能不能选出一个大小为 $m$ 的集合（加上选出的这个数），使得集合内部没有倍数关系。$n, m\leq 2\times 10 ^ 5$。</p><p>注意到恰好大小为 $m$，而所有数都满足 $\leq 2m$。什么东西恰好有 $m$ 个呢？这里就要用到构造，恰好有 $m$ 个奇数。我们把每个数按照 $a\times 2 ^ b$（$a$ 为奇数）拆分，然后塞到 $a$ 这个桶内部。容易发现 $m$ 个桶，每个桶都最多只有一个数被选。那么如果出现一个桶没有数，就一定没有解。否则假设选出来的数的 2 的次幂为 $v_i$。</p><p>此外，不同桶之间还可能存在倍数关系，比如 $a\times 2 ^ x$ 是 $b\times 2 ^ y$ 的倍数当且仅当 $b|a$ 并且 $x\geq y$。那么对于成倍数的 $(a, b)$ 的 <code>std::pair</code>，那么一定需要保证 $v_a &lt; v_b$。</p><p>如何判断一个数能否出现在合法的集合中呢？我们可以考虑对于每一个 $i$，计算 $v_i$ 的区间。具体的，如果需要计算最大值的话，顺序扫一遍，计算完一个数后更新他的倍数。计算最小值的时候倒序扫一遍，计算这个数的最小值时从他的倍数更新过来。复杂度都是 $O(m\log m)$ 的。</p><p>最后来一个数判一判在不在区间里即可。注意这个区间的上界和下界对应的数都是存在于原来的集合的，否则整个都无解。</p><p><del>赛后改题唯一一个 1 遍过的题目，其他的题目都不知错了多少发</del>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (n --) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) g[a[i] &gt;&gt; <span class="built_in">ctz</span>(a[i])].<span class="built_in">push_back</span>(<span class="built_in">ctz</span>(a[i]));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= m) j &lt;&lt;= <span class="number">1</span>, R[i] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * m; ++ i) L[i] = <span class="number">-1e9</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (g[i].<span class="built_in">empty</span>() || g[i].<span class="built_in">front</span>() &gt; R[i]) <span class="built_in">fail</span>();</span><br><span class="line">R[i] = *-- std::<span class="built_in">upper_bound</span>(g[i].<span class="built_in">begin</span>(), g[i].<span class="built_in">end</span>(), R[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">2</span>; d * i &lt;= <span class="number">2</span> * m; ++ d) <span class="built_in">chkmin</span>(R[i * d], R[i] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * m; i; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">2</span>; d * i &lt;= <span class="number">2</span> * m; ++ d) <span class="built_in">chkmax</span>(L[i], L[i * d] + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; L[i] &lt;&lt; &#x27; &#x27; &lt;&lt; g[i].back() &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">if</span> (g[i].<span class="built_in">empty</span>() || g[i].<span class="built_in">back</span>() &lt; L[i]) <span class="built_in">fail</span>();</span><br><span class="line">L[i] = *std::<span class="built_in">lower_bound</span>(g[i].<span class="built_in">begin</span>(), g[i].<span class="built_in">end</span>(), L[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> y = <span class="built_in">ctz</span>(a[i]), x = a[i] &gt;&gt; y;</span><br><span class="line"><span class="keyword">if</span> (y &gt;= L[x] &amp;&amp; y &lt;= R[x]) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：给定一个 $n\times n$ 的网格，标号从 0 开始，$m$ 次给定 $a, b, c, d$，把 $((a + i)\bmod n, (b + i)\bmod n)$ 和 $((c + i)\bmod n, (d + i)\bmod n)$ 连接起来，每次操作后问连通块数目。$n, m\leq 2\times 10 ^ 5$。</p><p>容易发现按照 $(b - a)\bmod n$ 分类，然后使用并查集，这样连边的时候相当于只是在 2 个集合中间按照一定的 $\Delta$ 量连边。这样考虑怎怎样动态维护这个 $\Delta$ 量。</p><p>首先显然需要维护该集合到根所代表的集合，其 $\Delta$ 是多少（即 根的 $(0, x)$ 连到该集合的 $(\Delta, \Delta + y)$）。然后可能出现连边两个原来就联通的集合，那么我们注意，并不一定是毫无用处，比如：</p><img src="/2022/07/13/ARC-Round-141/ARC141E1.png" class=""><p>这样蓝边后加入，虽然没有改变不同集合联通性，但是我们发现，一个集合内部出现的连边，他们每 3 个就连在了一起。于是我们还需要维护该集合内部循环长度是多少。两个合并的时候，其实就是 $\gcd$，手玩一下即可。循环长度也就是该集合总共的连通块个数，直接维护答案变化即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == f[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="type">int</span> rt = <span class="built_in">find</span>(f[x]);</span><br><span class="line">dis[x] = (dis[x] + dis[f[x]]) % del[rt];</span><br><span class="line"><span class="keyword">return</span> f[x] = rt;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) f[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) del[i] = n;</span><br><span class="line">LL ans = (LL) n * n;</span><br><span class="line"><span class="type">int</span> a, b, c, d;</span><br><span class="line"><span class="keyword">while</span> (m --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line"><span class="type">int</span> x = (b - a + n) % n, y = (d - c + n) % n, de = (d - b + n) % n,</span><br><span class="line">fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span> (fx == fy) &#123;</span><br><span class="line">ans -= del[fx];</span><br><span class="line">del[fx] = <span class="built_in">Gcd</span>(del[fx], dis[x] - dis[y] + del[fx] + de);</span><br><span class="line">ans += del[fx];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ans -= del[fx] + del[fy];</span><br><span class="line">del[fx] = <span class="built_in">Gcd</span>(del[fx], del[fy]);</span><br><span class="line">f[fy] = fx, dis[fy] = (dis[x] - dis[y] + n + de) % del[fx];</span><br><span class="line">ans += del[fx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>见 <a href="/2022/07/13/ARC141F/">ARC141F</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有趣的比赛，做题 + 改题一共交了 35 次……&lt;/p&gt;</summary>
    
    
    
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3473 字符串</title>
    <link href="https://mydcwfy.github.io/2022/07/09/BZOJ3473/"/>
    <id>https://mydcwfy.github.io/2022/07/09/BZOJ3473/</id>
    <published>2022-07-09T03:38:30.000Z</published>
    <updated>2022-07-09T06:00:55.748Z</updated>
    
    <content type="html"><![CDATA[<p>经典 SAM 题目，似乎有很简洁的做法，但没写……</p><span id="more"></span><p>题意：给定 $n$ 个字符串，对于每个字符串，求有多少个本质不同的子串满足在至少 $k$ 个串中出现过。$n, k, \sum |S|\leq 10 ^ 5$。</p><p>看到 $n$ 个串的本质不同统计，先建广义 SAM、</p><p>我们现在要干的事情是统计每一个子串在多少个字符串中出现过。组合一道广义 SAM 和普通 SAM 略有不同，如果直接打标记按照 parent 树上传的话，会出现重复的情况。于是我们使用线段树合并，这样就可以把相同位置重复的去掉了。于是时空复杂度都是 $O(\sum|S|\log \sum|S|)$，我们可以得到每一个子串在 $n$ 个字符串的那几个所覆盖，可以接受。</p><p>这里可以不用线段树合并，直接大力标记，遇到标记过的就跳过，这样可以平衡规划证得时间复杂度为 $O(\sum |S|\sqrt{\sum |S|})$，仍然可以通过。</p><p>然后考虑如何统计每一个串的答案。直接在广义 SAM 上跑匹配，因为一个字符串一旦合法，他 parent 的父亲都合法，我们不需要向上再跳，直接假设当前节点的最大值即可。这里是线性的。</p><p>于是可以在 $O(\sum |S| \log \sum |S|)$ 可以解决，注意一下应该在哪个节点加上该位置标记的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment_Tree</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> lc, rc, cnt;</span><br><span class="line">&#125; tr[N &lt;&lt; <span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!rt) rt = ++ cnt;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in">void</span>(tr[rt].cnt = <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (pos &lt;= mid) <span class="built_in">insert</span>(tr[rt].lc, l, mid, pos);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">insert</span>(tr[rt].rc, mid + <span class="number">1</span>, r, pos);</span><br><span class="line">tr[rt].cnt = tr[tr[rt].lc].cnt + tr[tr[rt].rc].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> p | q;</span><br><span class="line"><span class="type">int</span> cur = ++ cnt, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> tr[cur].cnt = tr[p].cnt | tr[q].cnt, cur;</span><br><span class="line">tr[cur].lc = <span class="built_in">merge</span>(tr[p].lc, tr[q].lc, l, mid);</span><br><span class="line">tr[cur].rc = <span class="built_in">merge</span>(tr[p].rc, tr[q].rc, mid + <span class="number">1</span>, r);</span><br><span class="line">tr[cur].cnt = tr[tr[cur].lc].cnt + tr[tr[cur].rc].cnt;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125; seg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SAM</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> ch[<span class="number">26</span>], len, fa;</span><br><span class="line">&#125; tr[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> rt[N &lt;&lt; <span class="number">1</span>], sz[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; g[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="built_in">SAM</span>() : <span class="built_in">tot</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> ls, <span class="type">int</span> c, <span class="type">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[ls].ch[c]) &#123;</span><br><span class="line"><span class="type">int</span> p = ls, q = tr[p].ch[c];</span><br><span class="line"><span class="keyword">if</span> (tr[q].len == tr[p].len + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> seg.<span class="built_in">insert</span>(rt[q], <span class="number">1</span>, n, col), q;</span><br><span class="line"><span class="type">int</span> nq = ++ tot;</span><br><span class="line">seg.<span class="built_in">insert</span>(rt[nq], <span class="number">1</span>, n, col);</span><br><span class="line">tr[nq] = tr[q], tr[nq].len = tr[p].len + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; tr[p].ch[c] == q; p = tr[p].fa) tr[p].ch[c] = nq;</span><br><span class="line"><span class="keyword">return</span> tr[q].fa = nq, nq;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> p = ls, np = ++ tot;</span><br><span class="line">tr[np].len = tr[p].len + <span class="number">1</span>;</span><br><span class="line">seg.<span class="built_in">insert</span>(rt[np], <span class="number">1</span>, n, col);</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; !tr[p].ch[c]; p = tr[p].fa) tr[p].ch[c] = np;</span><br><span class="line"><span class="keyword">if</span> (!p) tr[np].fa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> q = tr[p].ch[c];</span><br><span class="line"><span class="keyword">if</span> (tr[q].len == tr[p].len + <span class="number">1</span>)</span><br><span class="line">seg.<span class="built_in">insert</span>(rt[q], <span class="number">1</span>, n, col), tr[np].fa = q;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> nq = ++ tot;</span><br><span class="line">seg.<span class="built_in">insert</span>(rt[nq], <span class="number">1</span>, n, col);</span><br><span class="line">tr[nq] = tr[q], tr[nq].len = tr[p].len + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; tr[p].ch[c] == q; p = tr[p].fa) tr[p].ch[c] = nq;</span><br><span class="line">tr[np].fa = tr[q].fa = nq;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> np;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x])</span><br><span class="line"><span class="built_in">dfs</span>(v), rt[x] = seg.<span class="built_in">merge</span>(rt[x], rt[v]);</span><br><span class="line">sz[x] = seg.tr[rt[x]].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= tot; ++ i) g[tr[i].fa].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; sam;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, ls; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">std::cin &gt;&gt; s[i];</span><br><span class="line">ls = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : s[i]) ls = sam.<span class="built_in">extend</span>(ls, c - <span class="string">&#x27;a&#x27;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">sam.<span class="built_in">work</span>();</span><br><span class="line"><span class="comment">// exit(0);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : s[i])</span><br><span class="line">&#123;</span><br><span class="line">p = sam.tr[p].ch[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">while</span> (p != <span class="number">1</span> &amp;&amp; sam.sz[p] &lt; k) p = sam.tr[p].fa;</span><br><span class="line"><span class="keyword">if</span> (sam.sz[p] &gt;= k) res += sam.tr[p].len;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典 SAM 题目，似乎有很简洁的做法，但没写……&lt;/p&gt;</summary>
    
    
    
    
    <category term="字符串" scheme="https://mydcwfy.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="后缀数据结构" scheme="https://mydcwfy.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线段树合并" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>LOJ2720 [NOI2018]你的名字</title>
    <link href="https://mydcwfy.github.io/2022/07/09/LOJ2720/"/>
    <id>https://mydcwfy.github.io/2022/07/09/LOJ2720/</id>
    <published>2022-07-09T03:19:47.000Z</published>
    <updated>2022-07-09T03:43:20.503Z</updated>
    
    <content type="html"><![CDATA[<p>现在才来补 NOI 经典题 /kk</p><span id="more"></span><p>题意：给定一个串 $S$，$q$ 次询问，每次给出 $T, l, r$，问 $T$ 中不是 $S[l\to r]$ 的子串的本质不同子串个数。$|S|, q, |T|\leq 5\times 10 ^ 5$，$\sum |T|\leq 10 ^ 6$，4s。</p><p>考虑 $l = 1, r = n$ 怎么做。由于是求本质不同的串，考虑对 $T$ 建后缀自动机，对于每个节点统计答案。</p><p>还是要建 $S$ 的后缀自动机，然后把每一个前缀的最大匹配后缀找出来，于是这些不合法后缀的后缀都是不合法的，其他的都是合法的。</p><p>找到该前缀在 $T$ 的后缀自动机中对应的位置，那么一个节点的最大覆盖长度就是 parent 树子树下的覆盖长度的最大值。在 parent 树上做做就可以做到单次 $O(|T|)$ 的复杂度。</p><p>下面考虑 $S$ 有 $[l, r]$ 该如何计算。现在我们计算一个前缀是否能匹配，不再是看一个点有没有 <code>ch[c]</code> 这个儿子，还需要看 <code>ch[c]</code> 这个儿子有没有出现在 $[l, r]$ 区间完整出现。注意到我们相当于是看 $\text{endpos}$ 是否在 $[l + len - 1, r]$ 区间出现过。而维护每一个节点的 $\text{endpos}$，可以使用线段树合并做到 $O(|S|\log|S|)$ 的时空复杂度，单次 $O(\log|S|)$ 查询。</p><p>于是本题可以做到 $O(|S|\log|S| + \sum|T|\log|S|)$，可以通过。实现的时候注意 parent 树统计子树答案的时候用 bfs 拓扑序算而不是 dfs。另外，匹配的时候需要每一个 $len$ 都判一遍，而不是像直接跳到父亲，单次减少的 $len$ 比较大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SAM</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> ch[<span class="number">26</span>], len, fa;</span><br><span class="line">&#125; tr[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> ls, tot, pos[N &lt;&lt; <span class="number">1</span>], cov[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; ls = tot = <span class="number">1</span>, tr[<span class="number">1</span>] = &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> curpos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> p = ls, np = ++ tot;</span><br><span class="line">tr[np] = &#123;&#125;, pos[np] = curpos, ls = tot, tr[np].len = tr[p].len + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; !tr[p].ch[c]; p = tr[p].fa) tr[p].ch[c] = np;</span><br><span class="line"><span class="keyword">if</span> (!p) tr[np].fa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> q = tr[p].ch[c];</span><br><span class="line"><span class="keyword">if</span> (tr[q].len == tr[p].len + <span class="number">1</span>) tr[np].fa = q;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> nq = ++ tot;</span><br><span class="line">pos[nq] = <span class="number">0</span>, tr[nq] = tr[q], tr[nq].len = tr[p].len + <span class="number">1</span>;</span><br><span class="line">tr[np].fa = tr[q].fa = nq;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; tr[p].ch[c] == q; p = tr[p].fa) tr[p].ch[c] = nq;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Twork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) g[i].<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= tot; ++ i) g[tr[i].fa].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="type">int</span> hh = <span class="number">1</span>, tt = <span class="number">1</span>;</span><br><span class="line">q[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = q[hh ++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x])</span><br><span class="line">q[++ tt] = v;</span><br><span class="line">&#125;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = tt, x; i &gt; <span class="number">1</span>; -- i)</span><br><span class="line">&#123;</span><br><span class="line">x = q[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x])</span><br><span class="line"><span class="built_in">chkmax</span>(cov[x], cov[v]);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; cov[x] &lt;&lt; &#x27; &#x27; &lt;&lt; tr[x].len &lt;&lt; &#x27; &#x27; &lt;&lt; tr[tr[x].fa].len &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">if</span> (cov[x] &lt;= tr[x].len)</span><br><span class="line">res += tr[x].len - std::<span class="built_in">max</span>(cov[x], tr[tr[x].fa].len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125; sams, samt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> lc, rc, cnt;</span><br><span class="line">&#125; tr[(<span class="type">int</span>) <span class="number">3e7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> p | q;</span><br><span class="line"><span class="type">int</span> cur = ++ tot, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> tr[cur].cnt = tr[p].cnt + tr[q].cnt, cur;</span><br><span class="line">tr[cur].lc = <span class="built_in">merge</span>(tr[p].lc, tr[q].lc, l, mid);</span><br><span class="line">tr[cur].rc = <span class="built_in">merge</span>(tr[p].rc, tr[q].rc, mid + <span class="number">1</span>, r);</span><br><span class="line">tr[cur].cnt = tr[tr[cur].lc].cnt + tr[tr[cur].rc].cnt;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!rt) rt = ++ tot;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in">void</span>(tr[rt].cnt ++);</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (pos &lt;= mid) <span class="built_in">insert</span>(tr[rt].lc, l, mid, pos);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">insert</span>(tr[rt].rc, mid + <span class="number">1</span>, r, pos);</span><br><span class="line">tr[rt].cnt = tr[tr[rt].lc].cnt + tr[tr[rt].rc].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findlast</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x || l &gt; qr || r &lt; ql) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line"><span class="type">int</span> t, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((t = <span class="built_in">findlast</span>(tr[x].rc, mid + <span class="number">1</span>, r, ql, qr))) <span class="keyword">return</span> t;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">findlast</span>(tr[x].lc, l, mid, ql, qr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> L, R, m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, s + <span class="number">1</span>, &amp;L, &amp;R);</span><br><span class="line">samt.<span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span> (m = <span class="number">1</span>; s[m]; ++ m) samt.<span class="built_in">extend</span>(s[m] - <span class="string">&#x27;a&#x27;</span>, m);</span><br><span class="line">-- m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u = <span class="number">1</span>, len = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>, cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((!sams.tr[u].ch[c] || (cur = <span class="built_in">findlast</span>(rt[sams.tr[u].ch[c]], <span class="number">1</span>, n, L, R)) &lt; L + len)</span><br><span class="line">&amp;&amp; len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((-- len) &lt;= sams.tr[sams.tr[u].fa].len) u = sams.tr[u].fa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; u &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sams.tr[u].ch[c] &amp;&amp; <span class="built_in">findlast</span>(rt[sams.tr[u].ch[c]], <span class="number">1</span>, n, L, R) &gt;= L + len)</span><br><span class="line">len ++, u = sams.tr[u].ch[c];</span><br><span class="line">mxlen[i] = len;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; len &lt;&lt; &#x27; &#x27; &lt;&lt; cur &lt;&lt; &#x27; &#x27; &lt;&lt; u &lt;&lt; &#x27; &#x27; &lt;&lt; c &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= samt.tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (samt.pos[i]) samt.cov[i] = mxlen[samt.pos[i]];</span><br><span class="line"><span class="keyword">else</span> samt.cov[i] = <span class="number">0</span>;</span><br><span class="line">std::cout &lt;&lt; samt.<span class="built_in">Twork</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> Fly727</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;name.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;name.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">sams.<span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>; s[n]; ++ n) sams.<span class="built_in">extend</span>(s[n] - <span class="string">&#x27;a&#x27;</span>, n);</span><br><span class="line">-- n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= sams.tot; ++ i) g[sams.tr[i].fa].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="type">int</span> hh = <span class="number">1</span>, tt = <span class="number">1</span>;</span><br><span class="line">q[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = q[hh ++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x])</span><br><span class="line">q[++ tt] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;Check &quot; &lt;&lt; sams.tr[4].ch[0] &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">// for (int i = 2; i &lt;= sams.tot; ++ i) printf(&quot;%d &quot;, sams.pos[i]);</span></span><br><span class="line"><span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = tt, x; i; -- i)</span><br><span class="line">&#123;</span><br><span class="line">x = q[i];</span><br><span class="line"><span class="keyword">if</span> (sams.pos[x]) <span class="built_in">insert</span>(rt[x], <span class="number">1</span>, n, sams.pos[x]);</span><br><span class="line">rt[sams.tr[x].fa] = <span class="built_in">merge</span>(rt[sams.tr[x].fa], rt[x], <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">std::cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T --) <span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在才来补 NOI 经典题 /kk&lt;/p&gt;</summary>
    
    
    
    
    <category term="字符串" scheme="https://mydcwfy.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="后缀数据结构" scheme="https://mydcwfy.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线段树合并" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2627 JZPKIL</title>
    <link href="https://mydcwfy.github.io/2022/07/09/BZOJ2627/"/>
    <id>https://mydcwfy.github.io/2022/07/09/BZOJ2627/</id>
    <published>2022-07-09T02:40:37.000Z</published>
    <updated>2022-07-09T03:04:45.309Z</updated>
    
    <content type="html"><![CDATA[<p>nb 莫比乌斯反演题，和常规套路不同。</p><span id="more"></span><p>题意：<br>$$<br>\sum_{i = 1} ^ n \gcd(i, n) ^ x \text{lcm}(i, n) ^ y \bmod 10 ^ 9 + 7<br>$$<br>$T(T\leq 100)$ 次询问，每次给出 $n, x, y$，$n\leq 10 ^ {18}$，$x, y\leq 3000$。</p><p>看到 $n\leq 10 ^ {18}$ 似乎不对劲，但还是先套路莫反。<br>$$<br>\begin{aligned}<br>&amp;\sum_{i = 1} ^ n \sum_{d = 1} ^ n [\gcd(i, n) = d] d ^ x (\dfrac{in}d) ^ y\\<br>=&amp; \sum_{d | n} \sum_{i = 1} ^ {\frac nd} d ^ x (in) ^ y [\gcd(i, \dfrac nd) = 1]\\<br>=&amp; \sum_{d | n} d ^ x \sum_{i = 1} ^ n d ^ x (in) ^ y \sum_{s | i, s | \frac nd} \mu(s)\\<br>=&amp; n ^ y \sum_{d | n} d ^ x \sum_{s | \frac nd}\mu(s) s ^ y \sum_{i = 1} ^ {\frac n{ds}} i ^ y<br>\end{aligned}<br>$$<br>做到这里，似乎再化开，令 $T = ds$ 没有意义了，因为至少需要枚举 $T$，少说也得整除分块，复杂度 $O(\sqrt n)$ 不可接受。</p><p>发现一个绊脚石是 $\sum_{i = 1} ^ {\frac n{ds}}i ^ y$，这个自然数幂导致我们没法快速计算，因为前面的函数 $d ^ x, \mu(s) s ^ y$ 都可以狄利克雷卷积，但这个没法。</p><p>考虑使用伯努利数，把这样的一个式子写成 $\dfrac n{ds}$ 的次幂和：<br>$$<br>\begin{aligned}<br>&amp;\sum_{i = 1} ^ {\frac n {ds}} i ^ y\\<br>=&amp; \sum_{k = 0} ^ y \binom{y + 1}k B_k ^ + (\dfrac n{ds}) ^ {y + 1 - k}<br>\end{aligned}<br>$$<br>其中 $B_k^+$ 和 $B_k$ 的伯努利数略有区别，$B_k^+$ 在 $B_1^+$ 时取的 $\dfrac 12$，而 $B_k$ 在 $B_1$ 取的是 $-\dfrac 12$。伯努利数可以在 $O(y ^ 2)$ 的时间内递推出前 $y$ 项，不再赘述，可以接受。</p><p>带入原式，大力计算：<br>$$<br>\begin{aligned}<br>&amp; n ^ y \sum_{d | n} d ^ x \sum_{s | \frac nd}\mu(s) s ^ y \sum_{i = 1} ^ {\frac n{ds}} i ^ y\\<br>=&amp; \dfrac{n ^ y}{y + 1} \sum_{d | n} d ^ x \sum_{s | \frac nd}\mu(s) s ^ y \sum_{k = 0} ^ y \binom{y + 1}k B_k^+ (\dfrac n{ds}) ^ {y + 1 - k}\\<br>=&amp; \dfrac{n ^ y}{y + 1} \sum_{k = 0} ^ y \binom{y + 1}k B_k ^ + \sum_{d | n} d ^ x \sum_{s | \frac nd} \mu(s) s ^y (\dfrac{n}{ds}) ^ {y + 1 - k}<br>\end{aligned}<br>$$<br>枚举 $k$ 是可以接受的，那么现在考虑怎么计算后面的 $\sum_{d | n} d ^ x \sum_{e | \frac nd} \mu(s)s ^ y(\dfrac n{ds}) ^ {y + 1 - k}$。发现这个其实一个积性函数，是 $id ^ x \times (\mu\cdot id ^ y)\times id ^ {y + 1 - k}$，可以拆开每一个质数计算答案。而每一个质数计算的时候，相当于计算 $f(p ^ c)$，由于 $\mu$ 的有效位置只有 $1, p$ 两个位置，只需要考虑剩下的两个分配次幂即可。得到质因数的办法显然 Pollard-Rho，时间复杂度 $O(\sqrt p)$。</p><p>那么预处理时间复杂度为 $O(y ^ 2)$，单次询问时间复杂度 $O(n ^ {\frac 14} + y\cdot \text{poly}\log n)$，可以通过。</p><p>代码比较冗长，主要是 Pollard-Rho 太长了，就放一个求解函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL n;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">std::vector&lt;LL&gt; tmpfac = <span class="built_in">Pollard_Rho</span>(n);</span><br><span class="line">LL tmp = n;</span><br><span class="line">std::vector&lt;PLI&gt; fac;</span><br><span class="line"><span class="keyword">for</span> (LL &amp;x : tmpfac)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (tmp % x == <span class="number">0</span>) cnt ++, tmp /= x;</span><br><span class="line">fac.<span class="built_in">push_back</span>(&#123;x, cnt&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= y; ++ k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [p, t] : fac)</span><br><span class="line">&#123;</span><br><span class="line">p %= Mod;</span><br><span class="line"><span class="type">int</span> mul = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= t; ++ i)</span><br><span class="line"><span class="built_in">adj</span>(mul += <span class="built_in">qpow</span>(p, i * (y + <span class="number">1</span> - k) + (t - i) * x) - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++ i)</span><br><span class="line"><span class="built_in">adj</span>(mul -= <span class="built_in">qpow</span>(p, i * (y + <span class="number">1</span> - k) + y + (t - i - <span class="number">1</span>) * x));</span><br><span class="line">cur = (LL) cur * mul % Mod;</span><br><span class="line">&#125;</span><br><span class="line">res = (res + (LL) cur * <span class="built_in">C</span>(y + <span class="number">1</span>, k) % Mod * B[k]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">res = (LL) res * <span class="built_in">qpow</span>(n % Mod, y) % Mod * <span class="built_in">qpow</span>(y + <span class="number">1</span>) % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;nb 莫比乌斯反演题，和常规套路不同。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="莫比乌斯反演" scheme="https://mydcwfy.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="生成函数" scheme="https://mydcwfy.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
</feed>
