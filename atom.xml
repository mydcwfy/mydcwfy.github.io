<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mydcwfy&#39;s Blog</title>
  
  
  <link href="https://mydcwfy.github.io/atom.xml" rel="self"/>
  
  <link href="https://mydcwfy.github.io/"/>
  <updated>2022-06-18T13:04:37.642Z</updated>
  <id>https://mydcwfy.github.io/</id>
  
  <author>
    <name>mydcwfy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Luogu P4705 玩游戏</title>
    <link href="https://mydcwfy.github.io/2022/06/18/Luogu-P4705/"/>
    <id>https://mydcwfy.github.io/2022/06/18/Luogu-P4705/</id>
    <published>2022-06-18T12:46:10.000Z</published>
    <updated>2022-06-18T13:04:37.642Z</updated>
    
    <content type="html"><![CDATA[<p>求自然数等幂和的几乎模板题。</p><span id="more"></span><p>题意：从 $a_1, a_2, \cdots, a_n$ 和 $b_1, b_2\cdots, b_m$ 中任意选数 $x$ 和 $y$，求 $(x + y) ^ k$ 的期望。你需要求出 $k\in [1, t]$ 的所有答案。$n, m, t\leq 10 ^ 5$，3s。</p><p>首先大力拆贡献，可以得到：<br>$$<br>\begin{aligned}<br>ans_k =&amp; \dfrac 1{nm} \sum_{i = 1} ^ n\sum_{j = 1} ^ m (a_i + b_j) ^ k\\<br>=&amp; \dfrac 1{nm} \sum_{i = 1} ^ n \sum_{j = 1} ^ m \sum_{l = 0} ^ k \binom kl a_i ^ l b_j ^ {k - l}\\<br>=&amp; \dfrac 1{nm} \sum_{l = 0} ^ k \binom kl \sum_{i = 1} ^ n a_i ^ l\sum_{j = 1} ^ m b_j ^ {k - l}\\<br>=&amp; \dfrac 1{nm} \sum_{l = 0} ^ k \dfrac{\sum_{i = 1} ^ n a_i ^ l}{l!} \dfrac{\sum_{j = 1} ^ m b_j ^ {k - l}}{(k - l)!}<br>\end{aligned}<br>$$<br>容易发现如果我们已经得到了 $\sum_{i = 1} ^ n a_i ^ l$，卷积一下即可在 $O(n\log n)$ 时间内完成。于是问题变为了快速求出 $\sum_{i = 1} ^ n a_i ^ l$。</p><p>考虑生成函数 $F(x) = \prod_{i = 1} ^ n (a_ix + 1)$，容易发现这个可以使用分治在 $O(n\log ^ 2 n)$ 的时间内求出。</p><p>考虑对两边求 $\ln$，可以得到：$\ln F(x) = \sum_{i = 1} ^ n \ln (a_ix + 1)$。</p><p>考虑对 $\ln(1 + x)$ 泰勒展开，可以得到 $\ln(1 + x) = x - \dfrac{x ^ 2}2 + \dfrac{x ^ 3}3 - \dfrac{x ^ 4}{4}+\cdots$。于是我们带入即可得到：<br>$$<br>\begin{aligned}<br>\ln F(x) =&amp; -\sum_{i = 1} ^ n \sum_{j = 1}\dfrac{(-a_ix) ^ j}{j}\\<br>=&amp; -\sum_{j = 1} ^ n \dfrac{(-x) ^ j}{j} \sum_{i = 1} ^ n a_i ^ j<br>\end{aligned}<br>$$<br>容易发现后半段就是我们要求的东西，于是对 $F(x)$ 取 $\ln$，稍加变换即可得到 $\sum_{i = 1} ^ n a_i ^ j$，于是时间复杂度 $O(n\log ^ 2n)$，<del>稍加卡常</del>即可通过。注意上面的式子无法计算 $\sum_{i = 1} ^ n a_i ^ 0$，需要特殊计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">poly <span class="title">calcpow</span><span class="params">(poly a, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> solve = [&amp;](<span class="keyword">auto</span> &amp;self, poly &amp;a, <span class="keyword">int</span> l, <span class="keyword">int</span> r) -&gt; poly &#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> &#123;<span class="number">1</span>, a[l]&#125;;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">self</span>(self, a, l, mid) * <span class="built_in">self</span>(self, a, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">solve</span>(solve, a, <span class="number">0</span>, a.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">b.<span class="built_in">resize</span>(m + <span class="number">1</span>), b = <span class="built_in">Ln</span>(b);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) <span class="built_in">adj</span>(b[i] = -b[i]);</span><br><span class="line">b[i] = (LL) b[i] * i % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">int</span> n, m, t;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="function">poly <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(m)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : a) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : b) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">std::cin &gt;&gt; t;</span><br><span class="line">a = <span class="built_in">calcpow</span>(a, t), a[<span class="number">0</span>] = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; ++ i) a[i] = (LL) a[i] * infact[i] % Mod;</span><br><span class="line">b = <span class="built_in">calcpow</span>(b, t), b[<span class="number">0</span>] = m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; ++ i) b[i] = (LL) b[i] * infact[i] % Mod;</span><br><span class="line">a = a * b;</span><br><span class="line"><span class="keyword">int</span> Inv = <span class="built_in">qpow</span>((LL) n * m % Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; ++ i) a[i] = (LL) a[i] * fact[i] % Mod * Inv % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;求自然数等幂和的几乎模板题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    <category term="分治" scheme="https://mydcwfy.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P4491 [HAOI2018]染色</title>
    <link href="https://mydcwfy.github.io/2022/06/18/Luogu-P4491/"/>
    <id>https://mydcwfy.github.io/2022/06/18/Luogu-P4491/</id>
    <published>2022-06-18T09:12:28.000Z</published>
    <updated>2022-06-18T09:38:17.333Z</updated>
    
    <content type="html"><![CDATA[<p>简单的二项式反演 + 卷积题目。</p><span id="more"></span><p>题意：对长度为 $n$ 的序列染上 $m$ 个颜色中的一个，假设恰好有 $k$ 个出现次数为 $S$，那么贡献为 $a_k$。求所有染色方案的贡献和。$n\leq 10 ^ 7$，$m\leq 10 ^ 5$。</p><p><strong>看到恰好，二项式反演</strong>。</p><p>设 $f(k)$ 表示<strong>恰好</strong>有 $k$ 个出现次数为 $S$ 的方案数，$g(k)$ 为<strong>钦定</strong>有 $k$ 个出现次数为 $S$ 的方案数，则可以得到：<br>$$<br>\begin{aligned}<br>f(k) =&amp; \sum_{i = k} ^ m (-1) ^ {i - k} \binom ik g(i)\\<br>ans =&amp; \sum_{i = 0} ^ m f(i) a(i)<br>\end{aligned}<br>$$<br>先考虑如何计算 $g(i)$。先选定 $i$ 种颜色 $\binom mi$，从 $n$ 个位置 $i$ 次从挑出 $S$ 个位置，贡献为 $\dfrac{n!}{S! ^ i (n - iS)!}$，剩下的 $n - iS$ 个位置可以任意填 $m - i$ 颜色的任意一个，为 $(m - i) ^ {n - iS}$，于是 $g(i)$ 为：<br>$$<br>g(i) = \binom mi \dfrac{n!(m - i) ^ {n - iS}}{S! ^ i (n - iS)!}<br>$$<br>可以在 $O(m\log m)$ 时间计算。</p><p>然后考虑如何由 $g(i)$ 算出 $f(i)$，根据组合数的性质容易得到：<br>$$<br>k!f(k) = \sum_{i = k} ^ m \dfrac{(-1) ^ {i - k}}{(i - k)!}i!g(i)<br>$$<br>显然是一个差卷积的形式，复杂度 $O(m\log m)$，预处理阶乘及逆元为 $O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">int</span> n, m, S;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; S;</span><br><span class="line"><span class="function">poly <span class="title">w</span><span class="params">(m + <span class="number">1</span>)</span>, <span class="title">g</span><span class="params">(infact, infact + m + <span class="number">1</span>)</span>, <span class="title">f</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &amp; <span class="number">1</span>) <span class="built_in">adj</span>(g[i] = -g[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : f) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i * S &gt; n) w[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> w[i] = (LL) <span class="built_in">C</span>(m, i) * fact[n] % Mod * <span class="built_in">qpow</span>(infact[S], i) % Mod</span><br><span class="line">* infact[n - i * S] % Mod * <span class="built_in">qpow</span>(m - i, n - i * S) % Mod * fact[i] % Mod;</span><br><span class="line">std::<span class="built_in">reverse</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">w = w * g;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= <span class="number">2</span> * m; ++ i)</span><br><span class="line">res = (res + (LL) w[i] * infact[i - m] % Mod * f[i - m]) % Mod;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= <span class="number">2</span> * m; ++ i) <span class="built_in">adj</span>(sum += w[i] * (LL) infact[i - m] % Mod - Mod);</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单的二项式反演 + 卷积题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    <category term="二项式反演" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>CF1375H Set Merging</title>
    <link href="https://mydcwfy.github.io/2022/06/18/CF1375H/"/>
    <id>https://mydcwfy.github.io/2022/06/18/CF1375H/</id>
    <published>2022-06-18T03:39:43.000Z</published>
    <updated>2022-06-18T06:21:52.069Z</updated>
    
    <content type="html"><![CDATA[<p>一道平衡规划分析复杂度的题目。</p><span id="more"></span><p>题意：你开始有 $n$ 个集合 $\{a_1\}, \{a_2, \}\cdots, \{a_n\}$，其中 $a_1, a_2, \cdots, a_n$ 是一个排列。你可以合并两个集合 $A$ 和 $B$，但需要保证 $\max(A)&lt;\min(B)$。注意合并之后 $A$ 和 $B$ 仍然存在。给定 $q$ 次询问 $[l, r]$，你需要合并出一个 $\{a_l, a_{l + 1},\cdots, a_r\}$，并输出编号。$n\leq 2 ^ {12}, q\leq 2 ^ {16}$，要求最后集合总数不超过 $2.2\times 10 ^ 6$。</p><p>先不考虑复杂度，我们直接考虑合并出所有答案：建一个值域线段树，计算当值域区间为 $[l, r]$，询问区间为 $[ql, qr]$ 时的答案，输出的编号显然是 $[1, n]$ 的答案。直接考虑在线段树上合并，将 $[l, mid]$ 和 $[mid + 1, r]$ 的答案合并起来。</p><p>这样其实是 $O(nq)$ 的，但是大家肯定都能想到将所有在一个节点的询问记忆化一下，还可以把 $[l, r]$ 区间离散化到当前节点所对应所有位置的集合再记忆化。</p><p>等你码完之后，你小心翼翼地写好提交，正准备迎接 Wrong Answer 的事实时，却发现过了！（如果你没有被卡常的话</p><p>下面考虑分析复杂度。假设 $d = \lceil\log_2 q\rceil, t = \lceil\log_2 n\rceil$，对于下面的 $\dfrac d2$ 层，假设所有的询问能将这些所有层的所有区间卡满，这一部分就是：<br>$$<br>cost = \sum_{i = 0} ^ {\frac d2}2 ^ {t - i} 2 ^ {2i} = 2 ^ {t + \frac d2} = O(n\sqrt q)<br>$$<br>其中第一部分表示节点个数，第二部分表示每一个节点所有的子区间。</p><p>对于上面的 $t - \dfrac d2$ 层，由于一次询问最多只能覆盖一个节点的一个区间，于是这一部分就是：<br>$$<br>cost = 2 ^ {t - \frac d2}q = 2 ^ {t + \frac d2} = O(n\sqrt q)<br>$$<br>于是最多只会合并出 $O(n\sqrt q)$ 个区间，在本题数据范围下为 $10 ^ 6$，实际运行为 $1.7\sim 2.0 \times 10 ^ 6$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[x] = &#123;l, r, std::vector&lt;<span class="keyword">int</span>&gt;(r - l + <span class="number">1</span>)&#125;;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(tr[x].allid.<span class="built_in">front</span>() = nw[l]);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="keyword">auto</span> &amp;v1 = tr[x &lt;&lt; <span class="number">1</span>].allid, &amp;v2 = tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].allid;</span><br><span class="line">std::<span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), tr[x].allid.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> &amp;v = tr[x].allid;</span><br><span class="line"><span class="keyword">auto</span> iter1 = std::<span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), l), iter2 = std::<span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), r);</span><br><span class="line"><span class="keyword">if</span> (iter1 == v.<span class="built_in">end</span>() || iter2 == v.<span class="built_in">begin</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">l = *iter1, r = *-- iter2;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">if</span> (tr[x].mp.<span class="built_in">count</span>(&#123;l, r&#125;)) <span class="keyword">return</span> tr[x].mp[&#123;l, r&#125;];</span><br><span class="line"><span class="keyword">int</span> sl = <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span>, l, r), sr = <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line"><span class="keyword">if</span> (!sl || !sr) <span class="keyword">return</span> sl | sr;</span><br><span class="line">gt[++ tot] = &#123;sl, sr&#125;;</span><br><span class="line"><span class="keyword">return</span> tr[x].mp[&#123;l, r&#125;] = tot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) nw[p[i]] = i;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n), tot = n;</span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">while</span> (Q --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">ans.<span class="built_in">push_back</span>(<span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">write</span>(tot, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= tot; ++ i) <span class="built_in">write</span>(gt[i].first, <span class="string">&#x27; &#x27;</span>, gt[i].second, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : ans) <span class="built_in">write</span>(x, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一道平衡规划分析复杂度的题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="线段树" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="平衡规划" scheme="https://mydcwfy.github.io/tags/%E5%B9%B3%E8%A1%A1%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>UOJ37 主旋律</title>
    <link href="https://mydcwfy.github.io/2022/06/12/UOJ37/"/>
    <id>https://mydcwfy.github.io/2022/06/12/UOJ37/</id>
    <published>2022-06-12T01:20:32.000Z</published>
    <updated>2022-06-12T02:54:13.884Z</updated>
    
    <content type="html"><![CDATA[<p>有点（？）难推的容斥 + 状态压缩。</p><span id="more"></span><p>题意：问 $n$ 个点 $m$ 条边的有向图中，任意保留一些边使得 $n$ 个点仍然是一个强连通分量的方案数。$n\leq 15, m\leq n(n - 1)$。</p><p>定义 $f(s)$ 表示集合 $s$ 中所有点及内部的边（指端点都属于 $s$）任意保留使得仍然是强连通分量的方案数。</p><p>首先设 $E(s_1, s_2)$ 表示起点在 $s_1$ 集合中，终点在 $s_2$ 集合中的边数。</p><p>显然正着不好做，考虑容斥，那么不止一个强连通分量，那么缩点后一定会产生出度为 0 的点，钦定强连通分量出度为 0 的点集合为 $t_1$，没被选中的集合为 $t_2$，那么 $E(t_2, t_1)$ 和  $E(t_2, t_2)$ 都是可以选的，$E(t_1, t_1)$ 的贡献由 $g(t_1)$ 计算，那么可以得到：<br>$$<br>g(s) = 2 ^ {E(s, s)} - \sum_{t_1 \subsetneq s} 2 ^ {E(t_2, t_1) + E(t_2, t_2)} g(t_1)<br>$$<br>注意此时我们的 $g(s)$ 是自带系数的，根据经典的容斥，我们 $g(s)$ 的系数应该是 $(-1) ^ {k + 1}$，$k$ 表示出度为 0 的点的强连通分量个数。</p><p>然后考虑 $g(s)$ 的定义式，我们枚举最小编号所在的集合，那么就可以得到：<br>$$<br>g(s) = -\sum_{t\subsetneq s, t\not=\varnothing}[id\in t]f(t)g(s/t) + f(s)<br>$$<br>前面我们可以计算到 $g(s)$，把这个式子变一下形，可以得到：<br>$$<br>f(s) = g(s) + \sum_{t\subsetneq s, t\not= \varnothing}[id\in t]f(t)g(s/t)<br>$$<br>即可做到 $O(3 ^ n)$ 计算，可以通过。代码中是将 $g(0)$ 设为 -1，贡献不变。</p><p>两个集合之间的连边可以枚举一边集合的点，计算另一边到这个点的边数，到点的边数可以预处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">pw2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; M; ++ i) <span class="built_in">adj</span>(pw2[i] = (pw2[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>) - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++ i)</span><br><span class="line">std::cin &gt;&gt; u &gt;&gt; v, edg[-- u][-- v] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; ++ u)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; ++ v)</span><br><span class="line"><span class="keyword">if</span> ((s &gt;&gt; u &amp; <span class="number">1</span>) &amp;&amp; (s &gt;&gt; v &amp; <span class="number">1</span>)) in[s] += edg[u][v];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; ++ u)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; ++ v)</span><br><span class="line"><span class="keyword">if</span> (s &gt;&gt; v &amp; <span class="number">1</span>) to[s][u] += edg[v][u];</span><br><span class="line">g[<span class="number">0</span>] = Mod - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> calclink = [&amp;](<span class="keyword">int</span> s1, <span class="keyword">int</span> s2) &#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (s2) res += to[s1][<span class="built_in">ctz</span>(s2)], s2 ^= s2 &amp; -s2;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line">&#123;</span><br><span class="line">g[s] = pw2[in[s]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> frm = s &amp; (s - <span class="number">1</span>); frm; frm = (frm - <span class="number">1</span>) &amp; s)</span><br><span class="line"><span class="built_in">adj</span>(g[s] -= (LL) g[frm] * pw2[in[s ^ frm]] % Mod * pw2[<span class="built_in">calclink</span>(s ^ frm, frm)] % Mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line">&#123;</span><br><span class="line">f[s] = g[s];</span><br><span class="line"><span class="keyword">int</span> le = <span class="built_in">ctz</span>(s);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> frm = s &amp; (s - <span class="number">1</span>); frm; frm = (frm - <span class="number">1</span>) &amp; s)</span><br><span class="line"><span class="keyword">if</span> (frm &gt;&gt; le &amp; <span class="number">1</span>) f[s] = (f[s] + (LL) f[frm] * g[s ^ frm]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有点（？）难推的容斥 + 状态压缩。&lt;/p&gt;</summary>
    
    
    
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>CF995F Cowmpany Cowmpensation</title>
    <link href="https://mydcwfy.github.io/2022/06/12/CF995F/"/>
    <id>https://mydcwfy.github.io/2022/06/12/CF995F/</id>
    <published>2022-06-12T00:39:08.000Z</published>
    <updated>2022-06-12T01:08:00.734Z</updated>
    
    <content type="html"><![CDATA[<p>比较套路的二项式反演 + 树形 DP。</p><span id="more"></span><p>题意：给定 $n$ 个点的根为 1 的树，现在你要为 $n$ 个点赋上一个 $[1, D]$ 的值，儿子权值不能超过父亲。问合法的赋值方案。$n\leq 3000, D\leq 10 ^ 9$，对 $10 ^ 9 + 7$ 取模。</p><p>看样子是 $O(n ^ 2)$ 的做法。</p><p>虽然朴素 DP 是 $O(nD)$ 的（前缀和优化），但是我们发现这样其实真正用到的元素一定不超过 $n$ 个，如果记 $f(x)$ 为所有权值恰好有 $x$ 个不同的，那么答案可以写作：<br>$$<br>ans = \sum_{i = 1} ^ n f(i) \binom Di<br>$$<br>这个式子容易 $O(n)$ 计算，现在问题转化为求 $f(x)$。</p><p>我们仍然按照朴素 DP 的方式，但值域仅为 $[1, n]$，这样一定是 $O(n ^ 2)$ 的，记 $g(x)$ 为我们最后得到的 DP 数组，其意义为最大值为 $x$ 的方案数。</p><p>按照组合意义拆分，容易得到：<br>$$<br>g(x) = \sum_{i = 1} ^ x \binom{x - 1}{i - 1} f(i)<br>$$<br>容易二项式反演得到：<br>$$<br>f(x) = \sum_{i = 1} ^ x (-1) ^ {x - i} \binom{x - 1}{i - 1} g(i)<br>$$<br>这样就可以 $O(n ^ 2)$ 计算了。</p><p>另外，这个式子也可以简单容斥：<br>$$<br>\begin{aligned}<br>g(x) =&amp; f(x) + \sum_{i = 1} ^ {x - 1} \binom{x - 1}{i - 1} f(i)\\<br>f(x) =&amp; g(x) - \sum_{i = 1} ^ {x - 1} \binom{x - 1}{i - 1} f(i)<br>\end{aligned}<br>$$<br>这样就可以 $O(n ^ 2)$ 计算了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; D;</span><br><span class="line">infact[<span class="number">1</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">infact[i] = (LL) infact[Mod % i] * (Mod - Mod / i) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) infact[i] = (LL) infact[i] * infact[i - <span class="number">1</span>] % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = C[i][<span class="number">0</span>] = <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line"><span class="built_in">adj</span>(C[i][j] = C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j] - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, f + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) dp[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) <span class="built_in">adj</span>(s[i][j] = s[i][j - <span class="number">1</span>] + dp[i][j] - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">dp[f[i]][j] = dp[f[i]][j] * (LL) s[i][j] % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line"><span class="keyword">if</span> (!((i - j) &amp; <span class="number">1</span>)) g[i] = (g[i] + dp[<span class="number">1</span>][j] * (LL) C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % Mod;</span><br><span class="line"><span class="keyword">else</span> g[i] = (g[i] + (Mod - dp[<span class="number">1</span>][j]) * (LL) C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % Mod;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt;= n; ++ i)</span></span><br><span class="line"><span class="comment">for (int j = 1; j &lt; i; ++ j)</span></span><br><span class="line"><span class="comment">adj(dp[1][i] -= (LL) dp[1][j] * C[i - 1][j - 1] % Mod);</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt;= n; ++ i) g[i] = dp[1][i];</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, dn = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; i &lt;= D; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">dn = dn * (LL) (D - i + <span class="number">1</span>) % Mod;</span><br><span class="line">res = (res + (LL) dn * infact[i] % Mod * g[i]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;比较套路的二项式反演 + 树形 DP。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="二项式反演" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>ARC093F Dark Horse</title>
    <link href="https://mydcwfy.github.io/2022/06/11/ARC093F/"/>
    <id>https://mydcwfy.github.io/2022/06/11/ARC093F/</id>
    <published>2022-06-11T14:07:14.000Z</published>
    <updated>2022-06-12T07:58:11.654Z</updated>
    
    <content type="html"><![CDATA[<p>经典容斥。</p><span id="more"></span><p>题意：有 $2 ^ n$ 个选手进行淘汰赛，比赛时编号小的会获胜，但是当 1 号选手遇到给定 $m$ 位选手中的任意一个，他将会输掉比赛。问怎样合理的安排顺序，使得 1 号选手能获胜。$n, m\leq 16$。</p><p>首先 1 号选手的位置在 $[1, 2 ^ n]$ 中任意位置是一样的，所以最后答案乘上 $2 ^ n$。</p><p>然后其实很多的排法，我们只关心其中 $n$ 棵子树的最小值即可，并不关心是如何排布的。如下图，我们只需要关心蓝色子树的最小值即可。</p><img src="/2022/06/11/ARC093F/1.png" class=""><p>考虑容斥，题目要求这些子树的最小值中不能出现 $m$ 个数中的一个，那么考虑钦定其中 $k$ 个子树最小值是 $m$ 个数当中的，贡献乘上 $(-1) ^ k$。</p><p>如果我们要钦定大小为 $sz$ 的子树的最小值为 $v$，注意钦定的时候我们剩下的 $sz - 1$ 个都要严格大于 $v$。</p><p>注意如果我们乱序加入 $v$ 的话，我们其实是并不知道大于 $v$ 的有多少个。类似于 <a href="/2022/05/30/LOJ3119">LOJ3119 随机正方体</a> 的方式，我们倒序枚举 $v$ 加入，这样枚举到 $v$ 的时候，前面所有钦定的一定都是大于 $v$ 的，就避免了大于 $v$ 的个数不确定的情况。随便状态压缩一下，记录哪些 $sz$ 已经钦定了最小值即可，转移时乘一下组合数，最后注意排列顺序即可。时间复杂度 $O(mn2 ^ n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">usd</span><span class="params">(m)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : usd) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">std::<span class="built_in">sort</span>(usd.<span class="built_in">begin</span>(), usd.<span class="built_in">end</span>());</span><br><span class="line">f[m + <span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i; -- i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!f[i + <span class="number">1</span>][s]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">adj</span>(f[i][s] += f[i + <span class="number">1</span>][s] - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line"><span class="keyword">if</span> (!(s &gt;&gt; j &amp; <span class="number">1</span>))</span><br><span class="line">f[i][s | (<span class="number">1</span> &lt;&lt; j)] = (f[i][s | (<span class="number">1</span> &lt;&lt; j)] + (LL)</span><br><span class="line"><span class="built_in">C</span>((<span class="number">1</span> &lt;&lt; n) - usd[i - <span class="number">1</span>] - s, (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span>) * (Mod - f[i + <span class="number">1</span>][s])) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mul = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (s &gt;&gt; i &amp; <span class="number">1</span>) mul = (LL) mul * fact[<span class="number">1</span> &lt;&lt; i] % Mod;</span><br><span class="line">res = (res + (LL) f[<span class="number">1</span>][s] * mul % Mod * fact[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> - s]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">res = res * (<span class="number">1LL</span> &lt;&lt; n) % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典容斥。&lt;/p&gt;</summary>
    
    
    
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>单位根反演</title>
    <link href="https://mydcwfy.github.io/2022/06/05/Unit-root-intersion/"/>
    <id>https://mydcwfy.github.io/2022/06/05/Unit-root-intersion/</id>
    <published>2022-06-05T02:56:41.000Z</published>
    <updated>2022-06-05T07:14:34.240Z</updated>
    
    <content type="html"><![CDATA[<p>处理整除时才有贡献的利器。</p><span id="more"></span><h2 id="1-代换公式"><a href="#1-代换公式" class="headerlink" title="1. 代换公式"></a>1. 代换公式</h2><p>前置知识：FFT / NTT。</p><p>如果你对 FFT 的证明过程比较熟悉的话，你应该会记得一个叫单位根的东西 $\omega_{n}^k$，他还有一个特殊的性质：<br>$$<br>\dfrac 1n \sum_{i = 0} ^ {n - 1} \omega_{n}^{ik} = [n | k]<br>$$<br>如何证明这个结论呢？</p><p>当 $k\bmod n\not= 0$ 时，我们的公比为 $\omega_{n}^k$ 不是 1，考虑使用等比数列求和公式：<br>$$<br>\sum_{i = 0} ^ {n - 1} \omega_{n}^{ik} = \dfrac{\omega_n^{nk} - 1}{\omega_{n}^k - 1}<br>$$<br>上面的 $\omega_{n}^{nk}$ 等于 1，所以整个式子等于 0。原式成立。</p><p>当 $k\bmod n = 0$ 时，每一项都是 1，求和后除以 $n$ 就是 1 了。</p><p>这个有什么用了？当遇到 $[i\bmod n = j]$ 这种情况时，我们可以考虑时候单位根反演展开，和其他项合并以快速计算。我们来看几道例题。</p><h2 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h2><h4 id="T1：LJJ-学二项式定理"><a href="#T1：LJJ-学二项式定理" class="headerlink" title="T1：LJJ 学二项式定理"></a>T1：LJJ 学二项式定理</h4><p><a href="https://loj.ac/p/6485">题目传送门 LOJ</a></p><p>看到 $a_{i\bmod 4}$，这个就是经典的单位根反演了。</p><p>首先我们化成上面的那个形式：<br>$$<br>ans = \sum_{i = 0} ^ n \binom ni s ^ i \sum_{j = 0} ^ 3 a_j [i\bmod 4 = j]<br>$$<br>$[i\bmod 4 = j] = [4 | (i - j)]$，然后对后面这个式子用单位根反演大力展开：<br>$$<br>\sum_{j = 0} ^ 3 a_j[i\bmod 4 = j] = \sum_{j = 0} ^ 3 \dfrac{a_j}{4} \sum_{k = 0} ^ 3 \omega_{4}^{ik - jk}<br>$$<br>然后 $n$ 在前面是没有出路的，我们考虑将 $j, k$ 放在前面，分离单位根的 $i, j$ 变量：<br>$$<br>ans = \sum_{k = 0} ^ 3 \sum_{j = 0} ^ 3 \omega_{4}^{-jk}\dfrac{a_j}4 \sum_{i = 0} ^ n \binom ni s ^ i \omega_{4}^{ik}<br>$$<br>后面是一个二项式定理，我们直接合并为 $(s \omega_{4}^k + 1) ^ n$。这样暴力枚举 $j, k$，快速幂即可做到 $O(\log n)$ 单次。处理单位根按照 NTT 里面的求法即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">wn[<span class="number">0</span>] = <span class="number">1</span>, wn[<span class="number">1</span>] = <span class="built_in">qpow</span>(<span class="number">3</span>, (Mod - <span class="number">1</span>) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">wn[<span class="number">2</span>] = Mod - <span class="number">1</span>, wn[<span class="number">3</span>] = <span class="built_in">qpow</span>(<span class="number">3</span>, (Mod - <span class="number">1</span>) / <span class="number">4</span> * <span class="number">3</span>);</span><br><span class="line">inv4 = <span class="built_in">qpow</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>], s, res = <span class="number">0</span>;</span><br><span class="line">LL n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %d %d %d %d %d&quot;</span>, &amp;n, &amp;s, a, a + <span class="number">1</span>, a + <span class="number">2</span>, a + <span class="number">3</span>);</span><br><span class="line">n %= (Mod - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++ j)</span><br><span class="line">res = (res + (LL) a[i] * wn[(<span class="number">4</span> - (i * j &amp; <span class="number">3</span>)) &amp; <span class="number">3</span>] % Mod</span><br><span class="line">* <span class="built_in">qpow</span>((LL) s * wn[j] % Mod + <span class="number">1</span>, n)) % Mod;</span><br><span class="line">res = (LL) res * inv4 % Mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2：PYXFIB"><a href="#T2：PYXFIB" class="headerlink" title="T2：PYXFIB"></a>T2：PYXFIB</h4><p><a href="https://hydro.ac/d/bzoj/p/3328">题目传送门 HydroOJ - BZOJ</a></p><p>答案容易写作：<br>$$<br>ans = \sum_{i = 0} ^ n [k | i] \binom ni F_i<br>$$<br>其中 $F_i$ 表示第 $i$ 项斐波那契数。</p><p>还是直接单位根反演：<br>$$<br>\begin{aligned}<br>ans =&amp; \sum_{i = 0} ^ n \binom ni \dfrac{F_i}{k} \sum_{j = 0} ^ {k - 1} \omega_k^{ij}\\<br>=&amp; \dfrac 1k \sum_{j = 0} ^ {k - 1} \sum_{i = 0} ^ n \binom ni F_i \omega_k^{ij}<br>\end{aligned}<br>$$<br>现在我们有一个 $F_i$ 无法化开，不能像上面一样变形。但是我们知道 $F_n = \dfrac 1{\sqrt 5}\left((\dfrac {1 + \sqrt 5}2) ^ n - (\dfrac{1 - \sqrt 5}2) ^ n \right)$，如果 5 在该质数下有二次剩余，我们可以写作幂次的加减。但很可惜，这道题没有给出这样的条件。</p><p>看到斐波那契数，容易想到矩阵乘法，注意还是需要把次幂联系起来，否则无法计算。</p><p>直接将转移矩阵的 $n$ 次方写入，那么 $F_i = mat ^ i_{1, 1}$。于是我们直接带入可得：<br>$$<br>ans = \dfrac 1k \sum_{j = 0} ^ {k - 1} \sum_{i = 0} ^ n \binom ni \omega_k^{ij}mat ^ i_{1, 1}<br>$$<br>考虑前面我们处理 $\sum_{i = 0} ^ n \binom ni x ^ i$ 的时候，我们相当于是添上了乘法单位元 1 的 $n - i$ 次方。这里同样，我们添上单位矩阵 $I$ 的 $n - i$ 次方，于是答案可以写作：<br>$$<br>ans = \dfrac 1k\sum_{j = 0} ^ {k - 1} (\omega_k^{j}mat + I) ^ n_{1, 1}<br>$$<br>直接计算即可，复杂度 $O(k\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findrt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; fac;</span><br><span class="line"><span class="keyword">int</span> cur = Mod - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cur / i; ++ i)</span><br><span class="line"><span class="keyword">if</span> (cur % i == <span class="number">0</span>) &#123;</span><br><span class="line">fac.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">while</span> (cur % i == <span class="number">0</span>) cur /= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur ^ <span class="number">1</span>) fac.<span class="built_in">push_back</span>(cur);</span><br><span class="line"><span class="keyword">auto</span> check = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t : fac)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">qpow</span>(x, (Mod - <span class="number">1</span>) / t) == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Mod; ++ i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(i)) <span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL n;</span><br><span class="line"><span class="keyword">int</span> k, res = <span class="number">0</span>;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; Mod;</span><br><span class="line">wn[<span class="number">0</span>] = <span class="number">1</span>, wn[<span class="number">1</span>] = <span class="built_in">qpow</span>(<span class="built_in">findrt</span>(), (Mod - <span class="number">1</span>) / k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; k; ++ i) wn[i] = (LL) wn[i - <span class="number">1</span>] * wn[<span class="number">1</span>] % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">Matrix cur&#123;&#123;&#123;<span class="number">1</span>, wn[i]&#125;, &#123;wn[i], wn[i] + <span class="number">1</span>&#125;&#125;&#125;;</span><br><span class="line">cur = <span class="built_in">qpow</span>(cur, n), <span class="built_in">adj</span>(res += cur[<span class="number">1</span>][<span class="number">1</span>] - Mod);</span><br><span class="line">&#125;</span><br><span class="line">res = (LL) res * <span class="built_in">qpow</span>(k) % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3：小猪佩奇学数学"><a href="#T3：小猪佩奇学数学" class="headerlink" title="T3：小猪佩奇学数学"></a>T3：小猪佩奇学数学</h4><p><a href="https://www.luogu.com.cn/problem/P5591">题目传送门 Luogu</a></p><p>保证了 $k$ 是 2 的次幂，显然就需要单位根了，否则单位根就不好求了……</p><p>看到 $\lfloor\dfrac ik \rfloor$ 很神秘，先乘 $k$ 最后除回去，那么 $k\lfloor \dfrac ik\rfloor = i - i\bmod k$。</p><p>看到 $i\bmod k$，果断化为 $\sum_{j = 0} ^ {k - 1} j[k | (i - j)]$，然后单位根反演，于是就可以得到：<br>$$<br>i\bmod k = \sum_{j = 0} ^ {k - 1} \dfrac jk\sum_{l = 0} ^ {k - 1} \omega_k ^ {il - jl}<br>$$<br>带回原式：<br>$$<br>k\times ans = \sum_{i = 0} ^ n \binom ni p ^ i (i - \sum_{j = 0} ^ {k - 1} \dfrac jk \sum_{j = 0} ^ {k - 1}\omega_k^{il - jl})<br>$$<br>原式化为了两边，分别计算。<br>$$<br>ans1 = \sum_{i = 0} ^ n\binom ni p ^ i i<br>$$<br>孤零零的 $i$ 很烦，我们考虑将其合并进入组合数：<br>$$<br>\begin{aligned}<br>ans1 =&amp; \sum_{i = 0} ^ n \dfrac{n!p ^ ii}{i!(n - i)!}\\<br>=&amp; n\sum_{i = 1} ^ n \dfrac{(n - 1)!p ^ i}{(i - 1)!(n - i)!}\\<br>=&amp; np\sum_{i = 1} ^ n \binom{n - 1}{i - 1} p ^ {i - 1}\\<br>=&amp; np (p + 1) ^ {n - 1}<br>\end{aligned}<br>$$<br>这样第一部分可以在 $O(\log n)$ 的时间内解决。</p><p>接下来考虑第二部分：<br>$$<br>\begin{aligned}<br>k\times ans2 =&amp; \sum_{i = 0} ^ n \binom ni p ^ i\sum_{j = 0} ^ {k - 1} j\sum_{l = 0} ^ {k - 1} \omega_k^{ik - jk}<br>\end{aligned}<br>$$<br>仍然考虑先枚举 $j, l$，那么可以写作：<br>$$<br>\begin{aligned}<br>k\times ans2 =&amp; \sum_{j = 0} ^ {k - 1}j \sum_{l = 0} ^ {k - 1} \omega_k^{-jl} \sum_{i = 0} ^ {n}\binom ni p ^ i \omega_k^{il}\\<br>=&amp; \sum_{j = 0} ^ {k - 1}j \sum_{l = 0} ^ {k - 1} \omega_k^{-jl}(p\omega_k^{l} + 1) ^ n<br>\end{aligned}<br>$$<br>这样就得到了 $O(k ^ 2\log n)$ 的做法，可以得 60 pts。</p><p>后面 $l$ 一坨不好化开，我们看到 $j$ 相关的形式比较少，于是交换 $j, l$ 顺序：<br>$$<br>k\times ans2 = \sum_{l = 0} ^ {k - 1} (p\omega_k ^{l} + 1) ^ n\sum_{j = 0} ^ {k - 1} j\omega_k^{-jl}<br>$$<br>这里后面一坨还是不好计算，但是由于单位根特殊的性质 $\omega_k^{nk} = 0$，我们可以考虑错位减一下。</p><p>设 $S(x) = \sum_{j = 0} ^ {k - 1} j\omega_k^{jx}$，则有：<br>$$<br>\begin{aligned}<br>S(x) =&amp; \sum_{j = 0} ^ {k - 1} j\omega_k^{jx}\\<br>\omega_k^{x} S(x) =&amp; \sum_{j = 1} ^ k (j - 1)\omega_k^{jx}\\<br>(\omega_k^{x} - 1)S(x) =&amp; (k - 1)\omega_k^{jk} -\sum_{j = 1} ^ {k - 1} \omega_k^{jx}<br>\end{aligned}<br>$$<br>前面的 $(k - 1)\omega_k^{jk}$ 就是 $k - 1$，后面的 $\sum_{j = 1} ^ {k - 1} \omega_k^{jx}$ 其实是 -1，因为我们尝试加上 $\omega_k^0$ 整个式子就变成 0 了。</p><p>那么我们可以得到 $S(x) = \dfrac{k}{\omega_k^{x} - 1}$，唯一注意 $n | x$ 的时候 $S(x) = \dfrac{n(n - 1)}2$。总复杂度 $O(k\log n)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wnsum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> mul)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mul == n) <span class="keyword">return</span> (LL) n * (n - <span class="number">1</span>) / <span class="number">2</span> % Mod;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in"><span class="keyword">return</span></span> (LL) n * <span class="built_in">qpow</span>(wn[mul] - <span class="number">1</span>) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; p &gt;&gt; k;</span><br><span class="line">wn[<span class="number">0</span>] = <span class="number">1</span>, wn[<span class="number">1</span>] = <span class="built_in">qpow</span>(<span class="number">3</span>, (Mod - <span class="number">1</span>) / k); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; k; ++ i) wn[i] = (LL) wn[i - <span class="number">1</span>] * wn[<span class="number">1</span>] % Mod;</span><br><span class="line"><span class="keyword">int</span> res = (LL) n * <span class="built_in">qpow</span>(p + <span class="number">1</span>, n - <span class="number">1</span>) % Mod * p % Mod, res2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; k; ++ l)</span><br><span class="line">res2 = (res2 + (LL) <span class="built_in">qpow</span>((LL) p * wn[l] % Mod + <span class="number">1</span>, n) * <span class="built_in">wnsum</span>(k, k - l)) % Mod;</span><br><span class="line">res2 = res2 * (LL) <span class="built_in">qpow</span>(k) % Mod;</span><br><span class="line"><span class="built_in">adj</span>(res -= res2), res = (LL) res * <span class="built_in">qpow</span>(k) % Mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;处理整除时才有贡献的利器。&lt;/p&gt;</summary>
    
    
    
    
    <category term="单位根反演" scheme="https://mydcwfy.github.io/tags/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/"/>
    
    <category term="数学" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P2791 幼儿园篮球题</title>
    <link href="https://mydcwfy.github.io/2022/06/03/Luogu-P2791/"/>
    <id>https://mydcwfy.github.io/2022/06/03/Luogu-P2791/</id>
    <published>2022-06-03T06:46:00.000Z</published>
    <updated>2022-06-03T07:06:10.392Z</updated>
    
    <content type="html"><![CDATA[<p>自然数幂转斯特林数推式子题目。</p><span id="more"></span><p>题意：有 $n$ 个篮球，其中 $m$ 个没气，随机抽取 $k$ 个，问没气个数的 $l$ 次方的期望，对 998244353 取模。$T(T\leq 200)$ 次询问，每次询问 $l$ 相同。$n, m, k\leq 2\times 10 ^ 7, l\leq 2\times 10 ^ 5$，$ k\leq n, m\leq n$。</p><p>其实看到 $l\leq 2\times 10 ^ 5$ 和 $l$ 次方，以及每次 $l$ 相同，差不多就是斯特林数了吧……</p><p>直接一波推式子：<br>$$<br>\begin{aligned}<br>ans =&amp; \sum_{i = 1} ^ k i ^ l \binom mi \binom{n - m}{k - i}\\<br>=&amp; \sum_{i = 1} ^ k \binom mi \binom{n - m}{k - i} \sum_{j = 1} ^ i \binom ij j!{l\brace j}\\<br>=&amp; \sum_{j = 1} ^ k \binom mj j!{l\brace j} \sum_{i = j} ^ k \binom{n - m}{k - i} \binom{m - j}{i - j}\\<br>\end{aligned}<br>$$<br>然后前面的式子几乎化不了了，我们考虑计算后面的 $\sum_{i = j} ^ k\binom{n - m}{k - i}\binom{m - j}{i - j}$。容易发现枚举的上下界没有必要，因为多出来的都是 0。</p><p>考虑其组合意义，相当于我们在前面的 $n - m$ 个物品中抽出 $k - i$ 个，在后面的 $m - j$ 的物品中选出 $i - j$ 个，这相当于在 $n - m + m - j = n - j$ 个物品中，选出 $k - i + i - j = k - j$ 个物品，于是这一坨求和就可以写作 $\binom{n - j}{k - j}$。</p><p>于是答案就变成了：<br>$$<br>ans = \sum_{j = 1} ^ k m ^ {\underline j} {l\brace j} \binom{n - j}{k - j}<br>$$<br>看似我们需要枚举到 $k$，但是 $j &gt; l$ 的时候显然为 0，所以 $j\leq l$ 是必需的。</p><p>大力处理一列第二类斯特林数，即可做到 $O(l\log l + Tl + N)$ 的复杂度，可以一边算答案的时候计算组合数和下降幂，省掉那个 $N$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initsti</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">poly <span class="title">a</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &amp; <span class="number">1</span>) a[i] = Mod - infact[i];</span><br><span class="line"><span class="keyword">else</span> a[i] = infact[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++ i) b[i] = (LL) <span class="built_in">qpow</span>(i, N) * infact[i] % Mod;</span><br><span class="line">sti = a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> n &lt; m || n &lt; <span class="number">0</span> ? <span class="number">0</span> : (LL) fact[n] * infact[m] % Mod * infact[n - m] % Mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m, T, L, k;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; T &gt;&gt; L;</span><br><span class="line"><span class="built_in">initfact</span>(n), <span class="built_in">initsti</span>(L);</span><br><span class="line"><span class="keyword">while</span> (T --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, ed = std::<span class="built_in">min</span>(L, k); j &lt;= ed; ++ j)</span><br><span class="line">res = (res + (LL) <span class="built_in">C</span>(m, j) * fact[j] % Mod * sti[j] % Mod * <span class="built_in">C</span>(n - j, k - j)) % Mod;</span><br><span class="line">res = (LL) res * <span class="built_in">qpow</span>(<span class="built_in">C</span>(n, k)) % Mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;自然数幂转斯特林数推式子题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="斯特林数" scheme="https://mydcwfy.github.io/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>ARC061F Card Game for Three</title>
    <link href="https://mydcwfy.github.io/2022/06/03/ARC061F/"/>
    <id>https://mydcwfy.github.io/2022/06/03/ARC061F/</id>
    <published>2022-06-03T02:14:09.000Z</published>
    <updated>2022-06-12T00:13:25.615Z</updated>
    
    <content type="html"><![CDATA[<p>组合数学推式子题目。</p><span id="more"></span><p>题意：三个人面前分别有 $n, m, k$ 张牌，每张牌写着 1、2 或 3，从第一个人开始拿自己面前的牌，牌上写的什么下一个就该谁拿，当本该一个人拿时却没有牌时，这个人就获胜。求所有的牌的方案中，第一个人胜利的方案有多少种。$n, m, k\leq 3\times 10 ^ 5$。</p><p>我们考虑将取牌的序列拿出来看。除了第一次拿一张牌没有一个 1，后面每次都需要前面的人拿出一个 1，这样拿出 $n$ 个 1 后第一个人就胜利了。</p><p>于是我们得到的取牌的序列就是前面有 $n$ 个 1，然后前面不能多于 $m$ 个 2，$k$ 个 3。</p><p>枚举前面非 1 的个数，我们就可以得到：<br>$$<br>ans = \sum_{i = 0} ^ {m + k} 3 ^ {m + k - i}\binom{i + n - 1}i \sum_{j = i - k} ^ m \binom ij<br>$$<br>注意可能不合法，那么组合数为 0。</p><p>现在我们得到了 $O(n ^ 2)$ 的做法，但是显然不行。后面的一坨不好做，考虑递推。</p><p>设 $S(i) = \sum_{j = i - k} ^ m \binom ij$，那么裂项展开，可以得到：<br>$$<br>\begin{aligned}<br>S(i) =&amp; \sum_{j = i - k} ^ m \binom ij\\<br>=&amp; \sum_{j = i - k} ^ m \binom{i - 1}j + \sum_{j = i - k} ^ m \binom{i - 1}{j - 1}\\<br>S(i - 1) =&amp; \sum_{j = i - k - 1} ^ m \binom{i - 1}{j}\\<br>S(i) =&amp; 2S(i - 1) - \binom{i - 1}{i - k - 1} - \binom{i - 1}{m}<br>\end{aligned}<br>$$<br>直接递推即可，时间复杂度线性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + k; ++ i)</span><br><span class="line"><span class="built_in">adj</span>(<span class="built_in">adj</span>(<span class="built_in">adj</span>(s[i] = <span class="number">2</span> * s[i - <span class="number">1</span>] - Mod) -= <span class="built_in">C</span>(i - <span class="number">1</span>, i - k - <span class="number">1</span>)) -= <span class="built_in">C</span>(i - <span class="number">1</span>, m));</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m + k; ++ i)</span><br><span class="line">res = (res + (LL) pw3[m + k - i] * s[i] % Mod * <span class="built_in">C</span>(i + n - <span class="number">1</span>, n - <span class="number">1</span>)) % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;组合数学推式子题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P6031 Cards 加强版</title>
    <link href="https://mydcwfy.github.io/2022/06/02/Luogu-P6031/"/>
    <id>https://mydcwfy.github.io/2022/06/02/Luogu-P6031/</id>
    <published>2022-06-02T07:37:52.000Z</published>
    <updated>2022-06-03T03:11:10.374Z</updated>
    
    <content type="html"><![CDATA[<p>比较难推式子，对斯特林数和组合数的应用要求比较高。</p><span id="more"></span><p>题意：$m$ 张牌中有一张王牌，重排 $n$ 次，求第一张是王牌的次数 $k$ 次方的期望对 998244353 取模的结果。$k\leq 10 ^ 7, n, m\leq 998244353$。</p><p>容易发现单次第一张是王牌的期望显然为 $\dfrac 1m$，令其为 $p$。</p><p>则答案可以写作：<br>$$<br>\sum_{i = 0} ^ n \binom ni p ^ i(1 - p) ^ {n - i} i ^ k<br>$$<br>看到 $i ^ k$，考虑使用第二类斯特林数展开，让 $k$ 下来：<br>$$<br>m ^ n =  \sum_{i = 0} ^ m \binom mi {n\brace i}i!<br>$$</p><p>$$<br>\begin{aligned}<br>ans =&amp; \sum_{i = 1} ^ n \binom ni p ^ i (1 - p) ^ {n - i} i ^ k\\<br>=&amp; \sum_{i = 1} ^ n \binom ni p ^ i (1 - p) ^ {n - i} \sum_{j = 0} ^ i \binom ij j!{k\brace j}\\<br>=&amp; \sum_{i = 1} ^ n p ^ i (1 - p) ^ {n - i} \sum_{j = 0} ^ i \dfrac{n!}{(n - i)!(i - j)!}{k\brace j}\\<br>=&amp; n!\sum_{j = 0} ^ n {k\brace j} \sum_{i = j} ^ n \dfrac{p ^ i (1 - p) ^ {n - i}}{(n - i)!(i - j)!}<br>\end{aligned}<br>$$</p><p>考虑后面的一坨东西，我们看看能变成什么（此时 $j$ 为常量，我们写为 $a$）：<br>$$<br>\begin{aligned}<br>&amp;\sum_{i = a} ^ n \dfrac{p ^ i (1 - p) ^ {n - i}}{(n - i)!(i - a)!}\\<br>=&amp; \dfrac{1}{(n - a)!} \sum_{i = a} ^ n p ^ i (1 - p) ^ {n - i} \binom{n - a}{i - a}\\<br>=&amp; \dfrac{p ^ a}{(n - a)!}<br>\end{aligned}<br>$$<br>这个式子就比较简洁了，我们带入原来的式子就是：<br>$$<br>ans = n!\sum_{j = 0} ^ n {k\brace j} \dfrac{p ^ j}{(n - j)!}<br>$$<br>其实现在完全可以做到 $O(k\log k)$（循环上界肯定不超过 $k$，否则为 0），良心（？）的出题人也给了一定的部分分。但是肯定跑不过 $10 ^ 7$，考虑是否做到线性递推。</p><p>容易发现 $\displaystyle {k\brace j}$ 一定是需要 $O(n\log n)$ 的，所以考虑将其砍掉。第二类斯特林数的表达方式可以用二项式反演得到，为：<br>$$<br>{n\brace m} = \dfrac{1}{m!}\sum_{i = 0} ^ m(-1) ^ {m - i} \binom mi i ^ n<br>$$<br>但是注意这是在 $n\geq m$ 的情况下成立的，而我们枚举的 $\sum_{j = 0} ^ n {k\brace j}$ 可能是不满足的，所以我们分类讨论。</p><p>先讨论难一点的，就是 $n &gt; k$ 的情况，这样枚举上界就变为了 $k$。<br>$$<br>\begin{aligned}<br>ans =&amp; n!\sum_{j = 0} ^ k {k\brace j} \dfrac{p ^ j}{(n - j)!}\\<br>=&amp; n!\sum_{i = 0} ^ k \dfrac{p ^ i}{i!(n - i)!} \sum_{j = 0} ^ i \binom ij (-1) ^ {i - j} j ^ k \\<br>=&amp; \sum_{i = 0} ^ k p ^ i \binom ni\sum_{j = 0} ^ i\binom ij (-1) ^ {i - j} j ^ k\\<br>=&amp; \sum_{i = 0} ^ k p ^ i \sum_{j = 0} ^ i (-1) ^ {i - j} j ^ k \dfrac{n!}{(n - i)!j!(i - j)!}\\<br>=&amp; \sum_{j = 0} ^ k \binom nj (-1) ^ j j ^ k \sum_{i = j} ^ k (-p) ^ i \binom {n - j}{i - j}\\<br>=&amp; \sum_{j = 0} ^ k \binom nj j ^ k p ^ j\sum_{i = 0} ^ {k - j} (-p) ^ i \binom {n - j}i<br>\end{aligned}<br>$$<br>推到这里，似乎我们的式子已经比较简洁了，但是后面的一坨没法使用二项式定理（上界不同），我们陷入了死胡同。</p><p>对后面这个式子硬上，考虑裂项组合数递推，设 $\displaystyle S(t) = \sum_{i = 0} ^ {k - t} (-p) ^ j\binom{n - t}{i}$。考虑大力变形：<br>$$<br>\begin{aligned}<br>S(t) =&amp; \sum_{i = 0} ^ {k - t} (-p) ^ i \binom{n - j}{i}\\<br>=&amp; \sum_{i = 0} ^ {k - t} (-p) ^ i (\binom{n - j - 1}{i - 1} + \binom{n - j - 1}{i})\\<br>=&amp; (-p)\sum_{i = 1} ^ {k - t}(-p) ^ {i - 1}\binom{n - j - 1}{i - 1} + \sum_{i = 0} ^ {k - t} (-p) ^ i\binom{n - j - 1}{i} \\<br>S(t - 1)=&amp; \sum_{i = 0} ^ {k - t - 1} (-p) ^ i \binom{n - j - 1}{i}\\<br>S(t) =&amp; (-p)S(t + 1) + (-p) ^ {k - t} \binom{n - t - 1}{k - t} + S(t + 1)\\<br>S(t)=&amp; (1 - p) S(t + 1) + (-p) ^ {k - t} \binom{n - t - 1}{k - t}<br>\end{aligned}<br>$$<br>边界显然为 $S(k) = 1$，倒序递推即可。注意 $\binom{n - t - 1}{k - t}$ 无法计算，我们可以变形：<br>$$<br>\binom{n - t - 1}{k - t} = \dfrac{(n - t - 1) ^ {\underline{k - t}}}{(k - t)!} = \dfrac{(n - k) ^ {\overline {k - t}}}{(k - t)!}<br>$$<br>同时计算 $S(t)$ 和上升幂并预处理 $p ^ k$，可以做到线性。</p><p>现在回来，答案可以表示为：<br>$$<br>ans = \sum_{j = 0} ^ k \binom nj j ^ k p ^ i S(j)<br>$$<br>维护 $n ^ \underline{j}$，即可边计算答案边计算下降幂。至此，我们解决了 $n &gt; k$ 的情况，复杂度 $O(k)$。</p><p>下面我们计算 $n\leq k$ 的情况。<br>$$<br>\begin{aligned}<br>ans =&amp; n!\sum_{j = 0} ^ n {k\brace j} \dfrac{p ^ j}{(n - j)!}\\<br>=&amp; n!\sum_{j = 0} ^ n \dfrac{p ^ j}{(n - j)!j!} \sum_{i = 0} ^ j \binom ji(-1) ^ {i - j} i ^ k \\<br>=&amp; \sum_{j = 0} ^ n p ^ j\binom nj\sum_{i = 0} ^ j \binom ji (-1) ^ {i - j} i ^ k\\<br>=&amp; \sum_{i = 0} ^ n (-1) ^ i \binom ni \sum_{j = i} ^ n \binom{n - i}{j - i}(-p) ^ j i ^ k\\<br>=&amp; \sum_{i = 0} ^ n p ^ ii ^ k\binom ni \sum_{j = i} ^ n \binom{n - i}{j - i} (-p) ^ {j - i}\\<br>=&amp; \sum_{i = 0} ^ n p ^ ii ^ k \binom ni (1 - p) ^ {n - i}<br>\end{aligned}<br>$$<br>还是可以做到线性，可以直接计算 $\binom ni$，复杂度 $O(k)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) fact[i] = (LL) fact[i - <span class="number">1</span>] * i % Mod;</span><br><span class="line">infact[N - <span class="number">1</span>] = <span class="built_in">qpow</span>(fact[N - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">2</span>; i; -- i) infact[i] = (LL) infact[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % Mod;</span><br><span class="line"></span><br><span class="line">pk[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) prime[cnt ++] = i, pk[i] = <span class="built_in">qpow</span>(i, k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; i * prime[j] &lt; N; ++ j)</span><br><span class="line">&#123;</span><br><span class="line">st[i * prime[j]] = <span class="literal">true</span>, pk[i * prime[j]] = (LL) pk[i] * pk[prime[j]] % Mod;</span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) pw[i] = (LL) pw[i - <span class="number">1</span>] * p % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> (LL) fact[n] * infact[m] % Mod * infact[n - m] % Mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> NLarge &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> up = <span class="number">1</span>;</span><br><span class="line">s[k] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = k - <span class="number">1</span>; t; -- t)</span><br><span class="line">&#123;</span><br><span class="line">up = (LL) up * (n - t - <span class="number">1</span>) % Mod;</span><br><span class="line">s[t] = (LL) (Mod + <span class="number">1</span> - p) * s[t + <span class="number">1</span>] % Mod;</span><br><span class="line"><span class="keyword">if</span> ((t ^ k) &amp; <span class="number">1</span>) <span class="built_in">adj</span>(s[t] -= (LL) up * infact[k - t] % Mod * pw[k - t] % Mod);</span><br><span class="line"><span class="keyword">else</span> s[t] = (s[t] + (LL) up * infact[k - t] % Mod * pw[k - t]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dn = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++ j)</span><br><span class="line">&#123;</span><br><span class="line">dn = (LL) dn * (n - j + <span class="number">1</span>) % Mod;</span><br><span class="line">res = (res + (LL) dn * infact[j] % Mod * pk[j] % Mod * pw[j] % Mod * s[j]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> NSmall &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, cur = <span class="built_in">qpow</span>(Mod + <span class="number">1</span> - p, n), inv = <span class="built_in">qpow</span>(Mod + <span class="number">1</span> - p);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">cur = (LL) cur * inv % Mod;</span><br><span class="line">res = (res + (LL) pw[i] * pk[i] % Mod * <span class="built_in">C</span>(n, i) % Mod * cur) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; p &gt;&gt; k, p = <span class="built_in">qpow</span>(p);</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">if</span> (n &gt; k) NLarge::<span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">else</span> NSmall::<span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;比较难推式子，对斯特林数和组合数的应用要求比较高。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="斯特林数" scheme="https://mydcwfy.github.io/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    
    <category term="期望" scheme="https://mydcwfy.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>UOJ269 如何优雅地求和</title>
    <link href="https://mydcwfy.github.io/2022/05/30/UOJ269/"/>
    <id>https://mydcwfy.github.io/2022/05/30/UOJ269/</id>
    <published>2022-05-30T11:39:10.000Z</published>
    <updated>2022-05-30T12:15:12.330Z</updated>
    
    <content type="html"><![CDATA[<p>神奇二项式反演 + 卷积。</p><span id="more"></span><p>题意：求 $\displaystyle \sum_{k = 0} ^ n f(k) \binom nk x ^ k (1 - x) ^ {n - k}$，其中 $f(x)$ 以给出 $[0, m]$ 的点值 $a_{0\dots, m}$ 形式给出。$n\leq 10 ^ 9, m\leq 2\times 10 ^ 4$。</p><p>这里给出一种神秘的做法：将 $f(x)$ 以下降幂的形式写出。即：<br>$$<br>f(x) = \sum_{i = 0} ^ m b_i \dfrac{m ^ {\underline i}}{i!}<br>$$<br>这个其实就是下降幂多项式。我们考虑如何求出 $b_i$，使用二项式反演（为了方便，还是使用广义组合数形式写出）：<br>$$<br>b_n = \sum_{i = 0} ^ n (-1) ^ {n - i} \binom ni a_i<br>$$<br>这个很容易化成卷积，这里不再展开。</p><p>然后考虑将这个带入可得：<br>$$<br>\begin{aligned}<br>ans =&amp; \sum_{i = 0} ^ m b_i \sum_{k = 0} ^ n \binom nk\binom ki x ^ k (1 - x) ^ {n - k}\\<br>=&amp; \sum_{i = 0} ^ m b_i \sum_{k = 0} ^ n \binom ni \binom{n - i}kx ^ k (1 - x) ^ {n - k}\\<br>=&amp; \sum_{i = 0} ^ m b_i \binom ni x ^ i (x + 1 - x) ^ {n - k}\\<br>=&amp; \sum_{i = 0} ^ m b_i<br>\end{aligned}<br>$$<br>后面的部分可以 $O(m)$ 算得。总时间复杂度 $O(m\log m)$。看到似乎有 $O(m)$ 做法？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">int</span> n, m, x;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(m + <span class="number">1</span>)</span>, <span class="title">g</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;f[i]), f[i] = (LL) f[i] * infact[i] % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, op = <span class="number">1</span>; i &lt;= m; ++ i, op = Mod - op)</span><br><span class="line">g[i] = (LL) op * infact[i] % Mod;</span><br><span class="line">f = f * g, f.<span class="built_in">resize</span>(m + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> mul = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">res = (res + (LL) f[i] * mul) % Mod;</span><br><span class="line">mul = (LL) mul * x % Mod * (n - i) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;神奇二项式反演 + 卷积。&lt;/p&gt;</summary>
    
    
    
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    <category term="二项式反演" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>CF917D Stranger Trees</title>
    <link href="https://mydcwfy.github.io/2022/05/30/CF917D/"/>
    <id>https://mydcwfy.github.io/2022/05/30/CF917D/</id>
    <published>2022-05-30T11:03:11.000Z</published>
    <updated>2022-05-30T11:20:25.987Z</updated>
    
    <content type="html"><![CDATA[<p>矩阵树定理，好像和 2020 联合省选 作业题 套路类似。</p><span id="more"></span><p>题意：给定 $n$ 个点的树，问在所有 $n$ 个点的完全图的生成树中，与原树有 $k$ 条边相同的方案数。输出 $\forall k\in[0, n - 1]$ 的答案。$n\leq 100$。</p><p>看作多项式，如果我们把原树中的边记作 $x$，非原树中的边记作 1，那么最后所有生成树的和可以记为一个多项式，这样最后每一项的系数就对应着答案。</p><p>但是多项式卷积需要 $O(n\log n)$ 的时间，而应用矩阵树定理，计算行列式时有 $O(n ^ 3)$，总复杂度 $O(n ^ 4\log n)$，无法通过。</p><p>考虑常见套路：<strong>多次多项式乘法的时候，可以考虑维护点值而不是多项式本身</strong>。这样就可以避免不必要的多项式点值与系数之间的转换。</p><p>那么任取 $n$ 个点值，带入计算行列式，这样我们就得到了答案多项式的点值表达，最后高斯消元一下即可。时间复杂度 $O(n ^ 4)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">det</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; ++ j)</span><br><span class="line"><span class="keyword">if</span> (a[j][i]) &#123;</span><br><span class="line">t = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!~t) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (t ^ i) std::<span class="built_in">swap</span>(a[t], a[i]), x ^= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> Inv = <span class="built_in">qpow</span>(a[i][i]);</span><br><span class="line">res = (LL) res * a[i][i] % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n + <span class="number">1</span>; ++ j) a[i][j] = (LL) a[i][j] * Inv % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line"><span class="keyword">if</span> (j ^ i &amp;&amp; a[j][i])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = n + <span class="number">1</span>; k &gt;= i; -- k)</span><br><span class="line"><span class="built_in">adj</span>(a[j][k] -= (LL) a[i][k] * a[j][i] % Mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x ? <span class="built_in">adj</span>(res = -res) : res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">edg[u][v] ++, edg[v][u] ++, d[u] ++, d[v] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mul = <span class="number">1</span>; mul &lt;= n; ++ mul)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++ j)</span><br><span class="line"><span class="built_in">adj</span>(<span class="built_in">adj</span>(a[i][j] = -edg[i][j] * mul) -= ((i != j) - edg[i][j]));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">a[i][i] = (a[i][i] + (LL) d[i] * mul + (n - <span class="number">1</span> - d[i])) % Mod;</span><br><span class="line">f[mul] = <span class="built_in">det</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) a[i][j] = <span class="built_in">qpow</span>(i, j - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i][n + <span class="number">1</span>] = f[i];</span><br><span class="line"><span class="built_in">det</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][n + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;矩阵树定理，好像和 2020 联合省选 作业题 套路类似。&lt;/p&gt;</summary>
    
    
    
    
    <category term="高斯消元" scheme="https://mydcwfy.github.io/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
    <category term="矩阵树定理" scheme="https://mydcwfy.github.io/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>LOJ3119 随机正方体</title>
    <link href="https://mydcwfy.github.io/2022/05/30/LOJ3119/"/>
    <id>https://mydcwfy.github.io/2022/05/30/LOJ3119/</id>
    <published>2022-05-30T08:53:23.000Z</published>
    <updated>2022-05-30T11:00:08.758Z</updated>
    
    <content type="html"><![CDATA[<p>神仙的二项式反演，中间推导有点麻烦。</p><span id="more"></span><p>题意：随机在三维 $n\times m \times l$ 的立方体中，每个格子随机放入 $1\sim n\times m\times l$ 使得每个数恰好出现一次。若三维坐标中至少有一个和当前坐标相同的坐标所填的数中，没有比当前数大的数，则称当前坐标是一个极大值。求恰好有 $k$ 个极大值的概率。$T(T\leq 10)$ 组数据，$n, m, l\leq 5\times 10 ^ 6, k\leq 100$。</p><p>首先声明，$k\leq 100$ 似乎没起到作用……</p><p><strong>看到恰好，果断二项式反演</strong>，下面 $f(k)$ 表示钦定 $k$ 个极大值的方案数。显然 $k$ 不能超过 $\min\{n, m, l\}$，令其为 $lim$。则答案为：<br>$$<br>ans = \sum_{i = k} ^ {lim} (-1) ^ {i - k} \binom ik f(i)<br>$$<br>下面考虑如何计算 $f(k)$。</p><p>首先我们需要三维都选出 $k$ 个坐标，贡献就是 $n ^ {\underline k}m ^ {\underline k}l ^ {\underline k}$（注意是有序的）。与极大值无关的地方随便填，设为 $a_k = (n - k)(m - k)(l - k)$，为 $(nml) ^ {\underline {a_k}}$。</p><p>然后现在顺序这些都不需要考虑，我们现在只需要填入 $k$ 个最大值。</p><p>如果我们先填入 $k$ 个极大值中最大的那一个，填的时候我们将前 $k - 1$ 个所覆盖的（指至少有一维坐标相同）的先不管。这启示我们可以递推下去，假设这个函数为 $g(k)$。</p><p>我们填的时候，有影响的位置就应该是 $a_{k - 1} - a_k$，然后我们需要在 $nml - a_k - 1$ 个数（没有这个极大值，因为他一定选最大的那一个）中随意选出 $a_{k - 1} - a_k - 1$ 个数，然后除了极大值的位置固定以外，其他的又随意填，贡献就是：<br>$$<br>\binom{nml - a_k - 1}{a_{k - 1} - a_k - 1}(a_{k - 1} - a_k - 1)!<br>$$<br>通过这个，我们很容易从 $g(k - 1)$ 转移到 $g(k)$，而转移系数就是上面那个式子。</p><p>接下来就是把上面的式子一通合并（防止重名，题目中的 $k$ 更换为 $st$）：<br>$$<br>\begin{aligned}<br>ans =&amp; \dfrac 1{nml!}\sum_{k = st} ^ {lim} (-1) ^ {k - st} \binom k{st} n ^ {\underline k}m ^ {\underline k} l ^ {\underline k} nml ^ {\underline{a_k}} g(k)\\<br>=&amp; \dfrac 1{nml!}\sum_{k = st} ^ {lim} (-1) ^ {k - st} \binom k{st} n ^ {\underline k}m ^ {\underline k} l ^ {\underline k} nml ^ {\underline{a_k}} \prod_{i = 1} ^ k \dfrac{(nml - a_k - 1)!} {(nml - a_{k - 1})!} \\<br>=&amp; \sum_{k = st} ^ {lim} (-1) ^ {k - st} \binom k{st} n ^ {\underline k} m ^ {\underline k} l ^ {\underline k} \prod_{i = 1} ^ k \dfrac{1}{(nml - a_k)!}<br>\end{aligned}<br>$$<br>这样我们线性预处理前缀逆元即可 $O(n)$ 计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; k, lim = std::<span class="built_in">min</span>(&#123;n, m, l&#125;);</span><br><span class="line"><span class="keyword">if</span> (k &gt; lim) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; ++ i)</span><br><span class="line"><span class="built_in">adj</span>(r[i] = (LL) n * m % Mod * l % Mod - (LL) (n - i) * (m - i) % Mod * (l - i) % Mod);</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; ++ i) tot = (LL) tot * r[i] % Mod;</span><br><span class="line">tot = <span class="built_in">qpow</span>(tot), pre[lim] = tot;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lim - <span class="number">1</span>; i; -- i) pre[i] = (LL) pre[i + <span class="number">1</span>] * r[i + <span class="number">1</span>] % Mod;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k, op = <span class="number">1</span>; i &lt;= lim; ++ i, op = Mod - op)</span><br><span class="line">res = (res + (LL) op * <span class="built_in">C</span>(n, i) % Mod * <span class="built_in">C</span>(m, i) % Mod * <span class="built_in">C</span>(l, i)</span><br><span class="line">% Mod * <span class="built_in">qpow</span>(fact[i], <span class="number">3</span>) % Mod * pre[i] % Mod * <span class="built_in">C</span>(i, k)) % Mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;神仙的二项式反演，中间推导有点麻烦。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="二项式反演" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>CF1103E Radix Sum</title>
    <link href="https://mydcwfy.github.io/2022/05/30/CF1103E/"/>
    <id>https://mydcwfy.github.io/2022/05/30/CF1103E/</id>
    <published>2022-05-30T08:00:52.000Z</published>
    <updated>2022-05-30T08:42:15.997Z</updated>
    
    <content type="html"><![CDATA[<p>10 进制 FWT 的写法。</p><span id="more"></span><p>题意：给定 $n$ 个整数 $a_1, a_2, \dots, a_n$，求有多少个长度为 $n$ 的序列满足每一个数都从 $n$ 个数里面选（不同位置算不同方案），且 10 进制不进位加法后答案为 $x$。输出 $x\in [0, n - 1]$ 的答案。$n\leq 10 ^ 5, a_i &lt; 10 ^ 5$，答案对 $2 ^ {58}$ 取模。</p><p>容易发现我们只需要实现十进制 FWT，直接快速幂再逆变换即可。</p><p>首先考虑 FWT 的本质其实是一种高维的 FFT，只不过每一维的长度都是 2。现在考虑如何变为长度为 10。</p><p>FFT 的过程需要乘上 $\omega_{10} ^ k$，这个在 $\bmod 2 ^ {58}$ 下似乎是没有整数与之对应，所以我们需要用一个多项式表示，为 $\sum_{i = 0} ^ 9 a_i \omega_{10}^i$。用这个就可以使用 FFT 计算了。</p><p>另外，我们还需要考虑另外的问题：最后我们每一维都需要除以一个 10，最后就是除以 $10 ^ 5$，但是 $10 ^ 5$ 在 $\bmod 2 ^ {58}$ 意义下没有逆元。容易发现我们是因为有 $2 ^ 5$ 的缘故，我们可以保留答案 $\bmod 2 ^ {63}$ 意义下的结果，最后直接除，就不需要管逆元了。$5 ^ 5$ 在 $\bmod 2 ^ {63}$ 意义下的逆元可以扩欧计算，所以就可以算了。</p><p>最后我们得到的答案是一个多项式，但是由于单位根的性质，表示并不是唯一的。$\omega_{10} ^ 5 = -1, \omega_{10} ^ 9 = -\sum_{i = 0} ^ 8 \omega_{10} ^ i$，用这两个式子我们可以把这个多项式化成 $\sum_{i = 0} ^ 3 a_i\omega_{10}^i$，不能再转换，可以证明<del>盲猜一下</del>这时 $a_0$ 的答案就是最终答案。</p><p>实际代码中，我们使用 <code>unsigned long long</code> 计算即可。时间复杂度不好算，不过 <code>unsigned long long</code> 常数小，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ULL inv5 = <span class="number">14757395258967641293ULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">ULL a[<span class="number">5</span>];</span><br><span class="line">ULL&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> a[x]; &#125;</span><br><span class="line">Complex <span class="keyword">operator</span> +(Complex t) &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;a[<span class="number">0</span>] + t[<span class="number">0</span>], a[<span class="number">1</span>] + t[<span class="number">1</span>], a[<span class="number">2</span>] + t[<span class="number">2</span>], a[<span class="number">3</span>] + t[<span class="number">3</span>], a[<span class="number">4</span>] + t[<span class="number">4</span>]&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span> -(Complex t) &#123; </span><br><span class="line"><span class="keyword">return</span> &#123;a[<span class="number">0</span>] - t[<span class="number">0</span>], a[<span class="number">1</span>] - t[<span class="number">1</span>], a[<span class="number">2</span>] - t[<span class="number">2</span>], a[<span class="number">3</span>] - t[<span class="number">3</span>], a[<span class="number">4</span>] - t[<span class="number">4</span>]&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125; f[N];</span><br><span class="line"> </span><br><span class="line">Complex <span class="keyword">operator</span> *(Complex a, Complex b)</span><br><span class="line">&#123;</span><br><span class="line">Complex res&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++ j)</span><br><span class="line"><span class="keyword">if</span> (i + j &gt;= <span class="number">5</span>) res[i + j - <span class="number">5</span>] -= a[i] * b[j];</span><br><span class="line"><span class="keyword">else</span> res[i + j] += a[i] * b[j];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Complex <span class="title">qpow</span><span class="params">(Complex a, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Complex res&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = a * a)</span><br><span class="line"><span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * a;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Complex <span class="title">transw</span><span class="params">(Complex a, <span class="keyword">int</span> typ)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Complex res&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> to = (i + typ + <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (to &gt;= <span class="number">5</span>) res[to - <span class="number">5</span>] -= a[i];</span><br><span class="line"><span class="keyword">else</span> res[to] += a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FWT</span><span class="params">(Complex a[], <span class="keyword">int</span> typ)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; N; mid *= <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i += mid * <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++ j)</span><br><span class="line">&#123;</span><br><span class="line">Complex tmp[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++ k) tmp[k] = a[i + mid * k + j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++ k)</span><br><span class="line">&#123;</span><br><span class="line">Complex &amp;cur = a[i + mid * k + j];</span><br><span class="line">cur = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">10</span>; ++ p) cur = cur + tmp[p];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">10</span>; ++ p) tmp[p] = <span class="built_in">transw</span>(tmp[p], typ * p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (typ == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">ULL inv = inv5 * inv5 * inv5 * inv5 * inv5;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++ j) a[i][j] *= inv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;10 进制 FWT 的写法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="集合幂级数" scheme="https://mydcwfy.github.io/tags/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"/>
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P4931</title>
    <link href="https://mydcwfy.github.io/2022/05/27/Luogu-P4931/"/>
    <id>https://mydcwfy.github.io/2022/05/27/Luogu-P4931/</id>
    <published>2022-05-27T11:41:27.000Z</published>
    <updated>2022-05-27T14:00:05.274Z</updated>
    
    <content type="html"><![CDATA[<p>使劲反演、生成函数，数学功底似乎得有比较高的要求。</p><span id="more"></span><p>题意：有 $n$ 对 CP，任意做 $n$ 排双人座，求恰好有 $k$ 对 CP 坐在一排的方案数。$T(T\leq 2\times 10 ^ 5)$ 组数据，$n\in [1, 5\times 10 ^ 6]$，$ k\in [0, n]$。</p><p><strong>看到恰好，显然容斥</strong>。</p><p>这里可以用到二项式反演，具体地，我们考虑 $f(k)$ 表示恰好 $k$ 对 CP 坐在一排，$g(k)$ 表示<strong>钦定</strong> $k$ 对 CP 坐在一排。</p><p>$g(k)$ 是好求的，显然就是 $\displaystyle \binom nk ^ 2k!2 ^ k(2(n - k))!$，分别是选 CP，选座位，任意排列 CP，CP 位置交换，剩下的人随便坐。</p><p>由二项式反演可得：<br>$$<br>f(k) = \sum_{i = k} (-1) ^ {i - k} \binom ik g(k)<br>$$<br>直接暴力计算，可以做到 $O(n)$ 的时间复杂度，可以通过未通过加强版。</p><p>另外，我们可以先选 $k$ 对，然后用 $h(n)$ 表示没有一对 CP 坐在一起的方案数。</p><p>那么答案可以写作：<br>$$<br>ans = \binom nk ^ 2 k! 2 ^ k h(n - k)<br>$$<br>前面的可以 $O(\log k)$ 回答，主要是后面的看能不能做到 $O(n)$ 递推。</p><p>容易得到 $h(n)$ 的表达式为：<br>$$<br>h(n) = \sum_{i = 0} ^ n (-1) ^ i \binom ni ^ 2 i! 2 ^ i (2(n - i))!<br>$$<br>容易化为卷积形式，做到 $O(n\log n)$ 的复杂度：<br>$$<br>h(n) = n! ^ 2 \sum_{i = 0} ^ n \dfrac{(-2) ^ i}{i!} \dfrac{(2(n - i))!}{(n - i)! ^ 2}<br>$$<br>就是 $h_1(x) = \sum_{n = 0}\dfrac{(-2) ^ i}{i!}x ^ i, h_2(x) = \sum_{n = 0} \dfrac{(2n)!}{n! ^ 2}x ^ i$ 的卷积。</p><p>显然需要 $O(n)$ 递推，考虑求出 $h_1(x) \times h_2(x)$ 的生成函数。<br>$$<br>\begin{aligned}<br>h_1(x) &amp;= \sum_{i = 0}\dfrac{(-2) ^ i}{i!} x^i = e ^ {-2x}\\<br>h_2(x) &amp;= \sum_{i = 0}\dfrac{2i!}{i! ^ 2} x ^ i = \sum_{i = 0} \binom{2i}i x ^ i<br>\end{aligned}<br>$$<br>下面的式子可以化为 $\dfrac1{\sqrt {1 - 4x}}$，这里就不再详细展开。</p><p>那么就得到 $h(x) = h_1(x) \times h_2(x) = \dfrac{e ^ {-2x}}{\sqrt{1 - 4x}}$（先不考虑前面的 $n! ^ 2$）</p><p>考虑求导，那么就是 $h’(x) = \dfrac{8x\times e ^ {-2x}}{(1-4x) ^ {\frac 32}} = \dfrac{8x}{1 - 4x}h(x)$。</p><p>提取两边的 $[x ^ n]$，容易得到：<br>$$<br>\begin{aligned}<br>[x ^ n]F’(x) - 4[x ^ {n - 1}]F’(x) &amp;= 8[x ^ {n - 1}]F(x)\\<br>(n + 1)f_{n + 1} - 4nf_n &amp;= 8f_{n - 1}<br>\end{aligned}<br>$$<br>按照此递推即可，时间复杂度  $O(n + T\log k)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) fact[i] = (LL) fact[i - <span class="number">1</span>] * i % Mod;</span><br><span class="line">infact[N - <span class="number">1</span>] = <span class="built_in">qpow</span>(fact[N - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">2</span>; i; -- i) infact[i] = (LL) infact[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % Mod;</span><br><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++ i) inv[i] = (LL) (Mod - Mod / i) * inv[Mod % i] % Mod;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>, f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N - <span class="number">1</span>; ++ i)</span><br><span class="line">f[i + <span class="number">1</span>] = (<span class="number">4LL</span> * i * f[i] + <span class="number">8LL</span> * f[i - <span class="number">1</span>]) % Mod * inv[i + <span class="number">1</span>] % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> (LL) fact[n] * infact[m] % Mod * infact[n - m] % Mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">int</span> n, k, T;</span><br><span class="line">std::cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">int</span> res = (LL) <span class="built_in">qpow</span>(<span class="built_in">C</span>(n, k), <span class="number">2</span>) * fact[k] % Mod</span><br><span class="line">* <span class="built_in">qpow</span>(<span class="number">2</span>, k) % Mod * f[n - k] % Mod * <span class="built_in">qpow</span>(fact[n - k], <span class="number">2</span>) % Mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使劲反演、生成函数，数学功底似乎得有比较高的要求。&lt;/p&gt;</summary>
    
    
    
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="生成函数" scheme="https://mydcwfy.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
    <category term="二项式反演" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>万能欧几里得简介</title>
    <link href="https://mydcwfy.github.io/2022/05/19/Universal-Euclidean/"/>
    <id>https://mydcwfy.github.io/2022/05/19/Universal-Euclidean/</id>
    <published>2022-05-19T14:01:22.000Z</published>
    <updated>2022-05-20T10:13:25.818Z</updated>
    
    <content type="html"><![CDATA[<p>经典的下取整求和，一般不能使用数论分块等（因为被除数不固定）。</p><span id="more"></span><p>使用类欧几里得的模板题吧（为什么不讲类欧呢？因为感觉没什么用……）。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>题意：求<br>$$<br>\sum_{i = 0} ^ n \left\lfloor\dfrac{ai + b}c \right\rfloor<br>$$<br>$T \leq 10 ^ 5, a, b, c, n\leq 10 ^ 9, c\not= 0$。</p><p>看到如此庞大的数据范围，大概率是对数做法了。</p><p>将其放在坐标系下，我们可以看作 $y = \dfrac{ax + b}c$，定义这个直线生成的字符串为：越过一个 $x$ 整点，则加一个 <code>R</code>，越过一个 $y$ 整点，则加一个 <code>U</code>，遇到同时的整点先 <code>U</code> 后 <code>R</code>。容易发现这样下去答案一定只和这个字符串有关。</p><p>比如对于这个，我们计算答案，即为：遇到 <code>U</code> 则 <code>cnt ++</code>，遇到 <code>R</code> 就 <code>res += cnt</code>。</p><p>考虑合并两个已经计算好的答案，我们尝试使用一个结构体维护，容易发现答案需要和前面的 <code>U</code> $cntu$，后面 <code>R</code> 的个数 $cntr$，前后的答案，那么我们可以合并这两个的答案。具体可以写作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="keyword">operator</span> *(Node a, Node b)</span><br><span class="line">&#123;</span><br><span class="line">Node res;</span><br><span class="line"><span class="built_in">adj</span>(res.u = a.u + b.u - Mod), <span class="built_in">adj</span>(res.r = a.r + b.r - Mod);</span><br><span class="line">res.ans = (a.ans + b.ans + <span class="built_in">LL</span>(a.u) * b.r) % Mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们现在需要做的事情就是将整个序列拆开，最后合并答案。首先我们定义最开始单次向右 <code>R</code> 的结构体 <code>fr</code> 和单次向上 <code>U</code> 的结构体 <code>fu</code>，这样就可以最后合并得到答案。</p><p>令最开始的答案为 <code>f(a, b, c, n, fu, fr)</code>，其中 <code>fu</code> 表示向上走一步所乘的结构体，<code>fr</code> 表示向右走一步要成的结构体。注意这里可能不再是开始递归进入的 <code>fu, fr</code></p><p>首先我们考虑第一种情况 $a\geq c$，于是可以将 $a\geq c$ 的变为 $a &lt; c$，具体的，每次 <code>R</code> 前面相当于多加入了 $\left\lfloor\dfrac ac \right\rfloor$ 个 <code>U</code>，那么我们可以直接写作 <code>f(a % c, b, c, n, fu, qpow(fu, a / c) * fr)</code>，<code>qpow</code> 表示快速幂。</p><p>那么现在我们需要考虑的就是 $a &lt; c$ 的情况。一个初步的想法是我们现在 $y = \dfrac{ax + b}c$ 的斜率是小于 1 的，我们可以将 $x, y$ 交换一下，将 <code>fu, fr</code> 交换一下，这样就可以将斜率变为大于 1 的情况，从而可以继续递归。</p><p>我们显然可以变形为 $x = \dfrac{cy - b}{a}$（为了清楚，这里只是对式子进行了变形，没有把 $x, y$ 交换）。但是我们需要注意有 <code>U</code> 和 <code>R</code> 的优先级的问题。比如下图：</p><img src="/2022/05/19/Universal-Euclidean/%E7%BF%BB%E8%BD%AC%E5%9B%BE1.png" class=""><p>原来的线经过了 $(1, 1)$，是先 <code>U</code> 后 <code>R</code>，但是翻转之后，变成了先 <code>R</code> 后 <code>U</code>，所以我们需要将这条线向右平移 $\dfrac 1a$ 个单位，这样就是先 <code>U</code> 后 <code>R</code>，对应上了原来的字符串。</p><p>于是我们现在需要计算的就是 $x = \dfrac{cy - b - 1}a$ 的答案。注意我们现在这个的定义域是 $(0, n]$，即我们需要计算最开始的 <code>fu</code> 贡献，但不计算最开始 <code>fr</code> 的贡献。所以可以得到 $b$ 是属于 $[0, c - 1]$ 的。</p><p>回到上面那张图，我们发现 $(0, 1]$ 的部分的答案是不完整的，我们不能直接扔给下一个算，那么前面所经过的 $\left\lfloor\dfrac{c - b - 1} a \right\rfloor$ 个 <code>fu</code> 是需要提前乘入的，另外还有一个 <code>fr</code>。</p><p>然后我们考虑 $(1, \left\lfloor\dfrac{an + b}c \right\rfloor]$ 这段区间如何计算。容易发现这就是我们需要递归的部分，但是注意，我们计算的定义域是 $(0, n]$，所以需要我们向左平移一个单位得到 $x = \dfrac{cy + c - b - 1}{a}$，所以应该递归到 <code>f(c, c - b - 1, a, m - 1, fr, fu)</code>（$m = \left\lfloor\dfrac{an + b}c \right\rfloor$）。</p><p>最后我们需要考虑 $y &gt; m, x\leq n$，这样我们转化一下就是 $x\in (\left\lfloor\dfrac{cm - b - 1}a \right\rfloor, n]$，容易发现我们需要乘上 <code>qpow(fu, n - (c * m - b - 1) / a)</code>。</p><p>那么我们就可以得到最后的 <code>AsGcd</code> 代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">AsGcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> n, Node fu, Node fr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b %= c;</span><br><span class="line"><span class="keyword">if</span> (a &gt;= c) <span class="keyword">return</span> <span class="built_in">AsGcd</span>(a % c, b, c, n, fu, <span class="built_in">qpow</span>(fu, a / c) * fr);</span><br><span class="line">LL m = (<span class="built_in">LL</span>(a) * n + b) / c;<span class="comment">// y = (cx - b - 1) / a</span></span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">qpow</span>(fr, n);<span class="comment">// all is fr</span></span><br><span class="line">std::<span class="built_in">swap</span>(fu, fr);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">qpow</span>(fu, (c - b - <span class="number">1</span>) / a) * fr <span class="comment">// solving x in [0, 1]</span></span><br><span class="line">* <span class="built_in">AsGcd</span>(c, c - b - <span class="number">1</span>, a, m - <span class="number">1</span>, fu, fr) <span class="comment">// solving x in (1, m]</span></span><br><span class="line">* <span class="built_in">qpow</span>(fu, n - (c * m - b - <span class="number">1</span>) / a) <span class="comment">// solving x in [m, m + 1), notice that y_max = n</span></span><br><span class="line">;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似欧几里得算法，得到时间复杂度 $O(\log(a + c))$，不过常数比较大。</p><p>最后递归的时候，注意到 0 是被包含进入答案的，所以递归前，我们要先乘上 <code>qpow(fu, b / c) * fr</code>。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>给定 $a, b, c, l$ 和 $n\times n$ 的矩阵 $A, B$，求：<br>$$<br>\sum_{i = 1} ^ l A ^ {i} B ^ {\lfloor\frac{ai + b}{c} \rfloor}<br>$$<br>$a, b, c, \lfloor\dfrac{al + b}{c}\rfloor\leq 10 ^ {18}$。</p><p>通过这个题，我们就可以看出万能欧几里得的优势：只需要将上面的模板记住（或手推），然后处理一下信息的合并即可。这相对于类欧几里得优化了许多，思维量减小了不少。</p><p>看这个题，如果我们需要合并两个已经计算好的信息，我们需要维护 $A ^ x$，这就是后面的答案需要乘在前面的；然后还需要维护 $B ^ {\lfloor\frac {ax + b}c \rfloor}$，这个需要乘在答案的中间，这和乘在最后没有区别。</p><p>于是我们需要维护三个信息，而这三个信息是可以用 $O(n ^ 3)$ 时间合并的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">Matrix cntx, cnty, ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node <span class="keyword">operator</span> *(Node a, Node b)</span><br><span class="line">&#123;</span><br><span class="line">a.ans += a.cntx * b.ans * a.cnty;</span><br><span class="line">a.cnty = a.cnty * b.cnty, a.cntx = a.cntx * b.cntx;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们套用前面的计算方法<del>直接复制</del>，得到这份代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">AsGcd</span><span class="params">(LL a, LL b, LL c, LL n, Node fu, Node fr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b %= c;</span><br><span class="line"><span class="keyword">if</span> (a &gt;= c) <span class="keyword">return</span> <span class="built_in">AsGcd</span>(a % c, b, c, n, fu, <span class="built_in">qpow</span>(fu, a / c) * fr);</span><br><span class="line">LL m = ((s128) a * n + b) / c;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">qpow</span>(fr, n);</span><br><span class="line">std::<span class="built_in">swap</span>(fu, fr);</span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">qpow</span>(fu, (c - b - <span class="number">1</span>) / a) * fr * <span class="built_in">AsGcd</span>(c, c - b - <span class="number">1</span>, a, m - <span class="number">1</span>, fu, fr)</span><br><span class="line">* <span class="built_in">qpow</span>(fu, n - ((s128) c * m - b - <span class="number">1</span>) / a);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们需要考虑的就是一个 <code>U</code> 和一个 <code>R</code> 分别产生什么影响。</p><p>一个 <code>U</code> 会使得 <code>cnty ++</code>，而 $cntx$ 不变；一个 <code>R</code> 会使得 <code>cntx ++</code>，<code>ans += cntx</code>，$cnty$ 不变。而一个单位元就是 <code>cntx = cnty = 0</code>（注意我这里是使用 $A, B$ 的多少次方表示的，所以 <code>cntx = 0</code> 表示的是单位矩阵，以此类推）。</p><p>那么 <code>fu = &#123;I, B, 0&#125;, fr = &#123;A, I, A&#125;</code> 表示 <code>U</code> 和 <code>R</code> 分别带来的影响。</p><p>前面照例乘上一个 <code>qpow(fu, b / c)</code>，注意从 1 开始，不需要乘 <code>fr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">Matrix cntx, cnty, ans;</span><br><span class="line">&#125; f0;</span><br><span class="line"></span><br><span class="line">Node <span class="keyword">operator</span> *(Node a, Node b)</span><br><span class="line">&#123;</span><br><span class="line">a.ans += a.cntx * b.ans * a.cnty;</span><br><span class="line">a.cnty = a.cnty * b.cnty, a.cntx = a.cntx * b.cntx;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">qpow</span><span class="params">(Node a, LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(k &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="function">Node <span class="title">res</span><span class="params">(f0)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = a * a)</span><br><span class="line"><span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * a;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">AsGcd</span><span class="params">(LL a, LL b, LL c, LL n, Node fu, Node fr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b %= c;</span><br><span class="line"><span class="keyword">if</span> (a &gt;= c) <span class="keyword">return</span> <span class="built_in">AsGcd</span>(a % c, b, c, n, fu, <span class="built_in">qpow</span>(fu, a / c) * fr);</span><br><span class="line">LL m = ((s128) a * n + b) / c;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">qpow</span>(fr, n);</span><br><span class="line">std::<span class="built_in">swap</span>(fu, fr);</span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">qpow</span>(fu, (c - b - <span class="number">1</span>) / a) * fr * <span class="built_in">AsGcd</span>(c, c - b - <span class="number">1</span>, a, m - <span class="number">1</span>, fu, fr)</span><br><span class="line">* <span class="built_in">qpow</span>(fu, n - ((s128) c * m - b - <span class="number">1</span>) / a);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL a, b, c, l;</span><br><span class="line">std::cin &gt;&gt; a &gt;&gt; c &gt;&gt; b &gt;&gt; l &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) I[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i][j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;B[i][j]);</span><br><span class="line">Node fu&#123;I, B, &#123;&#125;&#125;, fr&#123;A, I, A&#125;;</span><br><span class="line">f0 = &#123;I, I, &#123;&#125;&#125;;</span><br><span class="line"><span class="keyword">auto</span> res = (<span class="built_in">qpow</span>(fu, b / c) * <span class="built_in">AsGcd</span>(a, b, c, l, fu, fr)).ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i, <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, res[i][j]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典的下取整求和，一般不能使用数论分块等（因为被除数不固定）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="万能欧几里得" scheme="https://mydcwfy.github.io/tags/%E4%B8%87%E8%83%BD%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>ARC132F</title>
    <link href="https://mydcwfy.github.io/2022/05/19/ARC132F/"/>
    <id>https://mydcwfy.github.io/2022/05/19/ARC132F/</id>
    <published>2022-05-19T11:40:08.000Z</published>
    <updated>2022-05-19T12:26:16.723Z</updated>
    
    <content type="html"><![CDATA[<p>扩展了集合幂级数的定义，比较有借鉴性。</p><span id="more"></span><p>题意：三个人玩 $k$ 次石头剪刀布，两个人会分别从自己的策略集合中随机选取一个然后按照选的策略出 $k$ 次（每个策略都是长度为 $k$ 的字符串，代表每次出的是什么）。第一个人策略集合大小为 $n$，第二个人策略集合大小为 $m$。第三个人想知道，对于 $3 ^ k$ 种他出的策略，计算他 $k$ 次中至少有一次成为唯一赢家的概率。$k\leq 12, n, m\leq 3 ^ k$，5s。</p><p>容易发现我们当且仅当第一个人和第二个人出的一样，第三个人出的可以赢他们的情况才可能计入答案。</p><p>我们考虑<strong>构造另外一种状态</strong>，记作 0，表示这个人可以随意出。容易发现这个状态是包含 1、2、3 的状态的（分别对应石头剪刀布），那么如果我们使用类似集合幂级数的思想前缀和的话，我们就要将对应 1、2、3 的数贡献到对应位为 0 的数。</p><p><strong>类似集合幂级数定义卷积</strong>，定义一个运算，使得如果两个数不同，这一位就是 0，否则就是相同的那个数。容易发现无需暴力卷积，我们按照上面的方法先前缀和，乘起来，再做逆变换。</p><blockquote><p>做法的正确性：拆位打开看，如果这两个数对应位相同，假设为 $x$，那么这个的贡献不仅会在该位为 0 的地方出现，还会在该位为 $x$ 的地方出现，乘起来后做逆变换，这样 0 位置的贡献就变为了 0。而如果不一样的话，这两个数对应位不同，这样一个出现的位置是 $0, x$，另一个出现的位置是 $0, y$，这样乘起来后，只出现在 0 的位置，于是贡献到了 0。这个可以看作是一个广义的与卷积。</p></blockquote><p>这样，我们可以用 $O(k4 ^ k)$ 的时间得到每个状态的各处。然后考虑如何得到答案。</p><p>经典<strong>至少一个容斥为都不是</strong>，考虑计算这个状态下不能胜的情况。对于这一位为 1 来说，不能胜的情况就是 0、2、3。特别的，这一位为 0 不能胜的情况是 0、1、2、3，即所有。</p><p><strong>还是类似集合幂级数拆位的思想</strong>，拆开每一位分别贡献，仍然可以做到 $O(k4 ^ k)$。</p><p>最后直接判断这一个状态是不是切实存在的（即所有位都不是 0），输出即可。</p><p>注意编号的问题，我们可以先将编号设为 1-石头，2-剪刀，3-布（原来是 1-布，2-石头，3-剪刀），这样就是计算三个人相同的问题了，直接按序输出即可。时间复杂度 $O(k4 ^ k)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trs</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; <span class="keyword">return</span> c == <span class="string">&#x27;P&#x27;</span> ? <span class="number">3</span> : (c == <span class="string">&#x27;R&#x27;</span> ? <span class="number">1</span> : <span class="number">2</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FMT</span><span class="params">(T *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k + k; j += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; (k + k)); ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">3</span>) a[i &amp; ~(<span class="number">3</span> &lt;&lt; j)] += a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IFMT</span><span class="params">(T *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k + k; j += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; (k + k)); ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">3</span>) a[i &amp; ~(<span class="number">3</span> &lt;&lt; j)] -= a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; k &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tmp + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i)</span><br><span class="line">s = (s &lt;&lt; <span class="number">2</span>) | <span class="built_in">trs</span>(tmp[i]);</span><br><span class="line">A[s] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tmp + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i)</span><br><span class="line">s = (s &lt;&lt; <span class="number">2</span>) | <span class="built_in">trs</span>(tmp[i]);</span><br><span class="line">B[s] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">FMT</span>(A), <span class="built_in">FMT</span>(B);</span><br><span class="line"><span class="comment">// for (int i = 0; i &lt; (1 &lt;&lt; (k + k)); ++ i) printf(&quot;%d %d\n&quot;, A[i], B[i]);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; (k + k)); ++ i) C[i] = (LL) A[i] * B[i];</span><br><span class="line"><span class="built_in">IFMT</span>(C);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (k + k); j += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; (k + k)); ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">LL sum = C[i] + C[i | (<span class="number">1</span> &lt;&lt; j)] + C[i | (<span class="number">2</span> &lt;&lt; j)] + C[i | (<span class="number">3</span> &lt;&lt; j)];</span><br><span class="line">C[i] = sum;</span><br><span class="line">C[i | (<span class="number">1</span> &lt;&lt; j)] = sum - C[i | (<span class="number">1</span> &lt;&lt; j)];</span><br><span class="line">C[i | (<span class="number">2</span> &lt;&lt; j)] = sum - C[i | (<span class="number">2</span> &lt;&lt; j)];</span><br><span class="line">C[i | (<span class="number">3</span> &lt;&lt; j)] = sum - C[i | (<span class="number">3</span> &lt;&lt; j)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; (k + k)); ++ s) &#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (k + k) &amp;&amp; flag; i += <span class="number">2</span>)</span><br><span class="line">flag &amp;= !!(s &gt;&gt; i &amp; <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (LL) n * m - C[s]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;扩展了集合幂级数的定义，比较有借鉴性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="集合幂级数" scheme="https://mydcwfy.github.io/tags/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>ARC Round#132</title>
    <link href="https://mydcwfy.github.io/2022/05/19/ARC-Round-132/"/>
    <id>https://mydcwfy.github.io/2022/05/19/ARC-Round-132/</id>
    <published>2022-05-19T09:22:52.000Z</published>
    <updated>2022-05-19T12:26:59.093Z</updated>
    
    <content type="html"><![CDATA[<p>vp 的时候降智了，简单的 D 题没做出来，被吊锤了。</p><p>赛时进度：ABC Accepted，Score：1400，Penalty：83：02。</p><p>改题进度：ABCDF Accepted。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定 $n\times n$ 的矩阵，已知每行有 $r_i$ 个 1，每列有 $c_i$ 个 1，且 $r, c$ 均为排列。$q$ 次询问某个点是否是 1。$n, m\leq 10 ^ 5$。</p><p>如果我们需要构造的话，那么 $r_i = n, c_j = n$ 的行列是可以全部赋值为 1 的，然后 $r_i = 1, c_j = 1$ 的行列除了已赋值的全部赋值为 0，然后 $r_i = n - 1, c_j = n - 1$……</p><p>这样行列相当于是一个要将他赋值为 1，一个需要将他赋值为 0，就看谁的优先级高。假设询问 $(x, y), r_x &gt; c_y$，容易发现行的优先级可以用 $n - r_x$，列的优先级可以用 $c_y$，这样行的优先级小于等于列的优先级那么就是 1，否则是 0。</p><p>整理一下，就是 $n - r_x\leq c_y$，即 $r_x + c_y\geq n$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Q --) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">int</span> mn = std::<span class="built_in">min</span>(a[x], b[y]), mx = std::<span class="built_in">max</span>(a[x], b[y]);</span><br><span class="line"><span class="keyword">if</span> (mn - <span class="number">1</span> &lt; n - mx) <span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定一个排列 $p_{1, \dots, n}$，每次可以将第一个数移到最后，或是反转整个数列，问至少多少次才能变为 $1, 2, \dots, n$。给出的排列保证可以变为 $1, 2, \dots, n$。$n\leq 10 ^ 5$。</p><p>如果将原序列看作是一个环的话，那么环的本质没有变，这样序列一定就是 $x, x - 1, \dots, 1, n, n - 1, \dots, x + 1$ 或者是 $x, x + 1, \dots, n, 1, 2, \dots, x - 1$。</p><p>下面用 $pos$ 表示 1 的位置。</p><p>对于第一种情况，我们必须翻转，如果最开始就翻转的话，那么答案就是 $n - pos + 1$，如果是最后翻转的话，答案就是 $(n - pos) + 1$，二者取 $\min$ 即可。</p><p>对于第二种情况，我们可以不翻转，答案就是 $pos - 1$，也可以翻转两次（一次最先，一次最后），答案就是先到 $(n - pos + 1) + 2$，二者取 $\min$ 即可。可以自己手玩一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, p + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) nw[p[i]] = i;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (p[(i + n - <span class="number">2</span>) % n + <span class="number">1</span>] != <span class="number">1</span> &amp;&amp; p[i] != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!~flag) flag = p[i] &gt; p[(i + n - <span class="number">2</span>) % n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">assert</span>(flag == (p[i] &gt; p[(i + n - <span class="number">2</span>) % n + <span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; flag &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, std::<span class="built_in">min</span>(nw[<span class="number">1</span>] - <span class="number">1</span>, <span class="number">3</span> + n - nw[<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, std::<span class="built_in">min</span>(n - nw[<span class="number">1</span>] + <span class="number">1</span>, nw[<span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定 $n, d$，求满足 $|p_i - i|\leq d$ 的排列的数量，某些 $p_i$ 确定，未确定用 -1 表示。$n\leq 500, d\leq 5$。</p><p><strong>排列的 DP 一般有两种：第一种是按顺序填入，哪个位置填 $n$，哪个位置填 $n - 1$，类推。还有一种是先将前 $i$个构成排列，然后枚举 $i + 1$ 的数 $x$，将前面原来 $\geq x$ 的数加 1</strong>。</p><p>如果方向选的是第二种的话，这道题就不好做，因为你需要维护前 5 个的数分别是什么，这样才能判断 +1 后是否合法。</p><p>而用第一种就体现出优势了：我们只需要维护和这个数距离不超过 5 的位置是否已经有数即可。这样就很好做了，时间复杂度 $O(nd2 ^ {2d})$，可以通过。</p><p>代码有些繁琐，有一点难写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (~a[i]) nw[a[i]] = i;</span><br><span class="line"><span class="keyword">int</span> sta = <span class="number">0</span>, lim = d &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; ++ j)</span><br><span class="line"><span class="keyword">if</span> (j &gt; d || ~a[n + j - d]) sta |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">f[n + <span class="number">1</span>][sta] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &gt; <span class="number">1</span>; -- i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; lim); ++ s) &#123;</span><br><span class="line"><span class="keyword">if</span> (!f[i][s]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> cur = f[i][s];</span><br><span class="line"><span class="comment">// printf(&quot;%d %d %d\n&quot;, i, s, cur);</span></span><br><span class="line"><span class="keyword">if</span> (nw[i - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> to = nw[i - <span class="number">1</span>] - i + <span class="number">2</span> + d;</span><br><span class="line"><span class="keyword">int</span> &amp;trs = f[i - <span class="number">1</span>][((s &lt;&lt; <span class="number">1</span>) | (<span class="number">1</span> &lt;&lt; to) | (i &lt;= d + <span class="number">2</span> || ~a[i - d - <span class="number">2</span>])) &amp; ((<span class="number">1</span> &lt;&lt; lim) - <span class="number">1</span>)];</span><br><span class="line"><span class="built_in">adj</span>(trs += cur - Mod);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nxt = <span class="number">0</span>; nxt &lt; lim; ++ nxt) &#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;&gt; nxt &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// printf(&quot;Trs %d\n&quot;, nxt);</span></span><br><span class="line"><span class="keyword">int</span> &amp;trs = f[i - <span class="number">1</span>][((s &lt;&lt; <span class="number">1</span>) | (<span class="number">1</span> &lt;&lt; (nxt + <span class="number">1</span>)) | (i &lt;= d + <span class="number">2</span> || ~a[i - d - <span class="number">2</span>])) &amp; ((<span class="number">1</span> &lt;&lt; lim) - <span class="number">1</span>)];</span><br><span class="line"><span class="built_in">adj</span>(trs += cur - Mod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; f[<span class="number">1</span>][(<span class="number">1</span> &lt;&lt; lim) - <span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定两个长度相同、1 个数相同的串 $s, t$，定义 $d(s, t)$ 为最少邻项交换的次数。定义一个字符串的权值为相邻字符相同的个数。求所有满足 $d(s, t) = d(s,u) + d(u, t)$ 中 $u$ 的最大权值。$|s|\leq 3\times 10 ^ 5$。</p><p>sb 贪心题。</p><p>容易发现 $u$ 的第 $i$ 个 1 一定在 $s$ 的第 $i$ 个 1 和 $t$ 的第 $i$ 个 1 之间。那么我们如果前面已经填好了，新加入一个字符我们就可以判断新的是否合法。注意还需要判断 0 是否合法，即 $u$ 的 0 在 $s$ 对应的 0 和 $t$ 对应的 0 之间。</p><p>剩下的直接贪心，考虑如果能和前一个相同就填相同的，否则就填不同的。注意第一个位置无法填入，随便枚举一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> valid = [&amp;](<span class="keyword">int</span> pos, <span class="keyword">int</span> x) &#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; std::<span class="built_in">min</span>(cnta[pos], cntb[pos]) || x &gt; std::<span class="built_in">max</span>(cnta[pos], cntb[pos]))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> x + (n + m - pos) &gt;= cnta[n + m] &amp;&amp; x &lt;= cnta[n + m];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] != st + <span class="string">&#x27;0&#x27;</span> &amp;&amp; b[<span class="number">1</span>] != st + <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = st, ls = st, res = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// printf(&quot;Solve %d\n&quot;, st);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n + m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// printf(&quot;%d %d %d\n&quot;, cnt, cnta[i - 1], cntb[i - 1]);</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">valid</span>(i, cnt + ls)) cnt += ls, res ++;</span><br><span class="line"><span class="keyword">else</span> cnt += !ls, ls = !ls;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// printf(&quot;%d %d %d\n&quot;, cnt, cnta[n + m], cntb[n + m]);</span></span><br><span class="line"><span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; (a + <span class="number">1</span>) &gt;&gt; (b + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; ++ i) cnta[i] = cnta[i - <span class="number">1</span>] + (a[i] ^ <span class="number">48</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; ++ i) cntb[i] = cntb[i - <span class="number">1</span>] + (b[i] ^ <span class="number">48</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, std::<span class="built_in">max</span>(<span class="built_in">solve</span>(<span class="number">0</span>), <span class="built_in">solve</span>(<span class="number">1</span>)));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>见 <a href="/2022/05/19/ARC132F">ARC132F</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;vp 的时候降智了，简单的 D 题没做出来，被吊锤了。&lt;/p&gt;
&lt;p&gt;赛时进度：ABC Accepted，Score：1400，Penalty：83：02。&lt;/p&gt;
&lt;p&gt;改题进度：ABCDF Accepted。&lt;/p&gt;</summary>
    
    
    
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>ARC Round#140</title>
    <link href="https://mydcwfy.github.io/2022/05/17/ARC-Round-140/"/>
    <id>https://mydcwfy.github.io/2022/05/17/ARC-Round-140/</id>
    <published>2022-05-17T06:13:30.000Z</published>
    <updated>2022-05-17T07:33:38.498Z</updated>
    
    <content type="html"><![CDATA[<p>赛时没做出来 D，结果似乎比较简单……</p><p>赛时进度：ABC Accepted，Penalty：59：56，Rank：291，Rating：1995 -&gt; 2006。</p><p>改题进度：ABCDE Accepted。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定字符串 $S$，可以修改其中的 $k$ 个字符，问可以得到的最小循环节。$|S|\leq 2000$。</p><p>直接暴力枚举循环节是否合法，这样每一个对应的位置需要变成一个字符，统计众数出现次数即可。计算众数的时候可以做到线性。</p><p>由于循环节最多只有 $O(\sqrt n)$ 种，所以得到时间复杂度 $O(n\sqrt n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = st; i &lt;= n; i += d) <span class="built_in">chkmax</span>(res, ++ cnt[s[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = st; i &lt;= n; i += d) -- cnt[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="comment">// printf(&quot;%d %d %d\n&quot;, st, d, res);</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (n % i) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> res = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++ j) res -= <span class="built_in">solve</span>(j, i);</span><br><span class="line"><span class="keyword">if</span> (res &lt;= k) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定只有 A、R、C 的字符串，奇数次操作可以 <code>ARC -&gt; R</code>，偶数次操作可以 <code>ARC -&gt; AC</code>，问最多可以进行的操作次数。$|S|\leq 2\times 10 ^ 5$。</p><p>容易发现我们每一段是独立的，因为 <code>ARC -&gt; AC</code> 后两边都不能再合并，只有 <code>AA...ARC...CC</code> 可以通过只有奇数次变换可以得到 <code>ARC</code>，最后一次任选。</p><p>这样我们可以将原串的有用部分压缩为 <code>AA...ARC...CC</code> 中 $\min\{len_A, len_C\}$，容易发现这一定是可以的，多出来的部分是无法操作的。</p><p>这样奇数操作就是对数列中的一个非零数 -1，偶数操作就是将一个非零数变为 0。问最多多少次操作。</p><p>这其实是可以贪心的：我每次将尽量靠近 1 又不是 1 的一个数用奇数操作，直到他变成 1，这样偶数操作删除这个数的时候代价是最小的。我赛时的代码就是这个。</p><p>考虑两个上界：</p><ol><li>偶数次操作最多只有 <code>ARC</code>出现的次数，因为一个偶数次一定会消耗一个 <code>ARC</code> 而不会再次出现。</li><li>总操作最多只有压缩后数列的和，因为操作一次，至少会减 1。</li></ol><p>从偶数操作容易推出所有操作的一个上界：$2\times cnt$（不可能最后一次是一个奇数操作，因为这样的话，我们预估的 $cnt$ 就可以 +1</p><p>直接取 $\min$ 即可。代码是贪心，时间复杂度 $O(n\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] ^ <span class="string">&#x27;R&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &gt; len &amp;&amp; i + len &lt;= n &amp;&amp; s[i - len] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i + len] == <span class="string">&#x27;C&#x27;</span>) len ++;</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">2</span>) al.<span class="built_in">push_back</span>(len - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> cnt += len == <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(al.<span class="built_in">begin</span>(), al.<span class="built_in">end</span>());</span><br><span class="line">sz = al.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">++ ans;</span><br><span class="line"><span class="keyword">if</span> (ans &amp; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; sz &amp;&amp; al[i] &lt;= <span class="number">1</span>) ++ i;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= sz) <span class="keyword">break</span>;</span><br><span class="line">al[i] --;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (cnt) &#123;</span><br><span class="line">-- cnt;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= sz) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">al[j ++] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">-- ans;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : al) <span class="built_in">assert</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= <span class="number">1</span>), cur += x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans + cur + cnt);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定 $n, x$，要求构造长度为 $n$ 的排列 $p$ 使得 $p_1 = x$ 且 $a_i = |p_i - p_{i + 1}|$ 序列的最长严格上升子序列最大。</p><p>首先，如果不管 $p_1$ 的话，我们有一个最长上升字符列为 $n - 2$ 的答案。如果 $n$ 是偶数，我们构造即为 $\{\dfrac n2, \dfrac n2 + 1, \dfrac n2 - 1, \dfrac n2 + 2\dots\}$ 或 $\{\dfrac n2 + 1, \dfrac n2, \dfrac n2 + 2, \dfrac n2 - 1\dots\}$，相邻两个差是 $\{1, 2, \dots\}$，这达到了上界。如果是奇数，构造即为 $\{\dfrac{n + 1}2, \dfrac{n + 1}2 + 1, \dfrac{n + 1}2 - 1, \dfrac{n + 1}2 + 2\dots \}$ ，容易证明这个也是达到了上界的。</p><p>现在考虑加入 $p_1 = x$。第一种方案是我们不管 $p_1$，后面原来 $\geq x$ 的加 1 即可。第二种方案是我们先将 $p_1$ 按照上面的构造尽可能摆放，剩下的随便摆。容易发现如果 $x$ 不是上面最优情况的开头，第二个一定不优。</p><p>剩下的随便分类讨论即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span> &amp;&amp; x == (n + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = (n + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>, k = (n + <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &amp; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, k ++);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, j --);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(n &amp; <span class="number">1</span>) &amp;&amp; x == n / <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = n / <span class="number">2</span> + <span class="number">1</span>, k = n / <span class="number">2</span> - <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, j ++);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, k --);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(n &amp; <span class="number">1</span>) &amp;&amp; x == n / <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = n / <span class="number">2</span> + <span class="number">2</span>, k = n / <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &amp; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, j ++);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, k --);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = n / <span class="number">2</span> + <span class="number">1</span>, k = n / <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &amp; <span class="number">1</span>) p[i] = j ++;</span><br><span class="line"><span class="keyword">else</span> p[i] = k --;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = n / <span class="number">2</span> + <span class="number">1</span>, k = n / <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) p[i] = k --;</span><br><span class="line"><span class="keyword">else</span> p[i] = j ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i] + (p[i] &gt;= x));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定一个无向图，$i$ 会和 $x_i$ 连边，有些 $x_i$ 未定，问所有可能的 $x_i$ 无向图连通块个数之和。$n\leq 2000$。</p><p>观察 1：容易发现确定 $x_i$ 后的图一定是基环树森林，连通块的个数就是环的个数（包括自环）</p><p>观察 2：还没有形成基环树的连通块一定是树，每棵树中 $x_i$ 不确定的点有且只有 1 个。</p><p>观察 3：一旦形成了环，这个连通块的贡献就固定了，和其他的有没有联通过来没有关系（因为统计的是环的数量）</p><p>有了上面的发现，其实就比较好做了。</p><p>首先如果我们确定了 $k$ 棵树，总共有 $cnt$ 个点 $x_i$ 未确定，每棵的大小为 $a_i$，互相连接，并形成了环，那么对应的贡献应该是<br>$$<br>(k - 1)!n ^ {cnt - k} \prod_{i = 1} ^ k a_i<br>$$<br>发现答案和 $k$ 和 $\prod$ 有关，那么直接考虑 DP，即目前个数为 $k$ 的所有树的组合的乘积和。直接 $O(n ^ 2)$ 转移即可。</p><p>对于原来就是基环树的，我们已经形成了环，不参加 DP，直接贡献为 $n ^ {cnt}$。加和即可，时间复杂度 $O(n ^ 2)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[x] = <span class="number">1</span>, sz ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (v ^ fa) &#123;</span><br><span class="line"><span class="keyword">if</span> (vis[v]) &#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(v, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line">fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) fact[i] = (LL) fact[i - <span class="number">1</span>] * i % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!~a[i]) <span class="keyword">continue</span>;</span><br><span class="line">g[a[i]].<span class="built_in">pb</span>(i), g[i].<span class="built_in">pb</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> excnt = <span class="number">0</span>, res = <span class="number">0</span>, mul;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) excnt += !~a[i];</span><br><span class="line">mul = <span class="built_in">qpow</span>(n, excnt);</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vad;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">sz = <span class="number">0</span>, flag = <span class="number">0</span>, <span class="built_in">dfs</span>(i);</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="built_in">adj</span>(res += mul - Mod);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">vad.<span class="built_in">pb</span>(sz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt = vad.<span class="built_in">size</span>();</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : vad)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = cnt - <span class="number">1</span>; ~j; -- j)</span><br><span class="line"><span class="keyword">if</span> (f[j]) f[j + <span class="number">1</span>] = (f[j + <span class="number">1</span>] + (LL) f[j] * x) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line"><span class="keyword">if</span> (f[i]) res = (res + (LL) f[i] * <span class="built_in">qpow</span>(n, cnt - i) % Mod * fact[i - <span class="number">1</span>]) % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：构造 $n\times m$ 的网格，每个数在 $[1, 25]$，要求 $\forall x_1, x_2\in [1, n], y_1, y_2\in [1, m]$，$a_{x_1, y_1}, a_{x_1, y_2}, a_{x_2, y_1}, a_{x_2, y_2}$ 不全相等。$n, m\leq 500$。</p><p>不是很好构造，虽然代码不超过 20 行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i, <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ((i / B) * (j / B) + i + j) % B + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到 $25$ 和 $\sqrt n$ 同级，果断分块。</p><p>暂定为 $\sqrt n\times \sqrt n$ 的分块，那么需要考虑块内和块间的不同情况。</p><p>块内的话，需要我们每两个相同的数字得不在一行一列，否则同行 / 列的块内可能会出现对应的情况导致不合法。</p><p>既然不在一行一列，这要求我们需要每行每列都是排列，这样的话，我们按照如下构造即可：<br>$$<br>\begin{bmatrix}<br>1&amp; 2&amp; 3&amp; \dots&amp; 22&amp; 23\\<br>2&amp; 3&amp; 4&amp; \dots&amp; 23&amp; 1\\<br>3&amp; 4&amp; 5&amp; \dots&amp; 1&amp; 2\\<br>\dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots\\<br>23&amp; 1&amp; 2&amp; \dots&amp; 21&amp; 22<br>\end{bmatrix}<br>$$<br>那么块间像块内一样是否合法呢？、</p><p>首先看 $B = 3, n = m = 9$ 的示范样例输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3 1 2 1 2 3 2 3 1 </span><br><span class="line">1 2 3 2 3 1 3 1 2 </span><br><span class="line">2 3 1 3 1 2 1 2 3 </span><br><span class="line">1 2 3 2 3 1 3 1 2 </span><br><span class="line">2 3 1 3 1 2 1 2 3 </span><br><span class="line">3 1 2 1 2 3 2 3 1 </span><br><span class="line">2 3 1 3 1 2 1 2 3 </span><br><span class="line">3 1 2 1 2 3 2 3 1 </span><br><span class="line">1 2 3 2 3 1 3 1 2 </span><br></pre></td></tr></table></figure><p>容易发现第 4 行和第 2 行是一样的，是怎么回事呢？</p><p>我们发现，当第 1 行变为第 4 行的时候，我们将 <code>1 2 3</code> 的排列变成了 <code>2 3 1</code>，变为第 2 行的时候也是这样，导致第 2 行的输出和第 4 行完全相同。</p><p>这启示我们需要找到另外的方式，使得不会产生不合法情况。</p><p>给出结论：使用块行编号和纵编号的乘积。</p><p>手玩一下发现是不会冲突的。于是就是上面的那个代码（别问我是怎么<del>看题解</del>想到的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;赛时没做出来 D，结果似乎比较简单……&lt;/p&gt;
&lt;p&gt;赛时进度：ABC Accepted，Penalty：59：56，Rank：291，Rating：1995 -&amp;gt; 2006。&lt;/p&gt;
&lt;p&gt;改题进度：ABCDE Accepted。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>CF Round#791</title>
    <link href="https://mydcwfy.github.io/2022/05/15/CF-Round-791/"/>
    <id>https://mydcwfy.github.io/2022/05/15/CF-Round-791/</id>
    <published>2022-05-15T07:42:13.000Z</published>
    <updated>2022-05-16T06:54:26.088Z</updated>
    
    <content type="html"><![CDATA[<p>A 吃了发罚时……</p><p>赛时进度：ABCDE Accepted，Score：6025，Rank：7，Rating：1987 -&gt; 2189。</p><p>改题进度：All Accepted。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定 $n$，拆分成 4 和 6，问最多有多少个 4、最多有多少个 6，或报告无解。</p><p>容易发现 $n$ 是奇数或 $n = 2$ 的时候显然无解。剩下的按余数那么随便分讨一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">if</span> ((n &amp; <span class="number">1</span>) || n &lt; <span class="number">4</span>) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">6</span> == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, n / <span class="number">6</span> + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, (n + <span class="number">2</span>) / <span class="number">6</span>);</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">4</span> == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, n / <span class="number">4</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, n / <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定一个序列 $n$ 和 $q$ 次操作，单点修改或是整体赋值。问操作后的和。$n\leq 2\times 10 ^ 5, q\leq 2\times 10 ^ 5$。</p><p>给出线性做法。</p><p>考虑每个数最后被覆盖 / 单点修改的时间，如果单点修改的时间晚于整体赋值的时间，那么就是 $a_i$，否则值就是最后的 $cov$。用增量法维护和即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) sum += a[i];</span><br><span class="line"><span class="keyword">int</span> pos, x, op;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cs = <span class="number">1</span>; cs &lt;= Q; ++ cs) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;pos, &amp;x);</span><br><span class="line"><span class="keyword">if</span> (t[pos] &lt; ct) sum += x - cov;</span><br><span class="line"><span class="keyword">else</span> sum += x - a[pos];</span><br><span class="line">t[pos] = cs, a[pos] = x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">sum = (LL) n * x;</span><br><span class="line">cov = x, ct = cs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>给出 $n\times n$ 的方格，有些位置有关键点，$q$ 次操作，设立关键点，删除关键点，询问一个子矩阵所有的格子都被关键点所覆盖。覆盖是将一行 / 一列的点覆盖。$n, q\leq 2\times 10 ^ 5$。</p><p>考虑结论：想要覆盖一个子矩阵，当且仅当所有行 / 所有列都被覆盖。</p><p>于是我们可以将 行 / 列 分开，分别判断 行 / 列 是否分别合法，一个合法就都可以了。</p><p>于是随便使用树状数组判断区间是否合法即可。具体的，如果覆盖的时候这个位置覆盖次数为 0，就在这个位置 +1；如果删除后这个位置覆盖次数为 0，就在这个位置 -1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, Q, t, x, y, sx, sy;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; Q;</span><br><span class="line"><span class="keyword">while</span> (Q --) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;t, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">if</span> (t == <span class="number">1</span>) row.<span class="built_in">add</span>(x, !r[x] ++), col.<span class="built_in">add</span>(y, !c[y] ++);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">2</span>) row.<span class="built_in">add</span>(x, -(!-- r[x])), col.<span class="built_in">add</span>(y, -(!-- c[y]));</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;sx, &amp;sy);</span><br><span class="line"><span class="built_in">puts</span>((row.<span class="built_in">ask</span>(sx) - row.<span class="built_in">ask</span>(x - <span class="number">1</span>)) == sx - x + <span class="number">1</span> || (col.<span class="built_in">ask</span>(sy) - col.<span class="built_in">ask</span>(y - <span class="number">1</span>)) == sy - y + <span class="number">1</span> ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>给出 $n$ 个点 $m$ 条边的有向图，点带权，任选点数为 $k$ 的路径使得最大点权最小。$n, m\leq 2\times 10 ^ 5, k\leq 10 ^ {18}$。</p><p>最大最小，果断二分。</p><p>二分后，有一些点不再能走，那么转化为了在现有图上走出 $k$ 个点。</p><p>首先容易发现如果有环的话，那么任意 $k$ 都是可以的。对于剩下的情况，直接拓扑排序做一下最长路径即可。拓扑排序的时候可以同时判断有没有环。判断时间复杂度线性。</p><p>总复杂度 $O((n + m)\log a)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) deg[i] = d[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[x] &gt; mid) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (a[v] &lt;= mid) deg[v] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!deg[i] &amp;&amp; a[i] &lt;= mid) q.<span class="built_in">push</span>(i), d[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (a[v] &lt;= mid) &#123;</span><br><span class="line"><span class="built_in">chkmax</span>(d[v], d[x] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!-- deg[v]) q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (deg[i] || d[i] &gt;= k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++ i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">g[u].<span class="built_in">pb</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">check</span>(<span class="number">1e9</span> + <span class="number">10</span>)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; l &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：给定长度为 $n$ 的字符串，满足每一个都属于 $\{a, b, c\dots, p, q\}$ 17 个字符，有一些待填，用 <code>?</code> 表示，$q$ 次给定可以将 <code>?</code> 变成的字符的集合，问所有填法回文串个数的和。$n\leq 1000, q\leq 2\times 10 ^ 5$。</p><p>容易发现 $n\leq 1000$，我们可以考虑枚举出所有可能的回文串，然后判断是否可能变为回文串。注意我们需要增量枚举，否则是 $O(n ^ 3)$ 的。</p><p>考虑现在新加入的两边字符：</p><ol><li>两边都是 <code>?</code>，这样答案就乘上 $|\sum|$。这样我们还需要枚举 $\sum$ 的大小贡献答案。</li><li>有一边是 <code>?</code>，这样字符集中需要有另一边的字符。</li><li>两边都不是 <code>?</code>，这样需要两边字符一样，否则直接停止。</li></ol><p>此外，其他的 <code>?</code> 可以随便选，那么我们需要给出随意选的个数。容易发现贡献和 $|\sum|$ 有关，所以再枚举 $|\sum|$，这样我们需要在包含当前需要的字符集的字符集位置加上 $cnt ^ {|\sum|}$。这个可以使用 FMT 简单的实现。于是总时间复杂度 $O(|\sum| ^ 22 ^ {|\sum|} + n ^ 2|\sum|)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">17</span>; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pw[j][<span class="number">0</span>] = <span class="number">1</span>; i &lt;= n; ++ i) pw[j][i] = (LL) pw[j][i - <span class="number">1</span>] * j % Mod;</span><br><span class="line"><span class="keyword">int</span> totcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) totcnt += str[i] == <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt;= n; ++ mid) &#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>, sta = <span class="number">0</span>, cnt = <span class="number">0</span>, excnt = totcnt;</span><br><span class="line"><span class="keyword">while</span> (mid &gt; len &amp;&amp; mid + len &lt;= n) &#123;</span><br><span class="line"><span class="keyword">int</span> i = mid - len, j = mid + len;</span><br><span class="line"><span class="keyword">if</span> (str[i] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; str[j] != <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] != str[j]) <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;?&#x27;</span> &amp;&amp; str[j] == <span class="string">&#x27;?&#x27;</span>) cnt ++;</span><br><span class="line"><span class="keyword">else</span> sta |= <span class="number">1</span> &lt;&lt; ((str[i] == <span class="string">&#x27;?&#x27;</span> ? str[j] : str[i]) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">excnt -= (str[i] == <span class="string">&#x27;?&#x27;</span>) + (str[j] == <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (i == j &amp;&amp; str[i] == <span class="string">&#x27;?&#x27;</span>) excnt ++;</span><br><span class="line"><span class="comment">// printf(&quot;1 : %d %d %d %d\n&quot;, mid, len, cnt, sta);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">17</span>; ++ j) <span class="built_in">adj</span>(ans[j][sta] += pw[j][cnt + excnt] - Mod);</span><br><span class="line">len ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt;= n; ++ mid) &#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">1</span>, sta = <span class="number">0</span>, cnt = <span class="number">0</span>, excnt = totcnt;</span><br><span class="line"><span class="keyword">while</span> (mid &gt;= len &amp;&amp; mid + len &lt;= n) &#123;</span><br><span class="line"><span class="keyword">int</span> i = mid - len + <span class="number">1</span>, j = mid + len;</span><br><span class="line"><span class="keyword">if</span> (str[i] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; str[j] != <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] != str[j]) <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;?&#x27;</span> &amp;&amp; str[j] == <span class="string">&#x27;?&#x27;</span>) cnt ++;</span><br><span class="line"><span class="keyword">else</span> sta |= <span class="number">1</span> &lt;&lt; ((str[i] == <span class="string">&#x27;?&#x27;</span> ? str[j] : str[i]) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">// printf(&quot;2 : %d %d %d %d\n&quot;, mid, len, cnt, sta);</span></span><br><span class="line">excnt -= (str[i] == <span class="string">&#x27;?&#x27;</span>) + (str[j] == <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">17</span>; ++ j) <span class="built_in">adj</span>(ans[j][sta] += pw[j][cnt + excnt] - Mod);</span><br><span class="line">len ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">17</span>; ++ j) <span class="built_in">FMT</span>(ans[j]);</span><br><span class="line">std::cin &gt;&gt; Q;</span><br><span class="line"><span class="keyword">while</span> (Q --) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tmp + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> sta = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; tmp[j]; ++ j) sta |= <span class="number">1</span> &lt;&lt; (tmp[j] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[<span class="built_in">popcount</span>(sta)][sta]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：给定长度为 $n$ 仅包含 $0\sim 9$ 的字符串相同，给定 $m$ 个交换，相邻两个出现在里面时可以交换。如果两个字符串可以互相交换得到，则称两个字符串相同。问本质不同的字符串有多少个。$n\leq 50000$。</p><p>首先我们定义代表元为本质相同的字符串中字典序最小的。这样，如果我们存在满足中间某些位是 $(d_1, d_2, d_3\dots, d_k)$ 并且 $(d_i, d_{i + 1})$ 中间可以交换，$d_1 &gt; d_k$，那么这个字符串就不是最小的。记录前面可以互相交换的 $d_1,\dots,  d_k$，如果存在一个 $d$ 满足 $d &gt; nxt$ 并且 $nxt$ 中可以有转移 $(d, nxt)$，那么加入 $nxt$ 之后就不是最小的了。（注意前面的都可以放到 $d_k$ 这个位置来和 $nxt$ 交换，如果存在 $d &gt; nxt$，可以将 $nxt$ 交换到 $d_k$ 的位置，$d$ 交换到 $nxt$ 的位置，就不是最小的</p><p>注意到我们只需要哪些元素出现没有，并不需要出现的次数及顺序。于是直接状压，将 $sta$ 记作前面 $d_1\dots, d_k$ 的并集。转移的时候观察存在 $(nxt, d)$ 且 $nxt &lt; d$ 的 $nxt$ 无法转移，其余均可。转移到的就是 $sta$ 中能和 $nxt$ 交换的数和 $nxt$ 本身。判断大于的有没有记录一下大于 $nxt$ 的所有转移，压一下状态即可。</p><p>时间复杂度 $O(n|\sum|2 ^ {|\sum|})$，可以通过。</p><p><strong>注意寻找代表元的做法统计本质不同个数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">std::cin &gt;&gt; u &gt;&gt; v;<span class="comment">// assert(u &lt; v);</span></span><br><span class="line">A[u] |= <span class="number">1</span> &lt;&lt; v, B[u] |= <span class="number">1</span> &lt;&lt; v, A[v] |= <span class="number">1</span> &lt;&lt; u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i) f[<span class="number">1</span>][<span class="number">1</span> &lt;&lt; i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; S; ++ s) f[i &amp; <span class="number">1</span>][s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>, cur; s &lt; S; ++ s) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(cur = f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][s])) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nxt = <span class="number">0</span>; nxt &lt; <span class="number">10</span>; ++ nxt)</span><br><span class="line"><span class="keyword">if</span> (!(B[nxt] &amp; s)) <span class="built_in">adj</span>(f[i &amp; <span class="number">1</span>][(A[nxt] &amp; s) | (<span class="number">1</span> &lt;&lt; nxt)] += cur - Mod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; ++ i) <span class="built_in">adj</span>(res += f[n &amp; <span class="number">1</span>][i] - Mod);</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;A 吃了发罚时……&lt;/p&gt;
&lt;p&gt;赛时进度：ABCDE Accepted，Score：6025，Rank：7，Rating：1987 -&amp;gt; 2189。&lt;/p&gt;
&lt;p&gt;改题进度：All Accepted。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="集合幂级数" scheme="https://mydcwfy.github.io/tags/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"/>
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
