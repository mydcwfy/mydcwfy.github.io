<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mydcwfy&#39;s Blog</title>
  
  
  <link href="https://mydcwfy.github.io/atom.xml" rel="self"/>
  
  <link href="https://mydcwfy.github.io/"/>
  <updated>2022-10-31T05:38:12.048Z</updated>
  <id>https://mydcwfy.github.io/</id>
  
  <author>
    <name>mydcwfy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSP-S 2022 游记</title>
    <link href="https://mydcwfy.github.io/2022/10/30/CSP-S-2022/"/>
    <id>https://mydcwfy.github.io/2022/10/30/CSP-S-2022/</id>
    <published>2022-10-30T14:13:36.000Z</published>
    <updated>2022-10-31T05:38:12.048Z</updated>
    
    <content type="html"><![CDATA[<p>中规中矩的一场……</p><span id="more"></span><h3 id="Day-inf"><a href="#Day-inf" class="headerlink" title="Day -inf"></a>Day -inf</h3><p>初赛 92，过了。为啥错的全是排序的题啊，看来排序得重修了！</p><p>报上名了，结果缴费就遇上服务器更新，还以为钱被吞了……</p><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>回顾整个 CSP 的备战过程，感觉很多事情都没有做到位，比如认真改题，总结并复习之类的，一天陷入了 做题 - 摆烂 - 讲题或听讲 的死循环了。特别是考前的几天又加入了同学互相展示讲课的过程，直接将整个一天填的满满当当，这直接导致我 AT 和 CF 在 10.21 过后除了 CF 10.23 的比赛外再没有提交，感觉降智严重，于是有预感 CSP 要寄。另外打 CF 连 *2000 都无法下手了，要是我拿这小于 2000 的水准考 CSP，显然会寄 /ll</p><p>但是不知怎么的，又没有感到紧张，反而一天颓得严重。这是怎么回事呢？我也不清楚，有一种说不出来的感觉。</p><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>2：30 在本校考试为啥要 1：30 就到啊！</p><p>发呆了一会看到 dottle 来了，又闲聊了一会。他们也是人渐稀疏啊，高二的似乎只有 2 个，去年 NOIp 可是我们考场 1-7 的座位都是他们学校的呢。</p><p>进去了就也是什么都做不了，连聊天的时间都没有了，所以为啥这么多人 2 点就进考场啊！</p><p>看到下发文件和密码 <code>belief2022</code>，但想起我省选的经历，这次坚决不先动键盘，坐等 2：30，应该不差这几分钟吧（flag）。</p><p>一开题，发现 T1 上来很神秘，T2 取最大最小直接秒了，T3 神秘基环树，发现只需要判断每个点出度是不是 1，T4 感觉很可做，但暂时不会。</p><p>想了一会 T3 一点不会，发现自己 T2 做法假了，又想想，发现取 $\geq 0$ 的最小值和 $\leq 0$ 的最大值，随便分讨即可。预估要 6 个 ST 表，等会再写。</p><p>回过头来想 T1，发现 5 元环 $1\to A\to B\to C\to D\to 1$ 枚举 $B\to C$ 即可把 5 元环枚举分到 $O(n ^ 2)$。又想了一会 T3，还是不会，于是 3：40 开始写 T1 和 T2，结果 ST 表写错了（，大概 4：20 写完。</p><p>先看了会 T4，发现随机是好做的，因为 $k\leq 2$ 只有链上的点有用，$k = 3$ 也只有链上和旁边最小点是有意义的。再一想就是一个显然的 $(\min, +)$ 矩阵，但是没想到倍增，以为动态 DP 只能使用树剖。</p><p>于是本场最大的决定来了：我决定猛冲 T3，不做 T4，因为虽然 T3 60pts 是显然的，但同样 T4 76pts 也是显然的，T3 想出来了可能很简洁，T4 即使我会也要写很久，还会因为写挂、卡常等问题挂分。于是我先做 T3。</p><p>然后直到 5：30 我一直在想，结果一点都不会 T3，意识到 T4 也时间不够了，于是光速写完 T3 60pts，反过来写 T4。</p><p>先把 $k = 3$ 的随机数据写了，一直过不了样例，发现 DP 写假的地方比较多，6：00 左右才调对。感觉不能倍增，于是 $k = 3$ 还 2log 不是很可过，开始写 $k = 2$ 的树剖。当我做下这个决定时已经 6：10 了，可想而知什么都写不出来，检查了一会，竟然发现了一个 <code>freopen</code> 打错了！！</p><p>但是在 6：28 的时候我猛然发现 $k = 2$ 至少是可以倍增维护的，虽然我已经写完了矩阵乘法，但是没有用了。要是我早点开题又是怎样的结局呢？</p><p>出来过后讨论了一下，发现大家都不怎么会 T3，T4 知道怎么做也写不完。看样子就是拼挂分的情况了！</p><p>回去冷静了一下发现 $k = 3$ 也是可以倍增维护的，那么 $O(k ^ 3 n\log n)$ 的复杂度就很可过了。不过已是后话了。</p><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>T3 怎么是随机权值判断啊！！没怎么做过这种题呢。</p><p>看游记知道 dottle AK 了，非常厉害。一问一车人 AK 了，感觉寄了。</p><p>Luogu 和 InfOJ 都没挂，$100 + 100 + 60 + 76 = 336$。</p><p>看到了 InfOJ 的榜，感觉很恐怖，336 连 BJ 的前 20 都进不去，属于是输麻了。</p><p>确实又感觉最近的状态比较差，打 CF Div1 直接垫底，平常 sb 题都做不出来了。究其原因还是太摆了，希望 NOIp 不再是这样了吧。</p><p>祝自己加油！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;中规中矩的一场……&lt;/p&gt;</summary>
    
    
    
    
    <category term="游记" scheme="https://mydcwfy.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF Educational Round#137</title>
    <link href="https://mydcwfy.github.io/2022/10/24/CF-Round-Edu137/"/>
    <id>https://mydcwfy.github.io/2022/10/24/CF-Round-Edu137/</id>
    <published>2022-10-24T00:20:23.000Z</published>
    <updated>2022-10-30T14:10:44.705Z</updated>
    
    <content type="html"><![CDATA[<p>没去打，赛后就做了 EFG 三个题。</p><span id="more"></span><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：有两把激光枪，冷却时长分别为 $t_1, t_2$，攻击力为 $p_1, p_2$，你需要攻击一个护盾为 $s$，血量为 $h$ 的怪兽，每次可以任意选择一些已冷却的激光枪射击，注意护盾可以抵挡 $s$ 的伤害。求至少需要的时间。$2\leq p_1, p_2\leq 5000$，$h\leq 5000$，$s&lt; \min(p_1, p_2)$，$t_1, t_2\leq 10 ^ {12}$。</p><p>显然比 F 难……</p><p>注意到一个特殊的地方在于 $t$ 很大，但是 $h, p_1, p_2$ 都很小。考虑按此 DP。</p><p>首先我们考虑用两把枪可能有哪些组合。假设我们最后需要把两把枪一起射，我们可以以此为分界点（因为这个点后面相当于冷却时间又从头开始）。一个暴力的想法是我们枚举下一次同时发射的时间，但显然是不好的。注意到贡献伤害的分界线只有 $t_1$ 的倍数和 $t_2$ 的倍数。于是考虑枚举这两个的倍数的时间，那么此时假设我们可以射 $c_1$ 次第一把，$c_2$ 次第二把，那么既然射击的次数已经确定了，我们可以直接计算总伤害了。</p><p>于是我们现在就考虑 DP：记 $f(i)$ 表示达到伤害 $i$ 至少需要多少时间。按照刚才我们确定伤害的方式，我们枚举 $t_1$ 的倍数和 $t_2$ 的倍数，在这些时间下我们考虑转移。</p><p>单次转移是 $O(h)$ 的，状态数也是 $O(h)$，于是总复杂度为 $O(h ^ 2)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= h; ++ i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j1 = <span class="number">1</span>; ; ++ j1) &#123;</span><br><span class="line">LL nxt = i + j1 * (p1 - s) + t1 * j1 / t2 * (p2 - s);</span><br><span class="line"><span class="keyword">if</span> (j1 * t1 &gt;= t2) nxt += s;</span><br><span class="line"><span class="built_in">chkmin</span>(nxt, h);</span><br><span class="line"><span class="built_in">chkmin</span>(dp[nxt], dp[i] + j1 * t1);</span><br><span class="line"><span class="keyword">if</span> (nxt == h) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j2 = <span class="number">1</span>; ; ++ j2) &#123;</span><br><span class="line">LL nxt = i + j2 * (p2 - s) + t2 * j2 / t1 * (p1 - s) + s;</span><br><span class="line"><span class="built_in">chkmin</span>(nxt, h);</span><br><span class="line"><span class="built_in">chkmin</span>(dp[nxt], dp[i] + j2 * t2);</span><br><span class="line"><span class="keyword">if</span> (nxt == h) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：有 $n$ 条线段 $[l_i, r_i]$，定义 $S_i$ 表示之间的所有整数。有 $\cup, \cap, \oplus$ 分别表示集合并，集合交，集合对称差。计算将 $\texttt{op}_i$ 任意替换后下列式子的和。</p><p>$$<br>\mid(((S_1 \texttt{op} _1 S_2) \texttt{op} _2 S_3)… \texttt {op} _{n - 1} S_n)\mid<br>$$</p><p>注意计算得到集合的大小之和。$0\leq n, l_i, r_i\leq 3\times 10 ^ 5$，$n\geq 2$。</p><p>容易发现这是一个扫描线模型，显然我们关键的问题是给定一个 01 序列，问有多少种填入运算符的方式满足得到的答案为 1。</p><p>注意到一个点的贡献方法和他左半部分计算得到的东西有关，于是我们考虑 DP，用 $f(i, c)$ 表示前 $i$ 个计算后得到结果为 $c$ 的方案数，转移直接看 3 中运算符后能得到什么即可。这个 DP 可以考虑用矩阵来描述，于是动态修改一个位置是 0 还是 1 的时候直接将对应的矩阵填入线段树即可。</p><p>注意第一个位置可能需要特殊处理，不能用矩阵描述。时间复杂度 $O(n\log n)$，可以通过，怕常数大的话用 ZKW 就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; <span class="keyword">operator</span> [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> a[x]; &#125;</span><br><span class="line"><span class="built_in">Matrix</span>() : a&#123;&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">I</span><span class="params">()</span> </span>&#123; a[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">Matrix <span class="keyword">operator</span> *(Matrix b) <span class="type">const</span> &#123;</span><br><span class="line">Matrix c;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : &#123;<span class="number">0</span>, <span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j : &#123;<span class="number">0</span>, <span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k : &#123;<span class="number">0</span>, <span class="number">1</span>&#125;)</span><br><span class="line">c[i][k] = (c[i][k] + (LL) a[i][j] * b[j][k]) % Mod;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">&#125; m0, m1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ZKW_Sgt</span> &#123;</span><br><span class="line">Matrix a[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; a[x] = a[x &lt;&lt; <span class="number">1</span>] * a[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">len = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (len &lt;= n) len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">2</span> &amp;&amp; i &lt;= n) a[i + len] = m0;</span><br><span class="line"><span class="keyword">else</span> a[i + len].<span class="built_in">I</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i; -- i) <span class="built_in">pushup</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, Matrix c)</span> </span>&#123;</span><br><span class="line">a[x += len] = c;</span><br><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">1</span>) <span class="built_in">pushup</span>(x &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; seg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line">m0[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">3</span>, m0[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>, m0[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">m1[<span class="number">0</span>][<span class="number">0</span>] = m1[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>, m1[<span class="number">0</span>][<span class="number">1</span>] = m1[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">seg.<span class="built_in">build</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, l + i, r + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">stl[l[i]].<span class="built_in">push_back</span>(i), edr[r[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> id : stl[i]) seg.<span class="built_in">update</span>(id, m1);</span><br><span class="line"><span class="built_in">upd</span>(res, seg.a[<span class="number">1</span>][i &gt;= l[<span class="number">1</span>] &amp;&amp; i &lt;= r[<span class="number">1</span>]][<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; seg.a[1][i &gt;= l[1] &amp;&amp; i &lt;= r[1]][1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> id : edr[i]) seg.<span class="built_in">update</span>(id, m0);</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p>题意：定义斐波那契串为 $f_0 = \texttt 0, f_1 = \texttt 1, f_i = f_{i - 1} + f_{i - 2}$，$+$ 表示拼接。定义 $g(s)$ 表示合法的划分方式使得每一个串都不是斐波那契串。先给定 $n$ 个字符串 $s_i$，求 $g(s_1)$，$g(s_1 + s_2)$，……。答案对 998244353 取模。$n\leq 3\times 10 ^ 3$，$|s_i|\leq 10 ^ 3$，12s，4MB。</p><p>假设我们不考虑神秘的空间限制怎么做。直接考虑容斥，记 $f(i)$ 表示前缀 $i$ 的答案。直接考虑容斥是 $\tilde O((\sum s_i) ^ 2)$ 的，不好。注意到除了 $f_0$ 以外，$f_{i - 1}$ 都是 $f_i$ 的前缀。于是我们可以考虑维护一个当前仍然是斐波那契串的前缀的一些转移位置。在数据范围内，我们可以用爆搜或者是之类的可以得到这样的转移位置是不超过 $O(\log \sum s_i)$ 的。</p><p>于是我们可以考虑直接维护所有满足是斐波那契串前缀的转移位置并判断当前是不是斐波那契串，这样直接做是 $O(\sum s_i \log ^ 2 \sum s_i)$，精细实现也可以做到 1log。</p><p>现在再来考虑卡空间。我们只能维护斐波那契串的前 $3\times 10 ^ 6$ 个字符，然后转移的时候需要我们只需要维护当前前缀的 dp 值，其他的都没必要。这样我们就不需要其他的空间来维护了。</p><p>这样大概能卡过空间了，注意不能使用 <code>std::string</code>，直接 MLE。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fib[<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>, fib[<span class="number">2</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="type">int</span> sz = <span class="number">2</span>, ls = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (sz &lt; (<span class="type">int</span>) <span class="number">3e6</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ls &amp;&amp; i + sz &lt;= (<span class="type">int</span>) <span class="number">3e6</span>; ++ i) fib[i + sz] = fib[i];</span><br><span class="line"><span class="type">int</span> tmp = sz + ls;</span><br><span class="line">ls = sz, sz = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isfib</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (c &lt; x) &#123;</span><br><span class="line">a = b, b = c, c = a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">append</span><span class="params">(<span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (fib[val[i].first + <span class="number">1</span>] == ch) nxt[++ tmp] = &#123;val[i].first + <span class="number">1</span>, val[i].second&#125;;</span><br><span class="line">std::<span class="built_in">swap</span>(tot, tmp), std::<span class="built_in">swap</span>(nxt, val);</span><br><span class="line"><span class="type">int</span> cur = sum;</span><br><span class="line"><span class="built_in">adj</span>(cur -= ls);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isfib</span>(val[i].first)) <span class="built_in">adj</span>(cur -= val[i].second);</span><br><span class="line"><span class="built_in">adj</span>(sum += cur - Mod);</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;1&#x27;</span>) val[++ tot] = &#123;<span class="number">1</span>, ls&#125;;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; ch &lt;&lt; &#x27; &#x27; &lt;&lt; tot &lt;&lt; &#x27; &#x27; &lt;&lt; cur &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">return</span> ls = cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;没去打，赛后就做了 EFG 三个题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>ARC125E Snack</title>
    <link href="https://mydcwfy.github.io/2022/10/22/ARC125E/"/>
    <id>https://mydcwfy.github.io/2022/10/22/ARC125E/</id>
    <published>2022-10-22T06:12:03.000Z</published>
    <updated>2022-10-22T06:41:07.228Z</updated>
    
    <content type="html"><![CDATA[<p>题意：有 $n$ 种零食，每种零食有 $a_i$ 片，有 $m$ 个小孩，每种小孩每种零食最多拿 $b_i$ 片（$b_i$ 只和小孩相关），一共不能超过 $c_i$ 片。问最多能拿走的零食片。$n, m\leq 2\times 10 ^ 5$，$a_i, c_i\leq 10 ^ {12}$，$b_i\leq 10 ^ 7$。</p><span id="more"></span><p>首先容易得到一个网络流的做法：$S$ 向每一个零食连边，流量为 $a_i$；零食 $i$ 想小孩 $j$ 连边，流量为 $b_j$；小孩 $j$ 向 $T$ 连边，流量为 $c_j$。</p><p>但是这这种办法的空间过于庞大，无法建出网络流。考虑我们<strong>模拟网络流的过程</strong>，尝试找到最大流。</p><p>首先一个性质就是<strong>将最大流转化为最小割</strong>。我们考虑左部点中有 $x$ 个与 $S$ 联通，按照割的定义，右边的 $m$ 个点要么和 $T$ 割开，要么和左边的 $x$ 个点都割开。前面一种方案的代价是 $c_j$，后面一种方案的代价是 $x\times b_j$。这两个需要取 $\min$，那么我们考虑一个分段的一次函数，分别维护斜率和截距即可。</p><p>容易发现后面的贡献只和 $x$ 的大小有关，和左边到底哪些和 $S$ 联通无关。于是我们直接对整个 $a$ 数组排序，选取前 $n - x$ 个与 $S$ 断开即可。</p><p>除开排序，我们很容易用前缀和在 $O(n + m)$ 的时间内解决原问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, b + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, c + i);</span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">k[<span class="number">1</span>] += b[i];</span><br><span class="line"><span class="keyword">if</span> ((t = (c[i] + b[i] - <span class="number">1</span>) / b[i]) &lt;= n)</span><br><span class="line">k[t] -= b[i], st[t] += c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) k[i] += k[i - <span class="number">1</span>], st[i] += st[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">auto</span> get = [&amp;](<span class="type">int</span> s) &#123; <span class="keyword">return</span> k[s] * s + st[s]; &#125;;</span><br><span class="line">LL res = <span class="number">5e18</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">res = std::<span class="built_in">min</span>(res, <span class="built_in">get</span>(n - i) + (sum += a[i]));</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：有 $n$ 种零食，每种零食有 $a_i$ 片，有 $m$ 个小孩，每种小孩每种零食最多拿 $b_i$ 片（$b_i$ 只和小孩相关），一共不能超过 $c_i$ 片。问最多能拿走的零食片。$n, m\leq 2\times 10 ^ 5$，$a_i, c_i\leq 10 ^ {12}$，$b_i\leq 10 ^ 7$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络流" scheme="https://mydcwfy.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="贪心" scheme="https://mydcwfy.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="堆" scheme="https://mydcwfy.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>ABC273Ex Inv(0,1)ving Insert(1,0)n</title>
    <link href="https://mydcwfy.github.io/2022/10/18/ABC273H/"/>
    <id>https://mydcwfy.github.io/2022/10/18/ABC273H/</id>
    <published>2022-10-18T13:10:05.000Z</published>
    <updated>2022-10-30T13:33:34.358Z</updated>
    
    <content type="html"><![CDATA[<p>题意：定义对序列 $A$（$A$ 包含整数二元组）操作一次为如下操作：选定任意两个相邻的二元组 $(a, b)$ 和 $(c, d)$，在他们中间插入 $(a + c, b + d)$。定义一个二元组序列的价值为从 $A = \{(0, 1), (1, 0)\}$ 开始至少要操作多少次才能包含序列中的所有二元组。如果无法的话价值就是 0。现给定一个长度为 $n$ 的二元组序列 $T$，问所有连续子序列的价值和，对 998244353 取模。$n\leq 10 ^ 5$，$a, b\leq 10 ^ 9$。</p><span id="more"></span><p>首先注意到这个的操作方式和 <a href="https://oi-wiki.org/math/number-theory/stern-brocot/#stern-brocot-%E6%A0%91">Stern-Brocot 树</a> 的构造方式是一样的，那么直接在这棵树上做似乎是一个不错的选择。</p><p>那么根据该树的性质，我们容易得到一个二元组有两种情况是无法得到的：</p><ol><li>$\gcd(a, b) \neq 1$</li><li>$a = 0\lor b = 0$</li></ol><p>那么我们相当于现在是划分为一段一段的分别做，每一段内都是合法的状态，然后不同段之间的显然贡献都为 0。现在就处理掉了没有贡献的区间。</p><p>现在我们考虑按照该树的构造办法，我们于是可以这么拆贡献：对于该树上的每一个节点 $[\dfrac ab, \dfrac cd]$（可能 $d$ 为 0，不太严谨，就是 $+\infty$ 的意思），我们考虑要生成 $\dfrac {a + c}{b + d}$ 需要被多少个子串所需要。</p><p>一个充要条件是如果一个子串中存在一个 $\dfrac pq$ 满足 $\dfrac ab &lt; \dfrac pq &lt; \dfrac cd$，那么就需要 $\dfrac {a + c}{b + d}$。那么，我们需要统计所有满足分数在 $(\dfrac ab, \dfrac cd)$ 之间的位置。这样的话就是容易容斥计算的。</p><p>这样直接做复杂度是不对的，应为单次统计至少需要 $O(len)$，$len$ 为在这个区间之间的分数个数。首先我们直接考虑分治下去，将 $[\dfrac ab, \dfrac {a + c}{b + d}]$ 和 $[\dfrac {a + c}{b + d}, \dfrac cd]$ 的答案分别算出来，然后可以启发式合并一下，将少的合并到多的上，用 <code>std::set</code> 维护并动态统计答案，假设每次都有分支的话，复杂度就是 $O(n\log ^ 2 n)$ 的。</p><p>然后我们再来处理假设区间内部的所有数都在 $\dfrac {a + c}{b + d}$ 的一边怎么办。一个极端的情况就是 $(10 ^ 9, 1)$，我们不得不递归 $10 ^ 9$ 层才能找到他。这样显然是不好的，于是我们可以考虑二分一个 $k$ 满足不是所有数都在 $\dfrac {a + kc}{b + kd}$（或者是 $\dfrac {ka + c}{kb + d}$，看在哪一边）的一边。注意到我们相当于在树上是一次跳了 $k$ 层，于是最后的答案要 $\times k$。</p><p>于是总复杂度就是 $O(n\log ^ 2 n + n\log a)$，可以通过。实际实现的时候二分的 $k$ 差一两个是没有问题的，效率如何没测试过（<del>因为我的 $k$ 好像就少 1</del>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Frac</span> &#123;</span><br><span class="line">LL x, y;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">Frac <span class="keyword">operator</span> +(Frac t) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;x + t.x, y + t.y&#125;; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(Frac t) <span class="type">const</span> &#123; <span class="keyword">return</span> (s128) x * t.y &lt; (s128) y * t.x; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &gt;(Frac t) <span class="type">const</span> &#123; <span class="keyword">return</span> (s128) x * t.y &gt; (s128) y * t.x; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> ==(Frac t) <span class="type">const</span> &#123; <span class="keyword">return</span> x == t.x &amp;&amp; y == t.y; &#125;</span><br><span class="line">Frac <span class="keyword">operator</span> *(LL t) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;x * t, y * t&#125;; &#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> iter = s[id].<span class="built_in">insert</span>(x).first;</span><br><span class="line"><span class="type">int</span> y = *std::<span class="built_in">prev</span>(iter), z = *std::<span class="built_in">next</span>(iter);</span><br><span class="line">ans[id] = (ans[id] + (LL) (z - x) * (x - y)) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, Frac lf, Frac rf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= n &amp;&amp; a[l] == lf) l ++;</span><br><span class="line"><span class="keyword">while</span> (r &amp;&amp; a[r] == rf) r --;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[r] &lt; lf + rf) &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>, y = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt; y) &#123;</span><br><span class="line"><span class="type">int</span> mid = (x + y + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (lf * mid + rf &gt; a[r]) x = mid;</span><br><span class="line"><span class="keyword">else</span> y = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">rf = rf + lf * (x - <span class="number">1</span>), cnt = x;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[l] &gt; lf + rf) &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>, y = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt; y) &#123;</span><br><span class="line"><span class="type">int</span> mid = (x + y + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (lf + rf * mid &lt; a[l]) x = mid;</span><br><span class="line"><span class="keyword">else</span> y = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">lf = lf + rf * (x - <span class="number">1</span>), cnt = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x = l, y = r + <span class="number">1</span>, mL, mR;</span><br><span class="line"><span class="keyword">while</span> (x &lt; y) &#123;</span><br><span class="line"><span class="type">int</span> mid = (x + y) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid] &lt; lf + rf) x = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> y = mid;</span><br><span class="line">&#125;</span><br><span class="line">mL = x, x = l - <span class="number">1</span>, y = r;</span><br><span class="line"><span class="keyword">while</span> (x &lt; y) &#123;</span><br><span class="line"><span class="type">int</span> mid = (x + y + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid] &gt; lf + rf) y = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> x = mid;</span><br><span class="line">&#125;</span><br><span class="line">mR = x;</span><br><span class="line"><span class="comment">// Equal (a + c) / (b + d) range</span></span><br><span class="line"><span class="type">int</span> lc = <span class="built_in">solve</span>(l, mL - <span class="number">1</span>, lf, lf + rf), rc = <span class="built_in">solve</span>(mR + <span class="number">1</span>, r, lf + rf, rf);</span><br><span class="line"><span class="keyword">if</span> (s[lc].<span class="built_in">size</span>() &gt; s[rc].<span class="built_in">size</span>()) std::<span class="built_in">swap</span>(lc, rc);</span><br><span class="line"><span class="keyword">if</span> (rc == <span class="number">1</span>) s[rc = ++ tot] = &#123;<span class="number">0</span>, n + <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> t : s[lc])</span><br><span class="line"><span class="keyword">if</span> (t &gt;= <span class="number">1</span> &amp;&amp; t &lt;= n) <span class="built_in">insert</span>(rc, t);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> t = mL; t &lt;= mR; ++ t) <span class="built_in">insert</span>(rc, a[t].id);</span><br><span class="line">res = (res + (LL) ans[rc] * cnt) % Mod;</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">(std::vector&lt;Frac&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">res = <span class="number">0</span>;</span><br><span class="line">n = vec.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) a[i + <span class="number">1</span>] = vec[i], a[i + <span class="number">1</span>].id = i + <span class="number">1</span>;</span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">s[<span class="number">1</span>] = &#123;<span class="number">0</span>, n + <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">solve</span>(<span class="number">1</span>, n, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;), res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：定义对序列 $A$（$A$ 包含整数二元组）操作一次为如下操作：选定任意两个相邻的二元组 $(a, b)$ 和 $(c, d)$，在他们中间插入 $(a + c, b + d)$。定义一个二元组序列的价值为从 $A = \{(0, 1), (1, 0)\}$ 开始至少要操作多少次才能包含序列中的所有二元组。如果无法的话价值就是 0。现给定一个长度为 $n$ 的二元组序列 $T$，问所有连续子序列的价值和，对 998244353 取模。$n\leq 10 ^ 5$，$a, b\leq 10 ^ 9$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分治" scheme="https://mydcwfy.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="启发式合并" scheme="https://mydcwfy.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
    <category term="二分" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="复杂度分析" scheme="https://mydcwfy.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>CF1515H Phoenix and Bits</title>
    <link href="https://mydcwfy.github.io/2022/10/15/CF1515H/"/>
    <id>https://mydcwfy.github.io/2022/10/15/CF1515H/</id>
    <published>2022-10-14T23:34:21.000Z</published>
    <updated>2022-10-15T00:58:04.113Z</updated>
    
    <content type="html"><![CDATA[<p>题意：维护一个集合 $a$，最开始有 $n$ 个元素，有 $m$ 次操作或者询问：</p><ol><li>将 $a_i\in [l, r]$ 的值全部与 $x$。</li><li>将 $a_i\in [l, r]$ 的值全部或 $x$。</li><li>将 $a_i\in [l, r]$ 的值全部异或 $x$。</li><li>询问在 $[l, r]$ 中有多少个不同的 $a_i$。</li></ol><p>$n\leq 2\times 10 ^ 5$，$m\leq 10 ^ 5$，$0\leq a_i &lt; 2 ^ {20}$。</p><span id="more"></span><p>进阶 01 Trie 的模板题。</p><h3 id="寻找一段区间"><a href="#寻找一段区间" class="headerlink" title="寻找一段区间"></a>寻找一段区间</h3><p>类似于 FHQ Treap 的 split 一样，我们考虑在 $[l, r]$ 之间分离出一段 $[x, y]$。此时考虑 $mid$ 在 $[x, y]$ 的位置，向左右递归即可。节点 split 直接新建即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!u || !tr[u].sz) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (bit &lt; <span class="number">0</span> || (l == <span class="number">0</span> &amp;&amp; r == <span class="number">2</span> * (<span class="number">1</span> &lt;&lt; bit) - <span class="number">1</span>)) &#123;</span><br><span class="line">x = u;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; u &lt;&lt; &#x27; &#x27; &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; &#x27; &#x27; &lt;&lt; bit &lt;&lt; &#x27; &#x27; &lt;&lt; tr[u].sz &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="built_in">pushdown</span>(u, bit);</span><br><span class="line"><span class="keyword">if</span> (l &gt;= mid)</span><br><span class="line">y = u, <span class="built_in">split</span>(tr[u].s[<span class="number">1</span>], tr[x = ++ tot].s[<span class="number">1</span>], tr[u].s[<span class="number">1</span>], l ^ mid, r ^ mid, bit - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r &lt; mid)</span><br><span class="line">y = u, <span class="built_in">split</span>(tr[u].s[<span class="number">0</span>], tr[x = ++ tot].s[<span class="number">0</span>], tr[u].s[<span class="number">0</span>], l, r, bit - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// if (l == 0 &amp;&amp; r == mid * 2 - 1) return x = u, void();</span></span><br><span class="line">x = u, y = ++ tot;</span><br><span class="line"><span class="built_in">split</span>(tr[u].s[<span class="number">0</span>], tr[u].s[<span class="number">0</span>], tr[y].s[<span class="number">0</span>], l, mid - <span class="number">1</span>, bit - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">split</span>(tr[u].s[<span class="number">1</span>], tr[u].s[<span class="number">1</span>], tr[y].s[<span class="number">1</span>], <span class="number">0</span>, r ^ mid, bit - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushup</span>(x), <span class="built_in">pushup</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并两棵子树"><a href="#合并两棵子树" class="headerlink" title="合并两棵子树"></a>合并两棵子树</h3><p>没什么好讲的，注意到了叶子节点只能保留一个信息即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;MERGE &quot; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; &#x27; &#x27; &lt;&lt; bit &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">if</span> (!x || !tr[x].sz) <span class="keyword">return</span> y;</span><br><span class="line"><span class="keyword">if</span> (!y || !tr[y].sz) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">if</span> (bit &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; tr[x].val &lt;&lt; &#x27; &#x27; &lt;&lt; tr[y].val &lt;&lt; std::endl;</span></span><br><span class="line"><span class="built_in">assert</span>(!tr[x].sz || !tr[y].sz || tr[x].val == tr[y].val);</span><br><span class="line"><span class="keyword">return</span> tr[x].sz ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(x, bit), <span class="built_in">pushdown</span>(y, bit);</span><br><span class="line">tr[x].s[<span class="number">0</span>] = <span class="built_in">merge</span>(tr[x].s[<span class="number">0</span>], tr[y].s[<span class="number">0</span>], bit - <span class="number">1</span>);</span><br><span class="line">tr[x].s[<span class="number">1</span>] = <span class="built_in">merge</span>(tr[x].s[<span class="number">1</span>], tr[y].s[<span class="number">1</span>], bit - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pushup</span>(x), x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对全局-xor"><a href="#对全局-xor" class="headerlink" title="对全局 xor"></a>对全局 xor</h3><p>我们考虑对于一棵子树全部 xor 怎么做。因为我们已经有 <code>split</code> 了，所以这个操作可以支持区间做。</p><p>这个可以使用懒标记实现。因为子树的节点个数并没有发生改变，而只是对于一些节点的左右儿子交换即可。这个节点的所有信息都可以在不递归子树的情况下 $O(1)$ 维护。</p><p>具体有哪些信息呢？我们目前只需要维护左右儿子、懒标记和不同的数的个数，都很简单，就不讲了。</p><h3 id="对全局-or"><a href="#对全局-or" class="headerlink" title="对全局 or"></a>对全局 or</h3><p>全局 or 是不好做的，因为我们可能合并节点之类的。虽然总结点个数是 $O((n + m)\log a)$ 的，但是我们并不好判断一棵子树内部有没有需要合并的节点。</p><p>首先如果全局 or 在一定情况下可以变成全局 xor，这样不会减少节点，所以我们为了保证复杂度，不能递归。容易发现这个的成立条件是在给定 or 的每一位上全局要么全是 1，要么全是 0。我们考虑记录全局的 or $v_1$ 和全局补集的 or $v_2$（将所有数取反的 or），那么判断条件可以写作 $[(v_2\odot x)\odot v_1 = 0]$（$\odot$ 表示与运算）。另外，此时我们相当于要对全局 xor 上 $v_2\odot x$。</p><p>否则的话，我们至少会出现一个节点的合并，这个时候我们再考虑递归。如果当前节点左右儿子都存在，并且我们这一位会 or 上 1，那么我们可以先将左儿子的所有值 xor 上 $2 ^ {bit}$，然后直接将左右儿子都合并到右儿子即可。</p><p>这个时候再反过去在 xor 的时候维护一下 or 和补集的 or，注意到如果 or 和补集的 or 都包含某一位的话，怎么 xor 这一位都是 1。拆位做一下就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">allxor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> bit, <span class="type">int</span> lt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> v = tr[x].val, lv = tr[x].lval;</span><br><span class="line"><span class="keyword">if</span> (lt &gt;&gt; bit &amp; <span class="number">1</span>) std::<span class="built_in">swap</span>(tr[x].s[<span class="number">0</span>], tr[x].s[<span class="number">1</span>]);</span><br><span class="line">tr[x].val = (v ^ lt) | (v &amp; lv &amp; lt);</span><br><span class="line">tr[x].lval = (lv ^ lt) | (v &amp; lv &amp; lt);</span><br><span class="line">tr[x].lt ^= lt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x || !tr[x].lt || !tr[x].sz) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">allxor</span>(tr[x].s[<span class="number">0</span>], bit - <span class="number">1</span>, tr[x].lt), <span class="built_in">allxor</span>(tr[x].s[<span class="number">1</span>], bit - <span class="number">1</span>, tr[x].lt);</span><br><span class="line">tr[x].lt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allor</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> bit, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!u || !tr[u].sz) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> add = val &amp; tr[u].lval;</span><br><span class="line"><span class="keyword">if</span> (!(add &amp; tr[u].val)) <span class="keyword">return</span> <span class="built_in">allxor</span>(u, bit, add);</span><br><span class="line"><span class="built_in">pushdown</span>(u, bit);</span><br><span class="line"><span class="type">int</span> mid = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">if</span> (val &amp; mid)</span><br><span class="line"><span class="built_in">allxor</span>(tr[u].s[<span class="number">0</span>], bit - <span class="number">1</span>, mid),</span><br><span class="line">tr[u].s[<span class="number">1</span>] = <span class="built_in">merge</span>(tr[u].s[<span class="number">0</span>], tr[u].s[<span class="number">1</span>], bit - <span class="number">1</span>), tr[u].s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">allor</span>(tr[u].s[<span class="number">0</span>], bit - <span class="number">1</span>, val), <span class="built_in">allor</span>(tr[u].s[<span class="number">1</span>], bit - <span class="number">1</span>, val);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对全局-and"><a href="#对全局-and" class="headerlink" title="对全局 and"></a>对全局 and</h3><p>容易发现 $v\odot x = \neg(\neg v |x)$，那么就可以拆分成 or 和 xor 操作。这个就好做了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于一共只有 $O((n + m)\log a)$ 个节点，我们花费 $O(\log a)$ 的时间可以永久删除一个点，所以复杂度时 $O((n + m)\log ^ 2a)$ 的，可以通过。</p><p>由于笔者也是第一次也这种代码，出了很多神秘错误，大概列几点可能常见的：</p><ol><li>计算低位的时候，不管 xor 还是 or 都不能只把 $x$ 的低位传下去，因为需要维护子树的值相关的信息。</li><li>由于 <code>split</code> 时可能出现里面一个数都没有的节点，操作时需要特判一下，比如把所有判断空节点都写成 <code>!tr[u].sz</code>。</li><li>注意 or 判断改为 xor 时的判断条件要准确，因为小样例测不出来。</li></ol><p>只放主函数了，调用的函数上面基本出现了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), <span class="built_in">insert</span>(x);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, typ, l, r, v, x, y; i &lt;= m; ++ i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;typ, &amp;l, &amp;r);</span><br><span class="line"><span class="built_in">split</span>(rt, x, y, l, r, <span class="number">19</span>);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;RANGE &quot; &lt;&lt; tr[x].sz &lt;&lt; &#x27; &#x27; &lt;&lt; tr[x].val &lt;&lt; &#x27; &#x27; &lt;&lt; tr[x].lval &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">if</span> (typ == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tr[x].sz);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (typ == <span class="number">3</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v), <span class="built_in">allxor</span>(x, <span class="number">19</span>, v);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (typ == <span class="number">2</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v), <span class="built_in">allor</span>(x, <span class="number">19</span>, v);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v), <span class="built_in">allxor</span>(x, <span class="number">19</span>, U), <span class="built_in">allor</span>(x, <span class="number">19</span>, U ^ v), <span class="built_in">allxor</span>(x, <span class="number">19</span>, U);</span><br><span class="line">rt = <span class="built_in">merge</span>(y, x, <span class="number">19</span>);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;ALL &quot; &lt;&lt; tr[rt].sz &lt;&lt; &#x27; &#x27; &lt;&lt; tr[rt].val &lt;&lt; &#x27; &#x27; &lt;&lt; tr[x].lval &lt;&lt; &quot;\n\n&quot;;</span></span><br><span class="line"><span class="comment">// exit(0);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：维护一个集合 $a$，最开始有 $n$ 个元素，有 $m$ 次操作或者询问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将 $a_i\in [l, r]$ 的值全部与 $x$。&lt;/li&gt;
&lt;li&gt;将 $a_i\in [l, r]$ 的值全部或 $x$。&lt;/li&gt;
&lt;li&gt;将 $a_i\in [l, r]$ 的值全部异或 $x$。&lt;/li&gt;
&lt;li&gt;询问在 $[l, r]$ 中有多少个不同的 $a_i$。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$n\leq 2\times 10 ^ 5$，$m\leq 10 ^ 5$，$0\leq a_i &amp;lt; 2 ^ {20}$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Trie" scheme="https://mydcwfy.github.io/tags/Trie/"/>
    
    <category term="位运算" scheme="https://mydcwfy.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="复杂度分析" scheme="https://mydcwfy.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>LOJ6736 「2020 集训队论文」最小连通块</title>
    <link href="https://mydcwfy.github.io/2022/10/13/LOJ6736/"/>
    <id>https://mydcwfy.github.io/2022/10/13/LOJ6736/</id>
    <published>2022-10-13T11:56:00.000Z</published>
    <updated>2022-10-13T12:23:44.347Z</updated>
    
    <content type="html"><![CDATA[<p>题意：<strong>交互题</strong>。给出一棵树的点数 $n$，你每次询问可以给出一个点集 $S$ 和一个点 $x$，可以得到 $x$ 是否在点集 $S$ 的最小连通块中，需要还原出树。$n = 1000$，你最多可以询问 22000 次。求构造方案。</p><span id="more"></span><p>这个题的做法有很多，我们切入一个比较简单并且易懂的角度。</p><p>首先我们考虑如果我们已经知道了这棵树的拓扑序后怎么做。注意此时我们需要定义一个根，然后每条边从儿子指向父亲。简单来说就是父亲的拓扑序在儿子的后面。</p><p>注意到我们在拓扑序上枚举到了 $x$，我们求它的所有后代。容易发现它的所有后代都是在它前面的，并且除了 $x$ 的儿子以外，其他的点都已经被这种方式覆盖过了。这给我们一个区分儿子和后代的办法：拿到所有的后代后，直接在拓扑序中把这些点删除，这样后面就不会再遍历到这些点了。那么我们就可以保证，现在拿到的所有的点都满足是 $x$ 的儿子。这样做下去，容易发现询问复杂度是 $O(n\log n)$ 的，因为遍历到一个点就会把他删除，遍历到点的过程可以二分查找前半段是否存在 $x$ 的后代，所以就是 $O(n\log n)$ 的。</p><p>那么现在问题就转化成了求树的拓扑序。假设我们当前 $S$ 集合里面的点都没有放进拓扑序，我们要把 $x$ 子树内全部放进去。做法比较神秘，我们考虑找到一个 $S$ 内部并且在 $x$ 子树内部的点 $y$，然后先将 $y$ 子树内部的点放进拓扑序（注意到 $y$ 子树内部的点一定在 $x$ 前面），$S$ 集合对应更新。我们这样做的话，显然是一定会把 $x$ 子树内部的所有点全部都放进拓扑序。最后放 $x$，这样的话就可以完成构造拓扑序。</p><p>考虑分析一下上述算法的复杂度。注意到每一个 $x$ 都只会被遍历一次（不挂其子树内是什么），找到一个 $x$ 的后代的过程同样可以二分，于是询问复杂度也是 $O(n\log n)$ 的。</p><p>综上，我们可以在询问复杂度 $O(n\log n)$ 的时间内完成，时间复杂度可以较容易地做到 $O(n ^ 2)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) s.<span class="built_in">size</span>(); ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s[i] == x) <span class="keyword">return</span> s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i), <span class="built_in">void</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; s, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask</span>(s, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">del</span>(x);</span><br><span class="line">    <span class="keyword">while</span> (s.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">query</span>(s, x))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">query</span>(&#123;s.<span class="built_in">data</span>(), s.<span class="built_in">data</span>() + mid&#125;, x)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> y = s[l - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">solve</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    ord.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">work</span>(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) s.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = ord[i];</span><br><span class="line">        <span class="keyword">while</span> (vec.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">query</span>(vec, x)) &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">1</span>, r = vec.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">query</span>(&#123;vec.<span class="built_in">data</span>(), vec.<span class="built_in">data</span>() + mid&#125;, x)) r = mid;</span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; &quot;Find &quot; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; vec[l - 1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;x, vec[l - <span class="number">1</span>]&#125;), vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + l - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; res.size() &lt;&lt; &#x27; &#x27; &lt;&lt; ord.size() &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：&lt;strong&gt;交互题&lt;/strong&gt;。给出一棵树的点数 $n$，你每次询问可以给出一个点集 $S$ 和一个点 $x$，可以得到 $x$ 是否在点集 $S$ 的最小连通块中，需要还原出树。$n = 1000$，你最多可以询问 22000 次。求构造方案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="交互" scheme="https://mydcwfy.github.io/tags/%E4%BA%A4%E4%BA%92/"/>
    
    <category term="二分" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="复杂度分析" scheme="https://mydcwfy.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>ARC150D Removing Gacha</title>
    <link href="https://mydcwfy.github.io/2022/10/12/ARC150D/"/>
    <id>https://mydcwfy.github.io/2022/10/12/ARC150D/</id>
    <published>2022-10-12T00:04:45.000Z</published>
    <updated>2022-10-12T00:25:31.944Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定 $n$ 个点的树，定义一个点是好的当且仅当它和它的所有祖先都是黑色的，从所有点都是白点开始，任选一个不好的点染成黑色，问期望染多少次使得所有都是黑色。$n\leq 2\times 10 ^ 5$，对 998244353 取模。</p><span id="more"></span><p>非常 nb 的期望题，做了一整场 /cy</p><p>和题解角度不同，我们考虑每个点的时候，需要考虑它没被祖先覆盖的概率，然后再在它的子树内部任意选，直到选到这个点为止。容易发现我们如果没选在子树内部的话，根据期望的线性性，我们可以把不同子树之间的答案直接加就好了。</p><p>首先考虑在它的子树内部任意选的期望。因为子树的根是没有被选中的，所以所有点都是不好的点，那么期望就是 $sz(x)$ 能选中子树的根。</p><p>然后考虑它没被祖先覆盖的概率。我们不管其他节点，我们现在只关心我们选到了 $x$ 以及所有祖先的情况。这个相当于是我们把所有祖先都染成黑色了，但是 $x$ 没被碰到。</p><p>有一个好点的限制比较烦，但是注意到我们选择好点对概率是没有影响的。所以我们相当于是不管好不好，所有点都是随机一个选择。这样的话，所有点是等价的，那么 $x$ 没被碰到相当于是 $x$ 被最后选到，概率就是 $\dfrac 1{dep(x)}$。</p><p>于是我们可以得到答案为 $\displaystyle \sum_{i = 1} ^ n \dfrac {sz(x)}{dep(x)}$。直接计算即可，时间复杂度 $O(n)$ 或者 $O(n\log a)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x ^ <span class="number">1</span>) dep[x] = dep[fa[x]] + <span class="number">1</span>;</span><br><span class="line">sz[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x]) <span class="built_in">dfs</span>(v), sz[x] += sz[v];</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; dep[x] &lt;&lt; &#x27; &#x27; &lt;&lt; sz[x] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">res = (res + (LL) <span class="built_in">qpow</span>(dep[x] + <span class="number">1</span>) * sz[x]) % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定 $n$ 个点的树，定义一个点是好的当且仅当它和它的所有祖先都是黑色的，从所有点都是白点开始，任选一个不好的点染成黑色，问期望染多少次使得所有都是黑色。$n\leq 2\times 10 ^ 5$，对 998244353 取模。&lt;/p&gt;</summary>
    
    
    
    
    <category term="树相关" scheme="https://mydcwfy.github.io/tags/%E6%A0%91%E7%9B%B8%E5%85%B3/"/>
    
    <category term="期望" scheme="https://mydcwfy.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>ABC272F Two Strings</title>
    <link href="https://mydcwfy.github.io/2022/10/12/ABC272F/"/>
    <id>https://mydcwfy.github.io/2022/10/12/ABC272F/</id>
    <published>2022-10-11T23:44:34.000Z</published>
    <updated>2022-10-12T00:03:25.867Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定两个长度为 $n$ 的字符串 $S, T$，定义 $f(S, i)$ 表示将前 $i$ 个字符放在最后得到的字符串，问有多少个 $(i, j)(0\leq i, j &lt;n)$ 满足 $f(S, i)\leq f(T, j)$。$n\leq 2\times 10 ^ 5$，$S, T$ 仅由小写英文字符构成。</p><span id="more"></span><p>场上没做出来，靠 G 的随机化才上了分……</p><p>我们尝试把 $S, T$ 拼在一起，然后把 $f(S, i)\leq f(T, j)$ 设置为整个字符串内部的某些后缀的大小关系。经过构造可以这样：<br>$$<br>S + S + \texttt a ^ n + T + T + \texttt z ^ n<br>$$<br>首先两倍是很显然的，因为我们需要把前 $i$ 个拼到最后面，复制一遍显然是比较好的选择。如果 $f(S, i) &lt; f(T, j)$，那么在新字符串中，他们对应的后缀一定满足小于关系。如果 $f(S, i) = f(T, j)$ 的话，容易发现他们一定会跳过本身的 $S, T$，而变成 $\tt a, z$ 的比较了。那么也就是说新的字符串，我们只需要比较新的字符串中 $S, T$ 区间的大小关系。</p><p>这个怎么做呢？其实我场上想到这了，但是没想到这是一个 SA 板子 /kk。直接做就好了，复杂度 $O(n\log n)$ 或者 $O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> m = <span class="number">2</span> * n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[i] = s[i + n] = a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[++ m] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[i + m] = s[i + n + m] = b[i];</span><br><span class="line">m += <span class="number">2</span> * n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[++ m] = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"><span class="built_in">get_sa</span>(s);</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, cnt = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line"><span class="keyword">if</span> (sa[i] &lt;= n) cnt ++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sa[i] &gt; <span class="number">3</span> * n &amp;&amp; sa[i] &lt;= <span class="number">4</span> * n) res += cnt;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定两个长度为 $n$ 的字符串 $S, T$，定义 $f(S, i)$ 表示将前 $i$ 个字符放在最后得到的字符串，问有多少个 $(i, j)(0\leq i, j &amp;lt;n)$ 满足 $f(S, i)\leq f(T, j)$。$n\leq 2\times 10 ^ 5$，$S, T$ 仅由小写英文字符构成。&lt;/p&gt;</summary>
    
    
    
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="字符串" scheme="https://mydcwfy.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="后缀数据结构" scheme="https://mydcwfy.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ABC270Ex add 1</title>
    <link href="https://mydcwfy.github.io/2022/09/29/ABC270H/"/>
    <id>https://mydcwfy.github.io/2022/09/29/ABC270H/</id>
    <published>2022-09-29T03:17:11.000Z</published>
    <updated>2022-10-02T02:23:43.448Z</updated>
    
    <content type="html"><![CDATA[<p>题意：有 $n$ 个计数器，每个计数器有一个上界 $a_i$，每次操作会将一个计数器清 0，然后将其他计数器 +1。问期望多少步每个计数器都达到上界。保证 $0 = a_1 \leq a_2 \leq \dots\leq a_n\leq 10 ^ {18}$，$a_n &gt; 0$，$n\leq 2\times 10 ^ 5$，答案对 998244353 取模。</p><span id="more"></span><p>好神的期望题。</p><p>首先 $n$ 个状态显然是不好计数的，我们考虑用一个状态描述。记 $k$ 为 $\max_{i = 1} ^ n(a_i - c_i)$，$c_i$ 表示当前的计数器的数。记录 $f_k$ 表示从状态 $k$ 期望的步数结束。容易发现 $f_0 = 0$。</p><p>考虑设一个 $r$ 为最大的满足 $a_r &lt; k\leq a_{r + 1}$ 的阈值，我们考虑分析两种情况：</p><ol><li>选中清空的 $i$ 满足 $i\leq r$。这时不管清空的是哪一个，我们都容易得到新的状态是 $k - 1$。</li><li>选中清空的 $i$ 满足 $i &gt; r$。这是清空哪一个，$k$ 就会变成哪一个计数器的值。所以就会变成 $a_i$。</li></ol><p>那么据此我们可以得到：<br>$$<br>f_k = \dfrac rn f_{k - 1} + \dfrac 1n \sum_{i = r + 1} ^ n f_{a_i} + 1<br>$$<br>注意到转移方向不确定，我们考虑变化一下，这样 $f_{k - 1}$ 在一边了。</p><p>但是我们又注意到一个问题，就是我们知道的不是最大的那一个，而是最小的那一个（$f_0 = 0$）。</p><p>考虑转化定义，设 $g_k$ 表示开始期望多少能走到状态 $k$。容易发现 $f_k + g_k = f_{a_n}$。那么我们现在已经知道了 $g_{a_n} = 0$，我们需要找到 $g_0$。</p><p>直接暴力带入上面的式子：<br>$$<br>\begin{aligned}<br>f_{a_n} - g_{k} =&amp;\dfrac rn(f_{a_n} - g_{k - 1}) + \dfrac 1n \sum_{i = r + 1} ^ n (f_{a_n} - g_{a_i}) + 1\\<br>g_k =&amp; \dfrac rn g_{k - 1} + \dfrac 1n \sum_{i = r + 1} ^ n g_{a_i} - 1\\<br>g_{k - 1} =&amp; \dfrac nr g_k - \dfrac 1r \sum_{i = r + 1} ^ n g_{a_i} + \dfrac nr<br>\end{aligned}<br>$$</p><p>得到这样的式子过后，我们可以得到一个 $O(a\log a)$ 的做法。但是仍然不够优秀，我们考虑优化。</p><p>容易发现在 $k\in (a_r, a_{r + 1}]$ 的转移都是相同的，因为 $r$ 不变。我们考虑从这里入手。我们记 $suf_r = \sum_{i = r} ^ n g_{a_i}$，有：<br>$$<br>\begin{aligned}<br>g_{k - 1} =&amp; \dfrac nr g_k - \dfrac {suf_{r + 1}}r + \dfrac nr\<br>g_{k - 1} - \dfrac {suf_{r + 1}}{n - r} + \dfrac n{n - r} =&amp; \dfrac nr(g_k - \dfrac {suf_{r + 1}}{n - r} + \dfrac n{n - r})<br>\end{aligned}<br>$$<br>注意到我们把两边的形式化为相同过后，直接快速幂，这个可以省去中间的状态，直接通过 $g_{a_{r + 1}}$ 得到 $g_{a_r}$。<br>$$<br>g_{a_r} + \dfrac {n - suf_{r + 1}}{n - r} = \left(\dfrac nr \right) ^ {a_{r + 1} - a_r} (g_{a_{r + 1}} + \dfrac {n - suf_{r + 1}}{n - r})<br>$$<br>直接计算可以得到 $O(n\log a)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>, x, tmp; i; -- i) &#123;</span><br><span class="line">x = <span class="built_in">qpow</span>((LL) n * <span class="built_in">qpow</span>(i) % Mod, a[i + <span class="number">1</span>] - a[i]);</span><br><span class="line">res[i] = (res[i + <span class="number">1</span>] + (LL) <span class="built_in">adj</span>(tmp = n - suf[i + <span class="number">1</span>]) * <span class="built_in">qpow</span>(n - i)) % Mod * x % Mod;</span><br><span class="line">res[i] = (res[i] + (LL) (Mod - tmp) * <span class="built_in">qpow</span>(n - i)) % Mod;</span><br><span class="line"><span class="built_in">adj</span>(suf[i] = suf[i + <span class="number">1</span>] + res[i] - Mod);</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：有 $n$ 个计数器，每个计数器有一个上界 $a_i$，每次操作会将一个计数器清 0，然后将其他计数器 +1。问期望多少步每个计数器都达到上界。保证 $0 = a_1 \leq a_2 \leq \dots\leq a_n\leq 10 ^ {18}$，$a_n &amp;gt; 0$，$n\leq 2\times 10 ^ 5$，答案对 998244353 取模。&lt;/p&gt;</summary>
    
    
    
    
    <category term="期望" scheme="https://mydcwfy.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>ARC Round#116</title>
    <link href="https://mydcwfy.github.io/2022/09/25/ARC-Round-116/"/>
    <id>https://mydcwfy.github.io/2022/09/25/ARC-Round-116/</id>
    <published>2022-09-25T13:04:44.000Z</published>
    <updated>2022-09-25T23:39:23.489Z</updated>
    
    <content type="html"><![CDATA[<p>All Accepted。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定一个数 $n$，判断 $n$ 的奇因数多还是偶因数多。$T(T\leq 2\times 10 ^ 5)$ 组数据，$n\leq 10 ^ {18}$。</p><p>容易发现如果 $n$ 是奇数肯定是奇因数多，否则如果 $n$ 是 4 的倍数，那么如果 $d$ 是奇因数，那么 $2d, 4d$ 都是偶因数，这样 $n$ 的偶因数多。否则一样多。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定一个序列 $A$，问所有非空子序列 $B$ 的 $\max(B)\times \min(B)$ 的和。$n\leq 2\times 10 ^ 5$，答案对 998244353 取模。</p><p>首先排除我们只选一个数的贡献，假设我们确定最大值和最小值，那么可以得到可以计算的次数为 $2 ^ {r - l}$。注意到 $r, l$ 是分开的，这个可以使用前缀 / 后缀和优化，比如我们记录 $\sum_{i = l} ^ n 2 ^ la_i$ 就可以 $O(\log p)$ 或者 $O(1)$ 计算单个最小值的贡献了。时间复杂度 $O(n\log p)$ 或者 $O(n)$。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定 $n, m$，问有多少个长度为 $n$ 的序列满足 $a_i | a_{i + 1}$ 并且 $1\leq a_i\leq m$。$n, m\leq 2\times 10 ^ 5$，对 998244353 取模。</p><p>考虑我们枚举 $a_n$，那么考虑对每个质因数的次数拆开看，相当于是找一个不减的序列，末项已经确定了。容易发现这就是一个插板法，答案为 $\displaystyle \binom {n + t - 1}{n - 1}$。</p><p>直接计算，复杂度 $O(m\log n)$（要分析成 $O(m\sqrt n)$ 没问题罢，但是感觉就是 $\log$ 的）。</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定 $n, m$，问有多少个长度为 $n$ 的序列和为 $m$ 并且异或和为 0。对 998244353 取模。$n, m\leq 5000$。</p><p>直接考虑按位 DP，注意每一位出现的次数必须为偶数，这样背包 + 组合数学可以做到 $O(n m\log m)$。另外还可以发现每一次操作完后末位必须为 0，否则肯定不合法。同时我们可以把最后一位去掉，可以做到 $O(nm)$。（好像原来也是 $O(nm)$ 的？</p><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>这个题之前的题似乎都比较一眼（</p><p>题意：给定一棵 $n$ 个点的树，你可以选定 $k$ 个关键点，使得 $\max_{i = 1} ^ n \min_{j = 1} ^ k \text{dis}(i, node_j)$ 最小。$n\leq 2\times 10 ^ 5$。</p><p>场上想到了二分 + 树形 DP，但是剩下的写不出来 /ll</p><p>看到这个最大最小，果断二分。</p><p>相当于我们已经给定了一个距离了，问至少要有多少个关键点。</p><p>注意到一棵子树只会对外面产生的影响由两种：一是关键点距离根距离 $&lt;d$，那么会对外面的一些选择产生影响。否则就是至少需要距离根不超过某一值的关键点。</p><p>注意到不同子树之间合并是容易的，反正可能细节比较多就是了。我直接贴代码。从 Um_nik 的写法中得到的，正数表示第一种情况，否则表示第二种情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[x] = add[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x]) &#123;</span><br><span class="line"><span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v, x);</span><br><span class="line">f[x] += f[v];</span><br><span class="line"><span class="keyword">if</span> (add[x] &gt; add[v]) std::<span class="built_in">swap</span>(add[x], add[v]);</span><br><span class="line"><span class="keyword">if</span> (add[x] &lt;= <span class="number">0</span> &amp;&amp; add[v] &gt; <span class="number">0</span> &amp;&amp; add[v] - add[x] &lt;= dis) add[x] = add[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (add[x] == -dis) f[x] ++, add[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (add[x] &gt; <span class="number">0</span>) add[x] ++;</span><br><span class="line"><span class="keyword">else</span> add[x] --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>), f[<span class="number">1</span>] + (add[<span class="number">1</span>] &lt; <span class="number">0</span>) &lt;= k; &#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：有 $n$ 个序列，每个序列长度为 $m_i$，两个人轮流拿数，每次可以把一个长度不为 1 的序列的首尾任意一个数拿走。在两个人都使用最优走法时（先手想让剩的 $n$ 个数和最大，后手相反），问剩的数的和。$n, \sum m\leq 2\times 10 ^ 5$。</p><p>假设所有数列的长度都是奇数，我们想一想该如何选。容易发现此时后手更有主动权，因为如果后手想要维持保留最终点的话时很容易做到的，而他也可以不这么选择。也就是说，如果先手选择的左半，后手也可以选择左半，此时后手肯定希望选到 $a(mid + 1)$，因为他不可能选到 $a(mid + 2)$（先手可以和他平衡），既然选择了删除左半，肯定是希望选到 $a(mid + 1)$。而如果先手先删除右半，那么后手就有机会选择 $a(mid - 1)$。这样的话，先手有能力去掉 $a(mid - 1)$ 和 $a(mid + 1)$ 中的较小值的，剩下的再和 $a(mid)$ 取 $\min$。这样的话，最后能取到的一定是 $\min(a(mid), \max(a(mid - 1), a(mid + 1)))$。</p><p>然后考虑有多个序列的。前面说到后手更有主动权，那么最开始的后手肯定并不希望自己成为先手，而这个又是可以实现的，就是和先手在同一条序列上操作。容易发现操作完后先后手顺序不变，所以直接简单的把所有加起来即可。</p><p>然后考虑有偶数情况的。注意到偶数长度的情况先手占有主动权。我们发现先手可以选择删前还是删后就可以变成一个偶数的情况了，而此时原来的先手就占有主动权了。删前还是删后是由删了过后偶数情况所决定的。</p><p>最后考虑有多个偶数情况的。容易发现由于单个序列先手有主动权，那么肯定先后手轮流先取偶数的序列。最后再考虑去玩过后，原来的先手有没有变成后手，两次的贡献不同。</p><p>时间复杂度 $O(n + \sum m)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, tot; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tot);</span><br><span class="line">sum += tot - <span class="number">1</span>;</span><br><span class="line">a[i].<span class="built_in">resize</span>(tot);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;x : a[i]) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">&#125;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (a[i].<span class="built_in">size</span>() &amp; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">int</span> mid = a[i].<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[i].<span class="built_in">size</span>() == <span class="number">1</span>) res += a[i][mid];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!(sum &amp; <span class="number">1</span>))</span><br><span class="line">res += std::<span class="built_in">min</span>(a[i][mid], std::<span class="built_in">max</span>(a[i][mid - <span class="number">1</span>], a[i][mid + <span class="number">1</span>]));</span><br><span class="line"><span class="keyword">else</span> res += std::<span class="built_in">max</span>(a[i][mid], std::<span class="built_in">min</span>(a[i][mid - <span class="number">1</span>], a[i][mid + <span class="number">1</span>]));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> mid = a[i].<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[i].<span class="built_in">size</span>() == <span class="number">2</span>)</span><br><span class="line">res += std::<span class="built_in">min</span>(a[i][mid - <span class="number">1</span>], a[i][mid]), vec.<span class="built_in">push_back</span>(<span class="built_in">abs</span>(a[i][mid] - a[i][mid - <span class="number">1</span>]));</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> v1 = std::<span class="built_in">max</span>(a[i][mid], std::<span class="built_in">min</span>(a[i][mid - <span class="number">1</span>], a[i][mid + <span class="number">1</span>])),</span><br><span class="line">v2 = std::<span class="built_in">max</span>(a[i][mid - <span class="number">1</span>], std::<span class="built_in">min</span>(a[i][mid - <span class="number">2</span>], a[i][mid]));</span><br><span class="line"><span class="keyword">if</span> (!(sum &amp; <span class="number">1</span>))</span><br><span class="line">v1 = std::<span class="built_in">min</span>(a[i][mid], std::<span class="built_in">max</span>(a[i][mid - <span class="number">1</span>], a[i][mid + <span class="number">1</span>])),</span><br><span class="line">v2 = std::<span class="built_in">min</span>(a[i][mid - <span class="number">1</span>], std::<span class="built_in">max</span>(a[i][mid - <span class="number">2</span>], a[i][mid]));</span><br><span class="line">res += std::<span class="built_in">min</span>(v1, v2), vec.<span class="built_in">push_back</span>(<span class="built_in">abs</span>(v1 - v2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (vec.<span class="built_in">size</span>() + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) vec.<span class="built_in">size</span>(); ++ i)</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) res += vec[i];</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;All Accepted。&lt;/p&gt;</summary>
    
    
    
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>HDU7201 Yet Another Easy Function Sum Problem</title>
    <link href="https://mydcwfy.github.io/2022/09/25/HDU7201/"/>
    <id>https://mydcwfy.github.io/2022/09/25/HDU7201/</id>
    <published>2022-09-25T11:42:31.000Z</published>
    <updated>2022-09-25T13:02:26.324Z</updated>
    
    <content type="html"><![CDATA[<p>题意：求</p><p>$$<br>\sum_{i = 1} ^ n \sum_{j = 1} ^ n H(ij) [\gcd(i, j) = 1]<br>$$<br>其中 $H(x)$ 表示 $x$ 所有质因子的乘积（去重后）。$n\leq 10 ^ 9$，$T(T\leq 5)$ 组数据，满足 $\sum n\leq 2\times 10 ^ 9$。20s。</p><span id="more"></span><p>类似 $\varphi$ 的，我们有一个这样的结论：<br>$$<br>H(ij) = \dfrac {H(i) H(j)}{H(\gcd(i, j))}<br>$$<br>对每个质因数分开看就好了。</p><p>首先看到 $\gcd$ 套路反演一下（所有除法默认下取整）：<br>$$<br>\begin{aligned}<br>&amp; \sum_{i = 1} ^ n \sum_{j = 1} ^ n H(ij) [\gcd(i, j) = 1] \\<br>=&amp; \sum_{i = 1} ^ n \sum_{j = 1} ^ n H(i)H(j) \sum_{d | i, d | j} \mu(d)\\<br>=&amp; \sum_{d = 1} ^ n \mu(d)(\sum_{i = 1} ^ {\frac nd} H(id)) ^ 2<br>\end{aligned}<br>$$<br>这个看样子就不能很好做，至少都得枚举 $d$，这样就不可能低于 $O(n)$。考虑对 $d$ 分治，钦定阈值 $B$，$d\leq B$ 就暴力枚举，否则我们换另外的方法。</p><h3 id="1-d-leq-B"><a href="#1-d-leq-B" class="headerlink" title="1. $d\leq B$"></a>1. $d\leq B$</h3><p>记 $F_1(n, d) = \sum_{i = 1} ^ n H(id)$，那么原式就可以表示成 $\sum_{d = 1} ^ B \mu(d)F_1 ^ 2(\dfrac nd, d)$。考虑如何计算 $F_1(n, d)$。</p><p>注意到有一个 $H(id)$ 很烦，使用上面的套路，我们开始展开：<br>$$<br>\begin{aligned}<br>F_1(n, d) =&amp; \sum_{i = 1} ^ n H(id)\\<br>=&amp; \sum_{k | d} \sum_{i = 1} ^ n [\gcd(i, d) = k] \dfrac {H(i)H(d)}{H(k)}\\<br>=&amp; \sum_{k | d} \dfrac 1{H(k)} \sum_{i = 1} ^ {\frac nk} [\gcd(i, \dfrac dk) = 1] H(ik)H(d)\\<br>=&amp; \sum_{k | d} \dfrac 1{H(k)}\sum_{i = 1} ^ {\frac nk} H(ik)H(d) \sum_{t | i, tk | d} \mu(t)\\<br>=&amp; \sum_{T | d}(\sum_{k | T} \dfrac {\mu(\frac Tk)}{H(k)}) (\sum_{i = 1} ^ {\frac nT} H(iT))\\<br>=&amp; \sum_{T | d} H_1(T) F_1(\dfrac nT, T)<br>\end{aligned}<br>$$<br>这里令 $H_1 = H \times \mu$，表示狄利克雷卷积。容易发现这是一个简单的递归函数，直接递归并记忆化即可。</p><p>注意边界是 $n = 0$（答案显然是 0）或者是 $d = 1$，此时我们相当于是求 $\sum_{i = 1} ^ n H(i)$。这个东西直接使用 Min_25 筛去处理，时间复杂度 $O(\dfrac {n ^ {\frac 34}}{\log n})$。</p><p>不考虑 Min_25 筛的复杂度，我们考虑所有可能的 $F_1(n, d)$ 和可能的转移数。容易发现一个 $F_1(n, d)$ 可能的转移数为 $O(\sigma(d))$。对于从外部调用的 $F_1(n, d)$，就是 $O(\sum_{i = 1} ^ B \sigma(i)) = O(B\log B)$。对于自调用的的 $F_1(m, t)$，一定满足 $m = \dfrac n{t ^ 2x}$，因为前面一个假设不来自外部调用的话，那么上一级的 $d$ 需要满足 $t|d$，我们可以分析得到 $O(\sum_{d = 1} ^ B \dfrac{\sqrt n}d) = O(\sqrt n\log n)$。类似的分析转移数可以得到 $O(\sqrt n\log ^ 2 n)$。总复杂度 $O(B\log n + \sqrt n\log ^ 2n)$，后半部分不管了（</p><h3 id="2-d-gt-B"><a href="#2-d-gt-B" class="headerlink" title="2. $d &gt; B$"></a>2. $d &gt; B$</h3><p>再看 $d$ 显然是不明智的选择，我们考虑把平方看作枚举 $i, j$，计算 $\sum_{d = 1} [id\leq n\land jd\leq n]H(id)H(jd)$。令 $G(m, i, j) = \sum_{d = 1} ^ m \mu(d) H(id)H(jd)$。那么就可以得到原式为：</p><p>$$<br>\sum_{i = 1} ^ {\frac nB} \sum_{j = 1} ^ {\frac nB} (G(\dfrac n{\max(i, j)}, i, j) - G(B, i, j))<br>$$<br>考虑如何计算 $G(m, i, j)$。仍然套路展开 $H(id)$ 和 $H(jd)$，大力计算：<br>$$<br>\begin{aligned}<br>&amp; \sum_{d = 1} ^ m \mu(d) H(id) H(jd)\\<br>=&amp; H(i)H(j)\sum_{d = 1} ^ m \mu(d) H ^ 2(d) \sum_{k_1 | i} [\gcd(i, d) = k_1] \sum_{k_2 | j} [\gcd(j, d) = k_2] \dfrac 1{H(k_1)H(k_2)}\\<br>=&amp; H(i) H(j) \sum_{k_1 | i} \sum_{k_2 | j} \dfrac 1{H(k_1)H(k_2)} \sum_{d = 1} ^ {\frac mk} \mu(dk) H ^ 2(dk) [\gcd(\dfrac i{k_1}, d) = 1][\gcd(\dfrac i{k_2}, d) = 1]\\<br>=&amp; H(i) H(j) \sum_{k_1 | i} \sum_{k_2 | j} \dfrac 1{H(k_1) H(k_2)} \sum_{d = 1} ^ {\frac mk} \mu(dk) H ^ 2(dk) \sum_{t_1 | d, t_1k_1 | i} \mu(t_1) \sum_{t_2 | d, t_2k_2 | j} \mu(t_2) \\<br>=&amp; H(i)H(j) \sum_{T_1 | i} \sum_{T_2 | j} (\sum_{k_1 | T_1} \dfrac {\mu(\frac {T_1}{k_1})}{H(k_1)})(\sum_{k_2 | T_2} \dfrac {\mu(\frac {T_2}{k_2})}{H(k_2)}) \sum_{d = 1} ^ {\frac mT} \mu(dT) H ^ 2(dT)<br>\end{aligned}<br>$$</p><p>上述式子中，$T = \text{lcm} (T_1, T_2)$，$k = \text{lcm} (k_1, k_2)$，最后一个仍然很难算，我们考虑再设一个函数 $F_2$ 来表示。令 $F_2(n, d)$ 为 $\sum_{i = 1} ^ n \mu(di) H ^ 2(di)$。这个和 $F_1$ 是比较类似的，我们就不做每一步的推导了，直接给结论：<br>$$<br>F_2(n, d) = \mu(d) H ^ 2(T) \sum_{T | d} \mu(k) F_2(\dfrac nT, T)<br>$$<br>同样，$F_2$ 的复杂度和 $F_1$ 分析的类似。不是很会分析了 /kk，据说是 $\tilde O(\dfrac {n}{\sqrt B})$。</p><h3 id="平衡规划与代码"><a href="#平衡规划与代码" class="headerlink" title="平衡规划与代码"></a>平衡规划与代码</h3><p>两边平衡一下，取 $B = n ^ {\frac 23}$，可以得到复杂度约为 $O(\dfrac {n ^ {\frac 34}}{\log n} + n ^ {\frac 23} \log n)$。卡卡常大概就可以过了（？）。</p><p>说几点代码细节：</p><ol><li>容易发现递归 $F_2$ 的时候 $\mu(t) = 0$ 可以直接返回。</li><li>$B$ 必须是 $n$ 的约数才能过，原因好像是交界处可能寄。</li><li>Min_25 可以写迭代，比较少见呢。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">H[<span class="number">1</span>] = mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) prime[cnt ++] = i, H[i] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; i * prime[j] &lt; N; ++ j) &#123;</span><br><span class="line">H[i * prime[j]] = H[i];</span><br><span class="line">st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">mu[i * prime[j]] = -mu[i], H[i * prime[j]] *= prime[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) iH[i] = <span class="built_in">qpow</span>(H[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mu[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (mu[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; i * j &lt; N; ++ j)</span><br><span class="line"><span class="built_in">adj</span>(H1[i * j] += iH[j] - Mod);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; i * j &lt; N; ++ j)</span><br><span class="line"><span class="built_in">adj</span>(H1[i * j] -= iH[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; i * j &lt; N; ++ j)</span><br><span class="line"><span class="keyword">if</span> (mu[i * j]) fac[i * j].<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getid</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &lt;= sq ? id1[x] : id2[n / x]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">loc</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">lower_bound</span>(a + <span class="number">1</span>, a + tot + <span class="number">1</span>, x, std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()) - a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sum1</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * (x + <span class="number">1LL</span>) / <span class="number">2</span> % Mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sum2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * (x + <span class="number">1LL</span>) % Mod * (x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) % Mod * (Mod + <span class="number">1</span>) / <span class="number">6</span> % Mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Min25_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sq = std::<span class="built_in">sqrt</span>(n), tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r, t; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = n / l, r = n / t;</span><br><span class="line">a[++ tot] = t;</span><br><span class="line"><span class="keyword">if</span> (t &lt;= sq) id1[t] = tot;</span><br><span class="line"><span class="keyword">else</span> id2[r] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i)</span><br><span class="line"><span class="built_in">adj</span>(sp1[i] = sp1[i - <span class="number">1</span>] + prime[i] - Mod), sp2[i] = (sp2[i - <span class="number">1</span>] + (LL) prime[i] * prime[i]) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) psum1[i] = <span class="built_in">sum1</span>(a[i]) - <span class="number">1</span>, psum2[i] = <span class="built_in">sum2</span>(a[i]) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i) &#123;</span><br><span class="line">LL le = (LL) prime[i] * prime[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>, p = prime[i]; j &lt;= tot &amp;&amp; a[j] &gt;= le; ++ j)</span><br><span class="line">psum1[j] = (psum1[j] + (LL) (sp1[i - <span class="number">1</span>] + Mod - psum1[<span class="built_in">getid</span>(a[j] / p)]) * p) % Mod,</span><br><span class="line">psum2[j] = (psum2[j] + (LL) (sp2[i - <span class="number">1</span>] + Mod - psum2[<span class="built_in">getid</span>(a[j] / p)]) * p * p) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>, x; j &lt;= tot; ++ j)</span><br><span class="line"><span class="built_in">adj</span>(f1[j] = psum1[j] - psum1[x = <span class="built_in">loc</span>(std::<span class="built_in">sqrt</span>(a[j]))]), <span class="built_in">adj</span>(f2[j] = psum2[x] - psum2[j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = cnt - <span class="number">1</span>; ~i; -- i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>, p = prime[i]; j &lt;= tot &amp;&amp; a[j] &gt;= (LL) p * p; ++ j) &#123;</span><br><span class="line">LL cur = p;</span><br><span class="line"><span class="type">int</span> v, nxt;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> e = <span class="number">1</span>; cur * p &lt;= a[j]; ++ e, cur *= p) &#123;</span><br><span class="line"><span class="type">int</span> nxt = a[j] / cur, v;</span><br><span class="line"><span class="keyword">if</span> (nxt &lt; p * p) <span class="built_in">adj</span>(v = psum1[<span class="built_in">getid</span>(nxt)] - sp1[i]);</span><br><span class="line"><span class="keyword">else</span> v = f1[<span class="built_in">getid</span>(nxt)];</span><br><span class="line">f1[j] = (f1[j] + (v + <span class="number">1LL</span>) * p) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((nxt = a[j] / p) &lt; p * p) <span class="built_in">adj</span>(v = sp2[i] - psum2[<span class="built_in">getid</span>(nxt)]);</span><br><span class="line"><span class="keyword">else</span> v = f2[<span class="built_in">getid</span>(nxt)];</span><br><span class="line"><span class="built_in">adj</span>(f1[j] += p - Mod);</span><br><span class="line">f2[j] = (f2[j] + (Mod - p * p) * (v + <span class="number">1LL</span>)) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot; ++ j) f1[j] ++, f2[j] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getF1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> H[d];</span><br><span class="line"><span class="keyword">if</span> (d == <span class="number">1</span>) <span class="keyword">return</span> f1[<span class="built_in">getid</span>(n)];</span><br><span class="line"><span class="keyword">if</span> (mf1[d].<span class="built_in">count</span>(n)) <span class="keyword">return</span> mf1[d][n];</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> T : fac[d])</span><br><span class="line">res = (res + (LL) H1[T] * <span class="built_in">getF1</span>(n / T, T)) % Mod;</span><br><span class="line"><span class="keyword">return</span> mf1[d][n] = (LL) res * H[d] % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getF2</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (d == <span class="number">1</span>) <span class="keyword">return</span> f2[<span class="built_in">getid</span>(n)];</span><br><span class="line"><span class="keyword">if</span> (!mu[d]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (mf2[d].<span class="built_in">count</span>(n)) <span class="keyword">return</span> mf2[d][n];</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k : fac[d])</span><br><span class="line"><span class="keyword">if</span> (mu[k] &gt; <span class="number">0</span>) <span class="built_in">adj</span>(res += <span class="built_in">getF2</span>(n / k, k) - Mod);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mu[k]) <span class="built_in">adj</span>(res -= <span class="built_in">getF2</span>(n / k, k));</span><br><span class="line">res = (LL) res * H[d] % Mod * H[d] % Mod;</span><br><span class="line"><span class="keyword">if</span> (mu[d] &lt; <span class="number">0</span>) <span class="built_in">adj</span>(res = -res);</span><br><span class="line"><span class="keyword">return</span> mf2[d][n] = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">Min25_init</span>();</span><br><span class="line">B = n / (<span class="type">int</span>) (std::<span class="built_in">pow</span>(n, <span class="number">1.</span> / <span class="number">3</span>) + <span class="number">1</span>), B = std::<span class="built_in">max</span>(B, <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, v; i &lt;= B; ++ i)</span><br><span class="line"><span class="keyword">if</span> (mu[i] &gt; <span class="number">0</span>) v = <span class="built_in">getF1</span>(n / i, i), res = (res + (LL) v * v) % Mod;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mu[i]) v = <span class="built_in">getF1</span>(n / i, i), res = (res + (LL) (Mod - v) * v) % Mod;</span><br><span class="line"><span class="type">int</span> lim = n / B;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> T1 = <span class="number">1</span>; T1 &lt;= lim; ++ T1)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> T2 = <span class="number">1</span>; T2 &lt;= lim; ++ T2) &#123;</span><br><span class="line">LL Lcm = (LL) T1 / <span class="built_in">Gcd</span>(T1, T2) * T2, mul = (LL) H1[T1] * H1[T2] % Mod, tmp;</span><br><span class="line"><span class="keyword">if</span> (!mu[Lcm]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = T1, ed = lim; i &lt;= ed; i += T1)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = T2; j &lt;= ed; j += T2)</span><br><span class="line">&#123;</span><br><span class="line">tmp = mul * H[i] % Mod * H[j] % Mod;</span><br><span class="line">res = (res + tmp * <span class="built_in">getF2</span>(n / std::<span class="built_in">max</span>(i, j) / Lcm, Lcm)) % Mod;</span><br><span class="line"><span class="keyword">if</span> (B &gt;= Lcm)</span><br><span class="line">res = (res + tmp * (Mod - <span class="built_in">getF2</span>(B / Lcm, Lcm))) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：求&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\sum_{i = 1} ^ n \sum_{j = 1} ^ n H(ij) [\gcd(i, j) = 1]&lt;br&gt;$$&lt;br&gt;其中 $H(x)$ 表示 $x$ 所有质因子的乘积（去重后）。$n\leq 10 ^ 9$，$T(T\leq 5)$ 组数据，满足 $\sum n\leq 2\times 10 ^ 9$。20s。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="平衡规划" scheme="https://mydcwfy.github.io/tags/%E5%B9%B3%E8%A1%A1%E8%A7%84%E5%88%92/"/>
    
    <category term="复杂度分析" scheme="https://mydcwfy.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
    <category term="Min_25 筛" scheme="https://mydcwfy.github.io/tags/Min-25-%E7%AD%9B/"/>
    
  </entry>
  
  <entry>
    <title>ARC Round#123</title>
    <link href="https://mydcwfy.github.io/2022/09/23/ARC-Round-123/"/>
    <id>https://mydcwfy.github.io/2022/09/23/ARC-Round-123/</id>
    <published>2022-09-23T13:57:11.000Z</published>
    <updated>2022-09-25T12:06:27.025Z</updated>
    
    <content type="html"><![CDATA[<p>已改 ABCD，E 太难写了 /tuu</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定 $a, b, c$ 三个数，操作一次可以对一个数 +1，问多少次操作后能变为一个等差数列。</p><p>考虑如果 $2b &gt; a + c$，显然只能提升 $c$ 来达成，否则提升 $b$ 是更优秀的选择。处理一下边界即可。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定 $a, b, c$ 三个长度为 $n$ 序列，要求任意序列内重排吗，使得满足 $a_i &lt; b_i &lt; c_i$ 的 $i$ 尽量多。求最大值。$n\leq 10 ^ 5$。</p><p>贪心即可，取最小的 $b_i &gt; a_i$，然后又取最小的 $c_i &gt; b_i$，没有就直接退出。</p><p>时间复杂度 $O(n\log n)$。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定一个数，他是好的当且仅当十进制下所有数都是 1、2、3 中的一个。给定 $n$，问 $n$ 最少可以由多少个好的数加起来构成。$T(T\leq 1000)$ 组数据，$n\leq 10 ^ {18}$。</p><p>场上 yy 的，好像和题解做法不太像。</p><p>假设我们先不考虑进位问题，那么对于每一位来说，都有一个取数个数的范围，也就是 $[\lceil\dfrac x3\rceil, x]$。如果这些区间交不为空，那么就取其中的最小值。容易发现不进位合法时一定是最小的情况。</p><p>下面考虑一下进位的问题。注意到我们一旦要从上一位偷一个 1 过来，到这里变成了 10，这样的话，这个取数个数的范围至少都是 4 了，这样就可以和前面的有交了。</p><p>直接暴力递归计算即可，时间复杂度应该是 $O(\log ^ 2 n)$ 的，反正很快就是了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">10</span>) <span class="keyword">return</span> (n + <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line">LL pre = <span class="built_in">solve</span>(n / <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (pre &gt; n % <span class="number">10</span>) <span class="keyword">return</span> std::<span class="built_in">max</span>(<span class="built_in">solve</span>(n / <span class="number">10</span> - <span class="number">1</span>), (n % <span class="number">10</span> + <span class="number">12</span>) / <span class="number">3</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> std::<span class="built_in">max</span>(pre, (n % <span class="number">10</span> + <span class="number">2</span>) / <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：将一个序列 $a$ 拆成两个序列 $b, c$ 的和，$b$ 不减，$c$ 不增，问这 $2n$ 个数绝对值的最小值。$n\leq 2\times 10 ^ 5$。</p><p>首先我们考虑假设已经知道了 $b_1, c_1$，如何按序构造出后面的项。</p><blockquote><p>如果 $a_i \geq a_{i - 1}$，则 $c_i$ 不变，$b_i$ 增加，否则 $b_i$ 不变，$c_i$ 减少。</p></blockquote><p>容易发现这样构造一定是最优的，因为如果 $a_i\geq a_{i - 1}$，让 $b_i$ 增加，$c_i$ 减少，这样肯定不会使绝对值变小，所以不优。</p><p>那么我们现在发现 $b_1, c_1$ 确定的时候我们可以找到一个合法的解。如果我们把 $b_1$ 看作变量并把 $b_1 = 0$ 带入计算得到 $b, c$，那么这就是一个 $2n$ 个绝对值相加的函数，具体的，就是 $\sum_{i = 1} ^ n |x + b_i| + |-x + c_i|$。</p><p>赛时 sb 了，我用一个 <code>std::map</code> 维护斜率和截距的实时变化。其实直接找到中位数做一做就好了。这就放一个赛时代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LL = <span class="type">__int128_t</span>;</span><br><span class="line"></span><br><span class="line">std::map&lt;LL, LL&gt; kmp, bmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">c[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt; a[i - <span class="number">1</span>]) b[i] = b[i - <span class="number">1</span>], c[i] = a[i] - b[i];</span><br><span class="line"><span class="keyword">else</span> c[i] = c[i - <span class="number">1</span>], b[i] = a[i] - c[i];</span><br><span class="line">LL del = <span class="number">1e25</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">kmp[-INF] -= <span class="number">1</span>, kmp[-b[i]] += <span class="number">2</span>, bmp[-INF] -= b[i], bmp[-b[i]] += <span class="number">2</span> * b[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">kmp[-INF] -= <span class="number">1</span>, kmp[c[i]] += <span class="number">2</span>, bmp[-INF] += c[i], bmp[c[i]] -= <span class="number">2</span> * c[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = std::<span class="built_in">next</span>(kmp.<span class="built_in">begin</span>()); iter != kmp.<span class="built_in">end</span>(); iter ++) &#123;</span><br><span class="line">iter-&gt;second += std::<span class="built_in">prev</span>(iter)-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = std::<span class="built_in">next</span>(bmp.<span class="built_in">begin</span>()); iter != bmp.<span class="built_in">end</span>(); iter ++) &#123;</span><br><span class="line">iter-&gt;second += std::<span class="built_in">prev</span>(iter)-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [x, k] : kmp) <span class="built_in">chkmin</span>(del, k * x + bmp[x]);</span><br><span class="line">std::cout &lt;&lt; del &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;已改 ABCD，E 太难写了 /tuu&lt;/p&gt;</summary>
    
    
    
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>ARC Round#127</title>
    <link href="https://mydcwfy.github.io/2022/09/23/ARC-Round-127/"/>
    <id>https://mydcwfy.github.io/2022/09/23/ARC-Round-127/</id>
    <published>2022-09-23T02:49:17.000Z</published>
    <updated>2022-09-23T13:47:22.165Z</updated>
    
    <content type="html"><![CDATA[<p>已改 ABCDE。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：记 $f(x)$ 表示 $x$ 十进制下前缀 1 的个数，给定 $n$，求 $\sum_{i = 1} ^ n f(i)$。$n\leq 10 ^ {15}$。</p><p>大概是数位 DP 模板题罢（</p><p>首先加上位数小于 $n$ 的位数的所有答案，容易发现可以预处理。</p><p>然后对于每一位考虑计算，假设前面 $n$ 的高位都是 1，如果当位为 0，那么这一位及更低的位都不可能出现前缀 1 了。</p><p>如果当位比 1 大的话，容易发现此时此位和低位的和已经可以计算了，而且和 $n$ 无关。具体的，其实就是所有 $t$ 位的答案。</p><p>时间复杂度 $O(\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> bit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">qpow</span>(<span class="number">10</span>, bit) &lt;= n) bit ++;</span><br><span class="line">LL cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bit; ++ i) cur += <span class="built_in">qpow</span>(<span class="number">10</span>, i);</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bit - <span class="number">1</span>; ++ i) res += a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, flag = <span class="literal">true</span>; i &lt;= bit; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="built_in">qpow</span>(<span class="number">10</span>, bit - i)) <span class="keyword">break</span>;</span><br><span class="line">flag &amp;= n &lt; <span class="number">2</span> * <span class="built_in">qpow</span>(<span class="number">10</span>, bit - i);</span><br><span class="line">n %= <span class="built_in">qpow</span>(<span class="number">10</span>, bit - i);</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="keyword">return</span> res + a[bit - i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (flag) res += (n + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定 $n, l$，需要构造 $3n$ 个长度为 $l$ 的字符串，满足 $\forall i\in [1, l]$，$3n$ 个字符串中 $s_i$ 是 <code>0, 1, 2</code> 的各占 $n$ 个，并且不存在两个字符串相同。另外需要保证字典序最大的字符串字典序最小。$l\leq 15, 3n\leq 3 ^ l$。</p><p>容易发现我们只需要构造开头为 2 的 $n$ 个长度为 $l$ 的字符串，按序推一下就可以相应的得到开头为 0 和 1 的字符串了。</p><p>那么现在问题就是我们需要 $n$ 个字符串使得字典序最大的最小，且不存在两两相同。直接 3 进制拆分即可，当然直接模拟也可以。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：有 $1\sim 2 ^ n - 1$ 的数二进制转换后按照字典序排列，问第 $x$ 个是哪个数。$x$ 和输出的数都使用二进制。$n\leq 10 ^ 6$。</p><p>首先考虑 $n = 3$ 的序列：<code>1, 10, 100, 101, 11, 110, 111</code>，一共有 7 个。注意到第二位的分布：第一个没有后面的位数，$2\sim 2 ^ {n - 1}$ 第二位是 0，$2 ^ {n - 1} - 1\sim 2 ^ n - 1$ 的第二位是 1。</p><p>注意到我们确定了第二位后，我们可以递归下去处理后面的位数。递归的方式如下：</p><ol><li>没有后面的位数，直接退出。</li><li>第二位是 0，对 $x$ 减 1，然后递归。</li><li>第二位是 1，对 $x$ 减 $2 ^ {n - 1}$，然后递归。</li></ol><p>注意到 $x$ 是二进制给出的，也就是说减 $2 ^ {n - 1}$ 是好做的，直接删除首位。但是减 1 没有好办法，但是我们发现暴力的复杂度是正确的，因为每在 $t$ 位（从低到高从 0 编号）退 1 的话，过 $O(2 ^ t)$ 次之后才可能再次贡献。也就是减 $n$ 次的复杂度是 $O(n)$ 的。</p><p>最后考虑如何判断第二位是什么。容易发现减完 1 / $2 ^ {n - 1}$ 之后为 0 了，直接退出就可以处理上述的第一种情况。另外，如果 $x = 2 ^ {n - 1}$，也可以直接退出。判断为 0 的方法就是维护最后一个非 0 位即可。</p><p>时间复杂度 $O(n)$。细节 yy 一下就差不多了（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">std::string s, res = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">s = std::<span class="built_in">string</span>(n - s.<span class="built_in">size</span>(), <span class="string">&#x27;0&#x27;</span>) + s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">while</span> (j &gt;= i &amp;&amp; s[j] == <span class="string">&#x27;0&#x27;</span>) -- j;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; j == i) &#123;</span><br><span class="line">res += <span class="string">&#x27;0&#x27;</span>, res += std::<span class="built_in">string</span>(n - i - <span class="number">2</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">res += <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">s[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span> ((++ j) &lt; n) s[j] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">j = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (j &gt;= i &amp;&amp; s[j] == <span class="string">&#x27;0&#x27;</span>) -- j;</span><br><span class="line"><span class="keyword">if</span> (j == i - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">res += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定两个长度为 $n$ 的数组 $a, b$，求：<br>$$<br>\sum_{i = 1} ^ n \sum_{j = i + 1} ^ n \min(a_i\oplus a_j, b_i\oplus b_j)<br>$$<br>$n\leq 2.5\times 10 ^ 5$，$a_i, b_i &lt; 2 ^ {18}$。</p><p>看题解其实感觉比较板，但是赛时 C 花了太久了，几乎没怎么想就 vp 结束了。</p><p>容易发现我们肯定是需要知道什么时候 $a_i\oplus a_j$ 小，什么时候 $b_i\oplus b_j$ 小。如果找到他们最高的不同位就好做了，我们判断一下就好了。又发现 $a_i\oplus a_j$ 和 $b_i \oplus b_j$ 最高的不同位就是 $a_i\oplus b_i\oplus a_j\oplus b_j$ 的最高位。</p><p>现在我们就可以把 $i, j$ 分离，令 $c_i = a_i\oplus b_i$，我们就是找 $c_i\oplus c_j$ 的最高不同位。现在我们比较 $c_i, c_j$ 的最高位是 0 还是 1，都是 0 的我们考虑递归，都是 1 的同理。也就是说只需要处理 $c_i, c_j$ 最高位不同的情况，也就是现在我们已经能区分 $a_i\oplus a_j$，$b_i\oplus b_j$ 的大小关系了。</p><p>我们考虑把数按照 $c_i$ 的最高位和 $a_i$ 的最高位分成 4 类。这样很容易区分出哪些是 $a_i\oplus a_j$ 更小，哪些是 $b_i\oplus b_j$ 更小。</p><p>现在我们已经去除了 $\min$，只需要考虑给定一个数组，就两两异或和。拆位贡献可做到 $O(n\log a)$。</p><p>最后分析复杂度，考虑每一个 $(a_i, b_i)$ 的 <code>std::pair</code>，会被使用 $O(\log a)$ 次，每次使用都是 $O(\log a)$ 的复杂度，时间复杂度 $O(n\log ^ 2 a)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; v1, std::vector&lt;<span class="type">int</span>&gt; v2, <span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v1.<span class="built_in">empty</span>() || v2.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cnt1[<span class="number">18</span>], cnt2[<span class="number">18</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">18</span>; ++ i) cnt1[i] = cnt2[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : v1)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> bit = <span class="number">0</span>; bit &lt; <span class="number">18</span>; ++ bit)</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;&gt; bit &amp; <span class="number">1</span>) cnt1[bit] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : v2)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> bit = <span class="number">0</span>; bit &lt; <span class="number">18</span>; ++ bit)</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;&gt; bit &amp; <span class="number">1</span>) cnt2[bit] ++;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = v1.<span class="built_in">size</span>(), m = v2.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> bit = <span class="number">0</span>; bit &lt; <span class="number">18</span>; ++ bit)</span><br><span class="line">res += ((LL) cnt1[bit] * (m - cnt2[bit]) + (LL) cnt2[bit] * (n - cnt1[bit])) &lt;&lt; bit;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; v, <span class="type">int</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (bit &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">calc</span>(v, v, a) / <span class="number">2</span>;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; to[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : v)</span><br><span class="line">to[c[i] &gt;&gt; bit &amp; <span class="number">1</span>][a[i] &gt;&gt; bit &amp; <span class="number">1</span>].<span class="built_in">push_back</span>(i);</span><br><span class="line">LL res = <span class="built_in">calc</span>(to[<span class="number">0</span>][<span class="number">0</span>], to[<span class="number">1</span>][<span class="number">0</span>], a) + <span class="built_in">calc</span>(to[<span class="number">0</span>][<span class="number">1</span>], to[<span class="number">1</span>][<span class="number">1</span>], a)</span><br><span class="line">+ <span class="built_in">calc</span>(to[<span class="number">0</span>][<span class="number">0</span>], to[<span class="number">1</span>][<span class="number">1</span>], b) + <span class="built_in">calc</span>(to[<span class="number">0</span>][<span class="number">1</span>], to[<span class="number">1</span>][<span class="number">0</span>], b);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : to[<span class="number">0</span>][<span class="number">1</span>]) to[<span class="number">0</span>][<span class="number">0</span>].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : to[<span class="number">1</span>][<span class="number">1</span>]) to[<span class="number">1</span>][<span class="number">0</span>].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">return</span> res + <span class="built_in">solve</span>(to[<span class="number">0</span>][<span class="number">0</span>], bit - <span class="number">1</span>) + <span class="built_in">solve</span>(to[<span class="number">1</span>][<span class="number">0</span>], bit - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>给定一个 $A + B$ 的序列，有 $A$ 个 1 和 $B$ 个 2，初始有一个空的集合 $s$。你需要对 $A$ 个 $1$ 分配一个 $[1, A]$ 的值使得不存在两个位置相等。对于每一个 1，你需要向 $s$ 中插入分配的值；否则你需要删除集合中最大的元素。问最后得到的集合 $s$ 有多少种可能，答案对 998244353 取模。$A\leq 5000$，$ B &lt; A$。</p><p>一个显然的想法是对每一个集合 $s$，判断其是否合法。</p><blockquote><p>假设能得到的最大的集合为 $t$，则集合合法的充要条件是 $s\leq t$（严格小于等于）。</p><p>证明：首先证明其必要性。容易发现如果不满足的话肯定是无法构造的，因为我们已经构造了最大的集合了。</p><p>然后证明其充分性。没看懂题解，但似乎是可以感性理解的（？</p></blockquote><p>有了上面的结论，我们先要找到最大的集合。容易发现我们肯定把更小的放前面，这样被删除的也偏小，留下的就自然更大了，于是就是在第 $i$ 个 1 的位置放 $i$ 即可得到最大的集合。</p><p>得到最大的集合过后，我们相当于是求合法的序列，有两个限制：$x_i &lt; x_{i + 1}$，$x_i\leq a_i$。这个显然是可以 $O(na)$ DP 完成的。</p><p>时间复杂度 $O(A ^ 2)$，代码不放了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;已改 ABCDE。&lt;/p&gt;</summary>
    
    
    
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P8541 「Wdoi-2」死亡之后愈发愉悦</title>
    <link href="https://mydcwfy.github.io/2022/09/13/Luogu-P8541/"/>
    <id>https://mydcwfy.github.io/2022/09/13/Luogu-P8541/</id>
    <published>2022-09-13T09:01:35.000Z</published>
    <updated>2022-09-13T09:23:18.827Z</updated>
    
    <content type="html"><![CDATA[<p>题意：交互题。定义 $f(x)$ 为严格大于 $x$ 的最小完全平方数，$g(x)$ 为小于等于 $x$ 的最大完全平方数。你需要猜一个 $\in[1, 10 ^ {12}]$ 中的一个数 $a$，用少于 64 次的询问得到答案，单次你给出 $t(t\in [0, 10 ^ 9])$，会返回 $a + t$ 是否满足 $x - g(x) &lt; f(x) - x$。$T(T\leq 2\times 10 ^ 3)$ 组数据，2s。</p><span id="more"></span><p>首先发现 $[i ^ 2, (i + 1) ^ 2)$ 中恰好有 $i + 1$ 个满足条件的数，$i$ 个不满足条件的数，分界线为 $i(i + 1)$（该数满足）。</p><p>然后考虑找到第一个不和 $a$ 性质相同的位置。如何找到呢？注意到我们其实并不知道上界，但是我们有一个关键的性质：如果 $a$ 和 $a + t$ 在同一段，那么 $a + 2t$ 和 $a$ 中间最多只有一个分界线。具体证明可以考虑段长不降的性质。于是我们可以靠这个进行倍增，找到最小的 $b$ 使得 $a + 2 ^ b$ 和 $a + 2 ^ {b + 1}$ 性质不同。这中间显然只有一个分界线，于是我们直接在这个区间进行二分即可。</p><p>如果我们找到这个分界线的位置，显然就可以求出 $a$ 了。根据上面的结论，我们可以类似地找到下一个分界线的位置即可，这样就可以询问 $4\log \sqrt a$ 次得到答案，需要 $\approx 80$ 次，还差一点。</p><p>注意到我们已经得到了最小的 $b$，也就是说这一段的长度肯定 $&gt; 2 ^ b$，我们没必要又从 1 开始倍增，直接从 $2 ^ b$ 即可。当然也可以使用上一段的长度倍增来寻找这一段的长度，参考代码是这种写法。容易发现这两个都只需要询问 $3\log \sqrt a$ 次，恰好通过。</p><p>实现的时候比较繁琐，可以用 <code>5, 7, 16, 30</code> 等几个数据调试，似乎能卡掉大部分 corner case。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mp.<span class="built_in">count</span>(x)) <span class="keyword">return</span> mp[x];</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; x &lt;&lt; std::endl, std::cin &gt;&gt; t;</span><br><span class="line"><span class="built_in">assert</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= (<span class="type">int</span>) <span class="number">1e9</span>);</span><br><span class="line"><span class="keyword">if</span> (!~t) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> mp[x] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mp.<span class="built_in">clear</span>();</span><br><span class="line"><span class="type">bool</span> st = <span class="built_in">query</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> mid, l, r, j1, j2, bit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">query</span>(<span class="number">1</span>) ^ st) j1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">query</span>(<span class="number">1</span> &lt;&lt; bit) == st) bit ++;</span><br><span class="line">l = <span class="number">1</span> &lt;&lt; (bit - <span class="number">1</span>), r = (<span class="number">1</span> &lt;&lt; bit) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">query</span>(mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ^ st) r = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid;</span><br><span class="line">&#125;</span><br><span class="line">j1 = l;</span><br><span class="line">&#125;</span><br><span class="line">j1 ++;</span><br><span class="line">bit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">query</span>((j1 &lt;&lt; bit) + j1) ^ st) bit ++;</span><br><span class="line">l = (bit == <span class="number">0</span> ? <span class="number">0</span> : (j1 &lt;&lt; (bit - <span class="number">1</span>))) + j1, r = (j1 &lt;&lt; bit) + j1 - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">query</span>(mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ^ st) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">j2 = l - j1 + <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;! &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (!st) -- j2, std::cout &lt;&lt; (LL) j2 * j2 - j1 &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">else</span> std::cout &lt;&lt; j2 * (j2 + <span class="number">1LL</span>) - j1 + <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：交互题。定义 $f(x)$ 为严格大于 $x$ 的最小完全平方数，$g(x)$ 为小于等于 $x$ 的最大完全平方数。你需要猜一个 $\in[1, 10 ^ {12}]$ 中的一个数 $a$，用少于 64 次的询问得到答案，单次你给出 $t(t\in [0, 10 ^ 9])$，会返回 $a + t$ 是否满足 $x - g(x) &amp;lt; f(x) - x$。$T(T\leq 2\times 10 ^ 3)$ 组数据，2s。&lt;/p&gt;</summary>
    
    
    
    
    <category term="倍增" scheme="https://mydcwfy.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
    <category term="二分" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>ARC148E ≥K</title>
    <link href="https://mydcwfy.github.io/2022/09/13/ARC148E/"/>
    <id>https://mydcwfy.github.io/2022/09/13/ARC148E/</id>
    <published>2022-09-13T08:09:57.000Z</published>
    <updated>2022-09-13T08:58:52.753Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一个长度为 $n$ 的序列，问有多少个重排序列的方案使得相邻两个数的和都 $\geq k$。$n\leq 2\times 10 ^ 5$，$a_i, k\leq 10 ^ 9$。</p><span id="more"></span><p>神仙构造 + 组合数学，只能复述题解了。</p><p>首先考虑如何生成这样的一个合法序列。考虑对序列排序，给定两个指针 $l, r$，使得 $[l, r]$ 里面的数都没有填入新的序列 $B$，其他的已经填入了。</p><p>我们分两种情况：如果 $A_l + A_r &lt; k$，就将 $A_l$ 插入 $B$，否则 $A_r$ 插入 $B$。两边的指针相应移动。</p><p>首先容易发现的结论是 $A_l &lt; \dfrac k2, A_r\geq \dfrac k2$。</p><p>假设 $A_l + A_r &lt; k$ 即插入 $l$ 的话，我们需要考虑哪些位置可以插入。假设满足 $\max\{B_{i}, B_{i + 1}\} + A_l\geq k$ 的位置有 $s$ 个。</p><blockquote><p>结论 1：满足 $\max\{B_i, B_{i + 1}\} + A_r\geq k$ 的数也恰好有 $s$ 个。</p><p>证明：假设 $A_l = \dfrac k2 - d(d &gt; 0)$，那么 $A_r \geq \dfrac k2 + d$（注意我们现在需要插入 $r$，一定满足 $A_l + A_r\geq k$），如果 $B_i$ 和 $B_{i + 1}$ 中间存在一个数 $&lt; \dfrac k2 - d$，那么不可能满足 $B_i + A_l \geq k$，同时也不满足 $B_i + A_r\geq k$（注意 $B_i$ 不可能等于 $A_l$，因为在插入第一个 $A_l$ 之前一定会先插入 $A_r$）。满足 $B_i + A_l\geq k$ 的一定满足 $B_i + A_r\geq k$，这个显然。</p></blockquote><p>那么我们就证明到了不管是 $A_l$ 还是 $A_r$ 插入，都恰好有 $s$ 个可插入的位置。</p><blockquote><p>结论 2：插入 $A_l$ 后会导致可插入位置 -1，插入 $A_r$ 后会导致可插入位置 +1。</p><p>首先证明除了插入位置外，其他位置的可插入性是不改变的。容易发现 $l$ 增加的话，一定是 $A_l + A_r &lt; k$ 了，那么原来合法的一定还合法，由于不合法的时候一定存在一个 $B_i$ 使得 $B_i \leq A_l$，因为 $A_l + A_r &lt; k$，所以不会再合法了。而如果 $r$ 减少的话，一定是满足 $A_l + A_r\geq k$，原来合法的一定还合法，原来不合法的一定满足 $B_i + A_r &lt; k$，所以也永远不合法。</p><p>现在考虑插入位置附近。容易发现 $A_l$ 插入后两边不能再插入，因为 $A_l + A_r &lt; k$ 了。而 $A_r$ 插入后两边都可以再插入，因为 $A_l + A_r \geq k$。</p></blockquote><p>有了上面的结论，我们很容易写出第一部分代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = n, c = <span class="number">1</span>; i &lt;= j;)</span><br><span class="line"><span class="keyword">if</span> (a[i] + a[j] &lt; lim) res = (LL) res * c -- % Mod, i ++;</span><br><span class="line"><span class="keyword">else</span> res = (LL) res * c ++ % Mod, j --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来考虑和原问题的对应关系。</p><p>注意到我们现在相当于求的是整个 $B$ 的生成过程有多少种。我们暂且把它称为三角阵。现在我们需要知道的就是一个三角阵会对应多少个 $B$。</p><p>我们考虑从一个合法的序列 $B$ 删除来得到三角阵。容易发现我们只需要找到距离 $\dfrac k2$ 最近的值删除一个即可（如果存在两个值距离相同，显然选大的）。注意到这和三角阵的生成过程恰好是逆序的。</p><p>注意到一个合法的 $B$ 每次删除值的时候值都是一定的，主要在于删除哪一个值。显然单次会删除 $cnt$ 个中的一个，然后 <code>cnt --</code>。</p><p>那么我们就是需要将刚刚得到的答案除以所有数字出现次数的逆元即可。时间复杂度 $O(n\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; lim;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = n, c = <span class="number">1</span>; i &lt;= j;)</span><br><span class="line"><span class="keyword">if</span> (a[i] + a[j] &lt; lim) res = (LL) res * c -- % Mod, i ++;</span><br><span class="line"><span class="keyword">else</span> res = (LL) res * c ++ % Mod, j --;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, ls = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (a[i] != a[i - <span class="number">1</span>]) res = (LL) res * infact[i - ls] % Mod, ls = i;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一个长度为 $n$ 的序列，问有多少个重排序列的方案使得相邻两个数的和都 $\geq k$。$n\leq 2\times 10 ^ 5$，$a_i, k\leq 10 ^ 9$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="结论" scheme="https://mydcwfy.github.io/tags/%E7%BB%93%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>ARC Round#148</title>
    <link href="https://mydcwfy.github.io/2022/09/13/ARC-Round-148/"/>
    <id>https://mydcwfy.github.io/2022/09/13/ARC-Round-148/</id>
    <published>2022-09-13T06:11:26.000Z</published>
    <updated>2022-09-13T08:09:26.920Z</updated>
    
    <content type="html"><![CDATA[<p>靠着 D 猜到结论好不容易上分了，第三次上黄（</p><p>赛后改题：All Accepted。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定 $n$ 个数，要你选择一个模数 $M$，问每个数 $\bmod M$ 过后不同的数最少都多少个，$M$ 不能选择 1。</p><p>容易发现当 $M = 2$ 的时候答案不超过 2。这是一个关键入口。</p><p>判断答案能不能为 1 是好判断的，差分数组的 $\gcd$ 不为 1 的话就存在。</p><p>否则答案一定为 2。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定一个长度为 $n$ 的只包含 <code>dp</code> 的字符串，你可以选择一个区间 $[l, r]$ 将该子串翻转。翻转的定义是 <code>d</code> 变 <code>p</code>，<code>p</code> 变 <code>d</code>，然后 <code>std::reverse</code>。问翻转后字典序最小是哪个串。$n\leq 5000$。</p><p>容易发现我们的翻转起始点就是第一个 <code>p</code> 的位置，我们将他变为 <code>d</code>，这样肯定比不变化该位置更优。另外我们把起始点设在该 <code>p</code> 前面的话，那么翻转区间的最后一定是一堆 <code>p</code>，否则不优。如果是一堆 <code>p</code> 的话，两端相当于没有交换，其实还是从 <code>p</code> 开始的。</p><p>这样可能的串就只有 $O(n)$ 个了，找到最小的即可，时间复杂度 $O(n ^ 2)$。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定一棵 $n$ 个点的无边权有根树，根为 1，每个点有一个正反面的硬币，翻转一个硬币会导致子树内的硬币都会翻转，代价为 1。$q$ 次询问，每次给定一个大小为 $m$ 的点集，求将集合内的硬币都翻转而不改变其他点状态的最小代价。$n, q, \sum m\leq 2\times 10 ^ 5$。</p><p>据说数据很水，最坏 $O(nq)$ 的直接过了（</p><p>容易发现一个点最多只会产生 1 的代价（注意这个点可能不在给定点集里）。</p><p>假设先不考虑上面的结论，我们直接翻转，假设集合只有 1 个点的话，我们需要对他本身和他的所有儿子都翻转一次，答案为 $1 + son(x)$。而多个点相较于 1 个点的差别在于如果一个集合内的点的父亲也在集合内的话，那么这个点原来应该翻转 2 次，现在不再需要翻转了，就可以减 2。</p><p>于是题目转化成了一个给定点集求父子关系对数。枚举儿子查父亲即可。时间复杂度 $O(n + \sum m)$ 或 $O(n + \sum m\log m)$。</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定 $2n$ 个数，Alice 和 Bob 分别任取其中的一个数，如果最后 Alice 取的数的和和 Bob 的和在 $\bmod m$ 意义下相同的话，Bob 胜，否则 Alice 胜。问最优情况下谁会胜利。$n\leq 2\times 10 ^ 5$。</p><p>先不考虑模意义，如果是和相同怎么做。容易发现每个数出现的次数必须是偶数，这样 Bob 才能获胜，否则 Alice 获胜。考虑证明，由于 Alice 取的时候，至少有两个数没有配对，Alice 取走一个过后，剩下的就和 Bob 取配对游戏，最后 Bob 一定会取到另外一个没有配对的数。这样两人的和并不同，Alice 胜。</p><p>现在我们需要考虑增加了模意义有什么变化。如果每个数出现次数是偶数的话，仍然还是 Bob 胜，但剩下的情况不太对劲。我们先给出一个 Hack：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 6</span><br><span class="line">1 4 2 5</span><br></pre></td></tr></table></figure><p>手玩一下，容易发现这个时候一定会是 Bob 胜利。</p><p>为什么呢？因为在 $\bmod m$ 意义下，$m$ 如果是偶数的话，并且 $\geq \dfrac m2$ 的数是偶数个的话，两个人最后拿到 $\geq \dfrac m2$ 的个数的奇偶性一定是相同的，而这就代表着只考虑 $\dfrac M2$ 的话两个人 $\bmod m$ 是相同的。这样我们就不能 $\bmod m$ 意义下了，而应该在$\bmod \dfrac m2$ 意义下做上面的结论了。</p><p>剩下的没有其他的情况需要特判了，简单的证一下。</p><ol><li>$m$ 是奇数：容易发现这时 Alice 最后一次选择的时候一定剩 2 个不同的数，选择一个数后会产生一个差值 $d$，而反过来选择差值就是 $m - d$。$d$ 和 $m - d$ 不相同，那么不可能两个数都是满足加上后变成 0 的，于是此时 Alice 胜。</li><li>$\geq \dfrac m2$ 有奇数个：让所有 $\geq \dfrac m2$ 的数都减去 $\dfrac m2$，我们只需要让 Alice 和 Bob 在 $\bmod m$ 意义下差值 $&lt; \dfrac m2$ 即可。这显然是容易办到的，而两个人选择的 $\geq \dfrac m2$ 的数的奇偶性不同，所以 Alice 一定胜利。</li></ol><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>咕咕咕。</p><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：提交答案题。给定一个计算器，有 26 个 <code>unsigned long long</code> 的存储功能，标号为 <code>A</code> 到  <code>Z</code>。满足的功能有 $a + b\to c$，$a\times b\to c$，$a\bmod 998244353\to c$。注意这里面的 $a, b$ 可以为给定常数。现在有两个数分别存储在 <code>A</code> 和 <code>B</code>，要求给定命令使得最后 <code>C</code> 存储的是 $a\times b\bmod 10 ^ 9 + 7$。</p><p>复述题解。</p><p>这个是完全不懂了，先给出一个 AT 的官方链接 <a href="https://en.wikipedia.org/wiki/Montgomery_modular_multiplication">Montgomery multiplication (Wikipedia)</a>。</p><p>令 $P_1 = 998244353, P_2 = 10 ^ 9 + 7$。</p><p>直接使用这个算法，我们相当于是可以在 $\bmod 2 ^ {64}$ 和 $\bmod P_1$ 下做乘法运算，现在需要求 $\bmod P_2$ 下的乘法。</p><p>直接给出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ULL = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P1 = <span class="number">998244353</span>, P2 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> _MP = P1 - <span class="built_in">qpow</span>(P2, P1 - <span class="number">2</span>, P1), M2 = (ULL) P1 * P1 % P2;</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">reduce</span><span class="params">(ULL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ULL ret = (x + (x % P1 * _MP % P1) * N) / P1;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= P2) x -= P2;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">mul</span><span class="params">(ULL a, ULL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = <span class="built_in">reduce</span>(a * M2), b = <span class="built_in">reduce</span>(b * M2);</span><br><span class="line">ULL c = a * b;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reduce</span>(<span class="built_in">reduce</span>(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_MP</code> 记为 $P_m$，满足 $P_mP_2\equiv -1\pmod {P_1}$，<code>M2</code> 满足 $M_2 = P_1 ^ 2\bmod P_2$。</p><p>原理不清楚，目前所知就是 <code>reduce(x)</code> 会返回 $xP_1 ^ {-1}\bmod P_2$，反正是这样了呢。现在考虑如何使用这段代码。</p><p>难点主要有两个：一是如何实现 $x / P_1$，二是如何实现 <code>if</code> 语句。</p><h4 id="实现-x-P-1"><a href="#实现-x-P-1" class="headerlink" title="实现 $x / P_1$"></a>实现 $x / P_1$</h4><p>假设我们把 <code>x + (x % P1 * _MP % P1) * P2</code> 在 $\bmod P_1$ 意义下，我们容易发现这个 $\bmod P_1$ 余 0 的。那么相当于就是直接除，而直接除可以使用乘 $P_1$ 在 $2 ^ {64}$ 的逆元完成。</p><h4 id="实现-if-语句"><a href="#实现-if-语句" class="headerlink" title="实现 if 语句"></a>实现 <code>if</code> 语句</h4><p>这个是难实现的，但是我们发现（？）执行该语句的次数很少，而且肯定不超过 $2N$。这样的话可以证明不超过 2 次执行 <code>reduce</code> 就可以代替该 <code>if</code> 语句了。</p><p>于是整个的就可以写作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">reduce</span>(a * M2), b = <span class="built_in">reduce</span>(b * M2);</span><br><span class="line">c = <span class="built_in">reduce</span>(<span class="built_in">reduce</span>(c));</span><br><span class="line">c *= M2, c = <span class="built_in">reduce</span>(<span class="built_in">reduce</span>(c));</span><br></pre></td></tr></table></figure><p>改成给的语言即可。代码附调试功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ULL = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> s128 = <span class="type">__int128_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Mod1 = <span class="number">998244353</span>, Mod2 = <span class="number">1e9</span> + <span class="number">7</span>, _MP = <span class="number">4915446</span>, M2 = <span class="number">320946142</span>;</span><br><span class="line"><span class="type">const</span> ULL Mul = <span class="number">996491785301655553ULL</span>;</span><br><span class="line">ULL a[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExGcd</span><span class="params">(s128 a, s128 b, s128 &amp;x, s128 &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, <span class="built_in">void</span>();</span><br><span class="line"><span class="built_in">ExGcd</span>(b, a % b, y, x), y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reduce</span><span class="params">(<span class="type">char</span> t)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*ULL ret = (t + (t % Mod1 * _MP % Mod1) * Mod2) / Mod1;</span></span><br><span class="line"><span class="comment">// if (ret &gt;= Mod2) ret -= Mod2;</span></span><br><span class="line"><span class="comment">t = ret;*/</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;rem Z &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[<span class="number">25</span>] = a[t - <span class="string">&#x27;A&#x27;</span>] % Mod1;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mul Z Z &quot;</span> &lt;&lt; _MP &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[<span class="number">25</span>] = a[<span class="number">25</span>] * _MP % Mod1;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;rem Z Z\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mul Z Z &quot;</span> &lt;&lt; Mod2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[<span class="number">25</span>] = a[<span class="number">25</span>] * Mod2;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;add Z Z &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[<span class="number">25</span>] += a[t - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mul &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot; Z &quot;</span> &lt;&lt; Mul &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[t - <span class="string">&#x27;A&#x27;</span>] = a[<span class="number">25</span>] * Mul;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; a[<span class="number">0</span>] &gt;&gt; a[<span class="number">1</span>];</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;40\nmul A A &quot;</span> &lt;&lt; M2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; <span class="string">&quot;mul B B &quot;</span> &lt;&lt; M2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[<span class="number">0</span>] *= M2, a[<span class="number">1</span>] *= M2;</span><br><span class="line"><span class="built_in">reduce</span>(<span class="string">&#x27;A&#x27;</span>), <span class="built_in">reduce</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mul C A B\n&quot;</span>;</span><br><span class="line">a[<span class="number">2</span>] = a[<span class="number">0</span>] * a[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">reduce</span>(<span class="string">&#x27;C&#x27;</span>), <span class="built_in">reduce</span>(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mul C C &quot;</span> &lt;&lt; M2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">a[<span class="number">2</span>] *= M2;</span><br><span class="line"><span class="built_in">reduce</span>(<span class="string">&#x27;C&#x27;</span>), <span class="built_in">reduce</span>(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">std::cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;靠着 D 猜到结论好不容易上分了，第三次上黄（&lt;/p&gt;
&lt;p&gt;赛后改题：All Accepted。&lt;/p&gt;</summary>
    
    
    
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>LOJ3276 「JOISC 2020 Day2」遗迹</title>
    <link href="https://mydcwfy.github.io/2022/09/13/LOJ3276/"/>
    <id>https://mydcwfy.github.io/2022/09/13/LOJ3276/</id>
    <published>2022-09-13T03:06:32.000Z</published>
    <updated>2022-09-13T04:29:22.787Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一个长度为 $2n$ 的序列，其中 $[1, n]$ 各出现 2 次，对序列一直操作直到不再变化：从前向后操作每一个数，如果这个数不为 0 并且在其后面存在一个和其相等的数，则将这个数减 1。可以证明最后存在 $n$ 个数不为 0。先给出这 $n$ 个位置，求有多少个序列满足操作后剩这些位置。$n\leq 600$。</p><span id="more"></span><p>这个的性质并不是很优美，我们考虑直接暴力 DP。</p><p>把这个序列 reverse 一下。</p><p>记 $f(i, j)$ 表示处理了前 $i$ 个，且前面 $[1, j]$ 在操作后已经存在的方案数（暗示 $j + 1$ 操作后不会存在）。注意到我们无法对 $[j + 2, n]$ 的出现情况压进状态，所以我们考虑如果出现了 $[j + 2, n]$ 的数，我们先视而不见，后面需要用到的时候再将其加入，因为他还用不到。</p><p>考虑转移，如果这一位最后剩的 0，那么这个数开始必须是 $[1, j]$。考虑计算 $[1, j]$ 中有多少个。注意一个问题是我们现在不好区分这个是第一还是第二，那么我们考虑<strong>对于所有相同的数假设不相同，最后再除以阶乘</strong>。假设前面有 $c$ 个位置最后不剩 0（包含 $i$），那么所有 $2j$ 个数已经被占领了 $i - 1 - c$，剩下的就都可以选择。</p><p>如果最后剩的 1，那么考虑两个情况：</p><ol><li>这个数最后剩的不是 $j + 1$。按照前面的理论，我们先不计算他的贡献。</li><li>最后剩的是 $j + 1$。假设现在变成了 $[1, j + k]$，那么 $[j + 2, j + k]$ 的所有数都需要在前面完成，并且 $i$ 位置最后必须剩 $j + 1$。注意到我们需要从剩下的 $c - j - 1$ 个数中选取 $k - 1$ 个数，并且让他最后覆盖 $[j + 2, j + k]$。容易发现这个式子只与 $k - 1$ 有关，假设为 $add_{k - 1, k - 1}$。剩下的 $i$ 位置，只能填 $[j + 1, k]$ 的数，我们可以从剩下的 $2k - (k - 1) = k + 1$ 个数中选择。于是可以得到转移方程为：</li></ol><p>$$<br>dp_{i - 1, j}\times \binom{c - j - 1}{k - 1} add_{k - 1, k - 1}(k + 1) \to dp_{i, j + k}<br>$$</p><p>最后一个问题就是如何计算 $add_{k, k}$。首先发现这个等价于计算 $k$ 个数，任意满足 $\in [i, k]$ 的数都 $\geq k - i + 1$，也就是满足 $[1, i]$ 的数都 $\leq i$。注意到一个数只能选择两次，考虑直接 DP。$add_{i, j}(j\leq i)$ 表示选择了 $[1, i]$ 的数，并且选了 $j$ 个的序列数。枚举 $i$ 是选择了 0、1、2 个容易得到转移方程：<br>$$<br>add_{i, j} = add_{i - 1, j} + 2j\times add_{i - 1, j - 1} + j(j - 1)\times add_{i - 1, j - 2}<br>$$<br>该部分复杂度 $O(n ^ 2)$。</p><p>主 DP 复杂度 $O(n ^ 3)$，总复杂度即为 $O(n ^ 3)$。注意我们开始把任意两个相同的数当作不同了，于是需要除以 $2 ^ n$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> x, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), key[<span class="number">2</span> * n - x + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">add[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = add[i][<span class="number">0</span>] = <span class="number">1</span>; j &lt;= i; ++ j) &#123;</span><br><span class="line">add[i][j] = (add[i - <span class="number">1</span>][j] + add[i - <span class="number">1</span>][j - <span class="number">1</span>] * <span class="number">2LL</span> * j) % Mod;</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">1</span>) add[i][j] = (add[i][j] + add[i - <span class="number">1</span>][j - <span class="number">2</span>] * (j - <span class="number">1LL</span>) * j) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (key[i]) &#123;</span><br><span class="line">++ cnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; ++ j) <span class="keyword">if</span> (f[i - <span class="number">1</span>][j])</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> nxt = <span class="number">1</span>; nxt + j &lt;= cnt; ++ nxt)</span><br><span class="line">f[i][j + nxt] = (f[i][j + nxt] + (LL) f[i - <span class="number">1</span>][j] * C[cnt - j - <span class="number">1</span>][nxt - <span class="number">1</span>] % Mod</span><br><span class="line">* add[nxt - <span class="number">1</span>][nxt - <span class="number">1</span>] % Mod * (nxt + <span class="number">1</span>)) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; ++ j)</span><br><span class="line"><span class="built_in">adj</span>(f[i][j] += f[i - <span class="number">1</span>][j] - Mod);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= cnt; ++ j)</span><br><span class="line">f[i][j] = (LL) f[i - <span class="number">1</span>][j] * (j - (i - <span class="number">1</span> - cnt)) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; (LL) f[<span class="number">2</span> * n][n] * <span class="built_in">qpow</span>(<span class="number">2</span>, Mod - <span class="number">1</span> - n) % Mod &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一个长度为 $2n$ 的序列，其中 $[1, n]$ 各出现 2 次，对序列一直操作直到不再变化：从前向后操作每一个数，如果这个数不为 0 并且在其后面存在一个和其相等的数，则将这个数减 1。可以证明最后存在 $n$ 个数不为 0。先给出这 $n$ 个位置，求有多少个序列满足操作后剩这些位置。$n\leq 600$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>UOJ710 【北大集训2021】魔塔 OL</title>
    <link href="https://mydcwfy.github.io/2022/08/30/UOJ710/"/>
    <id>https://mydcwfy.github.io/2022/08/30/UOJ710/</id>
    <published>2022-08-30T12:45:09.000Z</published>
    <updated>2022-08-30T13:16:18.568Z</updated>
    
    <content type="html"><![CDATA[<p>按序给出 $m$ 次操作或询问：</p><ol><li>新增元素 $(x, y, z)$，新给一个编号，获得他需要消耗 $a$ 点血量，获得他后可以获得 $b$ 点血量。</li><li>编号为 $k$ 的元素被删除了。保证不会重复利用或重复删除编号。</li><li>给定三元组 $(x, y, z)$，问要获得所有严格小于等于 $(x, y, z)$ 的元素需要开始时有多少血量才不会出现血量 $&lt; 0$ 的情况。</li></ol><p>元素和询问次数都不超过 $50000$，$x, y, z\leq 10000$，$a, b\leq 10 ^ 9$，2s。</p><span id="more"></span><p>首先我们需要考虑的问题是如果已经给出了所有严格小于等于的元素，如何排布使得开始的血量最少。</p><p>直接对这些元素排序，考虑微调来判断谁在前面，因为微调不会影响其他元素。假设当前 $(a_1, b_1)$ 和 $(a_2, b_2)$ 需要比较，那么假设 $a_1$ 在前，最少血量就是 $\max(a_1, a_1 + a_2 - b_1)$，$a_2$ 在前也是一样。比较这两个就可以了。</p><p>注意到这个判断先后顺序的是满足 <code>std::sort</code> 的要求（严格弱序）。我们可以观察到如果 $a_1 &lt; b_1$ 和 $a_2 &lt; b_2$ 不相同的话，是可以严格排序的（显然 $a &lt; b$ 的在前面）。而如果都是 $a &lt; b$ 的话，那么就是比较 $a_1$ 和 $a_2$。如果都是 $a \geq b$ 的话，就是比 $a_1 + a_2 - b_1$ 和 $a_1 + a_2 - b_2$ 也就是 $b_1$ 和 $b_2$。容易发现都是严格弱序的。</p><p>这样我们就解决了第一个问题，如何找到最小的方案。那么现在我们将所有元素按照该排序方式排序，离线询问，现在需要解决的问题就是如何找到所有满足严格小于等于的存在的元素。注意到存在其实也是时间轴上的偏序，于是就是解决偏序问题。</p><p>高维偏序问题，显然的 <code>std::bitset</code> 解法，复杂度 $O(\dfrac {n ^ 2}w)$ 也很对，但是注意到我们还是需要把每个元素取出来然后选择他，这样复杂度可能退化。考虑分块，我们每 $B$ 个一块，然后对一块所有可能的选择情况都预处理出来。然后再对于所有询问，这样就可以直接使用了。</p><p>假设 $n, m$ 同阶，复杂度显然是 $O(\dfrac {n2 ^ B}B + \dfrac{n ^ 2}B)$，取 $B = O(\log n)$ 即可得到复杂度为 $O(\dfrac{n ^ 2}{\log n})$。复杂度虽然比较奇怪，但事实是这算法能过。</p><p><strong>所有偏序需要一个一个加入统计答案的可以使用分块做到 $O(\dfrac{n ^ 2}{\log n})$。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> high(x) (31 - __builtin_clz(x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">LL nd, sum;</span><br><span class="line">Node <span class="keyword">operator</span> +(Node t) <span class="type">const</span> &#123;</span><br><span class="line">LL ret = std::<span class="built_in">max</span>(nd, nd - sum + t.nd);</span><br><span class="line"><span class="keyword">return</span> &#123;ret, ret + t.sum + sum - nd - t.nd&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Monster</span> &#123;</span><br><span class="line"><span class="type">int</span> st, ed, x, y, z;</span><br><span class="line">Node add;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(Monster t) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">min</span>(-add.nd, -add.nd + add.sum - t.add.nd)</span><br><span class="line">&gt; std::<span class="built_in">min</span>(-t.add.nd, -t.add.nd + t.add.sum - add.nd);</span><br><span class="line">&#125;</span><br><span class="line">&#125; mon[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y, z, at;</span><br><span class="line">Node res;</span><br><span class="line">&#125; q[N];</span><br><span class="line"><span class="type">int</span> m, n, Q, havx[S], havy[S], havz[S];</span><br><span class="line">Node ans[<span class="number">1</span> &lt;&lt; B | <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; len); ++ i)</span><br><span class="line">ans[i] = ans[i ^ (<span class="number">1</span> &lt;&lt; <span class="built_in">high</span>(i))] + mon[<span class="built_in">high</span>(i) + l].add;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; ++ i) havx[i] = havy[i] = havz[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l, id; i &lt;= r; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">havx[mon[i].x] |= <span class="number">1</span> &lt;&lt; (id = i - l);</span><br><span class="line">havy[mon[i].y] |= <span class="number">1</span> &lt;&lt; id, havz[mon[i].z] |= <span class="number">1</span> &lt;&lt; id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; S; ++ i)</span><br><span class="line">havx[i] |= havx[i - <span class="number">1</span>], havy[i] |= havy[i - <span class="number">1</span>], havz[i] |= havz[i - <span class="number">1</span>];</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">id1</span><span class="params">(r - l + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++ i) id1[i - l] = i;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">id2</span><span class="params">(id1)</span></span>;</span><br><span class="line">std::<span class="built_in">sort</span>(id1.<span class="built_in">begin</span>(), id1.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> mon[x].st &lt; mon[y].st; &#125;);</span><br><span class="line">std::<span class="built_in">sort</span>(id2.<span class="built_in">begin</span>(), id2.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> mon[x].ed &lt; mon[y].ed; &#125;);</span><br><span class="line"><span class="keyword">auto</span> iter1 = id1.<span class="built_in">begin</span>(), iter2 = id2.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, hav = <span class="number">0</span>; i &lt;= Q; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (iter1 != id1.<span class="built_in">end</span>() &amp;&amp; mon[*iter1].st &lt;= q[i].at) hav ^= <span class="number">1</span> &lt;&lt; (*(iter1 ++) - l);</span><br><span class="line"><span class="keyword">while</span> (iter2 != id2.<span class="built_in">end</span>() &amp;&amp; mon[*iter2].ed &lt;= q[i].at) hav ^= <span class="number">1</span> &lt;&lt; (*(iter2 ++) - l);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; (hav &amp; havx[q[i].x] &amp; havy[q[i].y] &amp; havz[q[i].z]) &lt;&lt; &#x27; &#x27; &lt;&lt; hav &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">q[i].res = q[i].res + ans[hav &amp; havx[q[i].x] &amp; havy[q[i].y] &amp; havz[q[i].z]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; m;</span><br><span class="line"><span class="type">char</span> op[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, id, t = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line"><span class="keyword">if</span> (*op == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">++ n, <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %lld %lld&quot;</span>, &amp;mon[n].x, &amp;mon[n].y, &amp;mon[n].z, &amp;mon[n].add.nd, &amp;mon[n].add.sum), mon[n].st = ++ t;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*op == <span class="string">&#x27;-&#x27;</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;id), mon[id].ed = ++ t;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*op == <span class="string">&#x27;?&#x27;</span>) ++ Q, <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;q[Q].x, &amp;q[Q].y, &amp;q[Q].z), q[Q].at = t;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!mon[i].ed) mon[i].ed = m + <span class="number">1</span>;</span><br><span class="line">std::<span class="built_in">sort</span>(mon + <span class="number">1</span>, mon + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) <span class="built_in">solve</span>(l, r = std::<span class="built_in">min</span>(n, l + B - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, q[i].res.nd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;按序给出 $m$ 次操作或询问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新增元素 $(x, y, z)$，新给一个编号，获得他需要消耗 $a$ 点血量，获得他后可以获得 $b$ 点血量。&lt;/li&gt;
&lt;li&gt;编号为 $k$ 的元素被删除了。保证不会重复利用或重复删除编号。&lt;/li&gt;
&lt;li&gt;给定三元组 $(x, y, z)$，问要获得所有严格小于等于 $(x, y, z)$ 的元素需要开始时有多少血量才不会出现血量 $&amp;lt; 0$ 的情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;元素和询问次数都不超过 $50000$，$x, y, z\leq 10000$，$a, b\leq 10 ^ 9$，2s。&lt;/p&gt;</summary>
    
    
    
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="分块" scheme="https://mydcwfy.github.io/tags/%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P5605 小A与两位神仙</title>
    <link href="https://mydcwfy.github.io/2022/08/29/Luogu-P5605/"/>
    <id>https://mydcwfy.github.io/2022/08/29/Luogu-P5605/</id>
    <published>2022-08-29T13:15:00.000Z</published>
    <updated>2022-08-30T12:42:17.058Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定模数 $m$ 和 $T$ 次询问，每次询问给定 $x, y$，问是否 $z$ 满足存在 $x ^ z\equiv y\pmod m$。$m\leq 10 ^ {18}, T\leq 2\times 10 ^ 4$，保证 $m$ 是奇质数的次幂，$\gcd(x, m) = \gcd(y, m) = 1$，3s。</p><span id="more"></span><p>首先考虑如何判断。仍然使用原根，令 $x = g ^ a$，$y = g ^ b$，那么就是问是否存在 $z$ 满足 $az\equiv b\pmod {\varphi(m)}$。那么显然合法的条件是 $b\bmod \gcd(a, \varphi(m)) = 0$。这样你就可以在单次 $O(\sqrt m)$ 的时间（？）求出，容易发现显然寄了。</p><p>注意到我们其实并不需要知道 $a, b$，我们其实只需要知道 $\gcd(a, \varphi(m))$ 和 $\gcd(b, \varphi(m))$ 即可。这个和什么有关呢？注意到 $x ^ {\frac m{\gcd(a, \varphi(m))}}$ 一定是 1，而且是最小的循环节。这样就是阶啊！显然我们需要使得 $\gcd(b, \varphi(m)) \bmod \gcd(a, \varphi(m)) = 0$，那么就是 $\dfrac m{\gcd(a, \varphi(m))} \bmod \dfrac m{\gcd(b, \varphi(m))} = 0$，也就是 $y$ 的阶整除 $x$ 的阶即可，记作 $\text{ord}(y) | \text{ord}(x)$。</p><p>现在问题转化为求阶了。一个显然的办法是枚举所有因数，看是否满足条件。这之前需要我们算出 $\varphi(m)$ 和他的分解。这个都需要使用 Pollard-Rho 算法，单次求解还是问题不大。然后枚举所有因数，复杂度为 $O(T\omega(n)\log n)$（检验需要快速幂），无法通过。</p><p>注意到一个数满足 $x ^ a\equiv 1\pmod m$，那么 $a$ 的所有倍数都满足。我们就可以每次试除每一个质因数即可，时间复杂度 $O(T\log ^ 2 n)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;LL&gt; <span class="title">Pollard_Rho</span><span class="params">(LL n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL m, T, p, ti = <span class="number">0</span>, tmp, x, y;</span><br><span class="line">std::cin &gt;&gt; m &gt;&gt; T;</span><br><span class="line">p = <span class="built_in">Pollard_Rho</span>(m).<span class="built_in">front</span>();</span><br><span class="line">tmp = m;</span><br><span class="line"><span class="keyword">while</span> (tmp % p == <span class="number">0</span>) tmp /= p, ti ++;</span><br><span class="line"><span class="keyword">if</span> (ti) pr.<span class="built_in">push_back</span>(&#123;p, ti - <span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">auto</span> vec = <span class="built_in">Pollard_Rho</span>(p - <span class="number">1</span>);</span><br><span class="line">tmp = p - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (LL &amp;x : vec)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (tmp % x == <span class="number">0</span>) t ++, tmp /= x;</span><br><span class="line">pr.<span class="built_in">push_back</span>(&#123;x, t&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> getord = [&amp;](LL x) &#123;</span><br><span class="line">LL ans = m / p * (p - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [p, cnt] : pr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (t &lt; cnt &amp;&amp; <span class="built_in">qpow</span>(x, ans / p, m) == <span class="number">1</span>) ++ t, ans /= p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">while</span> (T --) <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;x, &amp;y), <span class="built_in">puts</span>(<span class="built_in">getord</span>(x) % <span class="built_in">getord</span>(y) ? <span class="string">&quot;No&quot;</span> : <span class="string">&quot;Yes&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定模数 $m$ 和 $T$ 次询问，每次询问给定 $x, y$，问是否 $z$ 满足存在 $x ^ z\equiv y\pmod m$。$m\leq 10 ^ {18}, T\leq 2\times 10 ^ 4$，保证 $m$ 是奇质数的次幂，$\gcd(x, m) = \gcd(y, m) = 1$，3s。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="离散对数" scheme="https://mydcwfy.github.io/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"/>
    
    <category term="结论" scheme="https://mydcwfy.github.io/tags/%E7%BB%93%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>CF103102H AND = OR</title>
    <link href="https://mydcwfy.github.io/2022/08/29/CF103102H/"/>
    <id>https://mydcwfy.github.io/2022/08/29/CF103102H/</id>
    <published>2022-08-29T12:41:05.000Z</published>
    <updated>2022-08-29T13:08:10.640Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一个长度为 $n$ 的序列，$q$ 次给出 $l, r$，问 $[l, r]$ 区间能否拆成两个集合使得第一个集合的 OR 是第二个集合的 AND。$n, q\leq 10 ^ 5$，$0\leq a_i &lt; 2 ^ {30}$，3s，1GB。</p><span id="more"></span><p>首先考虑一个结论：</p><blockquote><p>如果合法，假设两个集合 OR/AND 的值 $mid$ 满足 $|mid| = x$，则一定存在一种方案，使得 $|v| &lt; x$ 的所有 $v$（$|v|$ 表示 $v$ 中 1 的个数）都放在 OR 里面，$|v| &gt; x$ 的所有 $v$ 都放在 AND 里面。</p><p>证明：容易发现如果 $|v| &gt; x$ 的放在 OR 里面，那么 OR 的结果一定 满足 $|v| &gt; x$，就不可能合法。$|v| &lt; x$ 放在 AND 同理。</p></blockquote><p>那么对于每次询问，考虑枚举 $x$，那么按照该方式，所有 $|v|&lt; x$ 的都放在 OR 里面。求出这些所有的 OR 可以把每个数按照 $|v|$ 放入对应的线段树，然后查一下前缀即可。AND 同理。</p><p>最后注意一下细节即可。一个可能的合法方案是枚举 $x$，$|v| &lt; x$ 的 OR 和 $|v| \geq x$ 的 AND 相同。另外一种方案是 $|v|\leq x$ 的 OR 和 $|v|\geq x$ 的 AND 相同，并且 $|v| = x$ 的个数不少于两个。容易发现如果满足前面的条件，所有满足 $|v| = x$ 的 $v$ 都相同。于是上面这个是对的。</p><p>用线段树维护一下即可。时间复杂度 $O(n\log ^ 2n + q\log ^ 2 n)$，空间复杂度 $O(n\log n)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> le[<span class="number">31</span>], ri[<span class="number">31</span>], prehav[<span class="number">31</span>], sufhav[<span class="number">31</span>], hav[<span class="number">31</span>];</span><br><span class="line">le[<span class="number">0</span>] = orseg[<span class="number">0</span>].<span class="built_in">query</span>(l, r), prehav[<span class="number">0</span>] = havseg[<span class="number">0</span>].<span class="built_in">query</span>(l, r);</span><br><span class="line">ri[<span class="number">30</span>] = andseg[<span class="number">30</span>].<span class="built_in">query</span>(l, r), sufhav[<span class="number">30</span>] = havseg[<span class="number">30</span>].<span class="built_in">query</span>(l, r);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++ i)</span><br><span class="line">le[i] = le[i - <span class="number">1</span>] | orseg[i].<span class="built_in">query</span>(l, r), prehav[i] = prehav[i - <span class="number">1</span>] | (hav[i] = havseg[i].<span class="built_in">query</span>(l, r));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">29</span>; ~i; -- i)</span><br><span class="line">ri[i] = ri[i + <span class="number">1</span>] &amp; andseg[i].<span class="built_in">query</span>(l, r), sufhav[i] = sufhav[i + <span class="number">1</span>] | hav[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &amp;&amp; prehav[i - <span class="number">1</span>] &amp;&amp; sufhav[i] &amp;&amp; le[i - <span class="number">1</span>] == ri[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">auto</span> iter = std::<span class="built_in">lower_bound</span>(app[i].<span class="built_in">begin</span>(), app[i].<span class="built_in">end</span>(), l);</span><br><span class="line"><span class="keyword">if</span> (iter == app[i].<span class="built_in">end</span>() || *iter &gt; r || nxt[i][iter - app[i].<span class="built_in">begin</span>()] &lt;= r) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> ccnt = std::<span class="built_in">upper_bound</span>(app[i].<span class="built_in">begin</span>(), app[i].<span class="built_in">end</span>(), r) - iter;</span><br><span class="line"><span class="keyword">if</span> (le[i] == ri[i] &amp;&amp; ccnt &gt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cerr &lt;&lt; std::<span class="built_in">abs</span>(&amp;mem1 - &amp;mem2) / <span class="number">1048576.</span> &lt;&lt; <span class="string">&quot; MB\n&quot;</span>;</span><br><span class="line"><span class="type">int</span> q, l = <span class="number">2</span>, r = n - <span class="number">1</span>;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) app[__builtin_popcount(a[i])].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++ i) &#123;</span><br><span class="line">nxt[i].<span class="built_in">resize</span>(app[i].<span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">if</span> (!app[i].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">nxt[i].<span class="built_in">back</span>() = n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = app[i].<span class="built_in">size</span>() - <span class="number">2</span>; ~j; -- j)</span><br><span class="line"><span class="keyword">if</span> (a[app[i][j]] != a[app[i][j + <span class="number">1</span>]]) nxt[i][j] = app[i][j + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> nxt[i][j] = nxt[i][j + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++ i) orseg[i].<span class="built_in">build</span>(n), andseg[i].<span class="built_in">build</span>(n), havseg[i].<span class="built_in">build</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;x : app[i]) orseg[i].<span class="built_in">modify</span>(x, a[x]), andseg[i].<span class="built_in">modify</span>(x, a[x]), havseg[i].<span class="built_in">modify</span>(x, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line"><span class="built_in">puts</span>(<span class="built_in">query</span>(l, r) ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一个长度为 $n$ 的序列，$q$ 次给出 $l, r$，问 $[l, r]$ 区间能否拆成两个集合使得第一个集合的 OR 是第二个集合的 AND。$n, q\leq 10 ^ 5$，$0\leq a_i &amp;lt; 2 ^ {30}$，3s，1GB。&lt;/p&gt;</summary>
    
    
    
    
    <category term="线段树" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="结论" scheme="https://mydcwfy.github.io/tags/%E7%BB%93%E8%AE%BA/"/>
    
  </entry>
  
</feed>
