<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mydcwfy&#39;s Blog</title>
  
  
  <link href="https://mydcwfy.github.io/atom.xml" rel="self"/>
  
  <link href="https://mydcwfy.github.io/"/>
  <updated>2022-06-24T16:20:50.576Z</updated>
  <id>https://mydcwfy.github.io/</id>
  
  <author>
    <name>mydcwfy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Luogu P4827 Crash 的文明世界</title>
    <link href="https://mydcwfy.github.io/2022/06/24/Luogu-P4827/"/>
    <id>https://mydcwfy.github.io/2022/06/24/Luogu-P4827/</id>
    <published>2022-06-24T13:01:58.000Z</published>
    <updated>2022-06-24T16:20:50.576Z</updated>
    
    <content type="html"><![CDATA[<p>斯特林数简单题。</p><span id="more"></span><p>题意：给定一棵树，边权都为 1，对于每一个点 $x$，求 $\sum_{i = 1} ^ n \text{dist}(x, i) ^ k$。$n\leq 5\times 10 ^ 4$，$k\leq 150$。</p><p>$k$ 次方不好使用组合意义，我们可以考虑利用第二类斯特林数弄出一个组合数：<br>$$<br>\begin{aligned}<br>x ^ k =&amp; \sum_{i = 0} ^ k {k\brace i} \binom xi i!<br>\end{aligned}<br>$$<br>那么我们可以求出 $\binom xi$，然后最后利用这个式子计算即可。第二类斯特林数直接 $O(k ^ 2)$ 递推即可。</p><p>现在考虑如何求出 $\binom xi$。先考虑暴力以每一个点为根 dfs。容易发现这个其实相当于在一条路径上选出 $i$ 条边的方案数。而这个可以通过简单的树形 DP 求出。具体的，考虑 $f(i)$ 表示已经选了 $i$ 条边的方案数，然后新加入一条边枚举其选不选从而做到 $O(k)$ 转移。</p><p>后面的优化思路就很显然了，使用换根 DP 即可做到 $O(nk)$ 的时间复杂度，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a[K];</span><br><span class="line"><span class="built_in">Node</span>() : a&#123;&#125; &#123;&#125;</span><br><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> a[x]; &#125;</span><br><span class="line">Node&amp; <span class="keyword">operator</span> +=(Node t) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++ i) <span class="built_in">adj</span>(a[i] += t[i] - Mod);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node&amp; <span class="keyword">operator</span> -() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++ i) <span class="built_in">adj</span>(a[i] = -a[i]);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node <span class="keyword">operator</span> +(Node t) <span class="keyword">const</span> &#123; <span class="keyword">return</span> t += *<span class="keyword">this</span>; &#125;</span><br><span class="line">Node <span class="keyword">operator</span> -(Node t) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *<span class="keyword">this</span> + -t; &#125;</span><br><span class="line"><span class="function">Node <span class="title">nxt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node res = *<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i) <span class="built_in">adj</span>(res[i] += a[i - <span class="number">1</span>] - Mod);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125; f1[N], f2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f1[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (v ^ fa) <span class="built_in">dfs1</span>(v, x), f1[x] += f1[v].<span class="built_in">nxt</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (fa) f2[x] = (f1[fa] - f1[x].<span class="built_in">nxt</span>() + f2[fa]).<span class="built_in">nxt</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (v ^ fa) <span class="built_in">dfs2</span>(v, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">g[u].<span class="built_in">push_back</span>(v), g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>), <span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">Node sta = f1[i] + f2[i];</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++ i)</span><br><span class="line">res = (res + (LL) S[k][i] * sta[i] % Mod * fact[i]) % Mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;斯特林数简单题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="斯特林数" scheme="https://mydcwfy.github.io/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P4707 重返现世</title>
    <link href="https://mydcwfy.github.io/2022/06/24/Luogu-P4707/"/>
    <id>https://mydcwfy.github.io/2022/06/24/Luogu-P4707/</id>
    <published>2022-06-24T11:44:32.000Z</published>
    <updated>2022-06-24T16:21:42.475Z</updated>
    
    <content type="html"><![CDATA[<p>有趣的 DP 优化 min-max 容斥。</p><span id="more"></span><p>题意：给定 $n$ 个物品，每一时刻有 $\dfrac {p(i)}m$ 的概率出现 $i$，问出现 $k$ 中出现 $k$ 中物品的期望。$n\leq 1000$，$m\leq 10 ^ 4$，$|k - n|\leq 10$。</p><p>首先考虑答案即为 $n$ 个物品出现时间第 $k$ 小的期望。注意到我们需要利用限制条件 $|k - n|\leq 10$，所以我们将其转化为 $k$ 大问题，则 $k\leq 11$。</p><p>考虑扩展 min-max 反演，我们可以得到以下式子：<br>$$<br>\text{kth}\max(S) = \sum_{T\subseteq S} (-1) ^ {|T| - k} \binom{T - 1}{k - 1} \min(T)<br>$$<br>考虑如何计算所有的 $\min(T)$，那么肯定是 $\dfrac{m}{\sum_{i\in T}p(i)}$，因为是概率的倒数。</p><p>但是枚举 $T$ 是 $O(2 ^ n)$ 的，不可接受。注意到答案只与 $|T|, \sum_{i\in T}p(i)$ 有关，而这两个变量分别是 $O(n), O(m)$ 的，考虑按照这个 DP。</p><p>记录 $f(i, j)$ 表示选了 $i$ 个元素，他们的和是 $j$ 的方案数和。一次枚举每一个物品，容易得到 $O(n ^ 2m)$ 的转移，但还是无法通过。</p><p>注意到 $k$ 很小，但是我们还没有利用到。那么，我们需要去掉一维，然后把 $k$ 压进去，这样做到 $O(nmk)$ 或者 $O(n ^ 2k)$ 的复杂度才可以通过。</p><p>但是 $\sum_{i\in T}p(i)$ 这一维是在分母上，压进去很不好转移，我们尝试把 $|T|$ 去掉。记录 $g(i, j)$ 表示如果 $k = i$，和为 $j$ 的答案，不需要最后一项 $\dfrac mj$ 的贡献。</p><p>那么我如果要选当前物品的话，那么 $|T|$ 就会 +1，看一下前面的 $(-1) ^ {|T| - k}\binom{|T| - 1}{k - 1}$ 会有什么变化。<br>$$<br>\begin{aligned}<br>&amp;(-1) ^ {|T| - k}\binom{|T| - 1}{k - 1}\\<br>=&amp; (-1) ^ {|T| - k} (\binom{|T| - 2}{k - 1} + \binom{|T|  - 2}{k - 2})\\<br>=&amp; -(-1) ^ {|T| - k - 1}\binom{|T| - 2}{k - 1} + (-1) ^ {|T| - k}\binom{|T| - 2}{k - 2}<br>\end{aligned}<br>$$<br>通过裂项组合数，我们发现其实裂项开的两项和原式形式是完全相同的，只不过参数发生了变化，一个是 $|T| - 1, k$，另一个是 $|T| - 1, k - 1$。而恰好 $|T| - 1$ 就是我们前面计算所得到的，那么这两项都可以由计算得到的 $g$ 来表示！</p><p>我们很轻松的得到 $g(i, j)$ 如果要选当前物品的话，我们其实可以由 $-g(i - 1, j - cur)$ 和 $g(i, j - cur)$ 得到。</p><p>那么这么做下去，剩下的思路就是按照这个转移，然后算完后统计一下答案即可。时间复杂度 $O(nmk)$（原题的 $k$ 被替换了），可以通过。注意空间复杂度也为 $O(nmk)$，需要滚动数组。</p><p><strong>min-max 反演很多都只是一步，后面的步骤需要根据 min-max 发言的结果进一步 DP 等优化</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; m, k = n - k + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) std::cin &gt;&gt; p[i];</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> sum = <span class="number">0</span>; sum &lt;= m; ++ sum) f[i &amp; <span class="number">1</span>][j][k] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// f[i &amp; 1][0][0] = 1;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> sum = <span class="number">0</span>; sum &lt;= m; ++ sum)</span><br><span class="line">&#123;</span><br><span class="line">f[i &amp; <span class="number">1</span>][j][sum] = f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j][sum];</span><br><span class="line"><span class="keyword">if</span> (j &amp;&amp; sum &gt;= p[i])</span><br><span class="line"><span class="built_in">adj</span>(<span class="built_in">adj</span>(f[i &amp; <span class="number">1</span>][j][sum] += f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j - <span class="number">1</span>][sum - p[i]] - Mod)</span><br><span class="line">-= f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j][sum - p[i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> sum = <span class="number">1</span>; sum &lt;= m; ++ sum)</span><br><span class="line">res = (res + (LL) f[n &amp; <span class="number">1</span>][k][sum] * <span class="built_in">qpow</span>(sum) % Mod * m) % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有趣的 DP 优化 min-max 容斥。&lt;/p&gt;</summary>
    
    
    
    
    <category term="min-max 容斥" scheme="https://mydcwfy.github.io/tags/min-max-%E5%AE%B9%E6%96%A5/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>CF1054H Epic Convolution</title>
    <link href="https://mydcwfy.github.io/2022/06/24/CF1054H/"/>
    <id>https://mydcwfy.github.io/2022/06/24/CF1054H/</id>
    <published>2022-06-24T02:15:37.000Z</published>
    <updated>2022-06-24T02:31:15.633Z</updated>
    
    <content type="html"><![CDATA[<p>Editorial 的做法似乎太复杂了？</p><span id="more"></span><p>题意：给出 $a, b$ 序列，求：<br>$$<br>\sum_{i = 0} ^ {n - 1} a_i b_j c ^ {i ^ 2j ^ 3}<br>$$<br>对 $P = 490019$ 取模的结果。$n, m\leq 10 ^ 5$，$a_i, b_i\leq 1000$。</p><p>其实有非常简洁的做法啊……</p><p>考虑如果是下面这种形式怎么做：<br>$$<br>\sum_{i = 0} ^ {n - 1} \sum_{j = 0} ^ {m - 1} a_ib_j c ^ {ij}<br>$$<br>这个我们在 <a href="/2022/06/21/BlueStein-Algorithm/#more">BlueStein 算法</a> 中提到过，就是 Chirp-Z 变换，把 $ij$ 拆成 $\binom{i + j}2 - \binom i2 - \binom j2$，可以在 $O(n\log n)$ 的时间内解决。</p><p>现在考虑计算原式。一个显然的想法就是我们还是替换成上面的类型。于是，我们把 $a_i$ 贡献到 $i \times i$ 的位置，把 $b_j$ 贡献到 $j\times j\times j$ 的位置。但是注意到贡献的位置 $\bmod P - 1$ 相同则贡献相同，于是只需要贡献到 $i ^ 2\bmod P - 1$ 的位置即可，$j ^ 3$ 同理。</p><p>最后我们直接按照上面的做法直接暴力变换，时间复杂度 $O(P\log P)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m, c;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line"><span class="function">poly <span class="title">a</span><span class="params">(Mod - <span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(Mod - <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; n; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), <span class="built_in">adj</span>(a[(LL) i * i % (Mod - <span class="number">1</span>)] += x - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; m; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), <span class="built_in">adj</span>(b[(LL) i * i * i % (Mod - <span class="number">1</span>)] += x - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mod - <span class="number">1</span>; ++ i)</span><br><span class="line">a[i] = (LL) a[i] * <span class="built_in">qpow</span>(c, Mod - <span class="number">1</span> - i * (i - <span class="number">1LL</span>) / <span class="number">2</span> % (Mod - <span class="number">1</span>)) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Mod - <span class="number">1</span>; ++ i)</span><br><span class="line">b[i] = (LL) b[i] * <span class="built_in">qpow</span>(c, Mod - <span class="number">1</span> - i * (i - <span class="number">1LL</span>) / <span class="number">2</span> % (Mod - <span class="number">1</span>)) % Mod;</span><br><span class="line">a = a * b;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, ed = a.<span class="built_in">size</span>(); i &lt; ed; ++ i)</span><br><span class="line">a[i] = (LL) a[i] * <span class="built_in">qpow</span>(c, i * (i - <span class="number">1LL</span>) / <span class="number">2</span> % (Mod - <span class="number">1</span>)) % Mod;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : a) <span class="built_in">adj</span>(res += x - Mod);</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Editorial 的做法似乎太复杂了？&lt;/p&gt;</summary>
    
    
    
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>LOJ3728 [SNOI2022]军队</title>
    <link href="https://mydcwfy.github.io/2022/06/23/LOJ3728/"/>
    <id>https://mydcwfy.github.io/2022/06/23/LOJ3728/</id>
    <published>2022-06-23T08:34:15.000Z</published>
    <updated>2022-06-23T09:36:21.253Z</updated>
    
    <content type="html"><![CDATA[<p>怎么省选题也出 lxl 的各种分块啊？</p><span id="more"></span><p>题意：给定 $n$ 个物品，每个物品有一个颜色和权值，有三种操作：将 $[l, r]$ 所有颜色为 $x$ 的变为颜色 $y$；将 $[l, r]$ 所有颜色为 $x$ 的权值加 $v$；询问 $[l, r]$ 的区间和。$n, m\leq 2.5\times 10 ^ 5$，6s，允许离线。</p><p>显然一眼 lxl Ynoi 题目，估计是没有 $\text{poly}\log$，考虑分块。</p><p>我们对于当前块维护一个并查集，用来维护每一个点的颜色是什么。</p><p>大概思路就是整块直接把当前并查集颜色 $x$ 代表的根连到 $y$ 上，然后加的时候直接加在根上即可，时间复杂度都是 $O(\alpha(n))$ 单块。散块直接暴力处理，把所有并查集重构一遍，复杂度 $O(\sqrt n)$ 的。</p><p>然后主要是坑点很多，下面讲几个：</p><ol><li>合并的时候注意我们不能直接把 $x$ 代表的根连到 $y$ 上，因为 $x, y$ 的标记可能会发生混乱。新建一个节点，当作 $y$ 的新根，然后 $x, y$ 的父亲都设为新建节点，新建节点注意也要设置颜色。另外，$x$ 的根应该赋为空。</li><li>在加的时候，注意使用并查集，我们其实是在边上加权值的，点上加会出错，所以我们再新建一个节点，把原来的节点加上变化权值，这样这个的意义就是原来节点到新根的路径加了一个权值。</li><li>暴力重构的时候注意清空问题。可行的办法是把所有遇到的颜色全部记录下来，把这些位置清空。至于节点清空可以要一个点清空一个点，这样不会导致复杂度退化。</li><li>注意到每一块都要建一个大小 $O(n)$ 的并查集，于是空间复杂度 $O(n\sqrt n)$，然后还因为中间多建点，至少需要开 3 倍空间，这样很容易导致 MLE，<del>所以我们机房的神仙就好像一直调块长</del>。正确的做法是由于允许离线，把每块离线处理，这样就可以做到线性空间，不过没有了强制在线。但其实数据几乎只需要多开点即可，我开始忘开 3 倍空间结果只有满数据没过……</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Start Solve &quot; &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    LL totval = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">all</span><span class="params">(C)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C; ++ i) all[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> pushdown = [&amp;]() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++ i)</span><br><span class="line">            col[i] = id[<span class="built_in">find</span>(i)], a[i] = val[i];</span><br><span class="line">        <span class="comment">/*printf(&quot;After Pushdown\n&quot;);</span></span><br><span class="line"><span class="comment">        for (int i = l; i &lt;= r; ++ i) printf(&quot;%d %lld\n&quot;, col[i], val[i]);*/</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> rebuild = [&amp;]() &#123;</span><br><span class="line">        tot = n, totval = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c : all) rt[c] = <span class="number">0</span>;</span><br><span class="line">        all.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!rt[col[i]]) id[rt[col[i]] = ++ tot] = col[i], f[tot] = tot, val[tot] = sz[tot] = <span class="number">0</span>;</span><br><span class="line">            f[i] = rt[col[i]], val[i] = a[i], sz[rt[col[i]]] ++, totval += a[i];</span><br><span class="line">            all.<span class="built_in">push_back</span>(col[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">rebuild</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (eve[i].l &gt; r || eve[i].r &lt; l) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (eve[i].op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eve[i].l &lt;= l &amp;&amp; eve[i].r &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = eve[i].x, y = eve[i].y;</span><br><span class="line">                <span class="keyword">if</span> (!rt[x]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// std::cout &lt;&lt; &quot;Change &quot; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">                all.<span class="built_in">push_back</span>(x), all.<span class="built_in">push_back</span>(y);</span><br><span class="line">                x = <span class="built_in">find</span>(rt[x]);</span><br><span class="line">                ++ tot, f[tot] = tot, val[tot] = sz[tot] = <span class="number">0</span>, id[tot] = y;</span><br><span class="line">                <span class="keyword">if</span> (rt[y]) f[rt[y]] = tot, sz[tot] += sz[rt[y]];</span><br><span class="line">                f[x] = rt[y] = tot, sz[tot] += sz[x], rt[id[x]] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">pushdown</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = std::<span class="built_in">max</span>(eve[i].l, l), ed = std::<span class="built_in">min</span>(eve[i].r, r); j &lt;= ed; ++ j)</span><br><span class="line">                    <span class="keyword">if</span> (col[j] == eve[i].x) col[j] = eve[i].y;</span><br><span class="line">                <span class="built_in">rebuild</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eve[i].op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eve[i].l &lt;= l &amp;&amp; eve[i].r &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rt[eve[i].x]) <span class="keyword">continue</span>;</span><br><span class="line">                all.<span class="built_in">push_back</span>(eve[i].x);</span><br><span class="line">                <span class="keyword">int</span> x = <span class="built_in">find</span>(rt[eve[i].x]);</span><br><span class="line">                ++ tot, f[tot] = tot, val[tot] = sz[tot] = <span class="number">0</span>;</span><br><span class="line">                val[x] += eve[i].y, totval += (LL) sz[x] * eve[i].y, rt[eve[i].x] = tot;</span><br><span class="line">                f[x] = tot, sz[tot] = sz[x], id[tot] = eve[i].x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">pushdown</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = std::<span class="built_in">max</span>(eve[i].l, l), ed = std::<span class="built_in">min</span>(eve[i].r, r); j &lt;= ed; ++ j)</span><br><span class="line">                    <span class="keyword">if</span> (col[j] == eve[i].x) a[j] += eve[i].y;</span><br><span class="line">                <span class="built_in">rebuild</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (eve[i].l &lt;= l &amp;&amp; eve[i].r &gt;= r) eve[i].res += totval;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = std::<span class="built_in">max</span>(eve[i].l, l), ed = std::<span class="built_in">min</span>(eve[i].r, r); j &lt;= ed; ++ j)</span><br><span class="line">                    <span class="built_in">find</span>(j), eve[i].res += val[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;military.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;military.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="built_in">read</span>(n, Q, C);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(col[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(eve[i].op, eve[i].l, eve[i].r);</span><br><span class="line">        <span class="keyword">if</span> (eve[i].op != <span class="number">3</span>) <span class="built_in">read</span>(eve[i].x, eve[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> B = std::<span class="built_in">sqrt</span>(n) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) <span class="built_in">solve</span>(l, r = std::<span class="built_in">min</span>(l + B - <span class="number">1</span>, n));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (eve[i].op == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, eve[i].res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;怎么省选题也出 lxl 的各种分块啊？&lt;/p&gt;</summary>
    
    
    
    
    <category term="分块" scheme="https://mydcwfy.github.io/tags/%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>LOJ3730 [SNOI2022]数位</title>
    <link href="https://mydcwfy.github.io/2022/06/23/LOJ3730/"/>
    <id>https://mydcwfy.github.io/2022/06/23/LOJ3730/</id>
    <published>2022-06-23T07:46:53.000Z</published>
    <updated>2022-06-23T09:13:07.247Z</updated>
    
    <content type="html"><![CDATA[<p>有趣的数数题，但压轴题确实码量较大。</p><span id="more"></span><p>题意：给定 $L, R$，问有多少个 $n$ 元组 $(a_1, a_2, \cdots, a_n)$ 满足 $a_i\in [L, R]$ 并且 $\sum a$ 10 进制表示从高位向低位数字不增。$L, R\leq 10 ^ {1000}$，$k\leq 50$，6s。</p><p>并不清楚为什么要给 6s，反正我代码最大点 200- ms，目前（2022-06-23）LOJ 最优解，大概是 rk2 速度的 4 倍。</p><p>以下令 $m = 10$，用于表示复杂度。</p><p>容易发现我们只有 $L$ 的限制是好做的，我们可以用插板法用一个组合数表示。</p><p>考虑容斥，计算钦定有 $k$ 个超出 $R$ 的限制的（似乎是二项式反演的弱化版），那么我们可以选择 $k$ 个超出限制，至少为 $R + 1$，这一部分需要乘上 $\binom nk$。假设最终的和为 $s$，那么可以得到方案数为：<br>$$<br>\binom{s - k(R + 1) - (n - k)L + n - 1}{n - 1}<br>$$<br>注意到 $s$ 必须 $\geq k(R + 1) + (n - k)L$，同时需要满足题目给的数位单调不降的特点，显然使用数位 DP。下面考虑如何计算这个组合数。</p><p>容易发现这个组合数是一个关于 $s - k(R + 1) - (n - k)L$ 的不超过 $n - 1$ 次多项式，那么我们可以把这个式子拆分为不同幂次的和。维护不同幂次的答案显然可以使用一个结构体维护，然后统一转移。具体的，使用二项式定理展开，$a(i), b(j)$ 乘 $\binom{i + j}i$ 到 $c(i + j)$。</p><p>考虑数位 DP 的具体过程，注意到我们没有上界，于是我们可以强行规定一个上界，使它比所有的 $k(R + 1) + (n - k)L$ 都要大。为了简洁我们直接设定位数不超过 $|R| + 3$，容易发现 $k(R + 1) + (n - k)L$ 肯定无法达到上界。</p><p>我们可以使用一个简单的预处理 $f(i, j)$ 表示 $i$ 位，最高位是 $j$ 且满足条件的所有数的各次幂。容易发现转移可以做到 $O(|R|\times m\times n ^ 2)$。</p><p>然后计算 $\geq cur$ 的答案，首先统计位数更大的答案，注意 $f(i, j)$ 不是最终答案，我们需要减去一个 $cur$ 的贡献，相当于对每个数加 $P - sum$。然后逐位比较，假设最高的 $i$ 位已经确定与 $cur$ 相同，枚举当前位置比 $cur$ 当前位置大并且合法的位置，然后就可以用我们预处理的 $f$。注意需要减去 $cur$ 的低位，因为高位相同，无需管。</p><p>最后一个问题是怎样通过次幂计算组合数。好像有二项式反演做法，但是 $n$ 太小了，直接暴力高斯消元得到每一项系数即可。</p><p>总时间复杂度 $O(|R|mn ^ 2 + n ^ 3)$，轻松通过。具体可以看代码。可以优化到 $O(|R|mn\log n + n ^ 3)$，不过没意义罢。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigNum</span> &#123;</span></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="built_in">BigNum</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">BigNum</span>(<span class="keyword">int</span> _v) &#123; <span class="keyword">while</span> (_v) a.<span class="built_in">push_back</span>(_v % <span class="number">10</span>), _v /= <span class="number">10</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">len</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> a[x]; &#125;</span><br><span class="line">&#125; L, R;</span><br><span class="line"><span class="keyword">int</span> n, C[N][N], mxlen, pw10[<span class="number">1010</span>], a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span>&amp; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123; <span class="keyword">return</span> x += x &gt;&gt; <span class="number">31</span> &amp; Mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k = Mod - <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = (LL) a * a % Mod)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL) res * a % Mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _v) : <span class="built_in">a</span>(n + <span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = a[i - <span class="number">1</span>] * (LL) _v % Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> a[x]; &#125;</span><br><span class="line">    Node <span class="keyword">operator</span> *(Node t) <span class="keyword">const</span> &#123;</span><br><span class="line">        Node res;</span><br><span class="line">        res.a.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n - i; ++ j)</span><br><span class="line">                res[i + j] = (res[i + j] + (LL) a[i] * t[j] % Mod * C[i + j][i]) % Mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&amp; <span class="keyword">operator</span> +=(Node t) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) <span class="built_in">adj</span>(a[i] += t[i] - Mod);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node <span class="keyword">operator</span> +(Node t) <span class="keyword">const</span> &#123; <span class="keyword">return</span> t += *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125; dp[<span class="number">1010</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (a[j][i]) &#123;</span><br><span class="line">                t = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">assert</span>(~t);</span><br><span class="line">        <span class="keyword">if</span> (t ^ i) std::<span class="built_in">swap</span>(a[t], a[i]);</span><br><span class="line">        <span class="keyword">int</span> Inv = <span class="built_in">qpow</span>(a[i][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n + <span class="number">1</span>; ++ j) a[i][j] = (LL) a[i][j] * Inv % Mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (j != i &amp;&amp; a[j][i])</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = n + <span class="number">1</span>; k &gt;= i; -- k)</span><br><span class="line">                    a[j][k] = (a[j][k] + (LL) (Mod - a[j][i]) * a[i][k]) % Mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigNum <span class="keyword">operator</span> +(BigNum a, BigNum b)</span><br><span class="line">&#123;</span><br><span class="line">    BigNum res;</span><br><span class="line">    <span class="keyword">int</span> len = std::<span class="built_in">max</span>(a.<span class="built_in">len</span>(), b.<span class="built_in">len</span>()), ls = <span class="number">0</span>;</span><br><span class="line">    a.a.<span class="built_in">resize</span>(len), b.a.<span class="built_in">resize</span>(len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i)</span><br><span class="line">        res.a.<span class="built_in">push_back</span>((a[i] + b[i] + ls) % <span class="number">10</span>), ls = (a[i] + b[i] + ls) &gt;= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (ls) res.a.<span class="built_in">push_back</span>(ls);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigNum <span class="keyword">operator</span> *(BigNum a, <span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    BigNum res;</span><br><span class="line">    LL ls = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : a.a)</span><br><span class="line">        ls = (LL) x * k + ls, res.a.<span class="built_in">push_back</span>(ls % <span class="number">10</span>), ls /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (ls) res.a.<span class="built_in">push_back</span>(ls % <span class="number">10</span>), ls /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::istream&amp; <span class="keyword">operator</span> &gt;&gt;(std::istream &amp;fin, BigNum &amp;res)</span><br><span class="line">&#123;</span><br><span class="line">    std::string buf;</span><br><span class="line">    fin &gt;&gt; buf;</span><br><span class="line">    std::<span class="built_in">reverse</span>(buf.<span class="built_in">begin</span>(), buf.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> len = buf.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) res.a.<span class="built_in">push_back</span>(buf[i] ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> fin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span> &lt;&lt;(std::ostream &amp;fout, BigNum res)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = res.<span class="built_in">len</span>() - <span class="number">1</span>; ~i; -- i) fout &lt;&lt; <span class="built_in"><span class="keyword">char</span></span>(res[i] % <span class="number">10</span> | <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> fout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(BigNum le)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node res;</span><br><span class="line">    res.a.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ls = <span class="number">9</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = le.<span class="built_in">len</span>() - <span class="number">1</span>; ~i; -- i) sum = (sum * <span class="number">10LL</span> + le[i]) % Mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = le.<span class="built_in">len</span>() + <span class="number">1</span>; i &lt;= mxlen; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; ++ j) res += dp[i][j] * <span class="built_in">Node</span>(Mod - sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = le.<span class="built_in">len</span>() - <span class="number">1</span>; ~i; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = le[i] + <span class="number">1</span>; j &lt;= ls; ++ j) res += dp[i + <span class="number">1</span>][j] * <span class="built_in">Node</span>(Mod - sum);</span><br><span class="line">        <span class="keyword">if</span> (le[i] &gt; ls) <span class="keyword">break</span>;</span><br><span class="line">        sum = (sum + (LL) (Mod - pw10[i]) * le[i]) % Mod, ls = le[i];</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) res += <span class="built_in">Node</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) ret = (ret + (LL) res[i] * a[i + <span class="number">1</span>][n + <span class="number">1</span>]) % Mod;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; ret &lt;&lt; &#x27; &#x27; &lt;&lt; le &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;digit.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;digit.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    std::cin &gt;&gt; L &gt;&gt; R &gt;&gt; n, mxlen = R.<span class="built_in">len</span>() + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; i &lt; N; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = C[i][<span class="number">0</span>] = <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line">            <span class="built_in">adj</span>(C[i][j] = C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j] - Mod);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pw10[<span class="number">0</span>] = <span class="number">1</span>; i &lt;= mxlen; ++ i) pw10[i] = pw10[i - <span class="number">1</span>] * <span class="number">10LL</span> % Mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= mxlen; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++ j) dp[i][j].a.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++ j) dp[<span class="number">1</span>][j] = <span class="built_in">Node</span>(j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; mxlen; ++ l)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= <span class="number">9</span>; ++ j)</span><br><span class="line">                dp[l + <span class="number">1</span>][j] += dp[l][i] * <span class="built_in">Node</span>(pw10[l] * (LL) j % Mod);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) a[i][j] = <span class="built_in">qpow</span>(i, j - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i][n + <span class="number">1</span>] = C[i + n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">Gauss</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mxlen = 2, solve(10), exit(0);</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, op = <span class="number">1</span>; i &lt;= n; ++ i, op = Mod - op)</span><br><span class="line">        res = (res + <span class="built_in">solve</span>(L * (n - i) + (R + <span class="number">1</span>) * i) * (LL) C[n][i] % Mod * op) % Mod;</span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有趣的数数题，但压轴题确实码量较大。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="高斯消元" scheme="https://mydcwfy.github.io/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
    <category term="数位 DP" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E4%BD%8D-DP/"/>
    
  </entry>
  
  <entry>
    <title>UOJ168 元旦老人与丛林</title>
    <link href="https://mydcwfy.github.io/2022/06/23/UOJ168/"/>
    <id>https://mydcwfy.github.io/2022/06/23/UOJ168/</id>
    <published>2022-06-23T06:12:17.000Z</published>
    <updated>2022-06-23T07:45:36.754Z</updated>
    
    <content type="html"><![CDATA[<p>网络流 + 神秘结论题目。</p><span id="more"></span><p>题意：给定 $n$ 个点，$m$ 条边的无向图，问能不能把边集划分成两部分，每一部分都是森林。$n\leq 2000, m\leq 4000$。</p><p>首先有一个结论：该无向图合法当且仅当任意子图都满足边数小于二倍点数 - 2 时可以找到方案。</p><p>证明不太会，大概感性理解一下吧。</p><p>现在我们要考虑的问题就是是否全部满足 $|E|\leq 2|V| - 2$。相当于要求 $|E| - 2|V|$ 的最大值。我们边拆点，每一个边向他的两个端点连边，然后相当于每一条边的权值是 1，每一个点的权值是 -2，然后有前提的选点。这样相当于是最大权闭合图，可以使用网络流在 $O(n ^ 2)$ 的时间内解决（因为权值是 $O(1)$ 级别的）。</p><p>注意到我们并不能选择空图，因为此时根据我们的判断一定不合法，所以我们需要强制选一个点（注意可以不选边）。那么此时，我们需要将 $u\to T$ 的边设为满流，如何操作呢？</p><p>首先暴力重建复杂度是 $O(n ^ 3)$，过不去，我们考虑在残留网络上接着跑。</p><p>考虑先将 $u\to T$ 的流量给退了，退流过程其实就是 $u\to S$ 做一遍流量上界为 $u\to S$ 容量 $c$ 的网络流，然后割掉 $u\to T$，暴力做一遍 $S$ 到 $T$ 的网络流，容易发现流量变化为 $O(1)$，所以单次 Dinic 时间复杂度 $O(n)$，总复杂度 $O(n ^ 2)$。但由于 Dinic 很玄学，没有限制容量也可以过（）。</p><p>下面考虑证明这个做法的正确性。先把 $u\to S$ 容量为 $c$ 的网络流退掉，这样考虑整张图的流量平衡，容易发现次数 $u$ 恰好少了 $c$ 的流量，这相当于我们割断了 $u\to T$ 并且使之满流，变化就是整个网络流的变化量，直接判断即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">std::vector&lt;PII&gt; <span class="title">edg</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">MFGraph&lt;<span class="keyword">int</span>&gt; <span class="title">mf</span><span class="params">(n + m + <span class="number">2</span>, m * <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> S = n + m + <span class="number">1</span>, T = n + m + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) mf.<span class="built_in">add</span>(i, T, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) mf.<span class="built_in">add</span>(S, i + n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;[u, v] = edg[i];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        mf.<span class="built_in">add</span>(i + n, u, INF), mf.<span class="built_in">add</span>(i + n, v, INF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> curflow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++ u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// auto [u, v] = edg[i];</span></span><br><span class="line">        mf.edg[(u - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>].w = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// mf.edg[(u - 1) &lt;&lt; 1 | 1].w = mf.edg[(v - 1) &lt;&lt; 1 | 1].w = 0;</span></span><br><span class="line">        curflow -= mf.<span class="built_in">solve</span>(u, S)<span class="comment">/*, curflow -= mf.solve(v, S)*/</span>;</span><br><span class="line">        curflow += mf.<span class="built_in">solve</span>(S, T);</span><br><span class="line">        <span class="keyword">if</span> (m - curflow + <span class="number">2</span> &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>), <span class="number">0</span>;</span><br><span class="line">        mf.edg[(u - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>].w = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;网络流 + 神秘结论题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络流" scheme="https://mydcwfy.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>BlueStein 算法</title>
    <link href="https://mydcwfy.github.io/2022/06/21/BlueStein-Algorithm/"/>
    <id>https://mydcwfy.github.io/2022/06/21/BlueStein-Algorithm/</id>
    <published>2022-06-21T07:07:33.000Z</published>
    <updated>2022-06-21T07:57:40.151Z</updated>
    
    <content type="html"><![CDATA[<p>BlueStein 算法是处理循环卷积的利器，需要对单位根要有比较清晰的认识。</p><span id="more"></span><h2 id="1-主要思想"><a href="#1-主要思想" class="headerlink" title="1. 主要思想"></a>1. 主要思想</h2><p>用于循环卷积，即 $c_k = \sum_i \sum_j [i + j\bmod n = k] a_ib_j$。你肯定要说了，这个有什么用？直接计算长度为 $2n$ 的正常卷积就行了？别急，我们待会看道例题就知道了。</p><h2 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2. 算法流程"></a>2. 算法流程</h2><p>仍然考虑计算 $a’(k) = \sum_{i = 0} ^ {n - 1} \omega_n ^ {ik} a(i)$，这本质和 FFT 是相同的。注意一般有模数时需要满足循环卷积长度 $n$ 整除 $p - 1$，这样才能使用单位根。</p><p>没有比较优秀的性质，怎么办呢？BlueStein 算法给出了一种<strong>化积为和</strong>的方案。</p><p>观察以下两个式子：<br>$$<br>\begin{aligned}<br>(x + y) ^ 2 - x ^ 2 - y ^ 2 =&amp; 2xy\\<br>\binom{x + y}2 - \binom x2 - \binom y2 =&amp; xy<br>\end{aligned}<br>$$<br>正确性展开即可得到。现在我们发现我们已经巧妙的把积放在了和之间了！</p><p>一般来说，第二个式子更常用，因为第一个式子有 $2xy$，可能需要用到二次剩余，但是一个数可能不存在二次剩余。</p><p>于是我们可以把上面的式子变形一下：<br>$$<br>\begin{aligned}<br>a’(k) =&amp; \sum_{i = 0} ^ {n - 1} \omega_n ^ {ik} a(i)\\<br>=&amp; \omega_n ^ {-\binom k2} \sum_{i = 0} ^ {n - 1} \omega_n ^ {\binom{i + k}2}\omega_n ^ {\binom i2}a(i)<br>\end{aligned}<br>$$<br>容易发现这其实是 $f(x) = \sum_{i = 0} ^ {n - 1} \omega_n ^ {\binom i2}$ 和 $g(x) = \sum_{i = 0} ^ {n - 1} \omega_n ^ {-\binom i2}$ 的差卷积，于是 NTT 加速，复杂度 $O(n\log n)$。这个办法再很多场合比较常见，这也是 BlueStein 算法的一个精妙之处。似乎也叫 Chirp Z-Transform？</p><p>然后类似于 FFT 的，我们只需要把 $c’(k) = a’(k) * b’(k)$，然后逆变换回去即可。逆变换只需要在单位根的位置乘上 -1 即可，最后每一项除以 $n$ 即可。</p><p>然后考虑证明这个就是循环卷积。同样，由于 BlueStein 算法与 FFT 的相似性，我们同样可以得到 FFT 其实也是循环卷积。</p><p>考虑 $a(x), b(y)$ 对于 $c(k)$ 的贡献为：<br>$$<br>\sum_{i = 0} ^ {n - 1} a(x) \omega_n ^ {ix} b(y) \omega_n ^ {iy} \omega_n ^ {-ik}<br>$$<br>通过表示 $a(x), b(y)$ 变换之后在哪一位，然后又逆变换回了 $k$ 这一位，就是上面的式子。</p><p>考虑推导：<br>$$<br>\begin{aligned}<br>&amp;\sum_{i = 0} ^ {n - 1} a(x) \omega_n ^ {ix} b(y) \omega_n ^ {iy} \omega_n ^ {-ik}\\<br>=&amp; a(x) b(y) \sum_{i = 0} ^ {n - 1} \omega_n ^ {ix} \omega_n ^ {iy} \omega_n ^ {-ik}\\<br>=&amp; a(x) b(y) \sum_{i = 0} ^ {n - 1} \omega_n ^ {(x + y - k)i}<br>\end{aligned}<br>$$<br>后面一坨式子可以通过 <a href=""></a> 得到即为 $n\times [n|(x + y - k)]$。（关系好像不太对，怎么感觉应该是单位根反演从这个得到的啊</p><p>于是我们就得到当 $(x + y)\bmod n = k$ 时，贡献为 $n\times a(x)b(y)$，否则为 0。最后除以 $n$ 即可得到 $c(k)$ 了。</p><p>至此，我们就可以在 $O(n\log n)$ 的之间内求出 $a$ 和 $b$ 的循环卷积了。</p><h2 id="3-例题"><a href="#3-例题" class="headerlink" title="3. 例题"></a>3. 例题</h2><h4 id="T1：BZOJ1919-CTSC2010-性能优化"><a href="#T1：BZOJ1919-CTSC2010-性能优化" class="headerlink" title="T1：BZOJ1919 [CTSC2010]性能优化"></a>T1：BZOJ1919 [CTSC2010]性能优化</h4><p><a href="https://www.luogu.com.cn/problem/P4191">题目传送门 Luogu</a></p><p><a href="https://hydro.ac/d/bzoj/p/1919">题目传送门 Hydro</a></p><p>题意：做 $A\times B ^ k$ 长度为 $n$ 的循环卷积，对 $n + 1$ 取模。保证 $n + 1$ 是质数。$n\leq 5\times 10 ^ 5$，6s。</p><p>提示：为确保你不被卡常，请使用比较快速的任意模数多项式乘法。（但好像可以不用任意模数多项式乘法</p><p>这时 BlueStien 的优势体现出来了：我做循环卷积的话，我可以对变换后的点值直接做 $a’(i) \times b’(i) ^ k$，而普通的变换不行，只有倍增快速幂。证明的话，可以考虑 BlueStein 算法逆变换后就是答案，而他和下一个相乘时又要变换回来，这个过程可以省略。这样可以把所有点值一起乘起来，再做逆变换，而普通的变换不行。</p><p>注意需要使用 MTT，但是可以使用大模数 NTT 代替，因为本题值域只有 $(5\times 10 ^ 5) ^ 3$，没实现过不知道常数如何（好像比较小）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlueStein</span><span class="params">(poly &amp;a, <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> flag = inv == <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (inv == <span class="number">-1</span>) inv = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> inv = Mod - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">poly <span class="title">b</span><span class="params">(<span class="number">2</span> * n - <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; ++ i)</span><br><span class="line">b[i] = <span class="built_in">qpow</span>(W, (i - <span class="number">1LL</span>) * i / <span class="number">2</span> % (Mod - <span class="number">1</span>) * (Mod - <span class="number">1</span> - inv) % (Mod - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">a[i] = (LL) a[i] * <span class="built_in">qpow</span>(W, (i - <span class="number">1LL</span>) * i / <span class="number">2</span> % (Mod - <span class="number">1</span>) * inv % (Mod - <span class="number">1</span>)) % Mod;</span><br><span class="line">std::<span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">a = a * b, a = std::vector&lt;<span class="keyword">int</span>&gt;(a.<span class="built_in">data</span>() + n - <span class="number">1</span>, a.<span class="built_in">data</span>() + <span class="number">2</span> * n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">a[i] = (LL) a[i] * <span class="built_in">qpow</span>(W, (i - <span class="number">1LL</span>) * i / <span class="number">2</span> % (Mod - <span class="number">1</span>) * inv % (Mod - <span class="number">1</span>)) % Mod;</span><br><span class="line"><span class="keyword">if</span> (flag) <span class="keyword">return</span>;</span><br><span class="line">inv = <span class="built_in">qpow</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : a) x = (LL) x * inv % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, C;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; C, W = <span class="built_in">findrt</span>(Mod = n + <span class="number">1</span>);</span><br><span class="line"><span class="function">poly <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : a) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : b) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="built_in">BlueStein</span>(a, <span class="number">1</span>), <span class="built_in">BlueStein</span>(b, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) a[i] = (LL) a[i] * <span class="built_in">qpow</span>(b[i], C) % Mod;</span><br><span class="line"><span class="built_in">BlueStein</span>(a, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : a) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;BlueStein 算法是处理循环卷积的利器，需要对单位根要有比较清晰的认识。&lt;/p&gt;</summary>
    
    
    
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    <category term="单位根反演" scheme="https://mydcwfy.github.io/tags/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P7812 Dark Forest</title>
    <link href="https://mydcwfy.github.io/2022/06/21/Luogu-P7812/"/>
    <id>https://mydcwfy.github.io/2022/06/21/Luogu-P7812/</id>
    <published>2022-06-21T03:19:56.000Z</published>
    <updated>2022-06-21T07:37:33.068Z</updated>
    
    <content type="html"><![CDATA[<p>哈哈，没事就做提答题。</p><span id="more"></span><p>题意：给定长度为 $n$ 的序列 $a$，定义一个排列 $p$ 的权值为：<br>$$<br>\sum_{i = 1} ^ n p_i a_{p_{i - 1}} a_{p_i} a_{p_{i + 1}}<br>$$<br>请给出一个排列，使得该权值尽量大。$n, a_i\leq 10 ^ 3$。已给出所有数据点。</p><p>显然考虑乱搞。</p><p>有一个比较神秘的思路就是你每次随机交换两个数，然后计算答案。但是有一个问题就是你很容易陷入一个局部最优解，导致怎么都跳不出来。可以考虑类似模拟退火的做法，随机一定概率接受新解。</p><p>这里需要优化复杂度（？）的地方是你需要 $O(1)$ 计算 $val$ 的变化量，可以暴力推式子，如果像我一样懒的人可以把所有影响到的位置重新算一遍，可能略慢一些。</p><p>然后<del>通过 Luogu 题解区</del>我们发现退火后面几个点几乎跑不出来，于是可以考虑固定一个次数， 每多少次直接 <code>std::shuffle</code> 一下，从头计算。这样大概能多过一些点，具体记不太清楚了。</p><p>你会发现你每次 <code>std::shuffle</code> 把前面的功夫全部弃掉，这样也不好，于是可以固定次数时，随机交换一些位置。这时 $n = 1000$，你取 $B = 2\times 10 ^ 7$ 随机交换一些位置，大概可以在 2.5min 通过 Test #10，得到 99 pts 的好成绩，Test #3 跑不过去。</p><p>注意 Test #3 的情况，$a_i = i$，考虑构造，将最大的那一个数 $x$ 放在 $x - 1$ 和 $x - 2$ 中间。这样一定是最大的（也不一定，反正过了）。这样就可以通过。</p><p>另外，你如果中间变量输出比较多的话，你会发现其实 $B = 2\times 10 ^ 7$ 过大，随便取小一点，大概 30s 即能跑过 Test #10，1min 多一点即可通过 Test #10 在讨论区给出的评分标准。当然也可以自己多试试，调整参数，可能得到更优更快的做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], p[N];</span><br><span class="line">LL val, score[<span class="number">11</span>];</span><br><span class="line">std::mt19937 rnd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (x + n - <span class="number">2</span>) % n + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nxt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x % n + <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">getval</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> (LL) p[i] * a[p[i]] * a[p[<span class="built_in">pre</span>(i)]] * a[p[<span class="built_in">nxt</span>(i)]]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++ i)</span><br><span class="line">        res += <span class="built_in">getval</span>(i);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">rnd</span>() % n + <span class="number">1</span>, y = <span class="built_in">rnd</span>() % n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">    LL nw = val;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="built_in">pre</span>(x), x, <span class="built_in">nxt</span>(x)&#125;;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">pre</span>(y)) == v.<span class="built_in">end</span>()) v.<span class="built_in">push_back</span>(<span class="built_in">pre</span>(y));</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), y) == v.<span class="built_in">end</span>()) v.<span class="built_in">push_back</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">nxt</span>(y)) == v.<span class="built_in">end</span>()) v.<span class="built_in">push_back</span>(<span class="built_in">nxt</span>(y));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : v) nw -= <span class="built_in">getval</span>(x);</span><br><span class="line">    std::<span class="built_in">swap</span>(p[x], p[y]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : v) nw += <span class="built_in">getval</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (nw &lt; val) std::<span class="built_in">swap</span>(p[x], p[y]);</span><br><span class="line">    <span class="keyword">else</span> val = nw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Timer</span> &#123;</span></span><br><span class="line">    ~<span class="built_in">Timer</span>() &#123; std::cout &lt;&lt; <span class="built_in">clock</span>() / <span class="number">1000000.</span> &lt;&lt; <span class="string">&quot; s used&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125; timer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">fin</span><span class="params">(argv[<span class="number">1</span>])</span>, <span class="title">fans</span><span class="params">(argv[<span class="number">2</span>])</span></span>;</span><br><span class="line">    fin &gt;&gt; n;</span><br><span class="line">    rnd.<span class="built_in">seed</span>((<span class="keyword">long</span> <span class="keyword">long</span>) <span class="keyword">new</span> <span class="keyword">char</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) fin &gt;&gt; a[i];</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; curp&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (curp[j] == i - <span class="number">2</span> || curp[j] == i - <span class="number">1</span>) &#123;</span><br><span class="line">                curp.<span class="built_in">insert</span>(curp.<span class="built_in">begin</span>() + j + <span class="number">1</span>, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) p[i + <span class="number">1</span>] = curp[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i) fans &gt;&gt; score[i];</span><br><span class="line">    fin.<span class="built_in">close</span>(), fans.<span class="built_in">close</span>();</span><br><span class="line">    LL cnt = <span class="number">0</span>;</span><br><span class="line">    val = <span class="built_in">calc</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (++ cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">SA</span>();</span><br><span class="line">        <span class="keyword">if</span> (cnt % <span class="number">1000000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> curscore = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i) curscore += val &gt;= score[i];</span><br><span class="line">            <span class="keyword">if</span> (cnt % <span class="number">2000000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;SA cnt : %lld   Val : %lld   Score : %d   Goal val : %lld   Delta : %.10lf\n&quot;</span>,</span><br><span class="line">                    cnt, val, curscore, score[<span class="number">9</span>], (val - score[<span class="number">9</span>]) * <span class="number">1.</span> / score[<span class="number">9</span>]);</span><br><span class="line">                <span class="function">std::ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;test.out&quot;</span>)</span></span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) fout &lt;&lt; p[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                fout.<span class="built_in">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt % <span class="number">6000000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> T = <span class="number">25</span>;</span><br><span class="line">                <span class="keyword">while</span> (T --) std::<span class="built_in">swap</span>(p[<span class="built_in">rnd</span>() % n + <span class="number">1</span>], p[<span class="built_in">rnd</span>() % n + <span class="number">1</span>]);</span><br><span class="line">                val = <span class="built_in">calc</span>(<span class="number">1</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;哈哈，没事就做提答题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="提交答案" scheme="https://mydcwfy.github.io/tags/%E6%8F%90%E4%BA%A4%E7%AD%94%E6%A1%88/"/>
    
    <category term="随机化" scheme="https://mydcwfy.github.io/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>LOJ6503 「雅礼集训 2018 Day4」Magic</title>
    <link href="https://mydcwfy.github.io/2022/06/21/LOJ6503/"/>
    <id>https://mydcwfy.github.io/2022/06/21/LOJ6503/</id>
    <published>2022-06-21T01:25:53.000Z</published>
    <updated>2022-06-21T01:36:43.652Z</updated>
    
    <content type="html"><![CDATA[<p>又一个二项式反演。</p><span id="more"></span><p>题意：给定 $m$ 种颜色，每种 $a_i$ 个球，共 $n$ 个球，任意排列，求恰好有 $k$ 个相邻球颜色相同的方案数，对 998244353 取模。$m\leq 2\times 10 ^ 4$，$n\leq 10 ^ 5$。</p><p>看到恰好，二项式反演，于是变为了计算钦定 $k$ 个的答案。</p><p>对于一种颜色，如果我们钦定他有 $i$ 个相邻位置相同，假设共 $a$ 个，那么方案数可以使用插板法计算，为 $\binom{a - 1}i$。</p><p>卷积不同的颜色时，我们可以直接使用 EGF，请注意，我们使用 $\binom{a - 1}i$ 的时候，已经默认这 $a - i$ 段是有序的了，于是直接计算使用 EGF，答案是正确的。</p><p>分治 NTT 卷积即可，时间复杂度 $O(n\log ^ 2 n)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">auto</span> solve = [&amp;](<span class="keyword">auto</span> &amp;self, poly *a, <span class="keyword">int</span> l, <span class="keyword">int</span> r) -&gt; poly &#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> a[l];</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">self</span>(self, a, l, mid) * <span class="built_in">self</span>(self, a, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line">std::vector&lt;poly&gt; all;</span><br><span class="line">std::cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, v; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v);</span><br><span class="line"><span class="function">poly <span class="title">cur</span><span class="params">(v)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++ i)</span><br><span class="line">cur[i] = (LL) <span class="built_in">C</span>(v - <span class="number">1</span>, v - <span class="number">1</span> - i) * infact[v - i] % Mod;</span><br><span class="line">all.<span class="built_in">push_back</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> g = <span class="built_in">solve</span>(solve, all.<span class="built_in">data</span>(), <span class="number">0</span>, (<span class="keyword">int</span>) all.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - m; ++ i) g[i] = (LL) g[i] * fact[n - i] % Mod;</span><br><span class="line"><span class="comment">/*for (int &amp;x : g) printf(&quot;%d &quot;, x);</span></span><br><span class="line"><span class="comment">puts(&quot;&quot;);*/</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k, op = <span class="number">1</span>; i &lt;= n - m; ++ i, op = Mod - op)</span><br><span class="line">res = (res + (LL) op * <span class="built_in">C</span>(i, k) % Mod * g[i]) % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;又一个二项式反演。&lt;/p&gt;</summary>
    
    
    
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    <category term="二项式反演" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"/>
    
    <category term="生成函数" scheme="https://mydcwfy.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P6516 Quark and Graph</title>
    <link href="https://mydcwfy.github.io/2022/06/21/Luogu-P6516/"/>
    <id>https://mydcwfy.github.io/2022/06/21/Luogu-P6516/</id>
    <published>2022-06-21T00:22:27.000Z</published>
    <updated>2022-06-21T00:44:43.343Z</updated>
    
    <content type="html"><![CDATA[<p>模板一点的生成函数题目。</p><span id="more"></span><p>题意：给定 $n$ 个点到 1 的距离，问有多少边数为 $m$ 的无向图满足该限制。边权均为 1，设 $cnt_i$ 表示距离为 $i$ 的点数，则 $n\leq 10 ^ 5$，$m\leq 2\times 10 ^ 5$，$\sum_i cnt_icnt_{i - 1}\leq 2\times 10 ^ 5$，3s，保证至少有一组解。</p><p>首先，我们容易发现，按照 $dis$ 分层后，只可能在相邻层和同层直接连边，不可能跨层连边。现在分别求他们的生成函数。</p><p>首先考虑邻层的生成函数。对于一个点来说，他可以任意向前一层的点连边，但是不能不连边（不然没法保证距离），于是单个点的生成函数为 $(1 + x) ^ {cnt_{i - 1}} - 1$，然后有 $cnt_i$ 个，于是为 $((1 + x) ^ {cnt_{i - 1}} - 1) ^ {cnt_i}$。由于题目保证了 $\sum_i cnt_icnt_{i - 1}\leq 2\times 10 ^ 5$，所以该算法可以直接分治 NTT 计算，时间复杂度 $O(m\log ^ 2 m)$。</p><p>然后考虑同层的生成函数。对于一层来说，我们有 $\binom{cnt_i}2$ 条边可供选择，假设总可选数记为 $T = \sum_i\binom{cnt_i}2$，于是可以得到生成函数为 $\sum_{i = 1} ^ T x ^ i \binom Ti$，由于最后答案取的 $m$，只需要到 $m$ 即可。然后有可能 $T$ 比较大，于是使用 Lucas 定理，写出拆分组合数的式子就可以简单的把 $T$ 直接模 998244353。</p><p>最后把两个卷积一下，总时间复杂度 $O(m\log ^ 2 m)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="function">poly <span class="title">cnt</span><span class="params">(n)</span></span>;</span><br><span class="line">std::vector&lt;poly&gt; all;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), cnt[x] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!cnt[i]) <span class="keyword">break</span>;</span><br><span class="line"><span class="function">poly <span class="title">cur</span><span class="params">(cnt[i - <span class="number">1</span>] + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt[i - <span class="number">1</span>]; ++ j) cur[j] = <span class="built_in">C</span>(cnt[i - <span class="number">1</span>], j);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cs = <span class="number">1</span>; cs &lt;= cnt[i]; ++ cs) all.<span class="built_in">push_back</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> solve = [&amp;](<span class="keyword">auto</span> &amp;self, poly *a, <span class="keyword">int</span> l, <span class="keyword">int</span> r) -&gt; poly &#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> a[l];</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">self</span>(self, a, l, mid) * <span class="built_in">self</span>(self, a, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> res = <span class="built_in">solve</span>(solve, all.<span class="built_in">data</span>(), <span class="number">0</span>, (<span class="keyword">int</span>) all.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">adj</span>(tot += <span class="built_in">C</span>(cnt[i], <span class="number">2</span>) - Mod);</span><br><span class="line"><span class="function">poly <span class="title">g</span><span class="params">(m)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, dn = <span class="number">1</span>; i &lt; m &amp;&amp; i &lt;= tot; ++ i, dn = (LL) dn * (tot - i + <span class="number">1</span>) % Mod)</span><br><span class="line">g[i] = (LL) dn * infact[i] % Mod;</span><br><span class="line">res = res * g;</span><br><span class="line">std::cout &lt;&lt; res[m] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;模板一点的生成函数题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    <category term="分治" scheme="https://mydcwfy.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="生成函数" scheme="https://mydcwfy.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P5860 Counting Trees</title>
    <link href="https://mydcwfy.github.io/2022/06/20/Luogu-P5860/"/>
    <id>https://mydcwfy.github.io/2022/06/20/Luogu-P5860/</id>
    <published>2022-06-20T12:15:02.000Z</published>
    <updated>2022-06-20T12:51:20.585Z</updated>
    
    <content type="html"><![CDATA[<p>生成负次幂的一种解决办法。</p><span id="more"></span><p>题意：给定每个点的度数，任选一些点使得他们能组成一棵树。$n\leq 5\times 10 ^ 5$，6s。</p><p>首先给出结论：</p><blockquote><p> $n$ 个点能组成树的充要条件是 $n$ 个点的度数和为 $2n - 2$（每个点度数 $\geq 1$）。</p></blockquote><p>必要性易得。充分性可以发现一个点的最大度数为 $n - 1$，不可能多出来度数没有连。严谨证明可以考虑 prufer 序列，<del>但我不会</del>。</p><p>由于 $n$ 并没有定，我们需要把 $2n - 2$ 拆给每一个数，于是对每一个数度数 -2，于是我们需要求的就是 $\prod(1 + x ^ {d_i - 2})$ 的 $x ^ {-2}$ 的系数。</p><p>负数没学过什么卷积，于是可以考虑<strong>正负各自卷积，最后倒过来合并</strong>。0 次项最后当常数乘上去即可。</p><p>容易发现负次幂只有 -1，假设有 $m$ 个，容易发现多项式已经确定，为 $\sum_{i = 0} ^ m \binom mix ^ {-i}$。下面考虑正次幂的计算。</p><p>看似我们可以 FFT，但是每个多项式虽然只有两个非零项，但是次数很高，无法计算。</p><p>还是考虑先取 $\ln$，于是我们需要计算 $\ln(1 + x ^ d)$（默认已经减了 2）。$\ln$ 可以展开得到：$-\sum_{i = 1} \dfrac{(-x) ^ {di}}i$。这个式子可以把相同的 $d$ 一起计算，容易得到复杂度为 $O(n\ln n)$。然后 $\exp$ 回去即可得到乘起来的式子。</p><p>最后我们把<strong>负的翻转到正次幂，卷积一下平移回去即可得到</strong>。在这里我们需要平移 $m$ 位，于是最后输出 $x ^ {m - 2}$ 的次数即可。注意乘上度数为 2 的贡献，为 $2 ^ {cnt}$。</p><p>总时间复杂度 $O(n\log n)$<del>，$\exp$ 这么大常数的东西居然能在 500ms 左右跑 $5\times 10 ^ 5$，令人震惊</del>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="function">poly <span class="title">cnt</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, v; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v), cnt[v] ++;</span><br><span class="line"><span class="keyword">int</span> m = cnt[<span class="number">1</span>], pw = cnt[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (m &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line"><span class="function">poly <span class="title">f</span><span class="params">(m - <span class="number">1</span>)</span>, <span class="title">g</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m - <span class="number">2</span>; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v = cnt[i + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, op = <span class="number">1</span>; j * i + <span class="number">1</span> &lt; m; ++ j, op = Mod - op)</span><br><span class="line">f[i * j] = (f[i * j] + (LL) op * v % Mod * inv[j]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">f = <span class="built_in">Exp</span>(f);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i) g[i] = <span class="built_in">C</span>(m, i);</span><br><span class="line">f = f * g;</span><br><span class="line"><span class="keyword">int</span> res = (LL) f[m - <span class="number">2</span>] * <span class="built_in">qpow</span>(<span class="number">2</span>, pw) % Mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;生成负次幂的一种解决办法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    <category term="生成函数" scheme="https://mydcwfy.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>LOJ3058 [HNOI2019]白兔之舞</title>
    <link href="https://mydcwfy.github.io/2022/06/20/LOJ3058/"/>
    <id>https://mydcwfy.github.io/2022/06/20/LOJ3058/</id>
    <published>2022-06-20T11:30:42.000Z</published>
    <updated>2022-06-21T07:40:22.409Z</updated>
    
    <content type="html"><![CDATA[<p>过程比较繁琐，知识比较综合。</p><span id="more"></span><p>题意：在 $L + 1$ 行 $n$ 列的图形上从 $(0, x)$ 随机游走，要求只能向下走，从 $v_1$ 列走到 $v_2$ 列的方案数为 $W_{v_1, v_2}$（与行无关），只能在 $y$ 列停止。给定 $k$，求所有 $t\in[0, k - 1]$，求停留的行的编号满足 $\bmod k = t$ 的所有方案和，答案对 $p$ 取模。满足 $k\leq 2 ^ {16}$，$L\leq 10 ^ 8$，$10 ^ 8 &lt; p &lt; 2 ^ {30}$，$n\leq 3$，$k|p - 1$，$p$ 为质数。</p><p>仔细观察发现如果我们确定步数 $k$，行和列的答案是无关的，只需要最后乘起来即可。对于行来说，我们假设多给一步，强制走到 $L + 1$ 的位置，于是插板法容易得到方案数为 $\binom Lk$。对于列来说，这就是一个显然的矩阵乘法，为 $W ^ k[x][y]$。</p><p>于是可以得到：<br>$$<br>ans_t = \sum_{i = 0} ^ L [i\bmod k = t] W ^ i[x][y]\binom Li<br>$$<br>然后看到 $[i\bmod k = t]$，果断单位根反演，于是一波变换：<br>$$<br>\begin{aligned}<br>ans_t = &amp; \sum_{i = 0} ^ L [i\bmod k = t] W ^ i[x][y]\binom Li\\<br>=&amp; \dfrac 1k \sum_{i = 0} ^ L W ^ i [x][y]\binom Li \sum_{j = 0} ^ {k - 1} \omega_{k} ^ {ij - tj}\\<br>=&amp; \dfrac 1k \sum_{j = 0} ^ {k - 1} \omega_k ^ {-tj}\sum_{i = 0} ^ L W ^ i[x][y] \omega_k ^ {ij}\binom Li\\<br>=&amp; \dfrac 1k \sum_{j = 0} ^ {k - 1} \omega_k ^ {-tj} (\omega_k ^ j W + I) ^ L[x][y]<br>\end{aligned}<br>$$<br>最后一步我们在 <a href="/2022/06/05/Unit-root-intersion/">单位根反演</a> 的 T2 中已经见过矩阵合并二项式定理了，这里不再赘述。注意这里单位根需要我们先求出原根计算。</p><p>假设后面只关于 $j$ 的一坨记作 $f(j)$，其为 $\sum_{j = 0} ^ {k - 1} \omega_k ^ {-tj} (\omega_k ^ j W + I) ^ L[x][y]$。单个 $f(j)$ 容易在 $\log L$ 的时间完成。</p><p>于是我们得到：<br>$$<br>k\times ans_t = \sum_{j = 0} ^ {k - 1} \omega_k ^ {-tj} f(j)<br>$$<br>看样子这是一个卷积，但是指数上有乘积，不好拆开。</p><p>考虑如下两个变换：<br>$$<br>\begin{aligned}<br>(x + y) ^ 2 - x ^ 2 - y ^ 2 =&amp; 2xy\\<br>\binom{x + y}2 - \binom x2 - \binom y2 =&amp; xy<br>\end{aligned}<br>$$<br>两个式子展开一下即可证明。我们惊喜的发现，这个恰好把 $xy$ 化为了 $(x + y)$，这样看样子就可以卷积了！</p><p>套用第一个式子：<br>$$<br>k\times ans_t = \omega_k ^ {\frac{t ^ 2}2}\sum_{j = 0} ^ {k - 1} f(j)\omega_k ^ {\frac{j ^ 2}{2}}\omega_k ^ {-\frac{(j + t) ^ 2}2}<br>$$<br>但是除以 2 不好处理，因为我们可能没法开根。</p><p>考虑套用第二个式子：<br>$$<br>\begin{aligned}<br>k\times ans_t =&amp; \sum_{j = 0} ^ {k - 1} \omega_k ^ {-tj} f(j)\\<br>=&amp; \sum_{j = 0} ^ {k - 1} \omega_k ^ {\binom t2+ \binom j2 - \binom{t + j}2}f(j)\\<br>=&amp; \omega_k ^ {\binom t2}\sum_{j = 0} ^ {k - 1} f(j)\omega_k ^ {\binom j2}\omega_k ^ {-\binom{j + t}{2}}<br>\end{aligned}<br>$$<br>显然这是一个差卷积，直接做即可，时间复杂度 $O(k\log k)$，可以通过。</p><p>另外，这后半部分拆开指数上的乘积其实就是一个叫 BlueStein 的算法。容易发现这个算法其实解决了任意长度的 FFT，因为 FFT 和这个算法都是计算 $n$ 个单位根位置的点值的，只不过 FFT 的 $n$ 是 2 的次幂。更详细的信息看 <a href="/2022/06/21/BlueStein-Algorithm/#more">这篇 Blog</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Matrix a;</span><br><span class="line"><span class="keyword">int</span> k, L, x, y, G;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; L &gt;&gt; x &gt;&gt; y &gt;&gt; Mod, -- x, -- y;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) std::cin &gt;&gt; a[i][j];</span><br><span class="line">w = <span class="built_in">qpow</span>(G = <span class="built_in">findrt</span>(), (Mod - <span class="number">1</span>) / k);</span><br><span class="line"><span class="function">poly <span class="title">f</span><span class="params">(k)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; k; ++ l)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">static</span> Matrix tmp;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="built_in">qpow</span>(w, l);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">tmp[i][j] = ((LL) a[i][j] * cur + (i == j)) % Mod;</span><br><span class="line">f[l] = <span class="built_in">qpow</span>(tmp, L)[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i)</span><br><span class="line">f[i] = (LL) f[i] * <span class="built_in">qpow</span>(w, (i - <span class="number">1LL</span>) * i / <span class="number">2</span> % (Mod - <span class="number">1</span>)) % Mod;</span><br><span class="line">std::<span class="built_in">reverse</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>());</span><br><span class="line"><span class="function">poly <span class="title">g</span><span class="params">(<span class="number">2</span> * k)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * k; ++ i)</span><br><span class="line">g[i] = <span class="built_in">qpow</span>(w, (Mod - <span class="number">1</span> - i * (i - <span class="number">1LL</span>) / <span class="number">2</span> % (Mod - <span class="number">1</span>)) % (Mod - <span class="number">1</span>));</span><br><span class="line">f = f * g, f = std::vector&lt;<span class="keyword">int</span>&gt;(f.<span class="built_in">data</span>() + k - <span class="number">1</span>, f.<span class="built_in">data</span>() + <span class="number">2</span> * k - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i)</span><br><span class="line">f[i] = (LL) f[i] * <span class="built_in">qpow</span>(w, (i - <span class="number">1LL</span>) * i / <span class="number">2</span> % (Mod - <span class="number">1</span>)) % Mod * <span class="built_in">qpow</span>(k) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : f) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;过程比较繁琐，知识比较综合。&lt;/p&gt;</summary>
    
    
    
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    <category term="单位根反演" scheme="https://mydcwfy.github.io/tags/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/"/>
    
    <category term="矩阵乘法" scheme="https://mydcwfy.github.io/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P6967 Delight for a Cat</title>
    <link href="https://mydcwfy.github.io/2022/06/19/Luogu-P6967/"/>
    <id>https://mydcwfy.github.io/2022/06/19/Luogu-P6967/</id>
    <published>2022-06-19T08:46:22.000Z</published>
    <updated>2022-06-20T11:28:31.068Z</updated>
    
    <content type="html"><![CDATA[<p>比较重要的区间限制建网络流方法，以前没有见过，记录一下。</p><span id="more"></span><p>题意：构造一个长度为 $n$ 的 01 序列，每个点选 01 分别有一些权值，并且每长度为 $k$ 的至少有 $m_0$ 个 0，$m_1$ 个 1。问最大权值。$n\leq 1000$。</p><p>做法来自 ix35，在这里表示感谢。</p><p>考虑以下的模型：给定 $m$ 个在 $[1, n]$ 的区间，每个区间代价为 $w$，最多选 $f$ 次，最后每个点的覆盖次数满足一个区间限制，求最小代价。</p><p>建出一个链的图，如下，我们暂且用 $i\to i + 1$ 的流量刻画 $i$ 的覆盖次数：</p><img src="/2022/06/19/Luogu-P6967/Network-flow-template.png" class=""><p>我们把 $[l, r]$ 的一次覆盖记作 $l$ 节点向 $r + 1$ 节点流 1 的流量，那么   $[l, r]$ 本身的流量就减少一。那么我们可以使用减少的流量来刻画覆盖次数，于是我们要求 $i\to i + 1$ 的边有上下界。假设范围为 $[l_i, r_i]$ 表示 $i$ 的覆盖范围，那么我们先给足够的流量 $M$，然后设置 $i\to i + 1$ 的流量 $\in[M - r_i, M - l_i]$。在有些题目中所有的 $r_i$ 相同，于是我们可以把 $M$ 设置为共同的 $r_i$，就没有下界，于是变为了普通的费用流。</p><p>在这个题中，我们用 $i$ 节点表示 $[i, i + k - 1]$ 的区间的 1 的个数，容易发现他的流量有一个上下界。然后覆盖某一位置时，他所影响的位置容易表示为一个区间。这道题目属于我们刚刚说的所有上界相同，于是无需上下界费用流，直接跑即可。输出方案直接在加边的时候记录当前编号，最后看一下流量即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// [mb, k - ma]</span></span><br><span class="line"><span class="keyword">int</span> n, k, ma, mb;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; ma &gt;&gt; mb;</span><br><span class="line"><span class="keyword">if</span> (ma + mb &gt; k) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span>, <span class="title">id</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : a) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : b) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">LL sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : a) sum += x;</span><br><span class="line"><span class="function">MCMFGraph&lt;<span class="keyword">int</span>, LL&gt; <span class="title">mcmf</span><span class="params">(n - k + <span class="number">2</span>, n * <span class="number">5</span>)</span></span>;</span><br><span class="line">mcmf.S = n - k + <span class="number">2</span>, mcmf.T = n - k + <span class="number">1</span>;</span><br><span class="line">mcmf.<span class="built_in">add</span>(n - k + <span class="number">2</span>, <span class="number">0</span>, k - ma, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">id[i] = mcmf.idx, mcmf.<span class="built_in">add</span>(std::<span class="built_in">max</span>(i - k + <span class="number">1</span>, <span class="number">0</span>), std::<span class="built_in">min</span>(n - k, i) + <span class="number">1</span>, <span class="number">1</span>, b[i] - a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - k; ++ i) mcmf.<span class="built_in">add</span>(i, i + <span class="number">1</span>, k - mb - ma, <span class="number">0</span>);</span><br><span class="line">std::cout &lt;&lt; sum + mcmf.<span class="built_in">solve</span>().second &lt;&lt; std::endl;</span><br><span class="line">LL cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; ++ x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = id[x];</span><br><span class="line"><span class="built_in">putchar</span>(mcmf.edg[i].f ? <span class="string">&#x27;S&#x27;</span> : <span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">cur += !mcmf.edg[i].f * (b[x] - a[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &#x27;\n&#x27; &lt;&lt; cur &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;比较重要的区间限制建网络流方法，以前没有见过，记录一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络流" scheme="https://mydcwfy.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>LOJ3120 [CTS2019]珍珠</title>
    <link href="https://mydcwfy.github.io/2022/06/19/LOJ3120/"/>
    <id>https://mydcwfy.github.io/2022/06/19/LOJ3120/</id>
    <published>2022-06-19T08:02:03.000Z</published>
    <updated>2022-06-19T08:33:44.790Z</updated>
    
    <content type="html"><![CDATA[<p>神秘二项式反演 + EGF 推导题目。</p><span id="more"></span><p>题意：有 $n$ 个 $[1, D]$ 的随机变量，求至少能组成 $m$ 个相同数字的二元组的方案数。$n, m\leq 10 ^ 9$，$ D\leq 10 ^ 5$。</p><p>显然可以计算出现次数为奇数的 $\leq n - 2\times m$ 个。</p><p>首先特判 $2\times m&gt;n$ 和 $2\times m\leq n - D$ 的情况，答案分别为 0 和 $D ^ n$。</p><p>容易发现我们需要对整个序列使用 EGF。我们知道 $\{a, a ^ 2, a ^ 3, \cdots\}$ 的 EGF 是 $e ^ {ax}$，那么 $\{1,1, 1, \cdots\}$ 的 EGF 是 $e ^ x$，$\{1, -1, 1, -1\}$ 的 EGF 是 $e ^ {-x}$，那么我们只要奇数的，那么就是 $\dfrac{e ^ x - e ^ {-x}}{2}$。</p><p>那么我们现在需要计算 $\forall k\in [1, n - 2\times m]$ 的答案，记为 $f(k)$。</p><p>这个是一个恰好的形式，然后考虑二项式反演，计算<strong>钦定 $k$ 个为奇数的答案</strong>，记为 $g(k)$。</p><p>按照刚才的 EGF，我们可以写出 $g(k)$ 的生成函数：<br>$$<br>\begin{aligned}<br>g(k) =&amp; (\dfrac{e ^ x - e ^ {-x}}{2}) ^ ke ^ {(D - k)x}[n] \binom Dk \\<br>=&amp; (e ^ {2x} - 1) ^ ke ^ {(D - 2k)x}[n] \dfrac{\binom Dk}{2 ^ k}\\<br>=&amp; \dfrac{\binom Dk}{2 ^ k} \sum_{i = 0} ^ k \binom ki (-1) ^ {k - i} e ^ {(D - 2k + 2i)x}[n]<br>\end{aligned}<br>$$<br>最后一步是二项式定理展开。然后我们就可以得到 $g(k)$ 的表达式：<br>$$<br>\begin{aligned}<br>g(k) =&amp; \dfrac{\binom Dk}{2 ^ k}\sum_{i = 0} ^ k \binom ki (-1) ^ {k - i} (D - 2k + 2i) ^ n \\<br>=&amp; \dfrac{D!}{(D - k)!2 ^ k}\sum_{i = 0} ^ k \dfrac{1}{i!} (D - 2k + 2i) ^ n\dfrac{(-1) ^ {k - i}}{(k - i)!}<br>\end{aligned}<br>$$<br>于是可以卷积计算 $g(k)$，时间复杂度 $O(D\log D)$。</p><p>然后按照 <a href="/2022/06/18/Luogu-P4491/">Luogu P4491 染色</a> 的套路，容易把二项式反演的过程卷积加速，于是总复杂度 $O(D\log D)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> D, n, m;</span><br><span class="line">    std::cin &gt;&gt; D &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * m &gt; n)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * m &lt;= n - D)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">qpow</span>(D, n)), <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">poly <span class="title">a</span><span class="params">(D + <span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(infact, infact + D + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, op = <span class="number">1</span>, tmp; i &lt;= D; ++ i, op = Mod - op)</span><br><span class="line">        a[i] = <span class="built_in">qpow</span>(<span class="built_in">adj</span>(tmp = D - <span class="number">2</span> * i), n) * (LL) infact[i] % Mod * op % Mod;</span><br><span class="line"></span><br><span class="line">    a = a * b, a.<span class="built_in">resize</span>(D + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= D; ++ i)</span><br><span class="line">        a[i] = (LL) a[i] * fact[D] % Mod * infact[D - i] % Mod * <span class="built_in">qpow</span>(<span class="number">2</span>, Mod - <span class="number">1</span> - i) % Mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= D; ++ i)</span><br><span class="line">        a[i] = (LL) a[i] * fact[i] % Mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= D; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">adj</span>(b[i] = -b[i]);</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    a = a * b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= D; ++ i)</span><br><span class="line">        a[i + D] = (LL) a[i + D] * infact[i] % Mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">2</span> * m; ++ i)</span><br><span class="line">        <span class="built_in">adj</span>(res += a[i + D] - Mod);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;神秘二项式反演 + EGF 推导题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    <category term="二项式反演" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P4705 玩游戏</title>
    <link href="https://mydcwfy.github.io/2022/06/18/Luogu-P4705/"/>
    <id>https://mydcwfy.github.io/2022/06/18/Luogu-P4705/</id>
    <published>2022-06-18T12:46:10.000Z</published>
    <updated>2022-06-18T13:04:37.642Z</updated>
    
    <content type="html"><![CDATA[<p>求自然数等幂和的几乎模板题。</p><span id="more"></span><p>题意：从 $a_1, a_2, \cdots, a_n$ 和 $b_1, b_2\cdots, b_m$ 中任意选数 $x$ 和 $y$，求 $(x + y) ^ k$ 的期望。你需要求出 $k\in [1, t]$ 的所有答案。$n, m, t\leq 10 ^ 5$，3s。</p><p>首先大力拆贡献，可以得到：<br>$$<br>\begin{aligned}<br>ans_k =&amp; \dfrac 1{nm} \sum_{i = 1} ^ n\sum_{j = 1} ^ m (a_i + b_j) ^ k\\<br>=&amp; \dfrac 1{nm} \sum_{i = 1} ^ n \sum_{j = 1} ^ m \sum_{l = 0} ^ k \binom kl a_i ^ l b_j ^ {k - l}\\<br>=&amp; \dfrac 1{nm} \sum_{l = 0} ^ k \binom kl \sum_{i = 1} ^ n a_i ^ l\sum_{j = 1} ^ m b_j ^ {k - l}\\<br>=&amp; \dfrac 1{nm} \sum_{l = 0} ^ k \dfrac{\sum_{i = 1} ^ n a_i ^ l}{l!} \dfrac{\sum_{j = 1} ^ m b_j ^ {k - l}}{(k - l)!}<br>\end{aligned}<br>$$<br>容易发现如果我们已经得到了 $\sum_{i = 1} ^ n a_i ^ l$，卷积一下即可在 $O(n\log n)$ 时间内完成。于是问题变为了快速求出 $\sum_{i = 1} ^ n a_i ^ l$。</p><p>考虑生成函数 $F(x) = \prod_{i = 1} ^ n (a_ix + 1)$，容易发现这个可以使用分治在 $O(n\log ^ 2 n)$ 的时间内求出。</p><p>考虑对两边求 $\ln$，可以得到：$\ln F(x) = \sum_{i = 1} ^ n \ln (a_ix + 1)$。</p><p>考虑对 $\ln(1 + x)$ 泰勒展开，可以得到 $\ln(1 + x) = x - \dfrac{x ^ 2}2 + \dfrac{x ^ 3}3 - \dfrac{x ^ 4}{4}+\cdots$。于是我们带入即可得到：<br>$$<br>\begin{aligned}<br>\ln F(x) =&amp; -\sum_{i = 1} ^ n \sum_{j = 1}\dfrac{(-a_ix) ^ j}{j}\\<br>=&amp; -\sum_{j = 1} ^ n \dfrac{(-x) ^ j}{j} \sum_{i = 1} ^ n a_i ^ j<br>\end{aligned}<br>$$<br>容易发现后半段就是我们要求的东西，于是对 $F(x)$ 取 $\ln$，稍加变换即可得到 $\sum_{i = 1} ^ n a_i ^ j$，于是时间复杂度 $O(n\log ^ 2n)$，<del>稍加卡常</del>即可通过。注意上面的式子无法计算 $\sum_{i = 1} ^ n a_i ^ 0$，需要特殊计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">poly <span class="title">calcpow</span><span class="params">(poly a, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> solve = [&amp;](<span class="keyword">auto</span> &amp;self, poly &amp;a, <span class="keyword">int</span> l, <span class="keyword">int</span> r) -&gt; poly &#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> &#123;<span class="number">1</span>, a[l]&#125;;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">self</span>(self, a, l, mid) * <span class="built_in">self</span>(self, a, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">solve</span>(solve, a, <span class="number">0</span>, a.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">b.<span class="built_in">resize</span>(m + <span class="number">1</span>), b = <span class="built_in">Ln</span>(b);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) <span class="built_in">adj</span>(b[i] = -b[i]);</span><br><span class="line">b[i] = (LL) b[i] * i % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">int</span> n, m, t;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="function">poly <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(m)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : a) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : b) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">std::cin &gt;&gt; t;</span><br><span class="line">a = <span class="built_in">calcpow</span>(a, t), a[<span class="number">0</span>] = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; ++ i) a[i] = (LL) a[i] * infact[i] % Mod;</span><br><span class="line">b = <span class="built_in">calcpow</span>(b, t), b[<span class="number">0</span>] = m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; ++ i) b[i] = (LL) b[i] * infact[i] % Mod;</span><br><span class="line">a = a * b;</span><br><span class="line"><span class="keyword">int</span> Inv = <span class="built_in">qpow</span>((LL) n * m % Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; ++ i) a[i] = (LL) a[i] * fact[i] % Mod * Inv % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;求自然数等幂和的几乎模板题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    <category term="分治" scheme="https://mydcwfy.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P4491 [HAOI2018]染色</title>
    <link href="https://mydcwfy.github.io/2022/06/18/Luogu-P4491/"/>
    <id>https://mydcwfy.github.io/2022/06/18/Luogu-P4491/</id>
    <published>2022-06-18T09:12:28.000Z</published>
    <updated>2022-06-18T09:38:17.333Z</updated>
    
    <content type="html"><![CDATA[<p>简单的二项式反演 + 卷积题目。</p><span id="more"></span><p>题意：对长度为 $n$ 的序列染上 $m$ 个颜色中的一个，假设恰好有 $k$ 个出现次数为 $S$，那么贡献为 $a_k$。求所有染色方案的贡献和。$n\leq 10 ^ 7$，$m\leq 10 ^ 5$。</p><p><strong>看到恰好，二项式反演</strong>。</p><p>设 $f(k)$ 表示<strong>恰好</strong>有 $k$ 个出现次数为 $S$ 的方案数，$g(k)$ 为<strong>钦定</strong>有 $k$ 个出现次数为 $S$ 的方案数，则可以得到：<br>$$<br>\begin{aligned}<br>f(k) =&amp; \sum_{i = k} ^ m (-1) ^ {i - k} \binom ik g(i)\\<br>ans =&amp; \sum_{i = 0} ^ m f(i) a(i)<br>\end{aligned}<br>$$<br>先考虑如何计算 $g(i)$。先选定 $i$ 种颜色 $\binom mi$，从 $n$ 个位置 $i$ 次从挑出 $S$ 个位置，贡献为 $\dfrac{n!}{S! ^ i (n - iS)!}$，剩下的 $n - iS$ 个位置可以任意填 $m - i$ 颜色的任意一个，为 $(m - i) ^ {n - iS}$，于是 $g(i)$ 为：<br>$$<br>g(i) = \binom mi \dfrac{n!(m - i) ^ {n - iS}}{S! ^ i (n - iS)!}<br>$$<br>可以在 $O(m\log m)$ 时间计算。</p><p>然后考虑如何由 $g(i)$ 算出 $f(i)$，根据组合数的性质容易得到：<br>$$<br>k!f(k) = \sum_{i = k} ^ m \dfrac{(-1) ^ {i - k}}{(i - k)!}i!g(i)<br>$$<br>显然是一个差卷积的形式，复杂度 $O(m\log m)$，预处理阶乘及逆元为 $O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">int</span> n, m, S;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; S;</span><br><span class="line"><span class="function">poly <span class="title">w</span><span class="params">(m + <span class="number">1</span>)</span>, <span class="title">g</span><span class="params">(infact, infact + m + <span class="number">1</span>)</span>, <span class="title">f</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &amp; <span class="number">1</span>) <span class="built_in">adj</span>(g[i] = -g[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : f) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i * S &gt; n) w[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> w[i] = (LL) <span class="built_in">C</span>(m, i) * fact[n] % Mod * <span class="built_in">qpow</span>(infact[S], i) % Mod</span><br><span class="line">* infact[n - i * S] % Mod * <span class="built_in">qpow</span>(m - i, n - i * S) % Mod * fact[i] % Mod;</span><br><span class="line">std::<span class="built_in">reverse</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">w = w * g;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= <span class="number">2</span> * m; ++ i)</span><br><span class="line">res = (res + (LL) w[i] * infact[i - m] % Mod * f[i - m]) % Mod;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= <span class="number">2</span> * m; ++ i) <span class="built_in">adj</span>(sum += w[i] * (LL) infact[i - m] % Mod - Mod);</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单的二项式反演 + 卷积题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    <category term="二项式反演" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>CF1375H Set Merging</title>
    <link href="https://mydcwfy.github.io/2022/06/18/CF1375H/"/>
    <id>https://mydcwfy.github.io/2022/06/18/CF1375H/</id>
    <published>2022-06-18T03:39:43.000Z</published>
    <updated>2022-06-18T06:21:52.069Z</updated>
    
    <content type="html"><![CDATA[<p>一道平衡规划分析复杂度的题目。</p><span id="more"></span><p>题意：你开始有 $n$ 个集合 $\{a_1\}, \{a_2, \}\cdots, \{a_n\}$，其中 $a_1, a_2, \cdots, a_n$ 是一个排列。你可以合并两个集合 $A$ 和 $B$，但需要保证 $\max(A)&lt;\min(B)$。注意合并之后 $A$ 和 $B$ 仍然存在。给定 $q$ 次询问 $[l, r]$，你需要合并出一个 $\{a_l, a_{l + 1},\cdots, a_r\}$，并输出编号。$n\leq 2 ^ {12}, q\leq 2 ^ {16}$，要求最后集合总数不超过 $2.2\times 10 ^ 6$。</p><p>先不考虑复杂度，我们直接考虑合并出所有答案：建一个值域线段树，计算当值域区间为 $[l, r]$，询问区间为 $[ql, qr]$ 时的答案，输出的编号显然是 $[1, n]$ 的答案。直接考虑在线段树上合并，将 $[l, mid]$ 和 $[mid + 1, r]$ 的答案合并起来。</p><p>这样其实是 $O(nq)$ 的，但是大家肯定都能想到将所有在一个节点的询问记忆化一下，还可以把 $[l, r]$ 区间离散化到当前节点所对应所有位置的集合再记忆化。</p><p>等你码完之后，你小心翼翼地写好提交，正准备迎接 Wrong Answer 的事实时，却发现过了！（如果你没有被卡常的话</p><p>下面考虑分析复杂度。假设 $d = \lceil\log_2 q\rceil, t = \lceil\log_2 n\rceil$，对于下面的 $\dfrac d2$ 层，假设所有的询问能将这些所有层的所有区间卡满，这一部分就是：<br>$$<br>cost = \sum_{i = 0} ^ {\frac d2}2 ^ {t - i} 2 ^ {2i} = 2 ^ {t + \frac d2} = O(n\sqrt q)<br>$$<br>其中第一部分表示节点个数，第二部分表示每一个节点所有的子区间。</p><p>对于上面的 $t - \dfrac d2$ 层，由于一次询问最多只能覆盖一个节点的一个区间，于是这一部分就是：<br>$$<br>cost = 2 ^ {t - \frac d2}q = 2 ^ {t + \frac d2} = O(n\sqrt q)<br>$$<br>于是最多只会合并出 $O(n\sqrt q)$ 个区间，在本题数据范围下为 $10 ^ 6$，实际运行为 $1.7\sim 2.0 \times 10 ^ 6$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[x] = &#123;l, r, std::vector&lt;<span class="keyword">int</span>&gt;(r - l + <span class="number">1</span>)&#125;;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(tr[x].allid.<span class="built_in">front</span>() = nw[l]);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="keyword">auto</span> &amp;v1 = tr[x &lt;&lt; <span class="number">1</span>].allid, &amp;v2 = tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].allid;</span><br><span class="line">std::<span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), tr[x].allid.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> &amp;v = tr[x].allid;</span><br><span class="line"><span class="keyword">auto</span> iter1 = std::<span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), l), iter2 = std::<span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), r);</span><br><span class="line"><span class="keyword">if</span> (iter1 == v.<span class="built_in">end</span>() || iter2 == v.<span class="built_in">begin</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">l = *iter1, r = *-- iter2;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">if</span> (tr[x].mp.<span class="built_in">count</span>(&#123;l, r&#125;)) <span class="keyword">return</span> tr[x].mp[&#123;l, r&#125;];</span><br><span class="line"><span class="keyword">int</span> sl = <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span>, l, r), sr = <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line"><span class="keyword">if</span> (!sl || !sr) <span class="keyword">return</span> sl | sr;</span><br><span class="line">gt[++ tot] = &#123;sl, sr&#125;;</span><br><span class="line"><span class="keyword">return</span> tr[x].mp[&#123;l, r&#125;] = tot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) nw[p[i]] = i;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n), tot = n;</span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">while</span> (Q --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">ans.<span class="built_in">push_back</span>(<span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">write</span>(tot, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= tot; ++ i) <span class="built_in">write</span>(gt[i].first, <span class="string">&#x27; &#x27;</span>, gt[i].second, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : ans) <span class="built_in">write</span>(x, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一道平衡规划分析复杂度的题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="线段树" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="平衡规划" scheme="https://mydcwfy.github.io/tags/%E5%B9%B3%E8%A1%A1%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>UOJ37 主旋律</title>
    <link href="https://mydcwfy.github.io/2022/06/12/UOJ37/"/>
    <id>https://mydcwfy.github.io/2022/06/12/UOJ37/</id>
    <published>2022-06-12T01:20:32.000Z</published>
    <updated>2022-06-12T02:54:13.884Z</updated>
    
    <content type="html"><![CDATA[<p>有点（？）难推的容斥 + 状态压缩。</p><span id="more"></span><p>题意：问 $n$ 个点 $m$ 条边的有向图中，任意保留一些边使得 $n$ 个点仍然是一个强连通分量的方案数。$n\leq 15, m\leq n(n - 1)$。</p><p>定义 $f(s)$ 表示集合 $s$ 中所有点及内部的边（指端点都属于 $s$）任意保留使得仍然是强连通分量的方案数。</p><p>首先设 $E(s_1, s_2)$ 表示起点在 $s_1$ 集合中，终点在 $s_2$ 集合中的边数。</p><p>显然正着不好做，考虑容斥，那么不止一个强连通分量，那么缩点后一定会产生出度为 0 的点，钦定强连通分量出度为 0 的点集合为 $t_1$，没被选中的集合为 $t_2$，那么 $E(t_2, t_1)$ 和  $E(t_2, t_2)$ 都是可以选的，$E(t_1, t_1)$ 的贡献由 $g(t_1)$ 计算，那么可以得到：<br>$$<br>g(s) = 2 ^ {E(s, s)} - \sum_{t_1 \subsetneq s} 2 ^ {E(t_2, t_1) + E(t_2, t_2)} g(t_1)<br>$$<br>注意此时我们的 $g(s)$ 是自带系数的，根据经典的容斥，我们 $g(s)$ 的系数应该是 $(-1) ^ {k + 1}$，$k$ 表示出度为 0 的点的强连通分量个数。</p><p>然后考虑 $g(s)$ 的定义式，我们枚举最小编号所在的集合，那么就可以得到：<br>$$<br>g(s) = -\sum_{t\subsetneq s, t\not=\varnothing}[id\in t]f(t)g(s/t) + f(s)<br>$$<br>前面我们可以计算到 $g(s)$，把这个式子变一下形，可以得到：<br>$$<br>f(s) = g(s) + \sum_{t\subsetneq s, t\not= \varnothing}[id\in t]f(t)g(s/t)<br>$$<br>即可做到 $O(3 ^ n)$ 计算，可以通过。代码中是将 $g(0)$ 设为 -1，贡献不变。</p><p>两个集合之间的连边可以枚举一边集合的点，计算另一边到这个点的边数，到点的边数可以预处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">pw2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; M; ++ i) <span class="built_in">adj</span>(pw2[i] = (pw2[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>) - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++ i)</span><br><span class="line">std::cin &gt;&gt; u &gt;&gt; v, edg[-- u][-- v] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; ++ u)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; ++ v)</span><br><span class="line"><span class="keyword">if</span> ((s &gt;&gt; u &amp; <span class="number">1</span>) &amp;&amp; (s &gt;&gt; v &amp; <span class="number">1</span>)) in[s] += edg[u][v];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; ++ u)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; ++ v)</span><br><span class="line"><span class="keyword">if</span> (s &gt;&gt; v &amp; <span class="number">1</span>) to[s][u] += edg[v][u];</span><br><span class="line">g[<span class="number">0</span>] = Mod - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> calclink = [&amp;](<span class="keyword">int</span> s1, <span class="keyword">int</span> s2) &#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (s2) res += to[s1][<span class="built_in">ctz</span>(s2)], s2 ^= s2 &amp; -s2;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line">&#123;</span><br><span class="line">g[s] = pw2[in[s]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> frm = s &amp; (s - <span class="number">1</span>); frm; frm = (frm - <span class="number">1</span>) &amp; s)</span><br><span class="line"><span class="built_in">adj</span>(g[s] -= (LL) g[frm] * pw2[in[s ^ frm]] % Mod * pw2[<span class="built_in">calclink</span>(s ^ frm, frm)] % Mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line">&#123;</span><br><span class="line">f[s] = g[s];</span><br><span class="line"><span class="keyword">int</span> le = <span class="built_in">ctz</span>(s);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> frm = s &amp; (s - <span class="number">1</span>); frm; frm = (frm - <span class="number">1</span>) &amp; s)</span><br><span class="line"><span class="keyword">if</span> (frm &gt;&gt; le &amp; <span class="number">1</span>) f[s] = (f[s] + (LL) f[frm] * g[s ^ frm]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有点（？）难推的容斥 + 状态压缩。&lt;/p&gt;</summary>
    
    
    
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>CF995F Cowmpany Cowmpensation</title>
    <link href="https://mydcwfy.github.io/2022/06/12/CF995F/"/>
    <id>https://mydcwfy.github.io/2022/06/12/CF995F/</id>
    <published>2022-06-12T00:39:08.000Z</published>
    <updated>2022-06-12T01:08:00.734Z</updated>
    
    <content type="html"><![CDATA[<p>比较套路的二项式反演 + 树形 DP。</p><span id="more"></span><p>题意：给定 $n$ 个点的根为 1 的树，现在你要为 $n$ 个点赋上一个 $[1, D]$ 的值，儿子权值不能超过父亲。问合法的赋值方案。$n\leq 3000, D\leq 10 ^ 9$，对 $10 ^ 9 + 7$ 取模。</p><p>看样子是 $O(n ^ 2)$ 的做法。</p><p>虽然朴素 DP 是 $O(nD)$ 的（前缀和优化），但是我们发现这样其实真正用到的元素一定不超过 $n$ 个，如果记 $f(x)$ 为所有权值恰好有 $x$ 个不同的，那么答案可以写作：<br>$$<br>ans = \sum_{i = 1} ^ n f(i) \binom Di<br>$$<br>这个式子容易 $O(n)$ 计算，现在问题转化为求 $f(x)$。</p><p>我们仍然按照朴素 DP 的方式，但值域仅为 $[1, n]$，这样一定是 $O(n ^ 2)$ 的，记 $g(x)$ 为我们最后得到的 DP 数组，其意义为最大值为 $x$ 的方案数。</p><p>按照组合意义拆分，容易得到：<br>$$<br>g(x) = \sum_{i = 1} ^ x \binom{x - 1}{i - 1} f(i)<br>$$<br>容易二项式反演得到：<br>$$<br>f(x) = \sum_{i = 1} ^ x (-1) ^ {x - i} \binom{x - 1}{i - 1} g(i)<br>$$<br>这样就可以 $O(n ^ 2)$ 计算了。</p><p>另外，这个式子也可以简单容斥：<br>$$<br>\begin{aligned}<br>g(x) =&amp; f(x) + \sum_{i = 1} ^ {x - 1} \binom{x - 1}{i - 1} f(i)\\<br>f(x) =&amp; g(x) - \sum_{i = 1} ^ {x - 1} \binom{x - 1}{i - 1} f(i)<br>\end{aligned}<br>$$<br>这样就可以 $O(n ^ 2)$ 计算了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; D;</span><br><span class="line">infact[<span class="number">1</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">infact[i] = (LL) infact[Mod % i] * (Mod - Mod / i) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) infact[i] = (LL) infact[i] * infact[i - <span class="number">1</span>] % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = C[i][<span class="number">0</span>] = <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line"><span class="built_in">adj</span>(C[i][j] = C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j] - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, f + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) dp[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) <span class="built_in">adj</span>(s[i][j] = s[i][j - <span class="number">1</span>] + dp[i][j] - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">dp[f[i]][j] = dp[f[i]][j] * (LL) s[i][j] % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line"><span class="keyword">if</span> (!((i - j) &amp; <span class="number">1</span>)) g[i] = (g[i] + dp[<span class="number">1</span>][j] * (LL) C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % Mod;</span><br><span class="line"><span class="keyword">else</span> g[i] = (g[i] + (Mod - dp[<span class="number">1</span>][j]) * (LL) C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % Mod;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt;= n; ++ i)</span></span><br><span class="line"><span class="comment">for (int j = 1; j &lt; i; ++ j)</span></span><br><span class="line"><span class="comment">adj(dp[1][i] -= (LL) dp[1][j] * C[i - 1][j - 1] % Mod);</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt;= n; ++ i) g[i] = dp[1][i];</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, dn = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; i &lt;= D; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">dn = dn * (LL) (D - i + <span class="number">1</span>) % Mod;</span><br><span class="line">res = (res + (LL) dn * infact[i] % Mod * g[i]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;比较套路的二项式反演 + 树形 DP。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="二项式反演" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>ARC093F Dark Horse</title>
    <link href="https://mydcwfy.github.io/2022/06/11/ARC093F/"/>
    <id>https://mydcwfy.github.io/2022/06/11/ARC093F/</id>
    <published>2022-06-11T14:07:14.000Z</published>
    <updated>2022-06-12T07:58:11.654Z</updated>
    
    <content type="html"><![CDATA[<p>经典容斥。</p><span id="more"></span><p>题意：有 $2 ^ n$ 个选手进行淘汰赛，比赛时编号小的会获胜，但是当 1 号选手遇到给定 $m$ 位选手中的任意一个，他将会输掉比赛。问怎样合理的安排顺序，使得 1 号选手能获胜。$n, m\leq 16$。</p><p>首先 1 号选手的位置在 $[1, 2 ^ n]$ 中任意位置是一样的，所以最后答案乘上 $2 ^ n$。</p><p>然后其实很多的排法，我们只关心其中 $n$ 棵子树的最小值即可，并不关心是如何排布的。如下图，我们只需要关心蓝色子树的最小值即可。</p><img src="/2022/06/11/ARC093F/1.png" class=""><p>考虑容斥，题目要求这些子树的最小值中不能出现 $m$ 个数中的一个，那么考虑钦定其中 $k$ 个子树最小值是 $m$ 个数当中的，贡献乘上 $(-1) ^ k$。</p><p>如果我们要钦定大小为 $sz$ 的子树的最小值为 $v$，注意钦定的时候我们剩下的 $sz - 1$ 个都要严格大于 $v$。</p><p>注意如果我们乱序加入 $v$ 的话，我们其实是并不知道大于 $v$ 的有多少个。类似于 <a href="/2022/05/30/LOJ3119">LOJ3119 随机正方体</a> 的方式，我们倒序枚举 $v$ 加入，这样枚举到 $v$ 的时候，前面所有钦定的一定都是大于 $v$ 的，就避免了大于 $v$ 的个数不确定的情况。随便状态压缩一下，记录哪些 $sz$ 已经钦定了最小值即可，转移时乘一下组合数，最后注意排列顺序即可。时间复杂度 $O(mn2 ^ n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">usd</span><span class="params">(m)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : usd) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">std::<span class="built_in">sort</span>(usd.<span class="built_in">begin</span>(), usd.<span class="built_in">end</span>());</span><br><span class="line">f[m + <span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i; -- i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!f[i + <span class="number">1</span>][s]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">adj</span>(f[i][s] += f[i + <span class="number">1</span>][s] - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line"><span class="keyword">if</span> (!(s &gt;&gt; j &amp; <span class="number">1</span>))</span><br><span class="line">f[i][s | (<span class="number">1</span> &lt;&lt; j)] = (f[i][s | (<span class="number">1</span> &lt;&lt; j)] + (LL)</span><br><span class="line"><span class="built_in">C</span>((<span class="number">1</span> &lt;&lt; n) - usd[i - <span class="number">1</span>] - s, (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span>) * (Mod - f[i + <span class="number">1</span>][s])) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mul = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (s &gt;&gt; i &amp; <span class="number">1</span>) mul = (LL) mul * fact[<span class="number">1</span> &lt;&lt; i] % Mod;</span><br><span class="line">res = (res + (LL) f[<span class="number">1</span>][s] * mul % Mod * fact[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> - s]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">res = res * (<span class="number">1LL</span> &lt;&lt; n) % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典容斥。&lt;/p&gt;</summary>
    
    
    
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
</feed>
