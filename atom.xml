<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mydcwfy&#39;s Blog</title>
  
  
  <link href="https://mydcwfy.github.io/atom.xml" rel="self"/>
  
  <link href="https://mydcwfy.github.io/"/>
  <updated>2022-05-30T08:42:15.997Z</updated>
  <id>https://mydcwfy.github.io/</id>
  
  <author>
    <name>mydcwfy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CF1103E Radix Sum</title>
    <link href="https://mydcwfy.github.io/2022/05/30/CF1103E/"/>
    <id>https://mydcwfy.github.io/2022/05/30/CF1103E/</id>
    <published>2022-05-30T08:00:52.000Z</published>
    <updated>2022-05-30T08:42:15.997Z</updated>
    
    <content type="html"><![CDATA[<p>10 进制 FWT 的写法。</p><span id="more"></span><p>题意：给定 $n$ 个整数 $a_1, a_2, \dots, a_n$，求有多少个长度为 $n$ 的序列满足每一个数都从 $n$ 个数里面选（不同位置算不同方案），且 10 进制不进位加法后答案为 $x$。输出 $x\in [0, n - 1]$ 的答案。$n\leq 10 ^ 5, a_i &lt; 10 ^ 5$，答案对 $2 ^ {58}$ 取模。</p><p>容易发现我们只需要实现十进制 FWT，直接快速幂再逆变换即可。</p><p>首先考虑 FWT 的本质其实是一种高维的 FFT，只不过每一维的长度都是 2。现在考虑如何变为长度为 10。</p><p>FFT 的过程需要乘上 $\omega_{10} ^ k$，这个在 $\bmod 2 ^ {58}$ 下似乎是没有整数与之对应，所以我们需要用一个多项式表示，为 $\sum_{i = 0} ^ 9 a_i \omega_{10}^i$。用这个就可以使用 FFT 计算了。</p><p>另外，我们还需要考虑另外的问题：最后我们每一维都需要除以一个 10，最后就是除以 $10 ^ 5$，但是 $10 ^ 5$ 在 $\bmod 2 ^ {58}$ 意义下没有逆元。容易发现我们是因为有 $2 ^ 5$ 的缘故，我们可以保留答案 $\bmod 2 ^ {63}$ 意义下的结果，最后直接除，就不需要管逆元了。$5 ^ 5$ 在 $\bmod 2 ^ {63}$ 意义下的逆元可以扩欧计算，所以就可以算了。</p><p>最后我们得到的答案是一个多项式，但是由于单位根的性质，表示并不是唯一的。$\omega_{10} ^ 5 = -1, \omega_{10} ^ 9 = -\sum_{i = 0} ^ 8 \omega_{10} ^ i$，用这两个式子我们可以把这个多项式化成 $\sum_{i = 0} ^ 3 a_i\omega_{10}^i$，不能再转换，可以证明<del>盲猜一下</del>这时 $a_0$ 的答案就是最终答案。</p><p>实际代码中，我们使用 <code>unsigned long long</code> 计算即可。时间复杂度不好算，不过 <code>unsigned long long</code> 常数小，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ULL inv5 = <span class="number">14757395258967641293ULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">ULL a[<span class="number">5</span>];</span><br><span class="line">ULL&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> a[x]; &#125;</span><br><span class="line">Complex <span class="keyword">operator</span> +(Complex t) &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;a[<span class="number">0</span>] + t[<span class="number">0</span>], a[<span class="number">1</span>] + t[<span class="number">1</span>], a[<span class="number">2</span>] + t[<span class="number">2</span>], a[<span class="number">3</span>] + t[<span class="number">3</span>], a[<span class="number">4</span>] + t[<span class="number">4</span>]&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span> -(Complex t) &#123; </span><br><span class="line"><span class="keyword">return</span> &#123;a[<span class="number">0</span>] - t[<span class="number">0</span>], a[<span class="number">1</span>] - t[<span class="number">1</span>], a[<span class="number">2</span>] - t[<span class="number">2</span>], a[<span class="number">3</span>] - t[<span class="number">3</span>], a[<span class="number">4</span>] - t[<span class="number">4</span>]&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125; f[N];</span><br><span class="line"> </span><br><span class="line">Complex <span class="keyword">operator</span> *(Complex a, Complex b)</span><br><span class="line">&#123;</span><br><span class="line">Complex res&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++ j)</span><br><span class="line"><span class="keyword">if</span> (i + j &gt;= <span class="number">5</span>) res[i + j - <span class="number">5</span>] -= a[i] * b[j];</span><br><span class="line"><span class="keyword">else</span> res[i + j] += a[i] * b[j];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Complex <span class="title">qpow</span><span class="params">(Complex a, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Complex res&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = a * a)</span><br><span class="line"><span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * a;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Complex <span class="title">transw</span><span class="params">(Complex a, <span class="keyword">int</span> typ)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Complex res&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> to = (i + typ + <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (to &gt;= <span class="number">5</span>) res[to - <span class="number">5</span>] -= a[i];</span><br><span class="line"><span class="keyword">else</span> res[to] += a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FWT</span><span class="params">(Complex a[], <span class="keyword">int</span> typ)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; N; mid *= <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i += mid * <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++ j)</span><br><span class="line">&#123;</span><br><span class="line">Complex tmp[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++ k) tmp[k] = a[i + mid * k + j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++ k)</span><br><span class="line">&#123;</span><br><span class="line">Complex &amp;cur = a[i + mid * k + j];</span><br><span class="line">cur = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">10</span>; ++ p) cur = cur + tmp[p];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">10</span>; ++ p) tmp[p] = <span class="built_in">transw</span>(tmp[p], typ * p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (typ == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">ULL inv = inv5 * inv5 * inv5 * inv5 * inv5;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++ j) a[i][j] *= inv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;10 进制 FWT 的写法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    <category term="集合幂级数" scheme="https://mydcwfy.github.io/tags/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P4931</title>
    <link href="https://mydcwfy.github.io/2022/05/27/Luogu-P4931/"/>
    <id>https://mydcwfy.github.io/2022/05/27/Luogu-P4931/</id>
    <published>2022-05-27T11:41:27.000Z</published>
    <updated>2022-05-27T14:00:05.274Z</updated>
    
    <content type="html"><![CDATA[<p>使劲反演、生成函数，数学功底似乎得有比较高的要求。</p><span id="more"></span><p>题意：有 $n$ 对 CP，任意做 $n$ 排双人座，求恰好有 $k$ 对 CP 坐在一排的方案数。$T(T\leq 2\times 10 ^ 5)$ 组数据，$n\in [1, 5\times 10 ^ 6]$，$ k\in [0, n]$。</p><p><strong>看到恰好，显然容斥</strong>。</p><p>这里可以用到二项式反演，具体地，我们考虑 $f(k)$ 表示恰好 $k$ 对 CP 坐在一排，$g(k)$ 表示<strong>钦定</strong> $k$ 对 CP 坐在一排。</p><p>$g(k)$ 是好求的，显然就是 $\displaystyle \binom nk ^ 2k!2 ^ k(2(n - k))!$，分别是选 CP，选座位，任意排列 CP，CP 位置交换，剩下的人随便坐。</p><p>由二项式反演可得：<br>$$<br>f(k) = \sum_{i = k} (-1) ^ {i - k} \binom ik g(k)<br>$$<br>直接暴力计算，可以做到 $O(n)$ 的时间复杂度，可以通过未通过加强版。</p><p>另外，我们可以先选 $k$ 对，然后用 $h(n)$ 表示没有一对 CP 坐在一起的方案数。</p><p>那么答案可以写作：<br>$$<br>ans = \binom nk ^ 2 k! 2 ^ k h(n - k)<br>$$<br>前面的可以 $O(\log k)$ 回答，主要是后面的看能不能做到 $O(n)$ 递推。</p><p>容易得到 $h(n)$ 的表达式为：<br>$$<br>h(n) = \sum_{i = 0} ^ n (-1) ^ i \binom ni ^ 2 i! 2 ^ i (2(n - i))!<br>$$<br>容易化为卷积形式，做到 $O(n\log n)$ 的复杂度：<br>$$<br>h(n) = n! ^ 2 \sum_{i = 0} ^ n \dfrac{(-2) ^ i}{i!} \dfrac{(2(n - i))!}{(n - i)! ^ 2}<br>$$<br>就是 $h_1(x) = \sum_{n = 0}\dfrac{(-2) ^ i}{i!}x ^ i, h_2(x) = \sum_{n = 0} \dfrac{(2n)!}{n! ^ 2}x ^ i$ 的卷积。</p><p>显然需要 $O(n)$ 递推，考虑求出 $h_1(x) \times h_2(x)$ 的生成函数。<br>$$<br>\begin{aligned}<br>h_1(x) &amp;= \sum_{i = 0}\dfrac{(-2) ^ i}{i!} x^i = e ^ {-2x}\\<br>h_2(x) &amp;= \sum_{i = 0}\dfrac{2i!}{i! ^ 2} x ^ i = \sum_{i = 0} \binom{2i}i x ^ i<br>\end{aligned}<br>$$<br>下面的式子可以化为 $\dfrac1{\sqrt {1 - 4x}}$，这里就不再详细展开。</p><p>那么就得到 $h(x) = h_1(x) \times h_2(x) = \dfrac{e ^ {-2x}}{\sqrt{1 - 4x}}$（先不考虑前面的 $n! ^ 2$）</p><p>考虑求导，那么就是 $h’(x) = \dfrac{8x\times e ^ {-2x}}{(1-4x) ^ {\frac 32}} = \dfrac{8x}{1 - 4x}h(x)$。</p><p>提取两边的 $[x ^ n]$，容易得到：<br>$$<br>\begin{aligned}<br>[x ^ n]F’(x) - 4[x ^ {n - 1}]F’(x) &amp;= 8[x ^ {n - 1}]F(x)\\<br>(n + 1)f_{n + 1} - 4nf_n &amp;= 8f_{n - 1}<br>\end{aligned}<br>$$<br>按照此递推即可，时间复杂度  $O(n + T\log k)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) fact[i] = (LL) fact[i - <span class="number">1</span>] * i % Mod;</span><br><span class="line">infact[N - <span class="number">1</span>] = <span class="built_in">qpow</span>(fact[N - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">2</span>; i; -- i) infact[i] = (LL) infact[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % Mod;</span><br><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++ i) inv[i] = (LL) (Mod - Mod / i) * inv[Mod % i] % Mod;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>, f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N - <span class="number">1</span>; ++ i)</span><br><span class="line">f[i + <span class="number">1</span>] = (<span class="number">4LL</span> * i * f[i] + <span class="number">8LL</span> * f[i - <span class="number">1</span>]) % Mod * inv[i + <span class="number">1</span>] % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> (LL) fact[n] * infact[m] % Mod * infact[n - m] % Mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">int</span> n, k, T;</span><br><span class="line">std::cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">int</span> res = (LL) <span class="built_in">qpow</span>(<span class="built_in">C</span>(n, k), <span class="number">2</span>) * fact[k] % Mod</span><br><span class="line">* <span class="built_in">qpow</span>(<span class="number">2</span>, k) % Mod * f[n - k] % Mod * <span class="built_in">qpow</span>(fact[n - k], <span class="number">2</span>) % Mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使劲反演、生成函数，数学功底似乎得有比较高的要求。&lt;/p&gt;</summary>
    
    
    
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="生成函数" scheme="https://mydcwfy.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
    <category term="二项式反演" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>万能欧几里得简介</title>
    <link href="https://mydcwfy.github.io/2022/05/19/Universal-Euclidean/"/>
    <id>https://mydcwfy.github.io/2022/05/19/Universal-Euclidean/</id>
    <published>2022-05-19T14:01:22.000Z</published>
    <updated>2022-05-20T10:13:25.818Z</updated>
    
    <content type="html"><![CDATA[<p>经典的下取整求和，一般不能使用数论分块等（因为被除数不固定）。</p><span id="more"></span><p>使用类欧几里得的模板题吧（为什么不讲类欧呢？因为感觉没什么用……）。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>题意：求<br>$$<br>\sum_{i = 0} ^ n \left\lfloor\dfrac{ai + b}c \right\rfloor<br>$$<br>$T \leq 10 ^ 5, a, b, c, n\leq 10 ^ 9, c\not= 0$。</p><p>看到如此庞大的数据范围，大概率是对数做法了。</p><p>将其放在坐标系下，我们可以看作 $y = \dfrac{ax + b}c$，定义这个直线生成的字符串为：越过一个 $x$ 整点，则加一个 <code>R</code>，越过一个 $y$ 整点，则加一个 <code>U</code>，遇到同时的整点先 <code>U</code> 后 <code>R</code>。容易发现这样下去答案一定只和这个字符串有关。</p><p>比如对于这个，我们计算答案，即为：遇到 <code>U</code> 则 <code>cnt ++</code>，遇到 <code>R</code> 就 <code>res += cnt</code>。</p><p>考虑合并两个已经计算好的答案，我们尝试使用一个结构体维护，容易发现答案需要和前面的 <code>U</code> $cntu$，后面 <code>R</code> 的个数 $cntr$，前后的答案，那么我们可以合并这两个的答案。具体可以写作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="keyword">operator</span> *(Node a, Node b)</span><br><span class="line">&#123;</span><br><span class="line">Node res;</span><br><span class="line"><span class="built_in">adj</span>(res.u = a.u + b.u - Mod), <span class="built_in">adj</span>(res.r = a.r + b.r - Mod);</span><br><span class="line">res.ans = (a.ans + b.ans + <span class="built_in">LL</span>(a.u) * b.r) % Mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们现在需要做的事情就是将整个序列拆开，最后合并答案。首先我们定义最开始单次向右 <code>R</code> 的结构体 <code>fr</code> 和单次向上 <code>U</code> 的结构体 <code>fu</code>，这样就可以最后合并得到答案。</p><p>令最开始的答案为 <code>f(a, b, c, n, fu, fr)</code>，其中 <code>fu</code> 表示向上走一步所乘的结构体，<code>fr</code> 表示向右走一步要成的结构体。注意这里可能不再是开始递归进入的 <code>fu, fr</code></p><p>首先我们考虑第一种情况 $a\geq c$，于是可以将 $a\geq c$ 的变为 $a &lt; c$，具体的，每次 <code>R</code> 前面相当于多加入了 $\left\lfloor\dfrac ac \right\rfloor$ 个 <code>U</code>，那么我们可以直接写作 <code>f(a % c, b, c, n, fu, qpow(fu, a / c) * fr)</code>，<code>qpow</code> 表示快速幂。</p><p>那么现在我们需要考虑的就是 $a &lt; c$ 的情况。一个初步的想法是我们现在 $y = \dfrac{ax + b}c$ 的斜率是小于 1 的，我们可以将 $x, y$ 交换一下，将 <code>fu, fr</code> 交换一下，这样就可以将斜率变为大于 1 的情况，从而可以继续递归。</p><p>我们显然可以变形为 $x = \dfrac{cy - b}{a}$（为了清楚，这里只是对式子进行了变形，没有把 $x, y$ 交换）。但是我们需要注意有 <code>U</code> 和 <code>R</code> 的优先级的问题。比如下图：</p><img src="/2022/05/19/Universal-Euclidean/%E7%BF%BB%E8%BD%AC%E5%9B%BE1.png" class=""><p>原来的线经过了 $(1, 1)$，是先 <code>U</code> 后 <code>R</code>，但是翻转之后，变成了先 <code>R</code> 后 <code>U</code>，所以我们需要将这条线向右平移 $\dfrac 1a$ 个单位，这样就是先 <code>U</code> 后 <code>R</code>，对应上了原来的字符串。</p><p>于是我们现在需要计算的就是 $x = \dfrac{cy - b - 1}a$ 的答案。注意我们现在这个的定义域是 $(0, n]$，即我们需要计算最开始的 <code>fu</code> 贡献，但不计算最开始 <code>fr</code> 的贡献。所以可以得到 $b$ 是属于 $[0, c - 1]$ 的。</p><p>回到上面那张图，我们发现 $(0, 1]$ 的部分的答案是不完整的，我们不能直接扔给下一个算，那么前面所经过的 $\left\lfloor\dfrac{c - b - 1} a \right\rfloor$ 个 <code>fu</code> 是需要提前乘入的，另外还有一个 <code>fr</code>。</p><p>然后我们考虑 $(1, \left\lfloor\dfrac{an + b}c \right\rfloor]$ 这段区间如何计算。容易发现这就是我们需要递归的部分，但是注意，我们计算的定义域是 $(0, n]$，所以需要我们向左平移一个单位得到 $x = \dfrac{cy + c - b - 1}{a}$，所以应该递归到 <code>f(c, c - b - 1, a, m - 1, fr, fu)</code>（$m = \left\lfloor\dfrac{an + b}c \right\rfloor$）。</p><p>最后我们需要考虑 $y &gt; m, x\leq n$，这样我们转化一下就是 $x\in (\left\lfloor\dfrac{cm - b - 1}a \right\rfloor, n]$，容易发现我们需要乘上 <code>qpow(fu, n - (c * m - b - 1) / a)</code>。</p><p>那么我们就可以得到最后的 <code>AsGcd</code> 代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">AsGcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> n, Node fu, Node fr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b %= c;</span><br><span class="line"><span class="keyword">if</span> (a &gt;= c) <span class="keyword">return</span> <span class="built_in">AsGcd</span>(a % c, b, c, n, fu, <span class="built_in">qpow</span>(fu, a / c) * fr);</span><br><span class="line">LL m = (<span class="built_in">LL</span>(a) * n + b) / c;<span class="comment">// y = (cx - b - 1) / a</span></span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">qpow</span>(fr, n);<span class="comment">// all is fr</span></span><br><span class="line">std::<span class="built_in">swap</span>(fu, fr);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">qpow</span>(fu, (c - b - <span class="number">1</span>) / a) * fr <span class="comment">// solving x in [0, 1]</span></span><br><span class="line">* <span class="built_in">AsGcd</span>(c, c - b - <span class="number">1</span>, a, m - <span class="number">1</span>, fu, fr) <span class="comment">// solving x in (1, m]</span></span><br><span class="line">* <span class="built_in">qpow</span>(fu, n - (c * m - b - <span class="number">1</span>) / a) <span class="comment">// solving x in [m, m + 1), notice that y_max = n</span></span><br><span class="line">;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似欧几里得算法，得到时间复杂度 $O(\log(a + c))$，不过常数比较大。</p><p>最后递归的时候，注意到 0 是被包含进入答案的，所以递归前，我们要先乘上 <code>qpow(fu, b / c) * fr</code>。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>给定 $a, b, c, l$ 和 $n\times n$ 的矩阵 $A, B$，求：<br>$$<br>\sum_{i = 1} ^ l A ^ {i} B ^ {\lfloor\frac{ai + b}{c} \rfloor}<br>$$<br>$a, b, c, \lfloor\dfrac{al + b}{c}\rfloor\leq 10 ^ {18}$。</p><p>通过这个题，我们就可以看出万能欧几里得的优势：只需要将上面的模板记住（或手推），然后处理一下信息的合并即可。这相对于类欧几里得优化了许多，思维量减小了不少。</p><p>看这个题，如果我们需要合并两个已经计算好的信息，我们需要维护 $A ^ x$，这就是后面的答案需要乘在前面的；然后还需要维护 $B ^ {\lfloor\frac {ax + b}c \rfloor}$，这个需要乘在答案的中间，这和乘在最后没有区别。</p><p>于是我们需要维护三个信息，而这三个信息是可以用 $O(n ^ 3)$ 时间合并的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">Matrix cntx, cnty, ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node <span class="keyword">operator</span> *(Node a, Node b)</span><br><span class="line">&#123;</span><br><span class="line">a.ans += a.cntx * b.ans * a.cnty;</span><br><span class="line">a.cnty = a.cnty * b.cnty, a.cntx = a.cntx * b.cntx;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们套用前面的计算方法<del>直接复制</del>，得到这份代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">AsGcd</span><span class="params">(LL a, LL b, LL c, LL n, Node fu, Node fr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b %= c;</span><br><span class="line"><span class="keyword">if</span> (a &gt;= c) <span class="keyword">return</span> <span class="built_in">AsGcd</span>(a % c, b, c, n, fu, <span class="built_in">qpow</span>(fu, a / c) * fr);</span><br><span class="line">LL m = ((s128) a * n + b) / c;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">qpow</span>(fr, n);</span><br><span class="line">std::<span class="built_in">swap</span>(fu, fr);</span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">qpow</span>(fu, (c - b - <span class="number">1</span>) / a) * fr * <span class="built_in">AsGcd</span>(c, c - b - <span class="number">1</span>, a, m - <span class="number">1</span>, fu, fr)</span><br><span class="line">* <span class="built_in">qpow</span>(fu, n - ((s128) c * m - b - <span class="number">1</span>) / a);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们需要考虑的就是一个 <code>U</code> 和一个 <code>R</code> 分别产生什么影响。</p><p>一个 <code>U</code> 会使得 <code>cnty ++</code>，而 $cntx$ 不变；一个 <code>R</code> 会使得 <code>cntx ++</code>，<code>ans += cntx</code>，$cnty$ 不变。而一个单位元就是 <code>cntx = cnty = 0</code>（注意我这里是使用 $A, B$ 的多少次方表示的，所以 <code>cntx = 0</code> 表示的是单位矩阵，以此类推）。</p><p>那么 <code>fu = &#123;I, B, 0&#125;, fr = &#123;A, I, A&#125;</code> 表示 <code>U</code> 和 <code>R</code> 分别带来的影响。</p><p>前面照例乘上一个 <code>qpow(fu, b / c)</code>，注意从 1 开始，不需要乘 <code>fr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">Matrix cntx, cnty, ans;</span><br><span class="line">&#125; f0;</span><br><span class="line"></span><br><span class="line">Node <span class="keyword">operator</span> *(Node a, Node b)</span><br><span class="line">&#123;</span><br><span class="line">a.ans += a.cntx * b.ans * a.cnty;</span><br><span class="line">a.cnty = a.cnty * b.cnty, a.cntx = a.cntx * b.cntx;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">qpow</span><span class="params">(Node a, LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(k &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="function">Node <span class="title">res</span><span class="params">(f0)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = a * a)</span><br><span class="line"><span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * a;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">AsGcd</span><span class="params">(LL a, LL b, LL c, LL n, Node fu, Node fr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b %= c;</span><br><span class="line"><span class="keyword">if</span> (a &gt;= c) <span class="keyword">return</span> <span class="built_in">AsGcd</span>(a % c, b, c, n, fu, <span class="built_in">qpow</span>(fu, a / c) * fr);</span><br><span class="line">LL m = ((s128) a * n + b) / c;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">qpow</span>(fr, n);</span><br><span class="line">std::<span class="built_in">swap</span>(fu, fr);</span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">qpow</span>(fu, (c - b - <span class="number">1</span>) / a) * fr * <span class="built_in">AsGcd</span>(c, c - b - <span class="number">1</span>, a, m - <span class="number">1</span>, fu, fr)</span><br><span class="line">* <span class="built_in">qpow</span>(fu, n - ((s128) c * m - b - <span class="number">1</span>) / a);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL a, b, c, l;</span><br><span class="line">std::cin &gt;&gt; a &gt;&gt; c &gt;&gt; b &gt;&gt; l &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) I[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i][j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;B[i][j]);</span><br><span class="line">Node fu&#123;I, B, &#123;&#125;&#125;, fr&#123;A, I, A&#125;;</span><br><span class="line">f0 = &#123;I, I, &#123;&#125;&#125;;</span><br><span class="line"><span class="keyword">auto</span> res = (<span class="built_in">qpow</span>(fu, b / c) * <span class="built_in">AsGcd</span>(a, b, c, l, fu, fr)).ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i, <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, res[i][j]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典的下取整求和，一般不能使用数论分块等（因为被除数不固定）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="万能欧几里得" scheme="https://mydcwfy.github.io/tags/%E4%B8%87%E8%83%BD%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>ARC132F</title>
    <link href="https://mydcwfy.github.io/2022/05/19/ARC132F/"/>
    <id>https://mydcwfy.github.io/2022/05/19/ARC132F/</id>
    <published>2022-05-19T11:40:08.000Z</published>
    <updated>2022-05-19T12:26:16.723Z</updated>
    
    <content type="html"><![CDATA[<p>扩展了集合幂级数的定义，比较有借鉴性。</p><span id="more"></span><p>题意：三个人玩 $k$ 次石头剪刀布，两个人会分别从自己的策略集合中随机选取一个然后按照选的策略出 $k$ 次（每个策略都是长度为 $k$ 的字符串，代表每次出的是什么）。第一个人策略集合大小为 $n$，第二个人策略集合大小为 $m$。第三个人想知道，对于 $3 ^ k$ 种他出的策略，计算他 $k$ 次中至少有一次成为唯一赢家的概率。$k\leq 12, n, m\leq 3 ^ k$，5s。</p><p>容易发现我们当且仅当第一个人和第二个人出的一样，第三个人出的可以赢他们的情况才可能计入答案。</p><p>我们考虑<strong>构造另外一种状态</strong>，记作 0，表示这个人可以随意出。容易发现这个状态是包含 1、2、3 的状态的（分别对应石头剪刀布），那么如果我们使用类似集合幂级数的思想前缀和的话，我们就要将对应 1、2、3 的数贡献到对应位为 0 的数。</p><p><strong>类似集合幂级数定义卷积</strong>，定义一个运算，使得如果两个数不同，这一位就是 0，否则就是相同的那个数。容易发现无需暴力卷积，我们按照上面的方法先前缀和，乘起来，再做逆变换。</p><blockquote><p>做法的正确性：拆位打开看，如果这两个数对应位相同，假设为 $x$，那么这个的贡献不仅会在该位为 0 的地方出现，还会在该位为 $x$ 的地方出现，乘起来后做逆变换，这样 0 位置的贡献就变为了 0。而如果不一样的话，这两个数对应位不同，这样一个出现的位置是 $0, x$，另一个出现的位置是 $0, y$，这样乘起来后，只出现在 0 的位置，于是贡献到了 0。这个可以看作是一个广义的与卷积。</p></blockquote><p>这样，我们可以用 $O(k4 ^ k)$ 的时间得到每个状态的各处。然后考虑如何得到答案。</p><p>经典<strong>至少一个容斥为都不是</strong>，考虑计算这个状态下不能胜的情况。对于这一位为 1 来说，不能胜的情况就是 0、2、3。特别的，这一位为 0 不能胜的情况是 0、1、2、3，即所有。</p><p><strong>还是类似集合幂级数拆位的思想</strong>，拆开每一位分别贡献，仍然可以做到 $O(k4 ^ k)$。</p><p>最后直接判断这一个状态是不是切实存在的（即所有位都不是 0），输出即可。</p><p>注意编号的问题，我们可以先将编号设为 1-石头，2-剪刀，3-布（原来是 1-布，2-石头，3-剪刀），这样就是计算三个人相同的问题了，直接按序输出即可。时间复杂度 $O(k4 ^ k)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trs</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; <span class="keyword">return</span> c == <span class="string">&#x27;P&#x27;</span> ? <span class="number">3</span> : (c == <span class="string">&#x27;R&#x27;</span> ? <span class="number">1</span> : <span class="number">2</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FMT</span><span class="params">(T *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k + k; j += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; (k + k)); ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">3</span>) a[i &amp; ~(<span class="number">3</span> &lt;&lt; j)] += a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IFMT</span><span class="params">(T *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k + k; j += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; (k + k)); ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">3</span>) a[i &amp; ~(<span class="number">3</span> &lt;&lt; j)] -= a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; k &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tmp + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i)</span><br><span class="line">s = (s &lt;&lt; <span class="number">2</span>) | <span class="built_in">trs</span>(tmp[i]);</span><br><span class="line">A[s] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tmp + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i)</span><br><span class="line">s = (s &lt;&lt; <span class="number">2</span>) | <span class="built_in">trs</span>(tmp[i]);</span><br><span class="line">B[s] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">FMT</span>(A), <span class="built_in">FMT</span>(B);</span><br><span class="line"><span class="comment">// for (int i = 0; i &lt; (1 &lt;&lt; (k + k)); ++ i) printf(&quot;%d %d\n&quot;, A[i], B[i]);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; (k + k)); ++ i) C[i] = (LL) A[i] * B[i];</span><br><span class="line"><span class="built_in">IFMT</span>(C);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (k + k); j += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; (k + k)); ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">LL sum = C[i] + C[i | (<span class="number">1</span> &lt;&lt; j)] + C[i | (<span class="number">2</span> &lt;&lt; j)] + C[i | (<span class="number">3</span> &lt;&lt; j)];</span><br><span class="line">C[i] = sum;</span><br><span class="line">C[i | (<span class="number">1</span> &lt;&lt; j)] = sum - C[i | (<span class="number">1</span> &lt;&lt; j)];</span><br><span class="line">C[i | (<span class="number">2</span> &lt;&lt; j)] = sum - C[i | (<span class="number">2</span> &lt;&lt; j)];</span><br><span class="line">C[i | (<span class="number">3</span> &lt;&lt; j)] = sum - C[i | (<span class="number">3</span> &lt;&lt; j)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; (k + k)); ++ s) &#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (k + k) &amp;&amp; flag; i += <span class="number">2</span>)</span><br><span class="line">flag &amp;= !!(s &gt;&gt; i &amp; <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (LL) n * m - C[s]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;扩展了集合幂级数的定义，比较有借鉴性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="集合幂级数" scheme="https://mydcwfy.github.io/tags/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>ARC Round#132</title>
    <link href="https://mydcwfy.github.io/2022/05/19/ARC-Round-132/"/>
    <id>https://mydcwfy.github.io/2022/05/19/ARC-Round-132/</id>
    <published>2022-05-19T09:22:52.000Z</published>
    <updated>2022-05-19T12:26:59.093Z</updated>
    
    <content type="html"><![CDATA[<p>vp 的时候降智了，简单的 D 题没做出来，被吊锤了。</p><p>赛时进度：ABC Accepted，Score：1400，Penalty：83：02。</p><p>改题进度：ABCDF Accepted。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定 $n\times n$ 的矩阵，已知每行有 $r_i$ 个 1，每列有 $c_i$ 个 1，且 $r, c$ 均为排列。$q$ 次询问某个点是否是 1。$n, m\leq 10 ^ 5$。</p><p>如果我们需要构造的话，那么 $r_i = n, c_j = n$ 的行列是可以全部赋值为 1 的，然后 $r_i = 1, c_j = 1$ 的行列除了已赋值的全部赋值为 0，然后 $r_i = n - 1, c_j = n - 1$……</p><p>这样行列相当于是一个要将他赋值为 1，一个需要将他赋值为 0，就看谁的优先级高。假设询问 $(x, y), r_x &gt; c_y$，容易发现行的优先级可以用 $n - r_x$，列的优先级可以用 $c_y$，这样行的优先级小于等于列的优先级那么就是 1，否则是 0。</p><p>整理一下，就是 $n - r_x\leq c_y$，即 $r_x + c_y\geq n$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Q --) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">int</span> mn = std::<span class="built_in">min</span>(a[x], b[y]), mx = std::<span class="built_in">max</span>(a[x], b[y]);</span><br><span class="line"><span class="keyword">if</span> (mn - <span class="number">1</span> &lt; n - mx) <span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定一个排列 $p_{1, \dots, n}$，每次可以将第一个数移到最后，或是反转整个数列，问至少多少次才能变为 $1, 2, \dots, n$。给出的排列保证可以变为 $1, 2, \dots, n$。$n\leq 10 ^ 5$。</p><p>如果将原序列看作是一个环的话，那么环的本质没有变，这样序列一定就是 $x, x - 1, \dots, 1, n, n - 1, \dots, x + 1$ 或者是 $x, x + 1, \dots, n, 1, 2, \dots, x - 1$。</p><p>下面用 $pos$ 表示 1 的位置。</p><p>对于第一种情况，我们必须翻转，如果最开始就翻转的话，那么答案就是 $n - pos + 1$，如果是最后翻转的话，答案就是 $(n - pos) + 1$，二者取 $\min$ 即可。</p><p>对于第二种情况，我们可以不翻转，答案就是 $pos - 1$，也可以翻转两次（一次最先，一次最后），答案就是先到 $(n - pos + 1) + 2$，二者取 $\min$ 即可。可以自己手玩一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, p + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) nw[p[i]] = i;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (p[(i + n - <span class="number">2</span>) % n + <span class="number">1</span>] != <span class="number">1</span> &amp;&amp; p[i] != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!~flag) flag = p[i] &gt; p[(i + n - <span class="number">2</span>) % n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">assert</span>(flag == (p[i] &gt; p[(i + n - <span class="number">2</span>) % n + <span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; flag &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, std::<span class="built_in">min</span>(nw[<span class="number">1</span>] - <span class="number">1</span>, <span class="number">3</span> + n - nw[<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, std::<span class="built_in">min</span>(n - nw[<span class="number">1</span>] + <span class="number">1</span>, nw[<span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定 $n, d$，求满足 $|p_i - i|\leq d$ 的排列的数量，某些 $p_i$ 确定，未确定用 -1 表示。$n\leq 500, d\leq 5$。</p><p><strong>排列的 DP 一般有两种：第一种是按顺序填入，哪个位置填 $n$，哪个位置填 $n - 1$，类推。还有一种是先将前 $i$个构成排列，然后枚举 $i + 1$ 的数 $x$，将前面原来 $\geq x$ 的数加 1</strong>。</p><p>如果方向选的是第二种的话，这道题就不好做，因为你需要维护前 5 个的数分别是什么，这样才能判断 +1 后是否合法。</p><p>而用第一种就体现出优势了：我们只需要维护和这个数距离不超过 5 的位置是否已经有数即可。这样就很好做了，时间复杂度 $O(nd2 ^ {2d})$，可以通过。</p><p>代码有些繁琐，有一点难写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (~a[i]) nw[a[i]] = i;</span><br><span class="line"><span class="keyword">int</span> sta = <span class="number">0</span>, lim = d &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; ++ j)</span><br><span class="line"><span class="keyword">if</span> (j &gt; d || ~a[n + j - d]) sta |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">f[n + <span class="number">1</span>][sta] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &gt; <span class="number">1</span>; -- i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; lim); ++ s) &#123;</span><br><span class="line"><span class="keyword">if</span> (!f[i][s]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> cur = f[i][s];</span><br><span class="line"><span class="comment">// printf(&quot;%d %d %d\n&quot;, i, s, cur);</span></span><br><span class="line"><span class="keyword">if</span> (nw[i - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> to = nw[i - <span class="number">1</span>] - i + <span class="number">2</span> + d;</span><br><span class="line"><span class="keyword">int</span> &amp;trs = f[i - <span class="number">1</span>][((s &lt;&lt; <span class="number">1</span>) | (<span class="number">1</span> &lt;&lt; to) | (i &lt;= d + <span class="number">2</span> || ~a[i - d - <span class="number">2</span>])) &amp; ((<span class="number">1</span> &lt;&lt; lim) - <span class="number">1</span>)];</span><br><span class="line"><span class="built_in">adj</span>(trs += cur - Mod);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nxt = <span class="number">0</span>; nxt &lt; lim; ++ nxt) &#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;&gt; nxt &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// printf(&quot;Trs %d\n&quot;, nxt);</span></span><br><span class="line"><span class="keyword">int</span> &amp;trs = f[i - <span class="number">1</span>][((s &lt;&lt; <span class="number">1</span>) | (<span class="number">1</span> &lt;&lt; (nxt + <span class="number">1</span>)) | (i &lt;= d + <span class="number">2</span> || ~a[i - d - <span class="number">2</span>])) &amp; ((<span class="number">1</span> &lt;&lt; lim) - <span class="number">1</span>)];</span><br><span class="line"><span class="built_in">adj</span>(trs += cur - Mod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; f[<span class="number">1</span>][(<span class="number">1</span> &lt;&lt; lim) - <span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定两个长度相同、1 个数相同的串 $s, t$，定义 $d(s, t)$ 为最少邻项交换的次数。定义一个字符串的权值为相邻字符相同的个数。求所有满足 $d(s, t) = d(s,u) + d(u, t)$ 中 $u$ 的最大权值。$|s|\leq 3\times 10 ^ 5$。</p><p>sb 贪心题。</p><p>容易发现 $u$ 的第 $i$ 个 1 一定在 $s$ 的第 $i$ 个 1 和 $t$ 的第 $i$ 个 1 之间。那么我们如果前面已经填好了，新加入一个字符我们就可以判断新的是否合法。注意还需要判断 0 是否合法，即 $u$ 的 0 在 $s$ 对应的 0 和 $t$ 对应的 0 之间。</p><p>剩下的直接贪心，考虑如果能和前一个相同就填相同的，否则就填不同的。注意第一个位置无法填入，随便枚举一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> valid = [&amp;](<span class="keyword">int</span> pos, <span class="keyword">int</span> x) &#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; std::<span class="built_in">min</span>(cnta[pos], cntb[pos]) || x &gt; std::<span class="built_in">max</span>(cnta[pos], cntb[pos]))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> x + (n + m - pos) &gt;= cnta[n + m] &amp;&amp; x &lt;= cnta[n + m];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] != st + <span class="string">&#x27;0&#x27;</span> &amp;&amp; b[<span class="number">1</span>] != st + <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = st, ls = st, res = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// printf(&quot;Solve %d\n&quot;, st);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n + m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// printf(&quot;%d %d %d\n&quot;, cnt, cnta[i - 1], cntb[i - 1]);</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">valid</span>(i, cnt + ls)) cnt += ls, res ++;</span><br><span class="line"><span class="keyword">else</span> cnt += !ls, ls = !ls;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// printf(&quot;%d %d %d\n&quot;, cnt, cnta[n + m], cntb[n + m]);</span></span><br><span class="line"><span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; (a + <span class="number">1</span>) &gt;&gt; (b + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; ++ i) cnta[i] = cnta[i - <span class="number">1</span>] + (a[i] ^ <span class="number">48</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; ++ i) cntb[i] = cntb[i - <span class="number">1</span>] + (b[i] ^ <span class="number">48</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, std::<span class="built_in">max</span>(<span class="built_in">solve</span>(<span class="number">0</span>), <span class="built_in">solve</span>(<span class="number">1</span>)));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>见 <a href="/2022/05/19/ARC132F">ARC132F</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;vp 的时候降智了，简单的 D 题没做出来，被吊锤了。&lt;/p&gt;
&lt;p&gt;赛时进度：ABC Accepted，Score：1400，Penalty：83：02。&lt;/p&gt;
&lt;p&gt;改题进度：ABCDF Accepted。&lt;/p&gt;</summary>
    
    
    
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>ARC Round#140</title>
    <link href="https://mydcwfy.github.io/2022/05/17/ARC-Round-140/"/>
    <id>https://mydcwfy.github.io/2022/05/17/ARC-Round-140/</id>
    <published>2022-05-17T06:13:30.000Z</published>
    <updated>2022-05-17T07:33:38.498Z</updated>
    
    <content type="html"><![CDATA[<p>赛时没做出来 D，结果似乎比较简单……</p><p>赛时进度：ABC Accepted，Penalty：59：56，Rank：291，Rating：1995 -&gt; 2006。</p><p>改题进度：ABCDE Accepted。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定字符串 $S$，可以修改其中的 $k$ 个字符，问可以得到的最小循环节。$|S|\leq 2000$。</p><p>直接暴力枚举循环节是否合法，这样每一个对应的位置需要变成一个字符，统计众数出现次数即可。计算众数的时候可以做到线性。</p><p>由于循环节最多只有 $O(\sqrt n)$ 种，所以得到时间复杂度 $O(n\sqrt n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = st; i &lt;= n; i += d) <span class="built_in">chkmax</span>(res, ++ cnt[s[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = st; i &lt;= n; i += d) -- cnt[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="comment">// printf(&quot;%d %d %d\n&quot;, st, d, res);</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (n % i) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> res = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++ j) res -= <span class="built_in">solve</span>(j, i);</span><br><span class="line"><span class="keyword">if</span> (res &lt;= k) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定只有 A、R、C 的字符串，奇数次操作可以 <code>ARC -&gt; R</code>，偶数次操作可以 <code>ARC -&gt; AC</code>，问最多可以进行的操作次数。$|S|\leq 2\times 10 ^ 5$。</p><p>容易发现我们每一段是独立的，因为 <code>ARC -&gt; AC</code> 后两边都不能再合并，只有 <code>AA...ARC...CC</code> 可以通过只有奇数次变换可以得到 <code>ARC</code>，最后一次任选。</p><p>这样我们可以将原串的有用部分压缩为 <code>AA...ARC...CC</code> 中 $\min\{len_A, len_C\}$，容易发现这一定是可以的，多出来的部分是无法操作的。</p><p>这样奇数操作就是对数列中的一个非零数 -1，偶数操作就是将一个非零数变为 0。问最多多少次操作。</p><p>这其实是可以贪心的：我每次将尽量靠近 1 又不是 1 的一个数用奇数操作，直到他变成 1，这样偶数操作删除这个数的时候代价是最小的。我赛时的代码就是这个。</p><p>考虑两个上界：</p><ol><li>偶数次操作最多只有 <code>ARC</code>出现的次数，因为一个偶数次一定会消耗一个 <code>ARC</code> 而不会再次出现。</li><li>总操作最多只有压缩后数列的和，因为操作一次，至少会减 1。</li></ol><p>从偶数操作容易推出所有操作的一个上界：$2\times cnt$（不可能最后一次是一个奇数操作，因为这样的话，我们预估的 $cnt$ 就可以 +1</p><p>直接取 $\min$ 即可。代码是贪心，时间复杂度 $O(n\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] ^ <span class="string">&#x27;R&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &gt; len &amp;&amp; i + len &lt;= n &amp;&amp; s[i - len] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i + len] == <span class="string">&#x27;C&#x27;</span>) len ++;</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">2</span>) al.<span class="built_in">push_back</span>(len - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> cnt += len == <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(al.<span class="built_in">begin</span>(), al.<span class="built_in">end</span>());</span><br><span class="line">sz = al.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">++ ans;</span><br><span class="line"><span class="keyword">if</span> (ans &amp; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; sz &amp;&amp; al[i] &lt;= <span class="number">1</span>) ++ i;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= sz) <span class="keyword">break</span>;</span><br><span class="line">al[i] --;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (cnt) &#123;</span><br><span class="line">-- cnt;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= sz) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">al[j ++] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">-- ans;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : al) <span class="built_in">assert</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= <span class="number">1</span>), cur += x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans + cur + cnt);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定 $n, x$，要求构造长度为 $n$ 的排列 $p$ 使得 $p_1 = x$ 且 $a_i = |p_i - p_{i + 1}|$ 序列的最长严格上升子序列最大。</p><p>首先，如果不管 $p_1$ 的话，我们有一个最长上升字符列为 $n - 2$ 的答案。如果 $n$ 是偶数，我们构造即为 $\{\dfrac n2, \dfrac n2 + 1, \dfrac n2 - 1, \dfrac n2 + 2\dots\}$ 或 $\{\dfrac n2 + 1, \dfrac n2, \dfrac n2 + 2, \dfrac n2 - 1\dots\}$，相邻两个差是 $\{1, 2, \dots\}$，这达到了上界。如果是奇数，构造即为 $\{\dfrac{n + 1}2, \dfrac{n + 1}2 + 1, \dfrac{n + 1}2 - 1, \dfrac{n + 1}2 + 2\dots \}$ ，容易证明这个也是达到了上界的。</p><p>现在考虑加入 $p_1 = x$。第一种方案是我们不管 $p_1$，后面原来 $\geq x$ 的加 1 即可。第二种方案是我们先将 $p_1$ 按照上面的构造尽可能摆放，剩下的随便摆。容易发现如果 $x$ 不是上面最优情况的开头，第二个一定不优。</p><p>剩下的随便分类讨论即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span> &amp;&amp; x == (n + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = (n + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>, k = (n + <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &amp; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, k ++);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, j --);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(n &amp; <span class="number">1</span>) &amp;&amp; x == n / <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = n / <span class="number">2</span> + <span class="number">1</span>, k = n / <span class="number">2</span> - <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, j ++);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, k --);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(n &amp; <span class="number">1</span>) &amp;&amp; x == n / <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = n / <span class="number">2</span> + <span class="number">2</span>, k = n / <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &amp; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, j ++);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, k --);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = n / <span class="number">2</span> + <span class="number">1</span>, k = n / <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &amp; <span class="number">1</span>) p[i] = j ++;</span><br><span class="line"><span class="keyword">else</span> p[i] = k --;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = n / <span class="number">2</span> + <span class="number">1</span>, k = n / <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) p[i] = k --;</span><br><span class="line"><span class="keyword">else</span> p[i] = j ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i] + (p[i] &gt;= x));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定一个无向图，$i$ 会和 $x_i$ 连边，有些 $x_i$ 未定，问所有可能的 $x_i$ 无向图连通块个数之和。$n\leq 2000$。</p><p>观察 1：容易发现确定 $x_i$ 后的图一定是基环树森林，连通块的个数就是环的个数（包括自环）</p><p>观察 2：还没有形成基环树的连通块一定是树，每棵树中 $x_i$ 不确定的点有且只有 1 个。</p><p>观察 3：一旦形成了环，这个连通块的贡献就固定了，和其他的有没有联通过来没有关系（因为统计的是环的数量）</p><p>有了上面的发现，其实就比较好做了。</p><p>首先如果我们确定了 $k$ 棵树，总共有 $cnt$ 个点 $x_i$ 未确定，每棵的大小为 $a_i$，互相连接，并形成了环，那么对应的贡献应该是<br>$$<br>(k - 1)!n ^ {cnt - k} \prod_{i = 1} ^ k a_i<br>$$<br>发现答案和 $k$ 和 $\prod$ 有关，那么直接考虑 DP，即目前个数为 $k$ 的所有树的组合的乘积和。直接 $O(n ^ 2)$ 转移即可。</p><p>对于原来就是基环树的，我们已经形成了环，不参加 DP，直接贡献为 $n ^ {cnt}$。加和即可，时间复杂度 $O(n ^ 2)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[x] = <span class="number">1</span>, sz ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (v ^ fa) &#123;</span><br><span class="line"><span class="keyword">if</span> (vis[v]) &#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(v, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line">fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) fact[i] = (LL) fact[i - <span class="number">1</span>] * i % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!~a[i]) <span class="keyword">continue</span>;</span><br><span class="line">g[a[i]].<span class="built_in">pb</span>(i), g[i].<span class="built_in">pb</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> excnt = <span class="number">0</span>, res = <span class="number">0</span>, mul;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) excnt += !~a[i];</span><br><span class="line">mul = <span class="built_in">qpow</span>(n, excnt);</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vad;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">sz = <span class="number">0</span>, flag = <span class="number">0</span>, <span class="built_in">dfs</span>(i);</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="built_in">adj</span>(res += mul - Mod);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">vad.<span class="built_in">pb</span>(sz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt = vad.<span class="built_in">size</span>();</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : vad)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = cnt - <span class="number">1</span>; ~j; -- j)</span><br><span class="line"><span class="keyword">if</span> (f[j]) f[j + <span class="number">1</span>] = (f[j + <span class="number">1</span>] + (LL) f[j] * x) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line"><span class="keyword">if</span> (f[i]) res = (res + (LL) f[i] * <span class="built_in">qpow</span>(n, cnt - i) % Mod * fact[i - <span class="number">1</span>]) % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：构造 $n\times m$ 的网格，每个数在 $[1, 25]$，要求 $\forall x_1, x_2\in [1, n], y_1, y_2\in [1, m]$，$a_{x_1, y_1}, a_{x_1, y_2}, a_{x_2, y_1}, a_{x_2, y_2}$ 不全相等。$n, m\leq 500$。</p><p>不是很好构造，虽然代码不超过 20 行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i, <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ((i / B) * (j / B) + i + j) % B + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到 $25$ 和 $\sqrt n$ 同级，果断分块。</p><p>暂定为 $\sqrt n\times \sqrt n$ 的分块，那么需要考虑块内和块间的不同情况。</p><p>块内的话，需要我们每两个相同的数字得不在一行一列，否则同行 / 列的块内可能会出现对应的情况导致不合法。</p><p>既然不在一行一列，这要求我们需要每行每列都是排列，这样的话，我们按照如下构造即可：<br>$$<br>\begin{bmatrix}<br>1&amp; 2&amp; 3&amp; \dots&amp; 22&amp; 23\\<br>2&amp; 3&amp; 4&amp; \dots&amp; 23&amp; 1\\<br>3&amp; 4&amp; 5&amp; \dots&amp; 1&amp; 2\\<br>\dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots\\<br>23&amp; 1&amp; 2&amp; \dots&amp; 21&amp; 22<br>\end{bmatrix}<br>$$<br>那么块间像块内一样是否合法呢？、</p><p>首先看 $B = 3, n = m = 9$ 的示范样例输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3 1 2 1 2 3 2 3 1 </span><br><span class="line">1 2 3 2 3 1 3 1 2 </span><br><span class="line">2 3 1 3 1 2 1 2 3 </span><br><span class="line">1 2 3 2 3 1 3 1 2 </span><br><span class="line">2 3 1 3 1 2 1 2 3 </span><br><span class="line">3 1 2 1 2 3 2 3 1 </span><br><span class="line">2 3 1 3 1 2 1 2 3 </span><br><span class="line">3 1 2 1 2 3 2 3 1 </span><br><span class="line">1 2 3 2 3 1 3 1 2 </span><br></pre></td></tr></table></figure><p>容易发现第 4 行和第 2 行是一样的，是怎么回事呢？</p><p>我们发现，当第 1 行变为第 4 行的时候，我们将 <code>1 2 3</code> 的排列变成了 <code>2 3 1</code>，变为第 2 行的时候也是这样，导致第 2 行的输出和第 4 行完全相同。</p><p>这启示我们需要找到另外的方式，使得不会产生不合法情况。</p><p>给出结论：使用块行编号和纵编号的乘积。</p><p>手玩一下发现是不会冲突的。于是就是上面的那个代码（别问我是怎么<del>看题解</del>想到的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;赛时没做出来 D，结果似乎比较简单……&lt;/p&gt;
&lt;p&gt;赛时进度：ABC Accepted，Penalty：59：56，Rank：291，Rating：1995 -&amp;gt; 2006。&lt;/p&gt;
&lt;p&gt;改题进度：ABCDE Accepted。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>CF Round#791</title>
    <link href="https://mydcwfy.github.io/2022/05/15/CF-Round-791/"/>
    <id>https://mydcwfy.github.io/2022/05/15/CF-Round-791/</id>
    <published>2022-05-15T07:42:13.000Z</published>
    <updated>2022-05-16T06:54:26.088Z</updated>
    
    <content type="html"><![CDATA[<p>A 吃了发罚时……</p><p>赛时进度：ABCDE Accepted，Score：6025，Rank：7，Rating：1987 -&gt; 2189。</p><p>改题进度：All Accepted。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定 $n$，拆分成 4 和 6，问最多有多少个 4、最多有多少个 6，或报告无解。</p><p>容易发现 $n$ 是奇数或 $n = 2$ 的时候显然无解。剩下的按余数那么随便分讨一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">if</span> ((n &amp; <span class="number">1</span>) || n &lt; <span class="number">4</span>) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">6</span> == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, n / <span class="number">6</span> + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, (n + <span class="number">2</span>) / <span class="number">6</span>);</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">4</span> == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, n / <span class="number">4</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, n / <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定一个序列 $n$ 和 $q$ 次操作，单点修改或是整体赋值。问操作后的和。$n\leq 2\times 10 ^ 5, q\leq 2\times 10 ^ 5$。</p><p>给出线性做法。</p><p>考虑每个数最后被覆盖 / 单点修改的时间，如果单点修改的时间晚于整体赋值的时间，那么就是 $a_i$，否则值就是最后的 $cov$。用增量法维护和即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) sum += a[i];</span><br><span class="line"><span class="keyword">int</span> pos, x, op;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cs = <span class="number">1</span>; cs &lt;= Q; ++ cs) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;pos, &amp;x);</span><br><span class="line"><span class="keyword">if</span> (t[pos] &lt; ct) sum += x - cov;</span><br><span class="line"><span class="keyword">else</span> sum += x - a[pos];</span><br><span class="line">t[pos] = cs, a[pos] = x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">sum = (LL) n * x;</span><br><span class="line">cov = x, ct = cs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>给出 $n\times n$ 的方格，有些位置有关键点，$q$ 次操作，设立关键点，删除关键点，询问一个子矩阵所有的格子都被关键点所覆盖。覆盖是将一行 / 一列的点覆盖。$n, q\leq 2\times 10 ^ 5$。</p><p>考虑结论：想要覆盖一个子矩阵，当且仅当所有行 / 所有列都被覆盖。</p><p>于是我们可以将 行 / 列 分开，分别判断 行 / 列 是否分别合法，一个合法就都可以了。</p><p>于是随便使用树状数组判断区间是否合法即可。具体的，如果覆盖的时候这个位置覆盖次数为 0，就在这个位置 +1；如果删除后这个位置覆盖次数为 0，就在这个位置 -1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, Q, t, x, y, sx, sy;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; Q;</span><br><span class="line"><span class="keyword">while</span> (Q --) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;t, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">if</span> (t == <span class="number">1</span>) row.<span class="built_in">add</span>(x, !r[x] ++), col.<span class="built_in">add</span>(y, !c[y] ++);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">2</span>) row.<span class="built_in">add</span>(x, -(!-- r[x])), col.<span class="built_in">add</span>(y, -(!-- c[y]));</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;sx, &amp;sy);</span><br><span class="line"><span class="built_in">puts</span>((row.<span class="built_in">ask</span>(sx) - row.<span class="built_in">ask</span>(x - <span class="number">1</span>)) == sx - x + <span class="number">1</span> || (col.<span class="built_in">ask</span>(sy) - col.<span class="built_in">ask</span>(y - <span class="number">1</span>)) == sy - y + <span class="number">1</span> ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>给出 $n$ 个点 $m$ 条边的有向图，点带权，任选点数为 $k$ 的路径使得最大点权最小。$n, m\leq 2\times 10 ^ 5, k\leq 10 ^ {18}$。</p><p>最大最小，果断二分。</p><p>二分后，有一些点不再能走，那么转化为了在现有图上走出 $k$ 个点。</p><p>首先容易发现如果有环的话，那么任意 $k$ 都是可以的。对于剩下的情况，直接拓扑排序做一下最长路径即可。拓扑排序的时候可以同时判断有没有环。判断时间复杂度线性。</p><p>总复杂度 $O((n + m)\log a)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) deg[i] = d[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[x] &gt; mid) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (a[v] &lt;= mid) deg[v] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!deg[i] &amp;&amp; a[i] &lt;= mid) q.<span class="built_in">push</span>(i), d[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (a[v] &lt;= mid) &#123;</span><br><span class="line"><span class="built_in">chkmax</span>(d[v], d[x] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!-- deg[v]) q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (deg[i] || d[i] &gt;= k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++ i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">g[u].<span class="built_in">pb</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">check</span>(<span class="number">1e9</span> + <span class="number">10</span>)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; l &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：给定长度为 $n$ 的字符串，满足每一个都属于 $\{a, b, c\dots, p, q\}$ 17 个字符，有一些待填，用 <code>?</code> 表示，$q$ 次给定可以将 <code>?</code> 变成的字符的集合，问所有填法回文串个数的和。$n\leq 1000, q\leq 2\times 10 ^ 5$。</p><p>容易发现 $n\leq 1000$，我们可以考虑枚举出所有可能的回文串，然后判断是否可能变为回文串。注意我们需要增量枚举，否则是 $O(n ^ 3)$ 的。</p><p>考虑现在新加入的两边字符：</p><ol><li>两边都是 <code>?</code>，这样答案就乘上 $|\sum|$。这样我们还需要枚举 $\sum$ 的大小贡献答案。</li><li>有一边是 <code>?</code>，这样字符集中需要有另一边的字符。</li><li>两边都不是 <code>?</code>，这样需要两边字符一样，否则直接停止。</li></ol><p>此外，其他的 <code>?</code> 可以随便选，那么我们需要给出随意选的个数。容易发现贡献和 $|\sum|$ 有关，所以再枚举 $|\sum|$，这样我们需要在包含当前需要的字符集的字符集位置加上 $cnt ^ {|\sum|}$。这个可以使用 FMT 简单的实现。于是总时间复杂度 $O(|\sum| ^ 22 ^ {|\sum|} + n ^ 2|\sum|)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">17</span>; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pw[j][<span class="number">0</span>] = <span class="number">1</span>; i &lt;= n; ++ i) pw[j][i] = (LL) pw[j][i - <span class="number">1</span>] * j % Mod;</span><br><span class="line"><span class="keyword">int</span> totcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) totcnt += str[i] == <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt;= n; ++ mid) &#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>, sta = <span class="number">0</span>, cnt = <span class="number">0</span>, excnt = totcnt;</span><br><span class="line"><span class="keyword">while</span> (mid &gt; len &amp;&amp; mid + len &lt;= n) &#123;</span><br><span class="line"><span class="keyword">int</span> i = mid - len, j = mid + len;</span><br><span class="line"><span class="keyword">if</span> (str[i] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; str[j] != <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] != str[j]) <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;?&#x27;</span> &amp;&amp; str[j] == <span class="string">&#x27;?&#x27;</span>) cnt ++;</span><br><span class="line"><span class="keyword">else</span> sta |= <span class="number">1</span> &lt;&lt; ((str[i] == <span class="string">&#x27;?&#x27;</span> ? str[j] : str[i]) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">excnt -= (str[i] == <span class="string">&#x27;?&#x27;</span>) + (str[j] == <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (i == j &amp;&amp; str[i] == <span class="string">&#x27;?&#x27;</span>) excnt ++;</span><br><span class="line"><span class="comment">// printf(&quot;1 : %d %d %d %d\n&quot;, mid, len, cnt, sta);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">17</span>; ++ j) <span class="built_in">adj</span>(ans[j][sta] += pw[j][cnt + excnt] - Mod);</span><br><span class="line">len ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt;= n; ++ mid) &#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">1</span>, sta = <span class="number">0</span>, cnt = <span class="number">0</span>, excnt = totcnt;</span><br><span class="line"><span class="keyword">while</span> (mid &gt;= len &amp;&amp; mid + len &lt;= n) &#123;</span><br><span class="line"><span class="keyword">int</span> i = mid - len + <span class="number">1</span>, j = mid + len;</span><br><span class="line"><span class="keyword">if</span> (str[i] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; str[j] != <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] != str[j]) <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;?&#x27;</span> &amp;&amp; str[j] == <span class="string">&#x27;?&#x27;</span>) cnt ++;</span><br><span class="line"><span class="keyword">else</span> sta |= <span class="number">1</span> &lt;&lt; ((str[i] == <span class="string">&#x27;?&#x27;</span> ? str[j] : str[i]) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">// printf(&quot;2 : %d %d %d %d\n&quot;, mid, len, cnt, sta);</span></span><br><span class="line">excnt -= (str[i] == <span class="string">&#x27;?&#x27;</span>) + (str[j] == <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">17</span>; ++ j) <span class="built_in">adj</span>(ans[j][sta] += pw[j][cnt + excnt] - Mod);</span><br><span class="line">len ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">17</span>; ++ j) <span class="built_in">FMT</span>(ans[j]);</span><br><span class="line">std::cin &gt;&gt; Q;</span><br><span class="line"><span class="keyword">while</span> (Q --) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tmp + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> sta = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; tmp[j]; ++ j) sta |= <span class="number">1</span> &lt;&lt; (tmp[j] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[<span class="built_in">popcount</span>(sta)][sta]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：给定长度为 $n$ 仅包含 $0\sim 9$ 的字符串相同，给定 $m$ 个交换，相邻两个出现在里面时可以交换。如果两个字符串可以互相交换得到，则称两个字符串相同。问本质不同的字符串有多少个。$n\leq 50000$。</p><p>首先我们定义代表元为本质相同的字符串中字典序最小的。这样，如果我们存在满足中间某些位是 $(d_1, d_2, d_3\dots, d_k)$ 并且 $(d_i, d_{i + 1})$ 中间可以交换，$d_1 &gt; d_k$，那么这个字符串就不是最小的。记录前面可以互相交换的 $d_1,\dots,  d_k$，如果存在一个 $d$ 满足 $d &gt; nxt$ 并且 $nxt$ 中可以有转移 $(d, nxt)$，那么加入 $nxt$ 之后就不是最小的了。（注意前面的都可以放到 $d_k$ 这个位置来和 $nxt$ 交换，如果存在 $d &gt; nxt$，可以将 $nxt$ 交换到 $d_k$ 的位置，$d$ 交换到 $nxt$ 的位置，就不是最小的</p><p>注意到我们只需要哪些元素出现没有，并不需要出现的次数及顺序。于是直接状压，将 $sta$ 记作前面 $d_1\dots, d_k$ 的并集。转移的时候观察存在 $(nxt, d)$ 且 $nxt &lt; d$ 的 $nxt$ 无法转移，其余均可。转移到的就是 $sta$ 中能和 $nxt$ 交换的数和 $nxt$ 本身。判断大于的有没有记录一下大于 $nxt$ 的所有转移，压一下状态即可。</p><p>时间复杂度 $O(n|\sum|2 ^ {|\sum|})$，可以通过。</p><p><strong>注意寻找代表元的做法统计本质不同个数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">std::cin &gt;&gt; u &gt;&gt; v;<span class="comment">// assert(u &lt; v);</span></span><br><span class="line">A[u] |= <span class="number">1</span> &lt;&lt; v, B[u] |= <span class="number">1</span> &lt;&lt; v, A[v] |= <span class="number">1</span> &lt;&lt; u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i) f[<span class="number">1</span>][<span class="number">1</span> &lt;&lt; i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; S; ++ s) f[i &amp; <span class="number">1</span>][s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>, cur; s &lt; S; ++ s) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(cur = f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][s])) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nxt = <span class="number">0</span>; nxt &lt; <span class="number">10</span>; ++ nxt)</span><br><span class="line"><span class="keyword">if</span> (!(B[nxt] &amp; s)) <span class="built_in">adj</span>(f[i &amp; <span class="number">1</span>][(A[nxt] &amp; s) | (<span class="number">1</span> &lt;&lt; nxt)] += cur - Mod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; ++ i) <span class="built_in">adj</span>(res += f[n &amp; <span class="number">1</span>][i] - Mod);</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;A 吃了发罚时……&lt;/p&gt;
&lt;p&gt;赛时进度：ABCDE Accepted，Score：6025，Rank：7，Rating：1987 -&amp;gt; 2189。&lt;/p&gt;
&lt;p&gt;改题进度：All Accepted。&lt;/p&gt;</summary>
    
    
    
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="集合幂级数" scheme="https://mydcwfy.github.io/tags/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"/>
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>CF Round#Edu128</title>
    <link href="https://mydcwfy.github.io/2022/05/14/CF-Round-Edu128/"/>
    <id>https://mydcwfy.github.io/2022/05/14/CF-Round-Edu128/</id>
    <published>2022-05-14T03:59:50.000Z</published>
    <updated>2022-05-14T07:20:44.157Z</updated>
    
    <content type="html"><![CDATA[<p>贪心做多了，E 题 DP 也认为是贪心（自然挂了却死活找不出错</p><p>个人感觉 D 比 E 简单，怎么 D 比 E 少那么多人？</p><p>赛时进度：ABCDE Accepted，Penalty：214，Rank：86。</p><p>改题进度：All Accepted。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：求一个数组长度最小，且满足有 $[l_1, r_1]$ 个最小值，$[l_2, r_2]$ 个最大值。</p><p>判一下区间有没有交即可。否则就是 $l_1 + l_2$。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定 $n\times m$ 的网格，有些格子有机器人，每次操作会让所有机器人移动同样的方向，问能否在所有机器人都不出格子的情况下有一个机器人走到最左上 $(1, 1)$。</p><p>容易发现下图情况一定不行：</p><img src="/2022/05/14/CF-Round-Edu128/B%E4%B8%8D%E5%90%88%E6%B3%95%E5%9B%BE.png" class=""><p>你无法将其中的任意一个移到左上方。</p><p>所以这样你只需要找到最靠左上的，判一下剩下的点是否在他的右下方，这样就可以看出是否合法了。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定一个 01 字符串，可以从前后删除一些数，使得剩下的 0 的个数和删除 1 的个数最大值最小。$n\leq 10 ^ 5$。</p><p>容易发现最大值最小，果断二分。</p><p>然后首先 0 的个数满足条件需要我们双指针到最远的位置，在判是否删除 1 的个数大于限制。时间复杂度 $O(n\log n)$。</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定一个序列，为 0 表示不知道，你需要将每一个 0 替换为 $[-k, k]$ 的一个数，使得和为 0，且前缀最大值 - 前缀最小值最大。输出前缀最大值 - 前缀最小值。$n\leq 3000$。</p><p>不知道做法是不是对的，反正过了（</p><p>假设前缀最大值出现在 $a$，前缀最小值出现在 $b$，设 $a &gt; b$，容易发现答案就是 $sum_a - sum_{b - 1}$。时间反正允许，我们直接枚举 $a, b$，这样我们就需要 $O(1)$ 或 $O(\log n)$ 计算答案。</p><p>容易发现我们将 $+k$ 全部放在中间，让两边去平衡，这样显然是最优的。于是就有两个限制：中间的最多只有 $sum + k\times z$，$z$ 表示 0 的个数，两边的限制为 $-sum + k\times z$，因为需要平衡为 0。直接取 $\min$ 即可，时间复杂度 $O(n ^ 2)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">chkmax</span>(res, std::<span class="built_in">min</span>(-(sum[n] - sum[r] + sum[l - <span class="number">1</span>]) + (LL) (cnt[n] - cnt[r] + cnt[l - <span class="number">1</span>]) * k, sum[r] - sum[l - <span class="number">1</span>] + (LL) (cnt[r] - cnt[l - <span class="number">1</span>]) * k));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">cnt[i] = cnt[i - <span class="number">1</span>] + !a[i], sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; ++ j)</span><br><span class="line"><span class="built_in">solve</span>(i, j);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) std::cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">LL sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cnt += !a[i], sum += a[i];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Abs</span>(sum) &gt; (LL) k * cnt) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line"><span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = -a[i];</span><br><span class="line"><span class="built_in">work</span>();</span><br><span class="line">std::cout &lt;&lt; res + <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：在 $2\times n$ 的网格上，有一些点上有权值 1，每次任选一个 1 向四周移动，注意两个 1 合并后还是一个 1，问最后剩 1 个 1 至少需要多少步。</p><p>想了许久，错了很久才发现贪心似乎有问题，写了个 DP 一下就过了。</p><p>容易发现我们合并的时候，如果前 $i$ 个有 1 的话，那么消完后一定是只有第一行有 / 只有第二行有一个 1，直接按照这个转移。</p><p>具体的，计算第一行的答案，那么答案可以来自 $f(2, i - 1) + 2$，或者是 $f(1, i - 1) + 1+a(2, i)$，因为第二行 $i$ 的位置有 1 的话，那么就需要多一个代价合并到 $f(1, i)$。第二行计算类似，不再赘述。</p><blockquote><p> 给出我的错误贪心思路，希望有好心人指出错误 / 给出反例：如果只有 1 行的话，答案显然是最后一个出现的位置减第一个出现的位置 $mx - mn$。这样枚举是最后合并到了第一行还是第二行，然后第二行如果在 $[mn, mx]$ 之间的 1 显然需要 1 个代价合并。旁边多出来的显然需要一次扫描，最后堆在 $mn / mx$ 的位置。这样 $mn, mx$ 如果原来有的话就不再需要多一次操作的，否则需要。<a href="https://codeforces.com/contest/1680/submission/157103464">错误代码链接</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%s%s&quot;</span>, &amp;n, s1 + <span class="number">1</span>, s2 + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> st = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (s1[st] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; s2[st] == <span class="string">&#x27;.&#x27;</span>) st ++;</span><br><span class="line">f1[st] = s2[st] == <span class="string">&#x27;*&#x27;</span>, f2[st] = s1[st] == <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = st + <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">f1[i] = std::<span class="built_in">min</span>(f1[i - <span class="number">1</span>] + (s2[i] == <span class="string">&#x27;*&#x27;</span>) + <span class="number">1</span>, f2[i - <span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">f2[i] = std::<span class="built_in">min</span>(f2[i - <span class="number">1</span>] + (s1[i] == <span class="string">&#x27;*&#x27;</span>) + <span class="number">1</span>, f1[i - <span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ed = n;</span><br><span class="line"><span class="keyword">while</span> (s1[ed] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; s2[ed] == <span class="string">&#x27;.&#x27;</span>) ed --;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, std::<span class="built_in">min</span>(f1[ed], f2[ed]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：给出一个无向图，要求选出一些关键点，使得每一条边至少有一个端点是关键点，且不超过一条边两个端点是关键点。给出构造，或报告无解。</p><p>赛时想到了一些，没写，赛后看到了这个做法，和自己做法有点像，就写<del>贺</del>了一遍。</p><p>抽出 dfs 树，如果不考虑可以有一条边两个关键点，那么必须保证所有边两边的深度奇偶性不同，这样按照深度选关键点即可。</p><p>现在我们有边可能不满足深度奇偶性不同，那么我们需要调整。具体地就是将一棵子树的选 / 不选状态反转，这样只有连边跨越这棵子树的状态会反转。</p><p>首先如果只有一条边不满足条件，直接输出原方案即可（可能不满足条件的边两边都是 0，注意整个翻转）。</p><p>注意到一条非树边只有可能是 儿子 - 祖先 的边，设其为 $(v, u)$，那么 $[v, u)$ 的所有点（指 $u, v$ 路径上的所有点，不包括 $u$）之中，需要一个点和他的子树进行翻转。我们将所有的深度奇偶性相同的非树边两边做一次差分，这样再次 dfs，就知道哪些点是可以反转的了。注意两边可能都是 0，所有点需要反转。</p><p>具体看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], v; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (!vis[v = e[i]])</span><br><span class="line">f[v] = x, dep[v] = dep[x] + <span class="number">1</span>, evis[i &gt;&gt; <span class="number">1</span>] = <span class="number">1</span>, <span class="built_in">dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], v; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (evis[i &gt;&gt; <span class="number">1</span>] &amp;&amp; dep[x] &lt; dep[v = e[i]])</span><br><span class="line"><span class="built_in">rdfs</span>(v), b[x] += b[v], c[x] += c[v];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsans</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dep[x] ^= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], v; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (evis[i &gt;&gt; <span class="number">1</span>] &amp;&amp; (v = e[i]) != f[x]) <span class="built_in">dfsans</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) vis[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) evis[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) h[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) b[i] = c[i] = <span class="number">0</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++ i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line"><span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, st, ed;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (evis[i &gt;&gt; <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> u = x, v = e[i];</span><br><span class="line"><span class="keyword">if</span> (dep[u] &gt; dep[v]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// printf(&quot;Extra Edge %d %d\n&quot;, u, v);</span></span><br><span class="line"><span class="keyword">if</span> ((dep[u] - dep[v]) &amp; <span class="number">1</span>) c[u] --, c[v] ++;</span><br><span class="line"><span class="keyword">else</span> st = u, ed = v, b[u] --, b[v] ++, cnt ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">rdfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(dep[ed] &amp; <span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) dep[i] ^= <span class="number">1</span>;</span><br><span class="line">dep[st] = dep[ed] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dep[i] &amp; <span class="number">1</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> to = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line"><span class="keyword">if</span> (b[x] == cnt &amp;&amp; c[x] == <span class="number">0</span>) &#123;</span><br><span class="line">to = x;</span><br><span class="line"><span class="keyword">if</span> (dep[x] &amp; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) dep[i] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!~to) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>));</span><br><span class="line"><span class="built_in">dfsans</span>(to);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dep[x] &amp; <span class="number">1</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;贪心做多了，E 题 DP 也认为是贪心（自然挂了却死活找不出错&lt;/p&gt;
&lt;p&gt;个人感觉 D 比 E 简单，怎么 D 比 E 少那么多人？&lt;/p&gt;
&lt;p&gt;赛时进度：ABCDE Accepted，Penalty：214，Rank：86。&lt;/p&gt;
&lt;p&gt;改题进度：All Accepted。&lt;/p&gt;</summary>
    
    
    
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>AGC020F</title>
    <link href="https://mydcwfy.github.io/2022/05/14/AGC020F/"/>
    <id>https://mydcwfy.github.io/2022/05/14/AGC020F/</id>
    <published>2022-05-14T00:08:09.000Z</published>
    <updated>2022-05-14T00:39:03.923Z</updated>
    
    <content type="html"><![CDATA[<p>有趣的无限转有限（<code>double</code> 转 <code>int</code>），似乎扩展了状态压缩的定义。</p><span id="more"></span><p>题意：给定一个长度为 $C$ 的圆周和 $n$ 个长度为 $l_i$ 的圆弧，随机将圆弧放在圆周的任意位置（不一定是整数），求圆周上的每一个点都被覆盖的概率。$n\leq 6, C\leq 50$，$C, l_i$ 均为整数。</p><p>数据范围这么小，几乎能想出怎么求就可以了。</p><p>首先固定一个位置，比如固定最大 $l_i$ 开始的位置为 0。这样其他的位置就比较好描述了。</p><p>首先，题目中有一个关键信息：$C, l_i$ 均为整数，虽然放的位置可能不是。如果我们将小数部分拆开看的话，其实他们到底是多少我们是无法枚举的，但是我们并不需要他们的准确值，也就是说，我们只需要他们的相对关系。这样，我们将 $n - 1$ 个 $[0, 1)$ 的小数映射到了 $[1, n - 1]$，这个离散化的过程就是第一次状态压缩。</p><p>容易发现两个小数相同的概率是 0，所以我们可以使用一个排列的方式表示这 $n - 1$ 个小数的大小关系。然后考虑在确定小数状态下，如何计算完全覆盖。</p><p>$n$ 如此之小，直接考虑状态压缩，记录 $f(s, len)$ 表示已经放入了 $s$ 状态的圆弧，最远达到了 $len$ 位置。注意 $len$ 包含了小数部分，为了方便，我们将整数部分 $\times n$，这样 $\bmod n$ 的就是小数部分。</p><p>枚举下一个数放在了哪个位置，直接考虑转移，这里不再详细展开，时间复杂度 $O((n - 1)! 2^{n - 1} (nC) ^ 2)$，可以通过。</p><p>注意实现的时候有两个坑点：</p><ol><li>代码中我直接对 $l_i$ 枚举全排列，注意可能出现 $l_i$ 相同的情况，这样 <code>std::next_permutation</code> 的次数不会达到 $(n - 1)!$，需要记录有多少。</li><li>代码中转移的时候必须先枚举下一个数放在了哪个位置（枚举了位置自然知道是哪个圆弧），顺序转移，否则会出现由于下一个数枚举的混乱导致算重情况。</li></ol><p>给出参考代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line"><span class="keyword">int</span> m = n - <span class="number">1</span>;</span><br><span class="line">f[<span class="number">0</span>][a[<span class="number">0</span>] * n] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nxt = <span class="number">0</span>; nxt &lt;= C * n; ++ nxt)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ls = nxt; ls &lt;= C * n; ++ ls)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; m); ++ s)</span><br><span class="line"><span class="keyword">if</span> (nxt % n &amp;&amp; !(s &gt;&gt; (nxt % n - <span class="number">1</span>) &amp; <span class="number">1</span>))</span><br><span class="line">f[s | (<span class="number">1</span> &lt;&lt; (nxt % n - <span class="number">1</span>))][std::<span class="built_in">min</span>(n * C, std::<span class="built_in">max</span>(ls, nxt + a[nxt % n] * n))]</span><br><span class="line">+= f[s][ls];</span><br><span class="line"><span class="comment">// for (int i = 0; i &lt; n; ++ i) printf(&quot;%d &quot;, a[i]);</span></span><br><span class="line"><span class="comment">// printf(&quot;: %.10lf\n&quot;, f[(1 &lt;&lt; m) - 1][n * C]);</span></span><br><span class="line"><span class="keyword">return</span> f[(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>][n * C];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; C;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) std::cin &gt;&gt; a[i];</span><br><span class="line">std::<span class="built_in">swap</span>(*std::<span class="built_in">max_element</span>(a, a + n), a[<span class="number">0</span>]);</span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n);</span><br><span class="line"><span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> res += <span class="built_in">solve</span>(), cnt ++; <span class="keyword">while</span> (std::<span class="built_in">next_permutation</span>(a + <span class="number">1</span>, a + n));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) res /= C;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.14lf\n&quot;</span>, res / cnt);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有趣的无限转有限（&lt;code&gt;double&lt;/code&gt; 转 &lt;code&gt;int&lt;/code&gt;），似乎扩展了状态压缩的定义。&lt;/p&gt;</summary>
    
    
    
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>CF Round#785</title>
    <link href="https://mydcwfy.github.io/2022/05/12/CF-Round-785/"/>
    <id>https://mydcwfy.github.io/2022/05/12/CF-Round-785/</id>
    <published>2022-05-12T08:59:27.000Z</published>
    <updated>2022-05-12T11:36:10.875Z</updated>
    
    <content type="html"><![CDATA[<p>E 想出来了，不过只有最后 5 min 了，以后还是得更快给出做法。</p><p>vp 赛时：ABCDF Accepted，Score：6734，Rank：38。</p><p>改题进度：All Accepted。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定字符串，字符权值为 $a\to z, 1\to 26$，每次轮流选，先手只能选长度为偶的子串拿走，后手只能选长度为奇的子串拿走，问最后谁得分高，高多少。</p><p>首先长度为偶数一定直接拿走。</p><p>长度为奇数直接选择少的一个不选即可。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：判断一个字符串是否满足以下条件：</p><blockquote><p>设该字符串字符集为 $\sum$，那么任意子串均满足 $\forall c_1, c_2\in \sum, |\text{occ}(c_1) - \text{occ}(c_2)| \leq 1$，$\text{occ}(c)$ 表示 $c$ 在子串中出现的次数。</p></blockquote><p>爆搜或者观察样例，容易发现一定是一个周期为 $\sum$ 的循环出现，否则一定不合法。</p><p>如果有打破规律的，那么一定是 $c_1c_2\dots c_1$ 而没有包括 $c_{\sum}$，这样出现次数差一定大于 1。</p><p>这个串合法是显然的。所以证明了这个是充分必要的。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：$T$ 组询问，给出一个数 $n$ 求使其由“回文数”加和的方案数。注意没有顺序，可以选择相同的数。$T\leq 10 ^ 4, n\leq 4\times 10 ^ 4$。</p><p>暴力 DP $O(n ^ 2)$ 似乎过不去，但是容易发现回文数的个数一定不多，打个表<del>看题解</del>发现只有不超过 500 个，随便完全背包即可。时间复杂度 $O(nm)$，$m$ 表示回文数的个数。</p><p>另外的问题：如果是有序的怎么做？没想到什么好的做法，只有记录有多少个 binom 一下，似乎是 $O(n^2 m)$。</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定两个有限递增等差数列 $B, C$，求有多少个有限递增等差数列 $A$ 满足 $A\cap B = C$。有无穷多个输出 -1。$T(T\leq 100)$ 组询问，</p><p>首先考虑无解情况：如果 $d_B$ 不整除 $d_C$，显然无解。如果 $d_B$ 不整除 $st_C - st_B$，无解。如果 $C$ 的首尾项超出了 $B$ 的范围，无解。</p><p>接下来考虑无穷的情况。如果 $C$ 的尾项后面一项超出了 $B$ 的范围，那么 $A$ 的尾项就可以无限延伸，就是无穷。首项前面同理。</p><p>如果 $\text{lcm}(d_A, d_B)\not= d_C$，显然是不可能的，所以我们可以暴力判断 $d_C$ 的所有因子是否合法。时间是允许的。</p><p>如果是合法的，那么 $A$ 的首项应该在 $C$ 的首项和 $C$ 首项前一项之间，尾项同理。贡献就是 $(\dfrac {d_C}{d_A}) ^ 2$。</p><p>直接暴力计算即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> ad)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Lcm</span>(ad, bd) != cd) <span class="keyword">return</span>;</span><br><span class="line">res = (res + (LL) (cd / ad) * (cd / ad)) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; bst &gt;&gt; bd &gt;&gt; bn &gt;&gt; cst &gt;&gt; cd &gt;&gt; cn;</span><br><span class="line">res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (cd % bd || (cst - bst) % bd) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (cst + (LL) cd * (cn - <span class="number">1</span>) &gt; bst + (LL) bd * (bn - <span class="number">1</span>) || cst &lt; bst)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (cst + (LL) cd * cn &gt; bst + (LL) bd * (bn - <span class="number">1</span>) || cst - cd &lt; bst)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cd / i; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (cd % i) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">solve</span>(i);</span><br><span class="line"><span class="keyword">if</span> (i != cd / i) <span class="built_in">solve</span>(cd / i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：给定 $n$ 的序列 $a_i = 2 ^ {b_i}$，可以在中间加入 $\oplus$ 或者是 $\texttt{Power}$，然后按照优先级计算，至少加入 $k$ 个 $\oplus$，问所有插入方式的计算答案的 $\oplus$，对 $2 ^ {2 ^ {20}}$ 取模，2 进制输出。$n\leq 2 ^ {20}, 1\leq b_i &lt; 2 ^ {20}$。</p><p>可能与 tutorial 做法不一样。</p><p>考虑，然后按照一段区间算贡献。容易发现一段不包含 $\oplus$ 区间的答案只有可能是 $2 ^ x$ 的形式，于是看贡献次数是否是 2 的倍数。</p><p>考虑如果我们已经确定了一段区间，怎样计算贡献次数。如果两边都没有到头，那么相当于我们已经选择了两个端点，又强制一些不能选，那么就是 $\binom {len - 1}{k - 2}$，$len$ 表示没有被选择的区间。至少有 $k$ 个，就是 $\displaystyle \sum_{i = k - 2} ^ {len - 2} \binom{len - 2}{i}$（自己手玩一下。如果覆盖了一端，那么就是 $\displaystyle \sum_{i = k - 1} ^ {len - 1}\binom{len - 1}{i}$。覆盖了两端当且仅当 $k = 0$ 合法。</p><p>怎样快速计算这个呢？根据 Lucas 定理，那么相当于 $i\odot (len - 1) = i$ 贡献才为 1，那么我们可以使用 FMT 前缀和一下，就可以得到了。</p><p>直接暴力枚举区间是 $O(n ^ 2)$，但是容易发现不超过 20 次就会超出模数范围，也就是说，区间长度最多只有 20。于是暴力枚举即可，注意分讨。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = std::<span class="built_in">max</span>(<span class="number">0</span>, k - <span class="number">2</span>); i &lt; n; ++ i) ans[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = std::<span class="built_in">max</span>(<span class="number">0</span>, k - <span class="number">1</span>); i &lt; n; ++ i) ans2[i] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">FMT</span>(ans, <span class="number">20</span>), <span class="built_in">FMT</span>(ans2, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, b + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> st = <span class="number">2</span>; st &lt;= n; ++ st)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cur = st;</span><br><span class="line">LL mul = b[st];</span><br><span class="line"><span class="keyword">while</span> (cur &lt;= n &amp;&amp; !(mul &gt;&gt; <span class="number">20</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur ^ n) &#123;</span><br><span class="line"><span class="keyword">if</span> (ans[n - <span class="number">2</span> - (cur - st + <span class="number">1</span>)]) res[mul] ^= <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (ans2[n - <span class="number">1</span> - (cur - st + <span class="number">1</span>)]) res[mul] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">++ cur;</span><br><span class="line"><span class="keyword">if</span> (b[cur] &gt;= <span class="number">20</span>) <span class="keyword">break</span>;</span><br><span class="line">mul &lt;&lt;= b[cur];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">LL mul = b[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (cur &lt;= n &amp;&amp; !(mul &gt;&gt; <span class="number">20</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur ^ n) &#123;</span><br><span class="line"><span class="keyword">if</span> (ans2[n - <span class="number">1</span> - cur]) res[mul] ^= <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">0</span>) res[mul] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">++ cur;</span><br><span class="line"><span class="keyword">if</span> (b[cur] &gt;= <span class="number">20</span>) <span class="keyword">break</span>;</span><br><span class="line">mul &lt;&lt;= b[cur];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>, flag = <span class="number">0</span>; ~i; -- i) &#123;</span><br><span class="line">flag |= res[i] || !i;</span><br><span class="line"><span class="keyword">if</span> (flag) <span class="built_in">putchar</span>(res[i] | <span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：$n\times n$ 的网格，合理设计四联通相邻的网格边权，使得从任意已知起点走到任意点都能通过边权异或值得到终点位置。$n\leq 32$，边权和不得超过 $48000$。</p><p>比较有意思的位运算题目。一下默认 0 开始标号。</p><p>首先考虑 1D 情况，我们需要把大的 $bit$ 出现次数尽量小，那么比如 $n = 32$，我们就在 $15\to 16$ 的边上放上 16，此外都不放 16，这样我就能判断是在 $[0, 15]$ 还是 $[16, 31]$。向下同理，可以发现需要的边权和就是 $16 + 8\times 2 + 4\times 4 + 2\times 8 + 1\times 16 = 64$。</p><p>放到 2D 上，一个显然的想法是我们将两维分开，两维互不干扰，于是 $x$ 维上使用 $0, 1, 2, 3, 4$ 位，$y$ 维上使用 $5, 6, 7, 8, 9$ 位，这样整个的代价就是 $32\times 64 + 32\times 2048 = 67584$，不能通过。</p><p>$y$ 维上全是高位，贡献组合较大，我们可以考虑交叉使用，$x$ 维使用 $0, 2, 4, 6, 8$，$y$ 维使用 $1, 3, 5, 7, 9$，这样跑一下程序发现是 $47616$，于是可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> tr1 = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (x &gt;&gt; i &amp; <span class="number">1</span>) res |= <span class="number">1</span> &lt;&lt; (i * <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> tr2 = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (x &gt;&gt; i &amp; <span class="number">1</span>) res |= <span class="number">1</span> &lt;&lt; (i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n, T, res = <span class="number">0</span>;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; T;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i, std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++ j) std::cout &lt;&lt; <span class="built_in">tr1</span>(j &amp; -j) &lt;&lt; <span class="string">&#x27; &#x27;</span>, res += <span class="built_in">tr1</span>(j &amp; -j);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i, std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) std::cout &lt;&lt; <span class="built_in">tr2</span>(i &amp; -i) &lt;&lt; <span class="string">&#x27; &#x27;</span>, res += <span class="built_in">tr2</span>(i &amp; -i);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; res &lt;&lt; std::endl;</span></span><br><span class="line">std::cout.<span class="built_in">flush</span>();</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>, lx = <span class="number">0</span>, ly = <span class="number">0</span>; <span class="comment">// x, y is exchanged</span></span><br><span class="line"><span class="keyword">while</span> (T --) &#123;</span><br><span class="line">std::cin &gt;&gt; cur;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">8</span>, ls = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i -= <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> ((cur &gt;&gt; i &amp; <span class="number">1</span>) ^ ls) lx ^= <span class="number">1</span> &lt;&lt; (i / <span class="number">2</span>), ls = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ls = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>, ls = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i -= <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> ((cur &gt;&gt; i &amp; <span class="number">1</span>) ^ ls) ly ^= <span class="number">1</span> &lt;&lt; (i / <span class="number">2</span>), ls = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ls = <span class="number">0</span>;</span><br><span class="line">std::cout &lt;&lt; ly + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; lx + <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;E 想出来了，不过只有最后 5 min 了，以后还是得更快给出做法。&lt;/p&gt;
&lt;p&gt;vp 赛时：ABCDF Accepted，Score：6734，Rank：38。&lt;/p&gt;
&lt;p&gt;改题进度：All Accepted。&lt;/p&gt;</summary>
    
    
    
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="位运算" scheme="https://mydcwfy.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="集合幂级数" scheme="https://mydcwfy.github.io/tags/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"/>
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>CF Round#788</title>
    <link href="https://mydcwfy.github.io/2022/05/11/CF-Round-788/"/>
    <id>https://mydcwfy.github.io/2022/05/11/CF-Round-788/</id>
    <published>2022-05-11T11:16:04.000Z</published>
    <updated>2022-05-11T12:04:47.645Z</updated>
    
    <content type="html"><![CDATA[<p>vp Div2 差点把构造题想出来了，结果以为自己是错的（</p><p>赛时进度：ABCD Accpeted，Score：4091，Rank：923，Rating 无变化。</p><p>改题进度：All Accepted。</p><span id="more"></span><p><a href="https://codeforces.com/contest/1670/">比赛传送门</a></p><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定一个序列，问能否通过交换符号的方式使序列有序。没有 0。</p><p>容易发现负号一定在前面，随便判一下即可。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定一个字符串和一些关键字符，一次删除是将关键字符前面的字符删去，问有用的删除有多少次。</p><p>卡了比较久，写出来了，结果还被卡常了（（（</p><p>首先相当于是一个序列，每次所有数减 1，小于 0 的数删去，能减多少次。开头的可能不同，特判一下。证明即考虑每一段关键字符之间的段即可。</p><p>答案显然是 $\max a$ 再加 1，注意 +1 是前面的关键字符被删了，所以如果是开头就不能加 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%s%d&quot;</span>, &amp;n, str + <span class="number">1</span>, &amp;cnt);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i) sp[<span class="string">&#x27;a&#x27;</span> + i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tmp);</span><br><span class="line">sp[tmp[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, ls = <span class="number">0</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!sp[str[i]]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">chkmax</span>(mx, i - ls - <span class="number">1</span> + !!ls), ls = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定两个排列 $a, b$，构造序列 $c$ 使得 $c_i\in\{a_i, b_i\}$ 且 $c$ 是排列的方案数有多少。部分 $c_i$ 给定，保证有解。</p><p>容易发现如果某一个没有选 $a_i$，那么 $b_j = a_i$ 的位置就得选 $b$，这样 $a_j$ 有没有选，这样就会轮下去，形成一个置换环。容易发现一个置换环只有两种选法。</p><p>题目保证有解，那么 $c_i$ 覆盖了的置换环有且仅有一种情况。计算有多少置换环没有被覆盖即可。注意长度为 1 的置换环贡献一定为 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, b + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) nw[a[i]] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) bel[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (bel[i] || a[i] == b[i]) <span class="keyword">continue</span>;</span><br><span class="line">++ cnt;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (!bel[j]) bel[j] = cnt, j = nw[b[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) usd[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="keyword">if</span> (x) usd[bel[i]] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> und = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) und += !usd[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pw2[und]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意不好描述，看原题面吧。</p><p>主要是题意转化比较麻烦。</p><p>如果我们将一个正六边形看作是一个点的话，那么相当于是三个方向的直线交点的个数（三线相交算 3 个交点），那么假设三个方向的直线分别是 $a, b, c$，那么答案就是 $ab + bc + ac$。</p><p>如果总条数已经确定，那么答案就是将 $a, b, c$ 尽量平均即可。随便二分即可。</p><p>代码和题解略有不同，代码中是二分的 $\min\{a, b, c\}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">std::cin &gt;&gt; n, n = (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">calc</span>(mid, mid, mid) &lt;= n) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">calc</span>(l, l, l) == n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">3</span> * l);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">calc</span>(l, l, l + <span class="number">1</span>) &gt;= n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">3</span> * l + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">calc</span>(l, l + <span class="number">1</span>, l + <span class="number">1</span>) &gt;= n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">3</span> * l + <span class="number">2</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">3</span> * l + <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：给定 $n = 2 ^ p$ 的树，要求给每个点 / 边设置权值，恰好覆盖 $0\sim 2 ^ {p + 1} - 1$ 的数，并选定根，使得每个点 / 边的前缀异或最大值最小。</p><p>本身想到了，结果以为菊花图将其卡掉，没认真想。</p><p>首先，观察样例可得答案应该为 $2 ^ p$，想一想为什么。</p><p>首先证明 $ans\geq 2 ^ {p}$，因为有一个 $\geq 2 ^ p$ 的数，如果答案都 $&lt; 2 ^ p$，那么 $\oplus 2 ^ p$ 一定就 $\geq 2 ^ p$，与假设矛盾。</p><p>答案应该就是 $2 ^ {p}$，考虑构造。首先选择根是假的，任选都可以。</p><p>先将根设为 $2 ^ p$，然后每个节点假设父亲前缀异或是 $2 ^ p$，那么边就是 $x + 2 ^ p$，点的权值就是 $x$，这样该点的前缀异或也是 $2 ^ p$，可以递归下去。</p><p>所以这样答案就是 $2 ^ p$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> ex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (e[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">++ tot;</span><br><span class="line">w[i] = w[i ^ <span class="number">1</span>] = tot ^ (ex * n), val[e[i]] = tot ^ (!ex * n);</span><br><span class="line"><span class="built_in">dfs</span>(e[i], x, !ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n, n = <span class="number">1</span> &lt;&lt; n, tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) h[i] = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++ i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line"><span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">&#125;</span><br><span class="line">val[<span class="number">1</span>] = n, <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, val[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idx; i += <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, w[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：给定 $n, l, r, z$，求满足条件的 $a$ 序列使得 $\sum_{i = 1} ^ na_i\in [l, r], \oplus_{i = 1} ^ n a_i = z$。对 $10 ^ 9 + 7$ 取模。$n\leq 1000, l, r, z\leq 10 ^ {18}$。</p><p>一看显然的数位 DP，不过做法复杂了，赛时没写出来。</p><p>显然差分一下，只有上界。</p><p>记录 $f(bit, x)$ 表示处理到 $bit$ 位，最多可以放 $x$ 个 1。最后从 $f(61, 0)$ 开始最后到 $f(-1, *)$ 的方案数（因为 0 位考虑后答案放在 -1 了）。限制可以从上一位传下来，也可以通过这一位 $lim$ 为 1 得到。</p><p>直接转移即可，注意 <code>chkmin(x, n)</code>，因为 $x = n$ 后面相当于不限制了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(LL lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">f[<span class="number">62</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">61</span>; ~i; -- i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= n; ++ s)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> trs = z &gt;&gt; i &amp; <span class="number">1</span>, ed = std::<span class="built_in">min</span>((LL) n, (s &lt;&lt; <span class="number">1</span>) + (lim &gt;&gt; i &amp; <span class="number">1</span>)); trs &lt;= ed; trs += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> &amp;nxt = f[i][std::<span class="built_in">min</span>((LL) n, (s &lt;&lt; <span class="number">1</span>) + (lim &gt;&gt; i &amp; <span class="number">1</span>) - trs)];</span><br><span class="line">nxt = (nxt + (LL) f[i + <span class="number">1</span>][s] * C[n][trs]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1023</span>; ++ i) <span class="built_in">adj</span>(res += f[<span class="number">0</span>][i] - Mod);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;vp Div2 差点把构造题想出来了，结果以为自己是错的（&lt;/p&gt;
&lt;p&gt;赛时进度：ABCD Accpeted，Score：4091，Rank：923，Rating 无变化。&lt;/p&gt;
&lt;p&gt;改题进度：All Accepted。&lt;/p&gt;</summary>
    
    
    
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>ABC248G</title>
    <link href="https://mydcwfy.github.io/2022/05/11/ABC248G/"/>
    <id>https://mydcwfy.github.io/2022/05/11/ABC248G/</id>
    <published>2022-05-11T10:39:13.000Z</published>
    <updated>2022-05-11T12:08:48.584Z</updated>
    
    <content type="html"><![CDATA[<p>有趣的反演（？）题目，欧拉函数基础变化。</p><span id="more"></span><p>题意：给定一棵带点权树，定义一条路径的权值为覆盖点的数目乘以所有数的 $\gcd$，求所有路径（不含单点路径）的和。$n\leq 10 ^ 5, 1\leq a_i\leq n$。</p><h3 id="做法-1（赛时做法）"><a href="#做法-1（赛时做法）" class="headerlink" title="做法 1（赛时做法）"></a>做法 1（赛时做法）</h3><p>考虑枚举 $d$，使得所有数都是 $d$ 的倍数，对所有连通块进行遍历，可以得到所有路径覆盖点的个数和。$\gcd$ 为 $d$ 的答案即为 $d | \gcd$ 的答案减去所有 $\gcd = 2d, 3d, \dots$ 的答案，倒序扫即可。时间复杂度 $O(nD + n\ln n)$，$D$ 表示 $n$ 以内最大因数个数。统计连通块的个数可以树形 DP 一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a[x] % d) <span class="keyword">return</span>;</span><br><span class="line">sz[x] = dis[x] = <span class="number">1</span>, vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (!(a[v] % d) &amp;&amp; !vis[v]) &#123;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">ans[d] = (ans[d] + (LL) dis[v] * sz[x] + (LL) dis[x] * sz[v]) % Mod;</span><br><span class="line"><span class="built_in">adj</span>(dis[x] += dis[v] - Mod), <span class="built_in">adj</span>(dis[x] += sz[v] - Mod), sz[x] += sz[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, x = a[i]; j &lt;= x / j; ++ j) &#123;</span><br><span class="line"><span class="keyword">if</span> (x % j) <span class="keyword">continue</span>;</span><br><span class="line">bs[j].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">if</span> (j * j != x) bs[x / j].<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (d = <span class="number">1</span>; d &lt; N; ++ d)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : bs[d])</span><br><span class="line"><span class="keyword">if</span> (!vis[x]) <span class="built_in">dfs</span>(x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : bs[d]) vis[x] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i; -- i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j * i &lt; N; ++ j) <span class="built_in">adj</span>(ans[i] -= ans[i * j]);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) res = (res + (LL) i * ans[i]) % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="做法-2（欧拉函数）"><a href="#做法-2（欧拉函数）" class="headerlink" title="做法 2（欧拉函数）"></a>做法 2（欧拉函数）</h3><p>考虑一件事情：$\sum_{d | n} \varphi(d) = n$，具体证明可以拆质数算。那么当贡献为 $n$ 时，我们只需要计算 $\sum_{d | n} \varphi(d)$ 即可。</p><p>向上面一样，我们直接计算 $d | \gcd$ 的路径点数之和，最后乘上 $\varphi(d)$ 即可。时间复杂度 $O(nD)$。</p><p>代码和上面差不多，不给了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有趣的反演（？）题目，欧拉函数基础变化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="莫比乌斯反演" scheme="https://mydcwfy.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>ABC242Ex</title>
    <link href="https://mydcwfy.github.io/2022/05/11/ABC242H/"/>
    <id>https://mydcwfy.github.io/2022/05/11/ABC242H/</id>
    <published>2022-05-11T08:01:56.000Z</published>
    <updated>2022-05-11T12:08:38.315Z</updated>
    
    <content type="html"><![CDATA[<p>虽然是 ABC，质量、难度还是不错的（考场上没想到）。</p><span id="more"></span><p>题意：给定 $m$ 个区间，每次随机选择一个区间，问期望多少次将 $[1, n]$ 全部覆盖。$n, m\leq 400$。</p><p>拆开每一位，相当于是 $E(\max t_i)$，$\max$ 的期望似乎很不好求，我们考虑 min-max 容斥。<br>$$<br>E(\max_{i\in T} a_i) = \sum_{S\subseteq T} (-1) ^ {|S| + 1}E(\min_{i\in S} a_i)<br>$$<br>一个集合的 $\min$ 是好求的，我们先求出与之有交的区间个数 $x$，那么选到 $x$ 中的任意一个都是合法的，那么期望显然是 $\dfrac mx$。</p><p>直接暴力枚举所有集合显然是不行的，我们考虑前面集合中都 $\subseteq \{1, 2, \dots, i - 1\}$在所有集合中加入 $i$，看需要维护什么。首先我们需要维护新加入 $i$ 后区间的个数，容斥系数直接每次加入元素时乘 -1 即可。维护区间个数需要我们维护出上一个选的数 $ls$，这样 $l\in [ls + 1, i], r\in [i, n]$ 的区间就是新加入的。容易发现这是对的。</p><p>于是我们需要维护的就是 $ls$ 表示上一个选的数，$cnt$ 表示有交的区间。状态数为 $O(nm)$，转移为 $O(n)$，总复杂度 $O(n ^ 2m)$。</p><p><strong>期望 max/min 可以互相转化</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = Mod - <span class="number">1</span>; <span class="comment">// last position i, j intervals</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line"><span class="keyword">if</span> (!f[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">res = (res + (LL) m * <span class="built_in">qpow</span>(j) % Mod * f[i][j]) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> to = i + <span class="number">1</span>; to &lt;= n; ++ to)</span><br><span class="line"><span class="built_in">adj</span>(f[to][j + cnt[i][to]] -= f[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然是 ABC，质量、难度还是不错的（考场上没想到）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="min-max 容斥" scheme="https://mydcwfy.github.io/tags/min-max-%E5%AE%B9%E6%96%A5/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>AHOI2022 钥匙</title>
    <link href="https://mydcwfy.github.io/2022/05/11/AHOI2022-T2/"/>
    <id>https://mydcwfy.github.io/2022/05/11/AHOI2022-T2/</id>
    <published>2022-05-11T07:42:56.000Z</published>
    <updated>2022-05-11T07:58:40.649Z</updated>
    
    <content type="html"><![CDATA[<p>码量题，vp 时差点写吐了（当然也和我选的方法不够简洁有关），没调出来。</p><span id="more"></span><p>题意：给定一棵树，每个节点有钥匙或宝箱，钥匙和宝箱都有一个颜色，相同颜色 的才能匹配。同一种颜色的钥匙最多只有 5 把。进行 $q$ 次旅行，问每次旅行能打开多少宝箱。$n\leq 5\times 10 ^ 5, q\leq 10 ^ 6$。</p><p>容易发现我们要对每一种颜色建一棵虚树。</p><p>建虚树过后，由于钥匙最多只有 5 把，暴力以为一个钥匙为起点枚举是可行的。考虑计算到每一个节点时还剩几把钥匙，如果没有了说明起点的钥匙会和这个点匹配，当他们两同时出现在路径上时，贡献会多 1。</p><p>最后就是一个路径覆盖问题，注意 $(a, b)$ 需要分类 $a$ 是 $b$ 的祖先，$b$ 是 $a$ 的祖先，其余情况。拍到 dfn 序上，扫描线 + 树状数组即可解决。</p><p>代码是在考场代码上改的，很冗长，仅供参考。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line">    <span class="keyword">int</span> st[N &lt;&lt; <span class="number">1</span>][<span class="number">22</span>], lg[N &lt;&lt; <span class="number">1</span>], fi[N], cnt;</span><br><span class="line">    <span class="keyword">int</span> dep[N], d1[N], d2[N], typ[N], f[N], up[N], frm, rem[N];</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) h[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) typ[i] = <span class="number">0</span>;</span><br><span class="line">        idx = cnt = frm = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        st[++ cnt][<span class="number">0</span>] = x, fi[x] = cnt, dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">        d1[x] = d1[fa], d2[x] = d2[fa], f[x] = fa, up[x] = frm;</span><br><span class="line">        <span class="keyword">if</span> (typ[x] == <span class="number">1</span>) d1[x] ++, frm = x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (typ[x] == <span class="number">2</span>) d2[x] ++;</span><br><span class="line">        <span class="keyword">int</span> tmp = frm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">            <span class="keyword">if</span> (e[i] ^ fa) <span class="built_in">dfs</span>(e[i], x), st[++ cnt][<span class="number">0</span>] = x, frm = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dmin</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> dep[x] &lt; dep[y] ? x : y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++ i) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lg[cnt]; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= cnt; ++ i)</span><br><span class="line">                st[i][j] = <span class="built_in">dmin</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fi[x] &gt; fi[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">int</span> k = lg[fi[y] - fi[x] + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dmin</span>(st[fi[x]][k], st[fi[y] - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dist1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">LCA</span>(x, y);</span><br><span class="line">        <span class="keyword">return</span> d1[x] + d1[y] - d1[t] - d1[f[t]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dist2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">LCA</span>(x, y);</span><br><span class="line">        <span class="keyword">return</span> d2[x] + d2[y] - d2[t] - d2[f[t]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        rem[x] = rem[fa];</span><br><span class="line">        <span class="keyword">if</span> (typ[x] == <span class="number">1</span>) rem[x] ++;</span><br><span class="line">        <span class="keyword">if</span> (typ[x] == <span class="number">2</span>) rem[x] --;</span><br><span class="line">        <span class="keyword">if</span> (rem[x] == <span class="number">0</span>) <span class="keyword">return</span> ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">            <span class="keyword">if</span> (e[i] ^ fa) <span class="built_in">dfs2</span>(e[i], x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">getmatch</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ans.<span class="built_in">clear</span>(), <span class="built_in">dfs2</span>(x);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr, oc;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tr[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; N; i += (i &amp; -i)) tr[i] += c; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i ^= (i &amp; -i)) res += tr[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!top) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(stk[top = <span class="number">1</span>] = x);</span><br><span class="line">    <span class="keyword">int</span> lca = tr.<span class="built_in">LCA</span>(x, stk[top]);</span><br><span class="line">    allnodes.<span class="built_in">push_back</span>(lca);</span><br><span class="line">    <span class="keyword">if</span> (!pos[lca]) pos[lca] = ++ curcnt;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; tr.dep[stk[top - <span class="number">1</span>]] &gt;= tr.dep[lca])</span><br><span class="line">        oc.<span class="built_in">link</span>(pos[stk[top - <span class="number">1</span>]], pos[stk[top]]), top --;</span><br><span class="line">    <span class="keyword">if</span> (stk[top] != lca) oc.<span class="built_in">link</span>(pos[lca], pos[stk[top]]), stk[top] = lca;</span><br><span class="line">    <span class="keyword">if</span> (lca != x) stk[++ top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = ++ *dfn, sz[x] = <span class="number">1</span>, nw[*dfn] = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[x])</span><br><span class="line">        <span class="keyword">if</span> (v ^ fa) <span class="built_in">dfs</span>(v, x), sz[x] += sz[v];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MyRun</span></span><br><span class="line">    <span class="comment">// freopen(&quot;keys.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;keys.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">read</span>(n, Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(typ[i], col[i]);</span><br><span class="line">    tr.<span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++ i)</span><br><span class="line">        <span class="built_in">read</span>(u, v), g[u].<span class="built_in">push_back</span>(v), g[v].<span class="built_in">push_back</span>(u), tr.<span class="built_in">add</span>(u, v), tr.<span class="built_in">add</span>(v, u);</span><br><span class="line">    tr.<span class="built_in">prework</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        all[col[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (typ[i] == <span class="number">1</span>) ky[col[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">else</span> bx[col[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> cmp = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> dfn[x] &lt; dfn[y]; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        std::<span class="built_in">sort</span>(all[i].<span class="built_in">begin</span>(), all[i].<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ky[i].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// std::cerr &lt;&lt; &quot;Col &quot; &lt;&lt; i &lt;&lt; std::endl;</span></span><br><span class="line">        oc.<span class="built_in">init</span>(std::<span class="built_in">min</span>((<span class="keyword">int</span>) all[i].<span class="built_in">size</span>() * <span class="number">2</span> + <span class="number">1</span>, n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>) all[i].<span class="built_in">size</span>(); ++ j)</span><br><span class="line">            pos[all[i][j]] = j + <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// for (int i = 1; i &lt;= n; ++ i) printf(&quot;%d &quot;, pos[i]);</span></span><br><span class="line">        <span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line">        allnodes = all[i], allnodes.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        pos[<span class="number">1</span>] = <span class="number">1</span>, <span class="built_in">insert</span>(<span class="number">1</span>), curcnt = all[i].<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// printf(&quot;%d %d %d %d\n&quot;, i, (int) all[i].size(), (int) ky[i].size(), (int) allnodes.size());</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : all[i])</span><br><span class="line">            <span class="keyword">if</span> (x ^ <span class="number">1</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (-- top) oc.<span class="built_in">link</span>(pos[stk[top]], pos[stk[top + <span class="number">1</span>]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : ky[i]) oc.typ[pos[x]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : bx[i]) oc.typ[pos[x]] = <span class="number">2</span>;</span><br><span class="line">        oc.<span class="built_in">prework</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p1 : ky[i]) &#123;</span><br><span class="line">            <span class="keyword">auto</span> mat = oc.<span class="built_in">getmatch</span>(pos[p1]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p2 : mat) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p2 &gt; (<span class="keyword">int</span>) all[i].<span class="built_in">size</span>() + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (p2 == <span class="number">1</span> &amp;&amp; bx[i].<span class="built_in">front</span>() != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (p2 == <span class="number">1</span>) p2 ++;</span><br><span class="line">                p2 = all[i][p2 - <span class="number">2</span>];</span><br><span class="line">                <span class="comment">// printf(&quot;%d %d Pair\n&quot;, p1, p2);</span></span><br><span class="line">                <span class="keyword">if</span> (dfn[p1] &lt;= dfn[p2] &amp;&amp; dfn[p2] &lt; dfn[p1] + sz[p1]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> son = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[p1])</span><br><span class="line">                        <span class="keyword">if</span> (dfn[v] &gt; dfn[p1] &amp;&amp; dfn[v] &lt;= dfn[p2] &amp;&amp; dfn[p2] &lt; dfn[v] + sz[v])</span><br><span class="line">                            <span class="built_in">assert</span>(!~son), son = v;</span><br><span class="line">                    <span class="built_in">assert</span>(~son);</span><br><span class="line">                    opt[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;dfn[p2], dfn[p2] + sz[p2] - <span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">                    opt[dfn[son]].<span class="built_in">push_back</span>(&#123;dfn[p2], dfn[p2] + sz[p2] - <span class="number">1</span>, <span class="number">-1</span>&#125;);</span><br><span class="line">                    opt[dfn[son] + sz[son]].<span class="built_in">push_back</span>(&#123;dfn[p2], dfn[p2] + sz[p2] - <span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dfn[p2] &lt;= dfn[p1] &amp;&amp; dfn[p1] &lt; dfn[p2] + sz[p2]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> son = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[p2])</span><br><span class="line">                        <span class="keyword">if</span> (dfn[v] &gt; dfn[p2] &amp;&amp; dfn[v] &lt;= dfn[p1] &amp;&amp; dfn[p1] &lt; dfn[v] + sz[v])</span><br><span class="line">                            <span class="built_in">assert</span>(!~son), son = v;</span><br><span class="line">                    <span class="built_in">assert</span>(~son);</span><br><span class="line">                    opt[dfn[p1]].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, dfn[son] - <span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">                    opt[dfn[p1]].<span class="built_in">push_back</span>(&#123;dfn[son] + sz[son], n, <span class="number">1</span>&#125;);</span><br><span class="line">                    opt[dfn[p1] + sz[p1]].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, dfn[son] - <span class="number">1</span>, <span class="number">-1</span>&#125;);</span><br><span class="line">                    opt[dfn[p1] + sz[p1]].<span class="built_in">push_back</span>(&#123;dfn[son] + sz[son], n, <span class="number">-1</span>&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    opt[dfn[p1]].<span class="built_in">push_back</span>(&#123;dfn[p2], dfn[p2] + sz[p2] - <span class="number">1</span>, <span class="number">1</span>&#125;),</span><br><span class="line">                    opt[dfn[p1] + sz[p1]].<span class="built_in">push_back</span>(&#123;dfn[p2], dfn[p2] + sz[p2] - <span class="number">1</span>, <span class="number">-1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : allnodes) pos[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::cerr &lt;&lt; &quot;Success&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, st, ed; i &lt;= Q; ++ i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(st, ed);</span><br><span class="line">        <span class="built_in">assert</span>(dfn[st] &gt;= <span class="number">1</span> &amp;&amp; dfn[st] &lt;= n);</span><br><span class="line">        q[dfn[st]].<span class="built_in">push_back</span>(&#123;dfn[ed], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : opt[i])</span><br><span class="line">            bt.<span class="built_in">add</span>(p.l, p.c), bt.<span class="built_in">add</span>(p.r + <span class="number">1</span>, -p.c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : q[i])</span><br><span class="line">            res[p.second] = bt.<span class="built_in">ask</span>(p.first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;码量题，vp 时差点写吐了（当然也和我选的方法不够简洁有关），没调出来。&lt;/p&gt;</summary>
    
    
    
    
    <category term="扫描线" scheme="https://mydcwfy.github.io/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    
    <category term="树状数组" scheme="https://mydcwfy.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
    <category term="虚树" scheme="https://mydcwfy.github.io/tags/%E8%99%9A%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>AHOI2022 排列</title>
    <link href="https://mydcwfy.github.io/2022/05/11/AHOI2022-T1/"/>
    <id>https://mydcwfy.github.io/2022/05/11/AHOI2022-T1/</id>
    <published>2022-05-11T07:28:50.000Z</published>
    <updated>2022-05-11T07:42:30.323Z</updated>
    
    <content type="html"><![CDATA[<p>有趣的数论题目，似乎说不上用了什么高级知识。</p><span id="more"></span><p>题意：一个排列的权值定义为最少置换次数使得出现循环。给出排列，求将任意两个不在一个置换环的数交换后排列的权值和。$n\leq 5\times 10 ^ 5$。</p><p>首先，容易发现一个排列的取值就是虽有置换环长度的 $\text{lcm}$。</p><p>$\text{lcm}$ 可能会炸，所以需要考虑枚举所有的质数，求质数幂次的最大值，最后合并答案。</p><p>考虑暴力枚举两个不同的置换环，我们需要将这两个环对于 $\text{lcm}$ 的贡献去掉，然后将两个置换环长度和加入整个 $\text{lcm}$ 的贡献。去掉两个数可能会产生删除最大值两次，于是我们需要维护质数幂的前三大值以便维护。回滚的时候记录下所有改变的值即可。</p><p>暴力枚举置换环最坏是 $O(n ^ 2)$ 的，还没有算计算 $\text{lcm}$ 的复杂度，但是容易发现只有 $O(\sqrt n)$ 个不同的置换环长度，而贡献又只与长度相关。这样枚举复杂度降为 $O(n)$，后面直接暴力枚举涉及到的质数即可通过。不太会算复杂度，据说是 $O(n\log n)$？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    all.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) vis[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cnt[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) mx1[i] = mx2[i] = mx3[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> j = i, cir = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!vis[j]) cir ++, vis[j] = <span class="literal">true</span>, j = a[j];</span><br><span class="line">        <span class="keyword">if</span> (!cnt[cir] ++) all.<span class="built_in">push_back</span>(cir);</span><br><span class="line">        <span class="comment">// printf(&quot;Cir %d\n&quot;, cir);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c : all) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = c, t = <span class="number">0</span>, p;</span><br><span class="line">        <span class="keyword">while</span> (cur ^ <span class="number">1</span>) &#123;</span><br><span class="line">            p = fac[cur].<span class="built_in">front</span>(), t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur % p == <span class="number">0</span>) t ++, cur /= p;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> cs = <span class="number">1</span>; cs &lt;= cnt[c]; ++ cs)</span><br><span class="line">                <span class="keyword">if</span> (t &gt; mx1[p]) mx3[p] = mx2[p], mx2[p] = mx1[p], mx1[p] = t;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; mx2[p]) mx3[p] = mx2[p], mx2[p] = t;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">chkmax</span>(mx3[p], t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lcm = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (mx1[i]) lcm = (LL) lcm * pw[i][mx1[i]] % Mod;</span><br><span class="line">    <span class="comment">// printf(&quot;Lcm = %d\n&quot;, lcm);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c1 : all)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c2 : all) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c1 == c2 &amp;&amp; cnt[c1] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = lcm;</span><br><span class="line">            <span class="keyword">auto</span> del = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">                <span class="keyword">int</span> p, t;</span><br><span class="line">                <span class="keyword">while</span> (x ^ <span class="number">1</span>) &#123;</span><br><span class="line">                    p = fac[x].<span class="built_in">front</span>(), t = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!havbac[p])</span><br><span class="line">                        havbac[p] = <span class="literal">true</span>, bac1[p] = mx1[p], bac2[p] = mx2[p], bac3[p] = mx3[p];</span><br><span class="line">                    <span class="keyword">while</span> (x % p == <span class="number">0</span>) t ++, x /= p;</span><br><span class="line">                    <span class="keyword">if</span> (t == mx1[p])</span><br><span class="line">                        cur = (LL) cur * inv[p][mx1[p] - mx2[p]] % Mod, mx1[p] = mx2[p], mx2[p] = mx3[p];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (t == mx2[p]) mx2[p] = mx3[p];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">auto</span> ins = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">                <span class="keyword">int</span> p, t;</span><br><span class="line">                <span class="keyword">while</span> (x ^ <span class="number">1</span>) &#123;</span><br><span class="line">                    p = fac[x].<span class="built_in">front</span>(), t = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!havbac[p])</span><br><span class="line">                        havbac[p] = <span class="literal">true</span>, bac1[p] = mx1[p], bac2[p] = mx2[p], bac3[p] = mx3[p];</span><br><span class="line">                    <span class="keyword">while</span> (x % p == <span class="number">0</span>) t ++, x /= p;</span><br><span class="line">                    <span class="keyword">if</span> (t &gt; mx1[p])</span><br><span class="line">                        cur = (LL) cur * pw[p][t - mx1[p]] % Mod, mx3[p] = mx2[p], mx2[p] = mx1[p], mx1[p] = t;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; mx2[p]) mx3[p] = mx2[p], mx2[p] = t;</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">chkmax</span>(mx3[p], t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">auto</span> bac = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">                <span class="keyword">int</span> p, t;</span><br><span class="line">                <span class="keyword">while</span> (x ^ <span class="number">1</span>) &#123;</span><br><span class="line">                    p = fac[x].<span class="built_in">front</span>(), t = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> (x % p == <span class="number">0</span>) t ++, x /= p;</span><br><span class="line">                    <span class="keyword">if</span> (havbac[p])</span><br><span class="line">                        havbac[p] = <span class="literal">false</span>, mx1[p] = bac1[p], mx2[p] = bac2[p], mx3[p] = bac3[p];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">del</span>(c1), <span class="built_in">del</span>(c2), <span class="built_in">ins</span>(c1 + c2);</span><br><span class="line">            <span class="built_in">bac</span>(c1), <span class="built_in">bac</span>(c2), <span class="built_in">bac</span>(c1 + c2);</span><br><span class="line">            <span class="comment">// printf(&quot;%d %d %d&quot;, c1, c2, cur);</span></span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) res = (res + (LL) cur * cnt[c1] % Mod * (cnt[c1] - <span class="number">1</span>) % Mod * c1 % Mod * c1) % Mod;</span><br><span class="line">            <span class="keyword">else</span> res = (res + (LL) cur * cnt[c1] % Mod * cnt[c2] % Mod * c1 % Mod * c2) % Mod;</span><br><span class="line">            <span class="comment">// printf(&quot; : %d\n&quot;, res);</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有趣的数论题目，似乎说不上用了什么高级知识。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>ZJOI2022 树</title>
    <link href="https://mydcwfy.github.io/2022/05/10/ZJOI2022-D1T1/"/>
    <id>https://mydcwfy.github.io/2022/05/10/ZJOI2022-D1T1/</id>
    <published>2022-05-10T00:07:56.000Z</published>
    <updated>2022-05-20T11:55:20.672Z</updated>
    
    <content type="html"><![CDATA[<p>经典的数数题，实在是做不来。</p><span id="more"></span><p><a href="https://loj.ac/p/3706">题目传送门 LOJ</a></p><p>题意：构造两棵有根树，第一棵树 $i$ 的父亲在 $[1, i - 1]$，第二棵树 $i$ 的父亲在 $[i + 1, n]$。问有多少种方案使得 $\forall i\in [1, n]$，第一棵树和第二棵树有且只有一个满足 $i$ 是叶子。$n\leq 500$，需要输出所有 $n\in [2, lim]$ 的答案对 $P$ 取模的结果，$lim, P$ 输入给定。</p><p><strong>有且只有明显在提示容斥</strong>。</p><p>容易发现我们限制一个节点是叶子是容易的，直接记录前面都有多少非叶子即可转移，于是可以得到状态 $f(i, x, y)$ 表示处理到 $i$，$[1, i]$ 第一棵树有 $x$ 个非叶子，$[i, n]$ 有 $y$ 个非叶子。主要是限制非叶子比较麻烦。</p><p>考虑容斥，假设我们选定的 $i$ 在第一棵树中是叶子，那么他在第二棵树中出现必须是非叶子。但是注意，我们不好限制非叶子。于是考虑容斥，虽然他是非叶子，我们考虑强制选择一个集合，使得集合内部的变为叶子，剩余的就不再需要考虑非叶子的问题了。这样容斥只需要是叶子容斥时系数乘 -1 即可，并且两边的容斥可以一起写。</p><p>边界状态就是开始的时候 $f(1, 1, i) = i$，统计答案就是 $\sum f(i, x, 1) \times x$。理解了写起来很简单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x) ans = (ans + (LL) f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][x][<span class="number">1</span>] * x) % Mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; ++ y) f[i &amp; <span class="number">1</span>][x][y] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; ++ y) &#123;</span><br><span class="line"><span class="keyword">if</span> (!f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][x][y]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">adj</span>(f[i &amp; <span class="number">1</span>][x][y] -= (LL) f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][x][y] * x % Mod * y % Mod * <span class="number">2</span> % Mod),</span><br><span class="line">f[i &amp; <span class="number">1</span>][x][y - <span class="number">1</span>] = (f[i &amp; <span class="number">1</span>][x][y - <span class="number">1</span>] + (LL) f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][x][y] * x % Mod * (y - <span class="number">1</span>)) % Mod;</span><br><span class="line">f[i &amp; <span class="number">1</span>][x + <span class="number">1</span>][y] = (f[i &amp; <span class="number">1</span>][x + <span class="number">1</span>][y] + (LL) f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][x][y] * x % Mod * y) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典的数数题，实在是做不来。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>ZJOI2022 众数</title>
    <link href="https://mydcwfy.github.io/2022/05/10/ZJOI2022-D1T2/"/>
    <id>https://mydcwfy.github.io/2022/05/10/ZJOI2022-D1T2/</id>
    <published>2022-05-09T23:48:49.000Z</published>
    <updated>2022-05-10T00:06:40.974Z</updated>
    
    <content type="html"><![CDATA[<p>非常厉害的 分块 / 平衡规划 题目，不卡常，码量小，比较有趣。</p><span id="more"></span><p><a href="https://loj.ac/p/3707">题目传送门 LOJ</a></p><p>题意：给定序列 $a$，可以任选一个区间加一个数，问最后众数个数的最大值和可能的众数。$n\leq 2\times 10 ^ 5, \sum n\leq 5\times 10 ^ 5$，3s。</p><p>首先相当于是选一个区间使得内外众数个数和最大。</p><p>设 $\text{occ}(i)$ 表示 $i$ 出现的次数，我们就是要利用好 $\sum \text{occ}(i) = n$ 的性质。</p><p>首先，如果我们确定的内部或者是外部的颜色，我们可以在线性时间内求出最大答案。具体的，比如我们已经确定的外部的颜色，我们再枚举内部颜色。容易发现我们一定两边都是这个颜色时最优，否则我们可以缩短使得刚好两边都是这个颜色。容易发现可以转化成前缀和，我们用前缀最大值更新当前右端点的答案，可以做到 $\text{occ}(i)$，所以确定了一个颜色后，可以在 $O(n)$ 时间得到。</p><p>但是不能每个颜色都扫一边，我们可以考虑平衡规划，将 $\text{occ}(i) &gt; B$ 的颜色用这个方法做，前面的复杂度为 $O(\dfrac {n ^ 2}B)$。剩下的都是 $\text{occ}(i)\leq B$ 的颜色了。</p><p>我们还是得枚举外部颜色，容易发现现在内部的众数答案一定 $\leq B$，我们可以考虑确定左端点时，暴力将 $ans\in [1, B]$ 时满足条件的最小的右端点全部统计一遍，这样就可以做到 $O(\text{occ}(i)B)$ 的复杂度。</p><p>将所有的全部扫一遍，于是总复杂度 $O(nB)$，与上一个平衡规划一下，复杂度就是 $O(n\sqrt n)$，不算卡常。</p><p>注意有一些实现细节，比如可能外部颜色只出现在左边，右边没有可能导致统计漏。可以自己手搓一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solvebig</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        cnt[i] = cnt[i - <span class="number">1</span>] + (a[i] == col);</span><br><span class="line">    <span class="keyword">int</span> tres = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> ed = app[i].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ed; ++ j)</span><br><span class="line">            pre[j] = cnt[app[i][j] - <span class="number">1</span>] - j + <span class="number">1</span>, suf[j] = cnt[n] - cnt[app[i][j]] + j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; ed; ++ j) <span class="built_in">chkmax</span>(pre[j], pre[j - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = ed - <span class="number">2</span>; ~j; -- j) <span class="built_in">chkmax</span>(suf[j], suf[j + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ed; ++ j) <span class="built_in">chkmax</span>(tres, pre[j] + suf[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;Big Col %d %d\n&quot;, col, tres);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">chkmax</span>(res, tres)) ans.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span> (res == tres) ans.<span class="built_in">push_back</span>(col);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> ed = app[i].<span class="built_in">size</span>(), tres = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ed; ++ j)</span><br><span class="line">            pre[j] = j - cnt[app[i][j]] + <span class="number">1</span>, suf[j] = cnt[app[i][j] - <span class="number">1</span>] + ed - j;</span><br><span class="line">        <span class="built_in">chkmax</span>(pre[<span class="number">0</span>], <span class="number">0</span>), <span class="built_in">chkmax</span>(suf[ed - <span class="number">1</span>], cnt[n]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; ed; ++ j) <span class="built_in">chkmax</span>(pre[j], pre[j - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = ed - <span class="number">2</span>; ~j; -- j) <span class="built_in">chkmax</span>(suf[j], suf[j + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ed - <span class="number">1</span>; ++ j) <span class="built_in">chkmax</span>(tres, pre[j] + suf[j + <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// printf(&quot;Col2 %d %d %d\n&quot;, i, col, tres);</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">chkmax</span>(res, tres)) ans.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span> (res == tres) ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solvesmall</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;ap = app[col];</span><br><span class="line">    app[col].<span class="built_in">insert</span>(app[col].<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ed = ap.<span class="built_in">size</span>(), tres = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, cur; j &lt; ed; ++ j) &#123;</span><br><span class="line">        cur = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> del = <span class="number">1</span>; del &lt;= lim; ++ del) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mx[ap[j] + <span class="number">1</span>][del] &gt; n + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur &lt; ed &amp;&amp; ap[cur] &lt;= mx[ap[j] + <span class="number">1</span>][del]) cur ++;</span><br><span class="line">            <span class="built_in">chkmax</span>(tres, ed - cur + j + del);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    app[col].<span class="built_in">erase</span>(app[col].<span class="built_in">begin</span>());</span><br><span class="line">    <span class="comment">// printf(&quot;Res : %d %d\n&quot;, col, tres);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">chkmax</span>(res, tres)) ans.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span> (res == tres) ans.<span class="built_in">push_back</span>(col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    lim = std::<span class="built_in">max</span>(std::<span class="built_in">sqrt</span>(n) + <span class="number">1</span>, <span class="number">1.</span>), res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) app[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">ws</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) ws[i] = a[i + <span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">sort</span>(ws.<span class="built_in">begin</span>(), ws.<span class="built_in">end</span>());</span><br><span class="line">    ws.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(ws.<span class="built_in">begin</span>(), ws.<span class="built_in">end</span>()), ws.<span class="built_in">end</span>());</span><br><span class="line">    sz = ws.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        a[i] = std::<span class="built_in">lower_bound</span>(ws.<span class="built_in">begin</span>(), ws.<span class="built_in">end</span>(), a[i]) - ws.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">    std::cerr &lt;&lt; a[n - <span class="number">6</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) app[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lim; ++ j) mx[i][j] = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int</span>) app[i].<span class="built_in">size</span>() &gt; lim) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> ed = app[i].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ed; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> del = <span class="number">1</span>; del &lt;= lim &amp;&amp; j + del &lt;= ed; ++ del)</span><br><span class="line">                <span class="built_in">chkmin</span>(mx[app[i][j]][del], app[i][j + del - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i; -- i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lim; ++ j) <span class="built_in">chkmin</span>(mx[i][j], mx[i + <span class="number">1</span>][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; ++ i)</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int</span>) app[i].<span class="built_in">size</span>() &gt; lim) <span class="built_in">solvebig</span>(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">solvesmall</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    std::<span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    ans.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>()), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : ans) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ws[x - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;非常厉害的 分块 / 平衡规划 题目，不卡常，码量小，比较有趣。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分块" scheme="https://mydcwfy.github.io/tags/%E5%88%86%E5%9D%97/"/>
    
    <category term="平衡规划" scheme="https://mydcwfy.github.io/tags/%E5%B9%B3%E8%A1%A1%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>2022 联合省选半退役记</title>
    <link href="https://mydcwfy.github.io/2022/04/22/2022-provincal-team-select-competition/"/>
    <id>https://mydcwfy.github.io/2022/04/22/2022-provincal-team-select-competition/</id>
    <published>2022-04-22T10:25:14.000Z</published>
    <updated>2022-05-02T08:18:38.790Z</updated>
    
    <content type="html"><![CDATA[<p>打的很臭，暂且是以一种轻松的心态写这篇游记吧。</p><span id="more"></span><h2 id="Day"><a href="#Day" class="headerlink" title="Day -?"></a>Day -?</h2><p>感觉状态总是不好，感觉赛后觉得比较套路 / 简单的题目赛时因为各种原因没有做出来，感觉要寄。</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>复习了比较多的模板，还在结束前绝杀了一道题，心态不错。但结局是一个都没有考到。不过和一些外校高我们一级的学生聊了一会。</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>8：00 左右就进了考场，本身想码一些模板的，结果被监考员警告了（</p><p>8：30 才能看到题目，14 页的题目，厉害。</p><p>T1 读懂题后发现是一个模拟（省选也有这题？），T2 是一个神仙的树形 DP，T3 神秘图论，题面过长，没怎么读懂。</p><p>先写 T1，本着好写的原则（？）用 <code>std::map&lt;std::string, std::pair&lt;std::string, bool&gt;&gt;</code> 没管复杂度直接写了。而且没注意空格之类的问题（flag）。</p><p>T2 一看肯定和容斥和树形 DP 相关，猜两个没有关键点之间是一个 1 次多项式，写了很久，发现没对。但是如果把所有的权值加进去就是对的，想了想，显然不是 1 次多项式，但是没想到是 $n$ / $n + 1$ 次多项式。想到了 $O(nK)$ 但是没写（？）。</p><p>T3 不可做题，一眼看 8 pts 状压，20 pts 白送，28 pts 到手。</p><p>检查了一下所有的代码问题，慢悠悠的结束了。估计 $100 + 20 + 28 = 148$，看样子是大众分。</p><p>出来感觉大家考得都不怎么好，不太多的人做出来了 T2。似乎 D1 没什么差距。</p><p>下午、晚上懒得复习，看了一部电影、足球比赛、篮球比赛（？）。听说 T1 有空串问题，我直接是先读入第一个字符串 <code>std::cin &gt;&gt; cur</code>，显然有锅。Luogu 上直接 0 pts，不过管他的，Day 2 才是拉差距的关键。</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>学懂了，8：30 才开始看题。</p><p>T1 一眼是一个 NOI 哪年的题（赛后发现是寿司晚宴），T2 神秘 <code>bracket</code> 直接跳过（谁叫我没认真听 WC 讲课？），T3 一眼 CSP2019 D1T3。决定顺序开题。</p><p>T1 结果想了好久没想到根号，一直想怎么容斥，结果都是 $2 ^ c$ 有关（$c$ 是质数个数），9：20 才发现是根号，大力胡了一个 DP，估计 65 pts。开始写，结果不记得那个题怎么写了，随便写了一个 $2 ^ {14} \times 2000$ 单次的做法。一跑大样例，发现直接过了。</p><p>这时 10：30，赶快去看 T2，推了一会，毫无收获，马上去看 T3。</p><p>T3 先写了 12 pts，想了一想，可以大力 $O(n ^ 5)$，按照树形背包的复杂度分析可以到 $O(n ^ 4)$，中间有 6 种情况，似乎很难写。有想了一会，发现两次用最大值更新可以去掉一些不必要的状态，可以做到 $O(n ^ 3)$。</p><p>赶忙开始写，此时已经 11：25 了。没有精力去认真调该题，虽然说是没有放弃，但是看着 35 行左右的转移方程，还是无能为力，还是交了个 $O(n!)$ 的代码。</p><p>预估分数：$65 + 0 + 12 = 77$。</p><h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><p>突然说 18：00 出成绩，先发下来数据。一测发现 D1T1 100 pts，但是 D2T1 挂成了 40 pts，发现原因是把含有大质数的直接当 01 背包处理了（似乎我写寿司晚宴就犯了这个错误），一改，直接 85 pts。发现最后的容斥似乎比较好想，不过我没时间了。T3 写出 44 pts 的人似乎不多，多数人是 12 pts，也有一些是 28 pts。</p><p>出成绩发现 D1T1 又挂了 10 pts，开头加一个空格是什么东西？</p><p>总分：$90 + 20 + 28 + 40 + 0 + 12 = 190$，暴力分都没有完全打满，整场比赛的分数没有一点亮点。</p><p>据说会在队线附近，比较紧张。被抓回去学了几天 whk。（暴力分也能进队？</p><p>UPD：居然踩线进队了。</p><h2 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h2><p>上午正准备月考，结果来了个“踩线进队”的消息，真是吃惊不小。幸好 NOIP T3 随机化骗了 96 pts，把我送进去了。不过这个消息显然对月考一点都不友好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然说是侥幸踩线了，不过暴露出了不少问题，借这里也写一下吧。</p><h3 id="1）挂分导致心态波折"><a href="#1）挂分导致心态波折" class="headerlink" title="1）挂分导致心态波折"></a>1）挂分导致心态波折</h3><p>明明可以写出 D1T1，D2T1（85 pts），结果却因为自己平时训练的时候没有注意这些细节，导致丢掉该得的分数。平常写代码遇到问题时，没有仔细理解就放过去了，这导致在考场写代码时也会出现同样的问题。</p><h3 id="2）时间安排不当导致没有时间"><a href="#2）时间安排不当导致没有时间" class="headerlink" title="2）时间安排不当导致没有时间"></a>2）时间安排不当导致没有时间</h3><p>D1T2 有精力可以做出 40 pts，结果总以为自己可以得到更高的分数，导致最后一点也没有得到。D2T1、D2T3 纷纷因为我在 D2T3 的难写 $O(n ^ 3)$ 上死磕，结果没有时间。如果先写了 $O(n ^ 4)$ 的朴素 DP，至少也有 28 pts 了。在平常考试时，应更加注意时间的合理分配。</p><p>不管怎样，还是奔赴下一站吧。NOI2022，相会！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;打的很臭，暂且是以一种轻松的心态写这篇游记吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="游记" scheme="https://mydcwfy.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF1119H Ex</title>
    <link href="https://mydcwfy.github.io/2022/04/11/CF1119H/"/>
    <id>https://mydcwfy.github.io/2022/04/11/CF1119H/</id>
    <published>2022-04-11T08:08:52.000Z</published>
    <updated>2022-04-11T13:58:17.279Z</updated>
    
    <content type="html"><![CDATA[<p>神仙的集合幂级数应用。</p><span id="more"></span><p>题意：有 $n$ 个物品，每个物品存在 $m$ 种子物品，权值为 $a_{i, j}$，每个子物品个数为 $w_j$。从每种物品中选择一个子物品，定义总权值为权值的异或和。求最后每种权值有多少种选法。满足 $a_{i, j} &lt; 2 ^ k$，$m$ 较小。CF 原题满足 $m = 3, k = 17,n\leq 2 ^ {17}$，对 998244353 取模。</p><p>考虑朴素的 FWT 卷积，先对每一个物品 FWT 一下，然后逐位乘起来，最后 FWT 逆变换回来，时间复杂度显然为 $O(nk2 ^ k)$，显然过不去。</p><p>发现有一个特殊的性质：每一个的个数都是 $w_{1, 2, \dots, m}$，有限的组合一定只有 $2 ^ m$ 种。而 $m$ 较小，我们或许可以从这里入手。</p><p>考虑每一个物品的 $p$ 位是什么，记录状态 $s$ 有 $m$ 位，他对应的权值为 $\sum_{i = 0} ^ {m - 1} (-1) ^ {i\in s} w_i$。我们可以对于每一位 $p$，求出 $n$ 个物品中，$s = 0, 1, \dots, 2 ^ m - 1$ 分别有多少种，快速幂求能求出每一位最后的权值，逆变换即可。我们针对 $p$ 这一位进行讨论。</p><p>现在我们考虑计算 $c_{0, 1, \dots, 2 ^ m - 1}$，这显然需要我们寻找 $2 ^ m$ 个方程来计算。哪里有 $2 ^ m$ 个方程呢？我们考虑对于任意 $T\subseteq \{1, 2, \dots, m\}$，计算<strong>只有权值为 $\sum_{i = 1} ^ n val_i = \oplus_{j\in T}a_{i, j}$ FWT 之后的结果</strong>。</p><p>考虑 FWT 的计算过程，即为 $f’(p) = \sum_{i = 0} ^ {2 ^ n - 1}f(i)(-1) ^ {i\odot p}$。这样拆开看，首先，如果 $\mid T\mid = 1$，显然 $f’(p)$ 就是唯一的一个 $w_j$ 乘上一个 1 或者 -1 的系数。否则，我们将每一个 $val_i$ 贡献到 $p$ 上，系数就是 $(-1) ^ {val_i\odot p}$。而整个需要再乘上 $\sum_{j\in T}w_j$，因为开始我们计算的时候没有带上这个权值。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;神仙的集合幂级数应用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="集合幂级数" scheme="https://mydcwfy.github.io/tags/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="数学" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>集合幂级数浅谈</title>
    <link href="https://mydcwfy.github.io/2022/04/09/set-power-series/"/>
    <id>https://mydcwfy.github.io/2022/04/09/set-power-series/</id>
    <published>2022-04-09T08:09:16.000Z</published>
    <updated>2022-04-11T07:49:58.446Z</updated>
    
    <content type="html"><![CDATA[<p>有点重要的知识点，不记得省选考不考了。</p><span id="more"></span><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>一个长度为 $2 ^ n$ 的序列，有一个生成函数为 $F(x) = \sum_{i = 0} ^ {2 ^ n - 1}f(i) x ^ i$，这个生成函数就叫<strong>集合幂级数</strong>。</p><p>为什么叫集合幂级数呢？是因为我们可以把 $i$ 看作一个 $\{0, 1, \cdots, n - 1\}$ 的子集并状态压缩。</p><p>定义以下几个计算：</p><ol><li>或卷积：$c(i) = \sum_{j \mid k = i}a(j)b(k)$。</li><li>与卷积：$c(i) = \sum_{j\odot k = i}a(j)b(k)$。</li><li>异或卷积：$c(i) = \sum_{j\oplus k = i}a(j)b(k)$。</li><li>子集卷积：$c(i) = \sum_{j\odot k = 0, j \mid k = i}b(j)c(k)$。</li></ol><p>还有一些奇怪的科技，如子集 ln，子集 exp，这里先鸽了。</p><p>这些东西如果是暴力计算的话，显然是 $O(4 ^ n)$ 的，我们考虑有没有更优的做法。</p><h2 id="2-FMT-FWT"><a href="#2-FMT-FWT" class="headerlink" title="2. FMT / FWT"></a>2. FMT / FWT</h2><h3 id="1）FMT"><a href="#1）FMT" class="headerlink" title="1）FMT"></a>1）FMT</h3><p>定义高维前缀和为：$b(i) = \sum_{j\subseteq i}a(j)$。容易发现暴力做是 $O(3 ^ n)$ 的。</p><p>为什么叫高位前缀和呢？因为他相当于是 $n$ 维数组做前缀和，每维只有 01 两种。（<del>所以好像就有了 $k$ 进制下的高维前缀和</del>）</p><p>考虑如果只有 2 维，怎么做呢？</p><p>显然枚举每一维，再对该维前缀和，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++ j) a[i][j] += a[i][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) a[i][j] += a[i - <span class="number">1</span>][j];</span><br></pre></td></tr></table></figure><p>显然是枚举了两维，虽然和平常写法不同，但是如果手玩一下发现是对的。</p><p>扩展到 $n$ 维，我们就可以得到一个简短的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); ++ j)</span><br><span class="line">        <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) a[j] += a[j ^ (<span class="number">1</span> &lt;&lt; i)];</span><br></pre></td></tr></table></figure><p>这个代码显然是 $O(n2 ^ n)$ 的。</p><p>同理，我们也可以得到高位后缀和的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); ++ j)</span><br><span class="line">        <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) a[j ^ (<span class="number">1</span> &lt;&lt; i)] += a[j];</span><br></pre></td></tr></table></figure><p>高维前缀和和高维后缀和统称为<strong>快速莫比乌斯变换</strong>，简写为 FMT。</p><h3 id="2）FWT"><a href="#2）FWT" class="headerlink" title="2）FWT"></a>2）FWT</h3><p>定义 $\displaystyle \text{FWT}(A) = \sum_{i = 0} ^ {2 ^ n - 1}x ^ i\sum_{j = 0} ^ {2 ^ n - 1}(-1) ^ {|i\odot j|}[x ^ j]A(x)$，这个东西就叫<strong>快速沃尔什变换</strong>，简写为 FWT。显然暴力计算是 $O(4 ^ n)$ 的。</p><p>类似于 FMT，我们逐维考虑。枚举每一维 $i$，假设我们枚举到 $j$ 不包含 $i$ 这一维。那么对于不包含 $i$ 的 $j$，显然会将两个都加起来，因为自己是 0，不管与谁都是 0，即 $a_j := a_j + a_{j\mid 2^i}, $，而包含 $i$ 的 $j\mid2^i$ 就不同了，如果是 $a_{j\mid 2 ^ i}$，显然贡献到 $a_{j\mid 2 ^ i}$ 就是 -1 了，即 $a_{j\mid2 ^ i}:= a_j - a_{j\mid 2 ^ i}$。</p><p>我们也可以写出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); ++ j)</span><br><span class="line">        <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = a[j], y = a[j | (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">            a[j] = x + y, a[j | (<span class="number">1</span> &lt;&lt; i)] = x - y;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>我们还可以写出另一份代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bit, tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++ j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = a[i + j], y = a[i + j + mid];</span><br><span class="line">            a[i + j] = x + y, a[i + j + mid] = x - y;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>发现和 NTT 其实是很像的。其实集合幂级数和多项式是有很多相似点的，我们这里才刚刚看到。</p><p>显然，时间复杂度为 $O(n2 ^ n)$。</p><h2 id="3-实现卷积"><a href="#3-实现卷积" class="headerlink" title="3. 实现卷积"></a>3. 实现卷积</h2><h3 id="1）与卷积"><a href="#1）与卷积" class="headerlink" title="1）与卷积"></a>1）与卷积</h3><p>考虑证明假设 $C(x) = \sum_{i = 0} ^ {2 ^ n - 1}x ^ i \sum_{j\odot k = i} [x ^ j]A(x) * [x ^ k]B(x)$，那么对 $A, B, C$ 高位前缀和后，$C(x) = \sum_{i = 0} ^ {2 ^ n - 1}x ^ i[x ^ i]A(x) * [x ^ i]B(x)$。</p><p>考虑每一对 $j, k$，最后 $j, k$ 一定会贡献到 $j\odot k$ 的所有子集，即 $\forall x\subseteq (j\odot k)$。而 $C$ 贡献显然也是 $\forall x\subseteq i$，这和前面的贡献是相同的。</p><p>于是我们先对 $A, B$ 高位前缀和，乘起来，再做高位前缀和的逆变换就可以得到 $C$ 了。</p><p>逆变换就将加号变为减号即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); ++ j)</span><br><span class="line">        <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) a[j] -= a[j ^ (<span class="number">1</span> &lt;&lt; i)];</span><br></pre></td></tr></table></figure><h3 id="2）与卷积"><a href="#2）与卷积" class="headerlink" title="2）与卷积"></a>2）与卷积</h3><p>考虑类似于或卷积的方法，这里不再赘述，证明留给读者。</p><h3 id="3）异或卷积"><a href="#3）异或卷积" class="headerlink" title="3）异或卷积"></a>3）异或卷积</h3><p>前面已经定义了 $FWT(A)$，类似于 FMT，我们证明 $FWT(C) = FWT(A) * FWT(b)$。</p><p>还是考虑 $i, j, p$ 的贡献，$i\to p$ 的贡献显然是 $a(i)(-1) ^ {\mid p\odot i\mid }$，$j\to p$ 的贡献显然是 $b(j)(-1) ^ {\mid p\odot j\mid }$。</p><p>考虑 $i\oplus j$ 对 $p$ 的贡献，显然是 $(-1) ^ {(i\oplus j)\odot p}$。所以我们考虑证明 $(-1) ^ {\mid (i\oplus j)\odot p\mid } = (-1) ^ {\mid i\odot p\mid }(-1) ^ {\mid j\odot p\mid }$。</p><p>容易发现 $p$ 的限制就是将 $i, j$ 中 $p$ 该位为 1 的位拿出来，其余的不管，我们可以先对 $i$ 赋值为 $i\odot p$，$j$ 同理，显然最后的答案左边就是 $(-1) ^ {\mid i\oplus j\mid}$，容易发现就是 $i$ 的 1 个数和 $j$ 的 1 个数相加。左右显然相等。</p><p>逆变换还是将操作反过来即可。这里给出一种实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++ j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = a[i + j], y = a[i + j + mid];</span><br><span class="line">            a[i + j] = (x + y) &gt;&gt; <span class="number">1</span>, a[i + j + mid] = (x - y) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>另外，可以像 NTT 一样实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++ j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = a[i + j], y = a[i + j + mid];</span><br><span class="line">            a[i + j] = x + y, a[i + j + mid] = x - y;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] &gt;&gt;= n;</span><br></pre></td></tr></table></figure><h3 id="4）子集卷积"><a href="#4）子集卷积" class="headerlink" title="4）子集卷积"></a>4）子集卷积</h3><p>先不考虑 $j\odot k = 0$ 的情况，容易发现这就是一个简单的或卷积。但是这个条件似乎不好处理。</p><p>发现当 $j, k\to j| k$ 是有贡献的，当且仅当 $\mid j\mid + \mid k\mid = \mid j|k\mid$，也就是说，我们限制的集合的大小。这启示我们按照集合大小分类。</p><p>我们考虑计算集合大小分别为 $a$ 和 $b$ 的或卷积，贡献到集合大小为 $a + b$ 的位置上。这样暴力做是 $O(n ^ 3 2 ^ n)$ 的，但是发现中间对 $a, b$ 的或卷积是由重复的，我们可以先将 $a = 0, \dots n - 1, b = 0, \dots n - 1$ 的高维前缀和后，再批量贡献到 $a + b$，再将 $a + b = 0, \dots, n - 1$ 的高维前缀和逆变换。容易发现时间复杂度是 $O(n ^ 2 2 ^ n)$ 的。代码在后面的例题。</p><h2 id="4-例题"><a href="#4-例题" class="headerlink" title="4. 例题"></a>4. 例题</h2><h3 id="T1：模板"><a href="#T1：模板" class="headerlink" title="T1：模板"></a>T1：模板</h3><p><a href="https://www.luogu.com.cn/problem/P4717">FMT / FWT 模板</a></p><p><a href="https://www.luogu.com.cn/problem/P6097">子集卷积模板 lg</a>，<a href="https://loj.ac/p/152">子集卷积模板 LOJ</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">base_or</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; ++ j)</span><br><span class="line"><span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) (a[j] += a[j ^ (<span class="number">1</span> &lt;&lt; i)] * inv) %= Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; ++ j) a[j] = (a[j] + Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_or</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(a, A, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * tot), <span class="built_in">memcpy</span>(b, B, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * tot);</span><br><span class="line"><span class="built_in">base_or</span>(a, <span class="number">1</span>), <span class="built_in">base_or</span>(b, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = (LL)a[i] * b[i] % Mod;</span><br><span class="line"><span class="built_in">base_or</span>(c, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, c[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">base_and</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = tot - <span class="number">1</span>; j; -- j)</span><br><span class="line"><span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) (a[j ^ (<span class="number">1</span> &lt;&lt; i)] += a[j] * inv) %= Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; ++ j) a[j] = (a[j] + Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_and</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(a, A, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * tot), <span class="built_in">memcpy</span>(b, B, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * tot);</span><br><span class="line"><span class="built_in">base_and</span>(a, <span class="number">1</span>), <span class="built_in">base_and</span>(b, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = (LL)a[i] * b[i] % Mod;</span><br><span class="line"><span class="built_in">base_and</span>(c, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, c[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">base_xor</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (inv == <span class="number">-1</span>) inv = inv2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; ++ j) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">LL x = a[j], y = a[j | (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">a[j] = (x + y) % Mod * inv % Mod;</span><br><span class="line">a[j | (<span class="number">1</span> &lt;&lt; i)] = (x - y + Mod) % Mod * inv % Mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_xor</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(a, A, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * tot), <span class="built_in">memcpy</span>(b, B, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * tot);</span><br><span class="line"><span class="built_in">base_xor</span>(a, <span class="number">1</span>), <span class="built_in">base_xor</span>(b, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = (LL)a[i] * b[i] % Mod;</span><br><span class="line"><span class="built_in">base_xor</span>(c, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, c[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++ i) <span class="built_in">FWT</span>(a[i], bit, <span class="number">1</span>), <span class="built_in">FWT</span>(b[i], bit, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bit - i; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; bit); ++ k)</span><br><span class="line">c[i + j][k] = (c[i + j][k] + (LL)a[i][k] * b[j][k]) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++ i) <span class="built_in">FWT</span>(c[i], bit, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T2：Sum-the-Fibonacci"><a href="#T2：Sum-the-Fibonacci" class="headerlink" title="T2：Sum the Fibonacci"></a>T2：Sum the Fibonacci</h3><p><a href="https://codeforces.com/problemset/problem/914/G">题目传送门 Codeforces</a></p><p>也是模板，请读者自行实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有点重要的知识点，不记得省选考不考了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="集合幂级数" scheme="https://mydcwfy.github.io/tags/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"/>
    
    <category term="数学" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
