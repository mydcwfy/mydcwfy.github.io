<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mydcwfy&#39;s Blog</title>
  
  
  <link href="https://mydcwfy.github.io/atom.xml" rel="self"/>
  
  <link href="https://mydcwfy.github.io/"/>
  <updated>2022-05-11T12:04:47.645Z</updated>
  <id>https://mydcwfy.github.io/</id>
  
  <author>
    <name>mydcwfy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CF Round#788</title>
    <link href="https://mydcwfy.github.io/2022/05/11/CF-Round-788/"/>
    <id>https://mydcwfy.github.io/2022/05/11/CF-Round-788/</id>
    <published>2022-05-11T11:16:04.000Z</published>
    <updated>2022-05-11T12:04:47.645Z</updated>
    
    <content type="html"><![CDATA[<p>vp Div2 差点把构造题想出来了，结果以为自己是错的（</p><p>赛时进度：ABCD Accpeted，Score：4091，Rank：923，Rating 无变化。</p><p>改题进度：All Accepted。</p><span id="more"></span><p><a href="https://codeforces.com/contest/1670/">比赛传送门</a></p><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定一个序列，问能否通过交换符号的方式使序列有序。没有 0。</p><p>容易发现负号一定在前面，随便判一下即可。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定一个字符串和一些关键字符，一次删除是将关键字符前面的字符删去，问有用的删除有多少次。</p><p>卡了比较久，写出来了，结果还被卡常了（（（</p><p>首先相当于是一个序列，每次所有数减 1，小于 0 的数删去，能减多少次。开头的可能不同，特判一下。证明即考虑每一段关键字符之间的段即可。</p><p>答案显然是 $\max a$ 再加 1，注意 +1 是前面的关键字符被删了，所以如果是开头就不能加 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%s%d&quot;</span>, &amp;n, str + <span class="number">1</span>, &amp;cnt);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i) sp[<span class="string">&#x27;a&#x27;</span> + i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tmp);</span><br><span class="line">sp[tmp[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, ls = <span class="number">0</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!sp[str[i]]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">chkmax</span>(mx, i - ls - <span class="number">1</span> + !!ls), ls = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定两个排列 $a, b$，构造序列 $c$ 使得 $c_i\in\{a_i, b_i\}$ 且 $c$ 是排列的方案数有多少。部分 $c_i$ 给定，保证有解。</p><p>容易发现如果某一个没有选 $a_i$，那么 $b_j = a_i$ 的位置就得选 $b$，这样 $a_j$ 有没有选，这样就会轮下去，形成一个置换环。容易发现一个置换环只有两种选法。</p><p>题目保证有解，那么 $c_i$ 覆盖了的置换环有且仅有一种情况。计算有多少置换环没有被覆盖即可。注意长度为 1 的置换环贡献一定为 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, b + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) nw[a[i]] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) bel[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (bel[i] || a[i] == b[i]) <span class="keyword">continue</span>;</span><br><span class="line">++ cnt;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (!bel[j]) bel[j] = cnt, j = nw[b[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) usd[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="keyword">if</span> (x) usd[bel[i]] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> und = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) und += !usd[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pw2[und]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意不好描述，看原题面吧。</p><p>主要是题意转化比较麻烦。</p><p>如果我们将一个正六边形看作是一个点的话，那么相当于是三个方向的直线交点的个数（三线相交算 3 个交点），那么假设三个方向的直线分别是 $a, b, c$，那么答案就是 $ab + bc + ac$。</p><p>如果总条数已经确定，那么答案就是将 $a, b, c$ 尽量平均即可。随便二分即可。</p><p>代码和题解略有不同，代码中是二分的 $\min\{a, b, c\}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">std::cin &gt;&gt; n, n = (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">calc</span>(mid, mid, mid) &lt;= n) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">calc</span>(l, l, l) == n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">3</span> * l);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">calc</span>(l, l, l + <span class="number">1</span>) &gt;= n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">3</span> * l + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">calc</span>(l, l + <span class="number">1</span>, l + <span class="number">1</span>) &gt;= n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">3</span> * l + <span class="number">2</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">3</span> * l + <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：给定 $n = 2 ^ p$ 的树，要求给每个点 / 边设置权值，恰好覆盖 $0\sim 2 ^ {p + 1} - 1$ 的数，并选定根，使得每个点 / 边的前缀异或最大值最小。</p><p>本身想到了，结果以为菊花图将其卡掉，没认真想。</p><p>首先，观察样例可得答案应该为 $2 ^ p$，想一想为什么。</p><p>首先证明 $ans\geq 2 ^ {p}$，因为有一个 $\geq 2 ^ p$ 的数，如果答案都 $&lt; 2 ^ p$，那么 $\oplus 2 ^ p$ 一定就 $\geq 2 ^ p$，与假设矛盾。</p><p>答案应该就是 $2 ^ {p}$，考虑构造。首先选择根是假的，任选都可以。</p><p>先将根设为 $2 ^ p$，然后每个节点假设父亲前缀异或是 $2 ^ p$，那么边就是 $x + 2 ^ p$，点的权值就是 $x$，这样该点的前缀异或也是 $2 ^ p$，可以递归下去。</p><p>所以这样答案就是 $2 ^ p$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> ex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (e[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">++ tot;</span><br><span class="line">w[i] = w[i ^ <span class="number">1</span>] = tot ^ (ex * n), val[e[i]] = tot ^ (!ex * n);</span><br><span class="line"><span class="built_in">dfs</span>(e[i], x, !ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n, n = <span class="number">1</span> &lt;&lt; n, tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) h[i] = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++ i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line"><span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">&#125;</span><br><span class="line">val[<span class="number">1</span>] = n, <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, val[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idx; i += <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, w[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：给定 $n, l, r, z$，求满足条件的 $a$ 序列使得 $\sum_{i = 1} ^ na_i\in [l, r], \oplus_{i = 1} ^ n a_i = z$。对 $10 ^ 9 + 7$ 取模。$n\leq 1000, l, r, z\leq 10 ^ {18}$。</p><p>一看显然的数位 DP，不过做法复杂了，赛时没写出来。</p><p>显然差分一下，只有上界。</p><p>记录 $f(bit, x)$ 表示处理到 $bit$ 位，最多可以放 $x$ 个 1。最后从 $f(61, 0)$ 开始最后到 $f(-1, *)$ 的方案数（因为 0 位考虑后答案放在 -1 了）。限制可以从上一位传下来，也可以通过这一位 $lim$ 为 1 得到。</p><p>直接转移即可，注意 <code>chkmin(x, n)</code>，因为 $x = n$ 后面相当于不限制了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(LL lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">f[<span class="number">62</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">61</span>; ~i; -- i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= n; ++ s)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> trs = z &gt;&gt; i &amp; <span class="number">1</span>, ed = std::<span class="built_in">min</span>((LL) n, (s &lt;&lt; <span class="number">1</span>) + (lim &gt;&gt; i &amp; <span class="number">1</span>)); trs &lt;= ed; trs += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> &amp;nxt = f[i][std::<span class="built_in">min</span>((LL) n, (s &lt;&lt; <span class="number">1</span>) + (lim &gt;&gt; i &amp; <span class="number">1</span>) - trs)];</span><br><span class="line">nxt = (nxt + (LL) f[i + <span class="number">1</span>][s] * C[n][trs]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1023</span>; ++ i) <span class="built_in">adj</span>(res += f[<span class="number">0</span>][i] - Mod);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;vp Div2 差点把构造题想出来了，结果以为自己是错的（&lt;/p&gt;
&lt;p&gt;赛时进度：ABCD Accpeted，Score：4091，Rank：923，Rating 无变化。&lt;/p&gt;
&lt;p&gt;改题进度：All Accepted。&lt;/p&gt;</summary>
    
    
    
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>ABC248G</title>
    <link href="https://mydcwfy.github.io/2022/05/11/ABC248G/"/>
    <id>https://mydcwfy.github.io/2022/05/11/ABC248G/</id>
    <published>2022-05-11T10:39:13.000Z</published>
    <updated>2022-05-11T12:08:48.584Z</updated>
    
    <content type="html"><![CDATA[<p>有趣的反演（？）题目，欧拉函数基础变化。</p><span id="more"></span><p>题意：给定一棵带点权树，定义一条路径的权值为覆盖点的数目乘以所有数的 $\gcd$，求所有路径（不含单点路径）的和。$n\leq 10 ^ 5, 1\leq a_i\leq n$。</p><h3 id="做法-1（赛时做法）"><a href="#做法-1（赛时做法）" class="headerlink" title="做法 1（赛时做法）"></a>做法 1（赛时做法）</h3><p>考虑枚举 $d$，使得所有数都是 $d$ 的倍数，对所有连通块进行遍历，可以得到所有路径覆盖点的个数和。$\gcd$ 为 $d$ 的答案即为 $d | \gcd$ 的答案减去所有 $\gcd = 2d, 3d, \dots$ 的答案，倒序扫即可。时间复杂度 $O(nD + n\ln n)$，$D$ 表示 $n$ 以内最大因数个数。统计连通块的个数可以树形 DP 一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a[x] % d) <span class="keyword">return</span>;</span><br><span class="line">sz[x] = dis[x] = <span class="number">1</span>, vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (!(a[v] % d) &amp;&amp; !vis[v]) &#123;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">ans[d] = (ans[d] + (LL) dis[v] * sz[x] + (LL) dis[x] * sz[v]) % Mod;</span><br><span class="line"><span class="built_in">adj</span>(dis[x] += dis[v] - Mod), <span class="built_in">adj</span>(dis[x] += sz[v] - Mod), sz[x] += sz[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, x = a[i]; j &lt;= x / j; ++ j) &#123;</span><br><span class="line"><span class="keyword">if</span> (x % j) <span class="keyword">continue</span>;</span><br><span class="line">bs[j].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">if</span> (j * j != x) bs[x / j].<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (d = <span class="number">1</span>; d &lt; N; ++ d)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : bs[d])</span><br><span class="line"><span class="keyword">if</span> (!vis[x]) <span class="built_in">dfs</span>(x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : bs[d]) vis[x] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i; -- i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j * i &lt; N; ++ j) <span class="built_in">adj</span>(ans[i] -= ans[i * j]);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) res = (res + (LL) i * ans[i]) % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="做法-2（欧拉函数）"><a href="#做法-2（欧拉函数）" class="headerlink" title="做法 2（欧拉函数）"></a>做法 2（欧拉函数）</h3><p>考虑一件事情：$\sum_{d | n} \varphi(d) = n$，具体证明可以拆质数算。那么当贡献为 $n$ 时，我们只需要计算 $\sum_{d | n} \varphi(d)$ 即可。</p><p>向上面一样，我们直接计算 $d | \gcd$ 的路径点数之和，最后乘上 $\varphi(d)$ 即可。时间复杂度 $O(nD)$。</p><p>代码和上面差不多，不给了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有趣的反演（？）题目，欧拉函数基础变化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
    <category term="莫比乌斯反演" scheme="https://mydcwfy.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>ABC242Ex</title>
    <link href="https://mydcwfy.github.io/2022/05/11/ABC242H/"/>
    <id>https://mydcwfy.github.io/2022/05/11/ABC242H/</id>
    <published>2022-05-11T08:01:56.000Z</published>
    <updated>2022-05-11T12:08:38.315Z</updated>
    
    <content type="html"><![CDATA[<p>虽然是 ABC，质量、难度还是不错的（考场上没想到）。</p><span id="more"></span><p>题意：给定 $m$ 个区间，每次随机选择一个区间，问期望多少次将 $[1, n]$ 全部覆盖。$n, m\leq 400$。</p><p>拆开每一位，相当于是 $E(\max t_i)$，$\max$ 的期望似乎很不好求，我们考虑 min-max 容斥。<br>$$<br>E(\max_{i\in T} a_i) = \sum_{S\subseteq T} (-1) ^ {|S| + 1}E(\min_{i\in S} a_i)<br>$$<br>一个集合的 $\min$ 是好求的，我们先求出与之有交的区间个数 $x$，那么选到 $x$ 中的任意一个都是合法的，那么期望显然是 $\dfrac mx$。</p><p>直接暴力枚举所有集合显然是不行的，我们考虑前面集合中都 $\subseteq \{1, 2, \dots, i - 1\}$在所有集合中加入 $i$，看需要维护什么。首先我们需要维护新加入 $i$ 后区间的个数，容斥系数直接每次加入元素时乘 -1 即可。维护区间个数需要我们维护出上一个选的数 $ls$，这样 $l\in [ls + 1, i], r\in [i, n]$ 的区间就是新加入的。容易发现这是对的。</p><p>于是我们需要维护的就是 $ls$ 表示上一个选的数，$cnt$ 表示有交的区间。状态数为 $O(nm)$，转移为 $O(n)$，总复杂度 $O(n ^ 2m)$。</p><p><strong>期望 max/min 可以互相转化</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = Mod - <span class="number">1</span>; <span class="comment">// last position i, j intervals</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line"><span class="keyword">if</span> (!f[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">res = (res + (LL) m * <span class="built_in">qpow</span>(j) % Mod * f[i][j]) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> to = i + <span class="number">1</span>; to &lt;= n; ++ to)</span><br><span class="line"><span class="built_in">adj</span>(f[to][j + cnt[i][to]] -= f[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然是 ABC，质量、难度还是不错的（考场上没想到）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="min-max 容斥" scheme="https://mydcwfy.github.io/tags/min-max-%E5%AE%B9%E6%96%A5/"/>
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>AHOI2022 钥匙</title>
    <link href="https://mydcwfy.github.io/2022/05/11/AHOI2022-T2/"/>
    <id>https://mydcwfy.github.io/2022/05/11/AHOI2022-T2/</id>
    <published>2022-05-11T07:42:56.000Z</published>
    <updated>2022-05-11T07:58:40.649Z</updated>
    
    <content type="html"><![CDATA[<p>码量题，vp 时差点写吐了（当然也和我选的方法不够简洁有关），没调出来。</p><span id="more"></span><p>题意：给定一棵树，每个节点有钥匙或宝箱，钥匙和宝箱都有一个颜色，相同颜色 的才能匹配。同一种颜色的钥匙最多只有 5 把。进行 $q$ 次旅行，问每次旅行能打开多少宝箱。$n\leq 5\times 10 ^ 5, q\leq 10 ^ 6$。</p><p>容易发现我们要对每一种颜色建一棵虚树。</p><p>建虚树过后，由于钥匙最多只有 5 把，暴力以为一个钥匙为起点枚举是可行的。考虑计算到每一个节点时还剩几把钥匙，如果没有了说明起点的钥匙会和这个点匹配，当他们两同时出现在路径上时，贡献会多 1。</p><p>最后就是一个路径覆盖问题，注意 $(a, b)$ 需要分类 $a$ 是 $b$ 的祖先，$b$ 是 $a$ 的祖先，其余情况。拍到 dfn 序上，扫描线 + 树状数组即可解决。</p><p>代码是在考场代码上改的，很冗长，仅供参考。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line">    <span class="keyword">int</span> st[N &lt;&lt; <span class="number">1</span>][<span class="number">22</span>], lg[N &lt;&lt; <span class="number">1</span>], fi[N], cnt;</span><br><span class="line">    <span class="keyword">int</span> dep[N], d1[N], d2[N], typ[N], f[N], up[N], frm, rem[N];</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) h[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) typ[i] = <span class="number">0</span>;</span><br><span class="line">        idx = cnt = frm = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        st[++ cnt][<span class="number">0</span>] = x, fi[x] = cnt, dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">        d1[x] = d1[fa], d2[x] = d2[fa], f[x] = fa, up[x] = frm;</span><br><span class="line">        <span class="keyword">if</span> (typ[x] == <span class="number">1</span>) d1[x] ++, frm = x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (typ[x] == <span class="number">2</span>) d2[x] ++;</span><br><span class="line">        <span class="keyword">int</span> tmp = frm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">            <span class="keyword">if</span> (e[i] ^ fa) <span class="built_in">dfs</span>(e[i], x), st[++ cnt][<span class="number">0</span>] = x, frm = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dmin</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> dep[x] &lt; dep[y] ? x : y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++ i) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lg[cnt]; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= cnt; ++ i)</span><br><span class="line">                st[i][j] = <span class="built_in">dmin</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fi[x] &gt; fi[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">int</span> k = lg[fi[y] - fi[x] + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dmin</span>(st[fi[x]][k], st[fi[y] - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dist1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">LCA</span>(x, y);</span><br><span class="line">        <span class="keyword">return</span> d1[x] + d1[y] - d1[t] - d1[f[t]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dist2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">LCA</span>(x, y);</span><br><span class="line">        <span class="keyword">return</span> d2[x] + d2[y] - d2[t] - d2[f[t]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        rem[x] = rem[fa];</span><br><span class="line">        <span class="keyword">if</span> (typ[x] == <span class="number">1</span>) rem[x] ++;</span><br><span class="line">        <span class="keyword">if</span> (typ[x] == <span class="number">2</span>) rem[x] --;</span><br><span class="line">        <span class="keyword">if</span> (rem[x] == <span class="number">0</span>) <span class="keyword">return</span> ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">            <span class="keyword">if</span> (e[i] ^ fa) <span class="built_in">dfs2</span>(e[i], x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">getmatch</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ans.<span class="built_in">clear</span>(), <span class="built_in">dfs2</span>(x);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr, oc;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tr[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; N; i += (i &amp; -i)) tr[i] += c; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i ^= (i &amp; -i)) res += tr[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!top) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(stk[top = <span class="number">1</span>] = x);</span><br><span class="line">    <span class="keyword">int</span> lca = tr.<span class="built_in">LCA</span>(x, stk[top]);</span><br><span class="line">    allnodes.<span class="built_in">push_back</span>(lca);</span><br><span class="line">    <span class="keyword">if</span> (!pos[lca]) pos[lca] = ++ curcnt;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; tr.dep[stk[top - <span class="number">1</span>]] &gt;= tr.dep[lca])</span><br><span class="line">        oc.<span class="built_in">link</span>(pos[stk[top - <span class="number">1</span>]], pos[stk[top]]), top --;</span><br><span class="line">    <span class="keyword">if</span> (stk[top] != lca) oc.<span class="built_in">link</span>(pos[lca], pos[stk[top]]), stk[top] = lca;</span><br><span class="line">    <span class="keyword">if</span> (lca != x) stk[++ top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = ++ *dfn, sz[x] = <span class="number">1</span>, nw[*dfn] = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[x])</span><br><span class="line">        <span class="keyword">if</span> (v ^ fa) <span class="built_in">dfs</span>(v, x), sz[x] += sz[v];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MyRun</span></span><br><span class="line">    <span class="comment">// freopen(&quot;keys.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;keys.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">read</span>(n, Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(typ[i], col[i]);</span><br><span class="line">    tr.<span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++ i)</span><br><span class="line">        <span class="built_in">read</span>(u, v), g[u].<span class="built_in">push_back</span>(v), g[v].<span class="built_in">push_back</span>(u), tr.<span class="built_in">add</span>(u, v), tr.<span class="built_in">add</span>(v, u);</span><br><span class="line">    tr.<span class="built_in">prework</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        all[col[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (typ[i] == <span class="number">1</span>) ky[col[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">else</span> bx[col[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> cmp = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> dfn[x] &lt; dfn[y]; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        std::<span class="built_in">sort</span>(all[i].<span class="built_in">begin</span>(), all[i].<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ky[i].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// std::cerr &lt;&lt; &quot;Col &quot; &lt;&lt; i &lt;&lt; std::endl;</span></span><br><span class="line">        oc.<span class="built_in">init</span>(std::<span class="built_in">min</span>((<span class="keyword">int</span>) all[i].<span class="built_in">size</span>() * <span class="number">2</span> + <span class="number">1</span>, n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>) all[i].<span class="built_in">size</span>(); ++ j)</span><br><span class="line">            pos[all[i][j]] = j + <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// for (int i = 1; i &lt;= n; ++ i) printf(&quot;%d &quot;, pos[i]);</span></span><br><span class="line">        <span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line">        allnodes = all[i], allnodes.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        pos[<span class="number">1</span>] = <span class="number">1</span>, <span class="built_in">insert</span>(<span class="number">1</span>), curcnt = all[i].<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// printf(&quot;%d %d %d %d\n&quot;, i, (int) all[i].size(), (int) ky[i].size(), (int) allnodes.size());</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : all[i])</span><br><span class="line">            <span class="keyword">if</span> (x ^ <span class="number">1</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (-- top) oc.<span class="built_in">link</span>(pos[stk[top]], pos[stk[top + <span class="number">1</span>]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : ky[i]) oc.typ[pos[x]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : bx[i]) oc.typ[pos[x]] = <span class="number">2</span>;</span><br><span class="line">        oc.<span class="built_in">prework</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p1 : ky[i]) &#123;</span><br><span class="line">            <span class="keyword">auto</span> mat = oc.<span class="built_in">getmatch</span>(pos[p1]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p2 : mat) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p2 &gt; (<span class="keyword">int</span>) all[i].<span class="built_in">size</span>() + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (p2 == <span class="number">1</span> &amp;&amp; bx[i].<span class="built_in">front</span>() != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (p2 == <span class="number">1</span>) p2 ++;</span><br><span class="line">                p2 = all[i][p2 - <span class="number">2</span>];</span><br><span class="line">                <span class="comment">// printf(&quot;%d %d Pair\n&quot;, p1, p2);</span></span><br><span class="line">                <span class="keyword">if</span> (dfn[p1] &lt;= dfn[p2] &amp;&amp; dfn[p2] &lt; dfn[p1] + sz[p1]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> son = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[p1])</span><br><span class="line">                        <span class="keyword">if</span> (dfn[v] &gt; dfn[p1] &amp;&amp; dfn[v] &lt;= dfn[p2] &amp;&amp; dfn[p2] &lt; dfn[v] + sz[v])</span><br><span class="line">                            <span class="built_in">assert</span>(!~son), son = v;</span><br><span class="line">                    <span class="built_in">assert</span>(~son);</span><br><span class="line">                    opt[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;dfn[p2], dfn[p2] + sz[p2] - <span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">                    opt[dfn[son]].<span class="built_in">push_back</span>(&#123;dfn[p2], dfn[p2] + sz[p2] - <span class="number">1</span>, <span class="number">-1</span>&#125;);</span><br><span class="line">                    opt[dfn[son] + sz[son]].<span class="built_in">push_back</span>(&#123;dfn[p2], dfn[p2] + sz[p2] - <span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dfn[p2] &lt;= dfn[p1] &amp;&amp; dfn[p1] &lt; dfn[p2] + sz[p2]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> son = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[p2])</span><br><span class="line">                        <span class="keyword">if</span> (dfn[v] &gt; dfn[p2] &amp;&amp; dfn[v] &lt;= dfn[p1] &amp;&amp; dfn[p1] &lt; dfn[v] + sz[v])</span><br><span class="line">                            <span class="built_in">assert</span>(!~son), son = v;</span><br><span class="line">                    <span class="built_in">assert</span>(~son);</span><br><span class="line">                    opt[dfn[p1]].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, dfn[son] - <span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">                    opt[dfn[p1]].<span class="built_in">push_back</span>(&#123;dfn[son] + sz[son], n, <span class="number">1</span>&#125;);</span><br><span class="line">                    opt[dfn[p1] + sz[p1]].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, dfn[son] - <span class="number">1</span>, <span class="number">-1</span>&#125;);</span><br><span class="line">                    opt[dfn[p1] + sz[p1]].<span class="built_in">push_back</span>(&#123;dfn[son] + sz[son], n, <span class="number">-1</span>&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    opt[dfn[p1]].<span class="built_in">push_back</span>(&#123;dfn[p2], dfn[p2] + sz[p2] - <span class="number">1</span>, <span class="number">1</span>&#125;),</span><br><span class="line">                    opt[dfn[p1] + sz[p1]].<span class="built_in">push_back</span>(&#123;dfn[p2], dfn[p2] + sz[p2] - <span class="number">1</span>, <span class="number">-1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : allnodes) pos[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::cerr &lt;&lt; &quot;Success&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, st, ed; i &lt;= Q; ++ i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(st, ed);</span><br><span class="line">        <span class="built_in">assert</span>(dfn[st] &gt;= <span class="number">1</span> &amp;&amp; dfn[st] &lt;= n);</span><br><span class="line">        q[dfn[st]].<span class="built_in">push_back</span>(&#123;dfn[ed], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : opt[i])</span><br><span class="line">            bt.<span class="built_in">add</span>(p.l, p.c), bt.<span class="built_in">add</span>(p.r + <span class="number">1</span>, -p.c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : q[i])</span><br><span class="line">            res[p.second] = bt.<span class="built_in">ask</span>(p.first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;码量题，vp 时差点写吐了（当然也和我选的方法不够简洁有关），没调出来。&lt;/p&gt;</summary>
    
    
    
    
    <category term="虚树" scheme="https://mydcwfy.github.io/tags/%E8%99%9A%E6%A0%91/"/>
    
    <category term="扫描线" scheme="https://mydcwfy.github.io/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    
    <category term="树状数组" scheme="https://mydcwfy.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>AHOI2022 排列</title>
    <link href="https://mydcwfy.github.io/2022/05/11/AHOI2022-T1/"/>
    <id>https://mydcwfy.github.io/2022/05/11/AHOI2022-T1/</id>
    <published>2022-05-11T07:28:50.000Z</published>
    <updated>2022-05-11T07:42:30.323Z</updated>
    
    <content type="html"><![CDATA[<p>有趣的数论题目，似乎说不上用了什么高级知识。</p><span id="more"></span><p>题意：一个排列的权值定义为最少置换次数使得出现循环。给出排列，求将任意两个不在一个置换环的数交换后排列的权值和。$n\leq 5\times 10 ^ 5$。</p><p>首先，容易发现一个排列的取值就是虽有置换环长度的 $\text{lcm}$。</p><p>$\text{lcm}$ 可能会炸，所以需要考虑枚举所有的质数，求质数幂次的最大值，最后合并答案。</p><p>考虑暴力枚举两个不同的置换环，我们需要将这两个环对于 $\text{lcm}$ 的贡献去掉，然后将两个置换环长度和加入整个 $\text{lcm}$ 的贡献。去掉两个数可能会产生删除最大值两次，于是我们需要维护质数幂的前三大值以便维护。回滚的时候记录下所有改变的值即可。</p><p>暴力枚举置换环最坏是 $O(n ^ 2)$ 的，还没有算计算 $\text{lcm}$ 的复杂度，但是容易发现只有 $O(\sqrt n)$ 个不同的置换环长度，而贡献又只与长度相关。这样枚举复杂度降为 $O(n)$，后面直接暴力枚举涉及到的质数即可通过。不太会算复杂度，据说是 $O(n\log n)$？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    all.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) vis[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cnt[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) mx1[i] = mx2[i] = mx3[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> j = i, cir = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!vis[j]) cir ++, vis[j] = <span class="literal">true</span>, j = a[j];</span><br><span class="line">        <span class="keyword">if</span> (!cnt[cir] ++) all.<span class="built_in">push_back</span>(cir);</span><br><span class="line">        <span class="comment">// printf(&quot;Cir %d\n&quot;, cir);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c : all) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = c, t = <span class="number">0</span>, p;</span><br><span class="line">        <span class="keyword">while</span> (cur ^ <span class="number">1</span>) &#123;</span><br><span class="line">            p = fac[cur].<span class="built_in">front</span>(), t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur % p == <span class="number">0</span>) t ++, cur /= p;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> cs = <span class="number">1</span>; cs &lt;= cnt[c]; ++ cs)</span><br><span class="line">                <span class="keyword">if</span> (t &gt; mx1[p]) mx3[p] = mx2[p], mx2[p] = mx1[p], mx1[p] = t;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; mx2[p]) mx3[p] = mx2[p], mx2[p] = t;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">chkmax</span>(mx3[p], t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lcm = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (mx1[i]) lcm = (LL) lcm * pw[i][mx1[i]] % Mod;</span><br><span class="line">    <span class="comment">// printf(&quot;Lcm = %d\n&quot;, lcm);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c1 : all)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c2 : all) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c1 == c2 &amp;&amp; cnt[c1] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = lcm;</span><br><span class="line">            <span class="keyword">auto</span> del = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">                <span class="keyword">int</span> p, t;</span><br><span class="line">                <span class="keyword">while</span> (x ^ <span class="number">1</span>) &#123;</span><br><span class="line">                    p = fac[x].<span class="built_in">front</span>(), t = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!havbac[p])</span><br><span class="line">                        havbac[p] = <span class="literal">true</span>, bac1[p] = mx1[p], bac2[p] = mx2[p], bac3[p] = mx3[p];</span><br><span class="line">                    <span class="keyword">while</span> (x % p == <span class="number">0</span>) t ++, x /= p;</span><br><span class="line">                    <span class="keyword">if</span> (t == mx1[p])</span><br><span class="line">                        cur = (LL) cur * inv[p][mx1[p] - mx2[p]] % Mod, mx1[p] = mx2[p], mx2[p] = mx3[p];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (t == mx2[p]) mx2[p] = mx3[p];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">auto</span> ins = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">                <span class="keyword">int</span> p, t;</span><br><span class="line">                <span class="keyword">while</span> (x ^ <span class="number">1</span>) &#123;</span><br><span class="line">                    p = fac[x].<span class="built_in">front</span>(), t = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!havbac[p])</span><br><span class="line">                        havbac[p] = <span class="literal">true</span>, bac1[p] = mx1[p], bac2[p] = mx2[p], bac3[p] = mx3[p];</span><br><span class="line">                    <span class="keyword">while</span> (x % p == <span class="number">0</span>) t ++, x /= p;</span><br><span class="line">                    <span class="keyword">if</span> (t &gt; mx1[p])</span><br><span class="line">                        cur = (LL) cur * pw[p][t - mx1[p]] % Mod, mx3[p] = mx2[p], mx2[p] = mx1[p], mx1[p] = t;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; mx2[p]) mx3[p] = mx2[p], mx2[p] = t;</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">chkmax</span>(mx3[p], t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">auto</span> bac = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">                <span class="keyword">int</span> p, t;</span><br><span class="line">                <span class="keyword">while</span> (x ^ <span class="number">1</span>) &#123;</span><br><span class="line">                    p = fac[x].<span class="built_in">front</span>(), t = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> (x % p == <span class="number">0</span>) t ++, x /= p;</span><br><span class="line">                    <span class="keyword">if</span> (havbac[p])</span><br><span class="line">                        havbac[p] = <span class="literal">false</span>, mx1[p] = bac1[p], mx2[p] = bac2[p], mx3[p] = bac3[p];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">del</span>(c1), <span class="built_in">del</span>(c2), <span class="built_in">ins</span>(c1 + c2);</span><br><span class="line">            <span class="built_in">bac</span>(c1), <span class="built_in">bac</span>(c2), <span class="built_in">bac</span>(c1 + c2);</span><br><span class="line">            <span class="comment">// printf(&quot;%d %d %d&quot;, c1, c2, cur);</span></span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) res = (res + (LL) cur * cnt[c1] % Mod * (cnt[c1] - <span class="number">1</span>) % Mod * c1 % Mod * c1) % Mod;</span><br><span class="line">            <span class="keyword">else</span> res = (res + (LL) cur * cnt[c1] % Mod * cnt[c2] % Mod * c1 % Mod * c2) % Mod;</span><br><span class="line">            <span class="comment">// printf(&quot; : %d\n&quot;, res);</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有趣的数论题目，似乎说不上用了什么高级知识。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>ZJOI2022 树</title>
    <link href="https://mydcwfy.github.io/2022/05/10/ZJOI2022-D1T1/"/>
    <id>https://mydcwfy.github.io/2022/05/10/ZJOI2022-D1T1/</id>
    <published>2022-05-10T00:07:56.000Z</published>
    <updated>2022-05-10T00:33:00.415Z</updated>
    
    <content type="html"><![CDATA[<p>经典的数数题，实在是做不来。</p><span id="more"></span><p><a href="https://loj.ac/p/3706">题目传送门 LOJ</a></p><p>题意：构造两棵有根树，第一棵树 $i$ 的父亲在 $[1, i - 1]$，第二棵树 $i$ 的父亲在 $[i + 1, n]$。问有多少种方案使得 $\forall i\in [1, n]$，第一棵树和第二棵树有且只有一个满足 $i$ 是叶子。$n\leq 500$，需要输出所有 $n\in [2, lim]$ 的答案对 $P$ 取模的结果，$lim, P$ 输入给定。</p><p><strong>有且只有明显在提示容斥</strong>。</p><p>容易发现我们限制一个节点是叶子是容易的，直接记录前面都有多少非叶子即可转移，于是可以得到状态 $f(i, x, y)$ 表示处理到 $i$，$[1, i]$ 第一棵树有 $x$ 个非叶子，$[i, n]$ 有 $y$ 个非叶子。主要是限制非叶子比较麻烦。</p><p>考虑容斥，假设我们选定的 $i$ 在第一棵树中是叶子，那么他在第二棵树中出现必须是非叶子。但是注意，我们不好限制非叶子。于是考虑容斥，虽然他是非叶子，我们考虑强制选择一个集合，使得集合内部的变为叶子，剩余的就不再需要考虑非叶子的问题了。这样容斥只需要是叶子容斥时系数乘 -1 即可，并且两边的容斥可以一起写。</p><p>边界状态就是开始的时候 $f(1, 1, i) = i$，统计答案就是 $\sum f(i, x, 1) \times x$。理解了写起来很简单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x) ans = (ans + (LL) f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][x][<span class="number">1</span>] * x) % Mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; ++ y) f[i &amp; <span class="number">1</span>][x][y] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; ++ y) &#123;</span><br><span class="line"><span class="keyword">if</span> (!f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][x][y]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">adj</span>(f[i &amp; <span class="number">1</span>][x][y] -= (LL) f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][x][y] * x % Mod * y % Mod * <span class="number">2</span> % Mod),</span><br><span class="line">f[i &amp; <span class="number">1</span>][x][y - <span class="number">1</span>] = (f[i &amp; <span class="number">1</span>][x][y - <span class="number">1</span>] + (LL) f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][x][y] * x % Mod * (y - <span class="number">1</span>)) % Mod;</span><br><span class="line">f[i &amp; <span class="number">1</span>][x + <span class="number">1</span>][y] = (f[i &amp; <span class="number">1</span>][x + <span class="number">1</span>][y] + (LL) f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][x][y] * x % Mod * y) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典的数数题，实在是做不来。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合计数" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/"/>
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>ZJOI2022 众数</title>
    <link href="https://mydcwfy.github.io/2022/05/10/ZJOI2022-D1T2/"/>
    <id>https://mydcwfy.github.io/2022/05/10/ZJOI2022-D1T2/</id>
    <published>2022-05-09T23:48:49.000Z</published>
    <updated>2022-05-10T00:06:40.974Z</updated>
    
    <content type="html"><![CDATA[<p>非常厉害的 分块 / 平衡规划 题目，不卡常，码量小，比较有趣。</p><span id="more"></span><p><a href="https://loj.ac/p/3707">题目传送门 LOJ</a></p><p>题意：给定序列 $a$，可以任选一个区间加一个数，问最后众数个数的最大值和可能的众数。$n\leq 2\times 10 ^ 5, \sum n\leq 5\times 10 ^ 5$，3s。</p><p>首先相当于是选一个区间使得内外众数个数和最大。</p><p>设 $\text{occ}(i)$ 表示 $i$ 出现的次数，我们就是要利用好 $\sum \text{occ}(i) = n$ 的性质。</p><p>首先，如果我们确定的内部或者是外部的颜色，我们可以在线性时间内求出最大答案。具体的，比如我们已经确定的外部的颜色，我们再枚举内部颜色。容易发现我们一定两边都是这个颜色时最优，否则我们可以缩短使得刚好两边都是这个颜色。容易发现可以转化成前缀和，我们用前缀最大值更新当前右端点的答案，可以做到 $\text{occ}(i)$，所以确定了一个颜色后，可以在 $O(n)$ 时间得到。</p><p>但是不能每个颜色都扫一边，我们可以考虑平衡规划，将 $\text{occ}(i) &gt; B$ 的颜色用这个方法做，前面的复杂度为 $O(\dfrac {n ^ 2}B)$。剩下的都是 $\text{occ}(i)\leq B$ 的颜色了。</p><p>我们还是得枚举外部颜色，容易发现现在内部的众数答案一定 $\leq B$，我们可以考虑确定左端点时，暴力将 $ans\in [1, B]$ 时满足条件的最小的右端点全部统计一遍，这样就可以做到 $O(\text{occ}(i)B)$ 的复杂度。</p><p>将所有的全部扫一遍，于是总复杂度 $O(nB)$，与上一个平衡规划一下，复杂度就是 $O(n\sqrt n)$，不算卡常。</p><p>注意有一些实现细节，比如可能外部颜色只出现在左边，右边没有可能导致统计漏。可以自己手搓一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solvebig</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        cnt[i] = cnt[i - <span class="number">1</span>] + (a[i] == col);</span><br><span class="line">    <span class="keyword">int</span> tres = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> ed = app[i].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ed; ++ j)</span><br><span class="line">            pre[j] = cnt[app[i][j] - <span class="number">1</span>] - j + <span class="number">1</span>, suf[j] = cnt[n] - cnt[app[i][j]] + j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; ed; ++ j) <span class="built_in">chkmax</span>(pre[j], pre[j - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = ed - <span class="number">2</span>; ~j; -- j) <span class="built_in">chkmax</span>(suf[j], suf[j + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ed; ++ j) <span class="built_in">chkmax</span>(tres, pre[j] + suf[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;Big Col %d %d\n&quot;, col, tres);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">chkmax</span>(res, tres)) ans.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span> (res == tres) ans.<span class="built_in">push_back</span>(col);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> ed = app[i].<span class="built_in">size</span>(), tres = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ed; ++ j)</span><br><span class="line">            pre[j] = j - cnt[app[i][j]] + <span class="number">1</span>, suf[j] = cnt[app[i][j] - <span class="number">1</span>] + ed - j;</span><br><span class="line">        <span class="built_in">chkmax</span>(pre[<span class="number">0</span>], <span class="number">0</span>), <span class="built_in">chkmax</span>(suf[ed - <span class="number">1</span>], cnt[n]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; ed; ++ j) <span class="built_in">chkmax</span>(pre[j], pre[j - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = ed - <span class="number">2</span>; ~j; -- j) <span class="built_in">chkmax</span>(suf[j], suf[j + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ed - <span class="number">1</span>; ++ j) <span class="built_in">chkmax</span>(tres, pre[j] + suf[j + <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// printf(&quot;Col2 %d %d %d\n&quot;, i, col, tres);</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">chkmax</span>(res, tres)) ans.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span> (res == tres) ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solvesmall</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;ap = app[col];</span><br><span class="line">    app[col].<span class="built_in">insert</span>(app[col].<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ed = ap.<span class="built_in">size</span>(), tres = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, cur; j &lt; ed; ++ j) &#123;</span><br><span class="line">        cur = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> del = <span class="number">1</span>; del &lt;= lim; ++ del) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mx[ap[j] + <span class="number">1</span>][del] &gt; n + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur &lt; ed &amp;&amp; ap[cur] &lt;= mx[ap[j] + <span class="number">1</span>][del]) cur ++;</span><br><span class="line">            <span class="built_in">chkmax</span>(tres, ed - cur + j + del);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    app[col].<span class="built_in">erase</span>(app[col].<span class="built_in">begin</span>());</span><br><span class="line">    <span class="comment">// printf(&quot;Res : %d %d\n&quot;, col, tres);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">chkmax</span>(res, tres)) ans.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span> (res == tres) ans.<span class="built_in">push_back</span>(col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    lim = std::<span class="built_in">max</span>(std::<span class="built_in">sqrt</span>(n) + <span class="number">1</span>, <span class="number">1.</span>), res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) app[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">ws</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) ws[i] = a[i + <span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">sort</span>(ws.<span class="built_in">begin</span>(), ws.<span class="built_in">end</span>());</span><br><span class="line">    ws.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(ws.<span class="built_in">begin</span>(), ws.<span class="built_in">end</span>()), ws.<span class="built_in">end</span>());</span><br><span class="line">    sz = ws.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        a[i] = std::<span class="built_in">lower_bound</span>(ws.<span class="built_in">begin</span>(), ws.<span class="built_in">end</span>(), a[i]) - ws.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">    std::cerr &lt;&lt; a[n - <span class="number">6</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) app[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lim; ++ j) mx[i][j] = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int</span>) app[i].<span class="built_in">size</span>() &gt; lim) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> ed = app[i].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ed; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> del = <span class="number">1</span>; del &lt;= lim &amp;&amp; j + del &lt;= ed; ++ del)</span><br><span class="line">                <span class="built_in">chkmin</span>(mx[app[i][j]][del], app[i][j + del - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i; -- i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lim; ++ j) <span class="built_in">chkmin</span>(mx[i][j], mx[i + <span class="number">1</span>][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; ++ i)</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int</span>) app[i].<span class="built_in">size</span>() &gt; lim) <span class="built_in">solvebig</span>(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">solvesmall</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    std::<span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    ans.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>()), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : ans) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ws[x - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;非常厉害的 分块 / 平衡规划 题目，不卡常，码量小，比较有趣。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分块" scheme="https://mydcwfy.github.io/tags/%E5%88%86%E5%9D%97/"/>
    
    <category term="平衡规划" scheme="https://mydcwfy.github.io/tags/%E5%B9%B3%E8%A1%A1%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>2022 联合省选半退役记</title>
    <link href="https://mydcwfy.github.io/2022/04/22/2022-provincal-team-select-competition/"/>
    <id>https://mydcwfy.github.io/2022/04/22/2022-provincal-team-select-competition/</id>
    <published>2022-04-22T10:25:14.000Z</published>
    <updated>2022-05-02T08:18:38.790Z</updated>
    
    <content type="html"><![CDATA[<p>打的很臭，暂且是以一种轻松的心态写这篇游记吧。</p><span id="more"></span><h2 id="Day"><a href="#Day" class="headerlink" title="Day -?"></a>Day -?</h2><p>感觉状态总是不好，感觉赛后觉得比较套路 / 简单的题目赛时因为各种原因没有做出来，感觉要寄。</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>复习了比较多的模板，还在结束前绝杀了一道题，心态不错。但结局是一个都没有考到。不过和一些外校高我们一级的学生聊了一会。</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>8：00 左右就进了考场，本身想码一些模板的，结果被监考员警告了（</p><p>8：30 才能看到题目，14 页的题目，厉害。</p><p>T1 读懂题后发现是一个模拟（省选也有这题？），T2 是一个神仙的树形 DP，T3 神秘图论，题面过长，没怎么读懂。</p><p>先写 T1，本着好写的原则（？）用 <code>std::map&lt;std::string, std::pair&lt;std::string, bool&gt;&gt;</code> 没管复杂度直接写了。而且没注意空格之类的问题（flag）。</p><p>T2 一看肯定和容斥和树形 DP 相关，猜两个没有关键点之间是一个 1 次多项式，写了很久，发现没对。但是如果把所有的权值加进去就是对的，想了想，显然不是 1 次多项式，但是没想到是 $n$ / $n + 1$ 次多项式。想到了 $O(nK)$ 但是没写（？）。</p><p>T3 不可做题，一眼看 8 pts 状压，20 pts 白送，28 pts 到手。</p><p>检查了一下所有的代码问题，慢悠悠的结束了。估计 $100 + 20 + 28 = 148$，看样子是大众分。</p><p>出来感觉大家考得都不怎么好，不太多的人做出来了 T2。似乎 D1 没什么差距。</p><p>下午、晚上懒得复习，看了一部电影、足球比赛、篮球比赛（？）。听说 T1 有空串问题，我直接是先读入第一个字符串 <code>std::cin &gt;&gt; cur</code>，显然有锅。Luogu 上直接 0 pts，不过管他的，Day 2 才是拉差距的关键。</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>学懂了，8：30 才开始看题。</p><p>T1 一眼是一个 NOI 哪年的题（赛后发现是寿司晚宴），T2 神秘 <code>bracket</code> 直接跳过（谁叫我没认真听 WC 讲课？），T3 一眼 CSP2019 D1T3。决定顺序开题。</p><p>T1 结果想了好久没想到根号，一直想怎么容斥，结果都是 $2 ^ c$ 有关（$c$ 是质数个数），9：20 才发现是根号，大力胡了一个 DP，估计 65 pts。开始写，结果不记得那个题怎么写了，随便写了一个 $2 ^ {14} \times 2000$ 单次的做法。一跑大样例，发现直接过了。</p><p>这时 10：30，赶快去看 T2，推了一会，毫无收获，马上去看 T3。</p><p>T3 先写了 12 pts，想了一想，可以大力 $O(n ^ 5)$，按照树形背包的复杂度分析可以到 $O(n ^ 4)$，中间有 6 种情况，似乎很难写。有想了一会，发现两次用最大值更新可以去掉一些不必要的状态，可以做到 $O(n ^ 3)$。</p><p>赶忙开始写，此时已经 11：25 了。没有精力去认真调该题，虽然说是没有放弃，但是看着 35 行左右的转移方程，还是无能为力，还是交了个 $O(n!)$ 的代码。</p><p>预估分数：$65 + 0 + 12 = 77$。</p><h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><p>突然说 18：00 出成绩，先发下来数据。一测发现 D1T1 100 pts，但是 D2T1 挂成了 40 pts，发现原因是把含有大质数的直接当 01 背包处理了（似乎我写寿司晚宴就犯了这个错误），一改，直接 85 pts。发现最后的容斥似乎比较好想，不过我没时间了。T3 写出 44 pts 的人似乎不多，多数人是 12 pts，也有一些是 28 pts。</p><p>出成绩发现 D1T1 又挂了 10 pts，开头加一个空格是什么东西？</p><p>总分：$90 + 20 + 28 + 40 + 0 + 12 = 190$，暴力分都没有完全打满，整场比赛的分数没有一点亮点。</p><p>据说会在队线附近，比较紧张。被抓回去学了几天 whk。（暴力分也能进队？</p><p>UPD：居然踩线进队了。</p><h2 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h2><p>上午正准备月考，结果来了个“踩线进队”的消息，真是吃惊不小。幸好 NOIP T3 随机化骗了 96 pts，把我送进去了。不过这个消息显然对月考一点都不友好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然说是侥幸踩线了，不过暴露出了不少问题，借这里也写一下吧。</p><h3 id="1）挂分导致心态波折"><a href="#1）挂分导致心态波折" class="headerlink" title="1）挂分导致心态波折"></a>1）挂分导致心态波折</h3><p>明明可以写出 D1T1，D2T1（85 pts），结果却因为自己平时训练的时候没有注意这些细节，导致丢掉该得的分数。平常写代码遇到问题时，没有仔细理解就放过去了，这导致在考场写代码时也会出现同样的问题。</p><h3 id="2）时间安排不当导致没有时间"><a href="#2）时间安排不当导致没有时间" class="headerlink" title="2）时间安排不当导致没有时间"></a>2）时间安排不当导致没有时间</h3><p>D1T2 有精力可以做出 40 pts，结果总以为自己可以得到更高的分数，导致最后一点也没有得到。D2T1、D2T3 纷纷因为我在 D2T3 的难写 $O(n ^ 3)$ 上死磕，结果没有时间。如果先写了 $O(n ^ 4)$ 的朴素 DP，至少也有 28 pts 了。在平常考试时，应更加注意时间的合理分配。</p><p>不管怎样，还是奔赴下一站吧。NOI2022，相会！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;打的很臭，暂且是以一种轻松的心态写这篇游记吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="游记" scheme="https://mydcwfy.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF1119H Ex</title>
    <link href="https://mydcwfy.github.io/2022/04/11/CF1119H/"/>
    <id>https://mydcwfy.github.io/2022/04/11/CF1119H/</id>
    <published>2022-04-11T08:08:52.000Z</published>
    <updated>2022-04-11T13:58:17.279Z</updated>
    
    <content type="html"><![CDATA[<p>神仙的集合幂级数应用。</p><span id="more"></span><p>题意：有 $n$ 个物品，每个物品存在 $m$ 种子物品，权值为 $a_{i, j}$，每个子物品个数为 $w_j$。从每种物品中选择一个子物品，定义总权值为权值的异或和。求最后每种权值有多少种选法。满足 $a_{i, j} &lt; 2 ^ k$，$m$ 较小。CF 原题满足 $m = 3, k = 17,n\leq 2 ^ {17}$，对 998244353 取模。</p><p>考虑朴素的 FWT 卷积，先对每一个物品 FWT 一下，然后逐位乘起来，最后 FWT 逆变换回来，时间复杂度显然为 $O(nk2 ^ k)$，显然过不去。</p><p>发现有一个特殊的性质：每一个的个数都是 $w_{1, 2, \dots, m}$，有限的组合一定只有 $2 ^ m$ 种。而 $m$ 较小，我们或许可以从这里入手。</p><p>考虑每一个物品的 $p$ 位是什么，记录状态 $s$ 有 $m$ 位，他对应的权值为 $\sum_{i = 0} ^ {m - 1} (-1) ^ {i\in s} w_i$。我们可以对于每一位 $p$，求出 $n$ 个物品中，$s = 0, 1, \dots, 2 ^ m - 1$ 分别有多少种，快速幂求能求出每一位最后的权值，逆变换即可。我们针对 $p$ 这一位进行讨论。</p><p>现在我们考虑计算 $c_{0, 1, \dots, 2 ^ m - 1}$，这显然需要我们寻找 $2 ^ m$ 个方程来计算。哪里有 $2 ^ m$ 个方程呢？我们考虑对于任意 $T\subseteq \{1, 2, \dots, m\}$，计算<strong>只有权值为 $\sum_{i = 1} ^ n val_i = \oplus_{j\in T}a_{i, j}$ FWT 之后的结果</strong>。</p><p>考虑 FWT 的计算过程，即为 $f’(p) = \sum_{i = 0} ^ {2 ^ n - 1}f(i)(-1) ^ {i\odot p}$。这样拆开看，首先，如果 $\mid T\mid = 1$，显然 $f’(p)$ 就是唯一的一个 $w_j$ 乘上一个 1 或者 -1 的系数。否则，我们将每一个 $val_i$ 贡献到 $p$ 上，系数就是 $(-1) ^ {val_i\odot p}$。而整个需要再乘上 $\sum_{j\in T}w_j$，因为开始我们计算的时候没有带上这个权值。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;神仙的集合幂级数应用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="集合幂级数" scheme="https://mydcwfy.github.io/tags/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"/>
    
    <category term="数学" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>集合幂级数浅谈</title>
    <link href="https://mydcwfy.github.io/2022/04/09/set-power-series/"/>
    <id>https://mydcwfy.github.io/2022/04/09/set-power-series/</id>
    <published>2022-04-09T08:09:16.000Z</published>
    <updated>2022-04-11T07:49:58.446Z</updated>
    
    <content type="html"><![CDATA[<p>有点重要的知识点，不记得省选考不考了。</p><span id="more"></span><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>一个长度为 $2 ^ n$ 的序列，有一个生成函数为 $F(x) = \sum_{i = 0} ^ {2 ^ n - 1}f(i) x ^ i$，这个生成函数就叫<strong>集合幂级数</strong>。</p><p>为什么叫集合幂级数呢？是因为我们可以把 $i$ 看作一个 $\{0, 1, \cdots, n - 1\}$ 的子集并状态压缩。</p><p>定义以下几个计算：</p><ol><li>或卷积：$c(i) = \sum_{j \mid k = i}a(j)b(k)$。</li><li>与卷积：$c(i) = \sum_{j\odot k = i}a(j)b(k)$。</li><li>异或卷积：$c(i) = \sum_{j\oplus k = i}a(j)b(k)$。</li><li>子集卷积：$c(i) = \sum_{j\odot k = 0, j \mid k = i}b(j)c(k)$。</li></ol><p>还有一些奇怪的科技，如子集 ln，子集 exp，这里先鸽了。</p><p>这些东西如果是暴力计算的话，显然是 $O(4 ^ n)$ 的，我们考虑有没有更优的做法。</p><h2 id="2-FMT-FWT"><a href="#2-FMT-FWT" class="headerlink" title="2. FMT / FWT"></a>2. FMT / FWT</h2><h3 id="1）FMT"><a href="#1）FMT" class="headerlink" title="1）FMT"></a>1）FMT</h3><p>定义高维前缀和为：$b(i) = \sum_{j\subseteq i}a(j)$。容易发现暴力做是 $O(3 ^ n)$ 的。</p><p>为什么叫高位前缀和呢？因为他相当于是 $n$ 维数组做前缀和，每维只有 01 两种。（<del>所以好像就有了 $k$ 进制下的高维前缀和</del>）</p><p>考虑如果只有 2 维，怎么做呢？</p><p>显然枚举每一维，再对该维前缀和，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++ j) a[i][j] += a[i][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) a[i][j] += a[i - <span class="number">1</span>][j];</span><br></pre></td></tr></table></figure><p>显然是枚举了两维，虽然和平常写法不同，但是如果手玩一下发现是对的。</p><p>扩展到 $n$ 维，我们就可以得到一个简短的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); ++ j)</span><br><span class="line">        <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) a[j] += a[j ^ (<span class="number">1</span> &lt;&lt; i)];</span><br></pre></td></tr></table></figure><p>这个代码显然是 $O(n2 ^ n)$ 的。</p><p>同理，我们也可以得到高位后缀和的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); ++ j)</span><br><span class="line">        <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) a[j ^ (<span class="number">1</span> &lt;&lt; i)] += a[j];</span><br></pre></td></tr></table></figure><p>高维前缀和和高维后缀和统称为<strong>快速莫比乌斯变换</strong>，简写为 FMT。</p><h3 id="2）FWT"><a href="#2）FWT" class="headerlink" title="2）FWT"></a>2）FWT</h3><p>定义 $\displaystyle \text{FWT}(A) = \sum_{i = 0} ^ {2 ^ n - 1}x ^ i\sum_{j = 0} ^ {2 ^ n - 1}(-1) ^ {|i\odot j|}[x ^ j]A(x)$，这个东西就叫<strong>快速沃尔什变换</strong>，简写为 FWT。显然暴力计算是 $O(4 ^ n)$ 的。</p><p>类似于 FMT，我们逐维考虑。枚举每一维 $i$，假设我们枚举到 $j$ 不包含 $i$ 这一维。那么对于不包含 $i$ 的 $j$，显然会将两个都加起来，因为自己是 0，不管与谁都是 0，即 $a_j := a_j + a_{j\mid 2^i}, $，而包含 $i$ 的 $j\mid2^i$ 就不同了，如果是 $a_{j\mid 2 ^ i}$，显然贡献到 $a_{j\mid 2 ^ i}$ 就是 -1 了，即 $a_{j\mid2 ^ i}:= a_j - a_{j\mid 2 ^ i}$。</p><p>我们也可以写出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); ++ j)</span><br><span class="line">        <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = a[j], y = a[j | (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">            a[j] = x + y, a[j | (<span class="number">1</span> &lt;&lt; i)] = x - y;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>我们还可以写出另一份代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bit, tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++ j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = a[i + j], y = a[i + j + mid];</span><br><span class="line">            a[i + j] = x + y, a[i + j + mid] = x - y;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>发现和 NTT 其实是很像的。其实集合幂级数和多项式是有很多相似点的，我们这里才刚刚看到。</p><p>显然，时间复杂度为 $O(n2 ^ n)$。</p><h2 id="3-实现卷积"><a href="#3-实现卷积" class="headerlink" title="3. 实现卷积"></a>3. 实现卷积</h2><h3 id="1）与卷积"><a href="#1）与卷积" class="headerlink" title="1）与卷积"></a>1）与卷积</h3><p>考虑证明假设 $C(x) = \sum_{i = 0} ^ {2 ^ n - 1}x ^ i \sum_{j\odot k = i} [x ^ j]A(x) * [x ^ k]B(x)$，那么对 $A, B, C$ 高位前缀和后，$C(x) = \sum_{i = 0} ^ {2 ^ n - 1}x ^ i[x ^ i]A(x) * [x ^ i]B(x)$。</p><p>考虑每一对 $j, k$，最后 $j, k$ 一定会贡献到 $j\odot k$ 的所有子集，即 $\forall x\subseteq (j\odot k)$。而 $C$ 贡献显然也是 $\forall x\subseteq i$，这和前面的贡献是相同的。</p><p>于是我们先对 $A, B$ 高位前缀和，乘起来，再做高位前缀和的逆变换就可以得到 $C$ 了。</p><p>逆变换就将加号变为减号即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); ++ j)</span><br><span class="line">        <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) a[j] -= a[j ^ (<span class="number">1</span> &lt;&lt; i)];</span><br></pre></td></tr></table></figure><h3 id="2）与卷积"><a href="#2）与卷积" class="headerlink" title="2）与卷积"></a>2）与卷积</h3><p>考虑类似于或卷积的方法，这里不再赘述，证明留给读者。</p><h3 id="3）异或卷积"><a href="#3）异或卷积" class="headerlink" title="3）异或卷积"></a>3）异或卷积</h3><p>前面已经定义了 $FWT(A)$，类似于 FMT，我们证明 $FWT(C) = FWT(A) * FWT(b)$。</p><p>还是考虑 $i, j, p$ 的贡献，$i\to p$ 的贡献显然是 $a(i)(-1) ^ {\mid p\odot i\mid }$，$j\to p$ 的贡献显然是 $b(j)(-1) ^ {\mid p\odot j\mid }$。</p><p>考虑 $i\oplus j$ 对 $p$ 的贡献，显然是 $(-1) ^ {(i\oplus j)\odot p}$。所以我们考虑证明 $(-1) ^ {\mid (i\oplus j)\odot p\mid } = (-1) ^ {\mid i\odot p\mid }(-1) ^ {\mid j\odot p\mid }$。</p><p>容易发现 $p$ 的限制就是将 $i, j$ 中 $p$ 该位为 1 的位拿出来，其余的不管，我们可以先对 $i$ 赋值为 $i\odot p$，$j$ 同理，显然最后的答案左边就是 $(-1) ^ {\mid i\oplus j\mid}$，容易发现就是 $i$ 的 1 个数和 $j$ 的 1 个数相加。左右显然相等。</p><p>逆变换还是将操作反过来即可。这里给出一种实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++ j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = a[i + j], y = a[i + j + mid];</span><br><span class="line">            a[i + j] = (x + y) &gt;&gt; <span class="number">1</span>, a[i + j + mid] = (x - y) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>另外，可以像 NTT 一样实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++ j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = a[i + j], y = a[i + j + mid];</span><br><span class="line">            a[i + j] = x + y, a[i + j + mid] = x - y;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] &gt;&gt;= n;</span><br></pre></td></tr></table></figure><h3 id="4）子集卷积"><a href="#4）子集卷积" class="headerlink" title="4）子集卷积"></a>4）子集卷积</h3><p>先不考虑 $j\odot k = 0$ 的情况，容易发现这就是一个简单的或卷积。但是这个条件似乎不好处理。</p><p>发现当 $j, k\to j| k$ 是有贡献的，当且仅当 $\mid j\mid + \mid k\mid = \mid j|k\mid$，也就是说，我们限制的集合的大小。这启示我们按照集合大小分类。</p><p>我们考虑计算集合大小分别为 $a$ 和 $b$ 的或卷积，贡献到集合大小为 $a + b$ 的位置上。这样暴力做是 $O(n ^ 3 2 ^ n)$ 的，但是发现中间对 $a, b$ 的或卷积是由重复的，我们可以先将 $a = 0, \dots n - 1, b = 0, \dots n - 1$ 的高维前缀和后，再批量贡献到 $a + b$，再将 $a + b = 0, \dots, n - 1$ 的高维前缀和逆变换。容易发现时间复杂度是 $O(n ^ 2 2 ^ n)$ 的。代码在后面的例题。</p><h2 id="4-例题"><a href="#4-例题" class="headerlink" title="4. 例题"></a>4. 例题</h2><h3 id="T1：模板"><a href="#T1：模板" class="headerlink" title="T1：模板"></a>T1：模板</h3><p><a href="https://www.luogu.com.cn/problem/P4717">FMT / FWT 模板</a></p><p><a href="https://www.luogu.com.cn/problem/P6097">子集卷积模板 lg</a>，<a href="https://loj.ac/p/152">子集卷积模板 LOJ</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">base_or</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; ++ j)</span><br><span class="line"><span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) (a[j] += a[j ^ (<span class="number">1</span> &lt;&lt; i)] * inv) %= Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; ++ j) a[j] = (a[j] + Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_or</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(a, A, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * tot), <span class="built_in">memcpy</span>(b, B, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * tot);</span><br><span class="line"><span class="built_in">base_or</span>(a, <span class="number">1</span>), <span class="built_in">base_or</span>(b, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = (LL)a[i] * b[i] % Mod;</span><br><span class="line"><span class="built_in">base_or</span>(c, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, c[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">base_and</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = tot - <span class="number">1</span>; j; -- j)</span><br><span class="line"><span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) (a[j ^ (<span class="number">1</span> &lt;&lt; i)] += a[j] * inv) %= Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; ++ j) a[j] = (a[j] + Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_and</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(a, A, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * tot), <span class="built_in">memcpy</span>(b, B, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * tot);</span><br><span class="line"><span class="built_in">base_and</span>(a, <span class="number">1</span>), <span class="built_in">base_and</span>(b, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = (LL)a[i] * b[i] % Mod;</span><br><span class="line"><span class="built_in">base_and</span>(c, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, c[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">base_xor</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (inv == <span class="number">-1</span>) inv = inv2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; ++ j) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">LL x = a[j], y = a[j | (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">a[j] = (x + y) % Mod * inv % Mod;</span><br><span class="line">a[j | (<span class="number">1</span> &lt;&lt; i)] = (x - y + Mod) % Mod * inv % Mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_xor</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(a, A, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * tot), <span class="built_in">memcpy</span>(b, B, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * tot);</span><br><span class="line"><span class="built_in">base_xor</span>(a, <span class="number">1</span>), <span class="built_in">base_xor</span>(b, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = (LL)a[i] * b[i] % Mod;</span><br><span class="line"><span class="built_in">base_xor</span>(c, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, c[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++ i) <span class="built_in">FWT</span>(a[i], bit, <span class="number">1</span>), <span class="built_in">FWT</span>(b[i], bit, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bit - i; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; bit); ++ k)</span><br><span class="line">c[i + j][k] = (c[i + j][k] + (LL)a[i][k] * b[j][k]) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++ i) <span class="built_in">FWT</span>(c[i], bit, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T2：Sum-the-Fibonacci"><a href="#T2：Sum-the-Fibonacci" class="headerlink" title="T2：Sum the Fibonacci"></a>T2：Sum the Fibonacci</h3><p><a href="https://codeforces.com/problemset/problem/914/G">题目传送门 Codeforces</a></p><p>也是模板，请读者自行实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有点重要的知识点，不记得省选考不考了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="集合幂级数" scheme="https://mydcwfy.github.io/tags/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"/>
    
    <category term="数学" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>CF643G</title>
    <link href="https://mydcwfy.github.io/2022/04/09/CF643G/"/>
    <id>https://mydcwfy.github.io/2022/04/09/CF643G/</id>
    <published>2022-04-09T03:43:26.000Z</published>
    <updated>2022-04-09T05:59:25.359Z</updated>
    
    <content type="html"><![CDATA[<p>线段树 + 众数的好题。</p><span id="more"></span><p>题意：给定长度为 $n$ 的序列和常数 $p$，$q$ 次操作，区间赋值或是查询区间出现次数大于 $p\%$ 的数。可以有无关输出，但总数不能超过 $\left\lfloor\dfrac{100}p \right\rfloor$。$20\leq p\leq 100, n, q\leq 1.5\times 10 ^ 5$。</p><p>考虑 $p &gt; 50$ 怎么做。维护一个 <code>(x, cnt)</code>，表示一个数和当前数出现次数减去非当前数的出现次数。显然 $cnt &gt; 0$ 的数最多只有一个，也就是说，我们只需要维护一个 <code>pair</code> 即可。来了新的一个数时，如果等于当前数，显然 <code>cnt ++</code>，否则 <code>cnt --</code>。如果当前的 $cnt$ 已经 $\leq 0$ 了，说明这个数是不优的，一定不可能成为答案，我们就删除这个 <code>pair</code>。如果新来一个数时 <code>pair</code> 是空的，我们直接设置为 <code>(x, 1)</code> 即可。</p><p>考虑证明可行。显然一个数 $x$ 如果出现频率大于 $50\%$，那么到最后的时候，他一定没有被其他数所换下，因为即使所有数都攻击 $x$ 的 $cnt$，最后仍然 $cnt &gt; 0$，也就是不会被弹出。至此我们证明的这一定是可行的。</p><p>扩展该做法，维护 $\left\lfloor\dfrac{100}p \right\rfloor$ 个 <code>(x, cnt)</code>，如果来了一个数是其中的某一个数，直接对这个 <code>(x, cnt)</code> 加一。否则对每一个 <code>(x, cnt)</code> 减一，如果有 $cnt = 0$，则删除。显然如不满 $\left\lfloor\dfrac{100}p \right\rfloor$ 个的话，我们就设置一个 <code>(x, 1)</code> 即可。</p><p>考虑正确性。如果这个数被弹出仅当至少出现了 $\left\lfloor\dfrac{100}p \right\rfloor$ 个和他互不相同的数，并且这个数仅出现了一次，如果再出现这个数也至少有 $\left\lfloor\dfrac{100}p \right\rfloor$ 个和他不同的数，说明这个数的出现频率不可能达到 $p%$，得证。</p><p>区间操作直接直接使用线段树维护即可，合并信息的时候可以将一边的数按照 <code>cnt</code> 次出现计算，暴力加入另外一边（显然没有出现在左右的 <code>pair</code> 中则不可能出现在最终的 <code>pair</code> 中）。假设 $k = \left\lfloor\dfrac{100}p \right\rfloor$，则时间复杂度为 $O(k ^ 2n\log n)$。</p><p>题外话：可不可以使用这个维护区间众数呢？欢迎在评论区留言。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Major</span> &#123;</span></span><br><span class="line">    PII dat[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">Major</span>() &#123;  &#125;</span><br><span class="line">    <span class="built_in">Major</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> cnt) &#123; dat[<span class="number">0</span>] = &#123;x, cnt&#125;; &#125;</span><br><span class="line">    PII&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> dat[x]; &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">int</span> k; <span class="comment">// 维护 k 个 pair</span></span><br><span class="line"></span><br><span class="line">Major <span class="keyword">operator</span> +(Major a, Major b) <span class="comment">// 合并两边的 pair</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = b[i].first, cnt = b[i].second, flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k &amp;&amp; !flag; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (a[j].first == x) flag = <span class="number">1</span>, a[j].second += cnt;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k &amp;&amp; !flag; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (!a[j].first) a[j] = &#123;x, cnt&#125;, flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">1e9</span>, pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">chkmin</span>(mx, a[j].second)) pos = j;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; a[pos].second)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++ j) a[j].second -= cnt;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++ j) a[j].second -= mx;</span><br><span class="line">            a[pos] = &#123;x, cnt - mx&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;线段树 + 众数的好题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="线段树" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>CF653G</title>
    <link href="https://mydcwfy.github.io/2022/04/07/CF653G/"/>
    <id>https://mydcwfy.github.io/2022/04/07/CF653G/</id>
    <published>2022-04-07T08:28:48.000Z</published>
    <updated>2022-05-02T13:45:19.480Z</updated>
    
    <content type="html"><![CDATA[<p>一道埃筛 + 组合数学的题目。</p><span id="more"></span><p>题意：给定一个序列 $\{a\}$，执行以下的操作直到所有数相等：乘一个质数或除一个质数。求所有子序列最少操作次数的和，对 $10 ^ 9 + 7$ 取模。$n, a_i\leq 3\times 10 ^ 5$，5 s。可以加强到 $n, a_i\leq 2\times 10 ^ 7$。</p><p>容易发现每一个质数是独立的，可以分开计算贡献。另外，显然当取质数次数的中位数是最优的策略。</p><p>对每一个质数分别考虑，假设当前按质数次数降序排名为 $i$ 的数次数为 $x_i$，中位数为 $x$，那么答案为 $|x_i - x|$。</p><p>如果我们将整个展开，发现 $\dfrac n2$ 个数 $x$ 的贡献是负，$\dfrac n2$ 个数 $x$ 的贡献是正，那么我们只需要考虑 $x_i$ 的贡献。</p><p>假设排名小于 $i$ 的选了 $a$ 个（$0\leq a&lt; i$），大于 $i$ 的选了 $b$ 个（$0\leq b&lt; n - i + 1$），那么根据 $a$ 和 $b$ 的大小可以分为：</p><ol><li>$a &lt; b$，则 $x_i$ 贡献为正。</li><li>$a = b$，则 $x_i$ 贡献为 0。</li><li>$a &gt; b$，则 $x_i$ 贡献为负。</li></ol><p>$a, b$ 的相对关系看起来不好枚举，我们换做 $i - 1 - a + b$ 与 $i - 1$ 的大小关系可能更好枚举。于是我们可以得到下面的式子：<br>$$<br>\sum_{j = i} ^ {n - 1} \binom{n - 1}{j} - \sum_{j = 0} ^ {i - 2} \binom{n - 1}{j}<br>$$</p><p>我们可以预处理 $f(k) = \sum_{i = k}^{n - 1} \binom{n - 1}i - \sum_{i = 0}^{k - 2}\binom{n - 1}i$，可能会更好求。</p><p>发现 $x_i$ 一样的段，贡献是连续的，也就是 $f(k)$ 是一段的和。假设枚举次幂 $t$，设 $x_i\geq t$ 的个数为 $a$，$x_i &gt; t$ 的个数为 $b$，那么 $t$ 的贡献就是：<br>$$<br>t\sum_{i = b + 1} ^ a f(i)<br>$$<br>再次前缀和 $g(i) = \sum_{j = 1} ^ i f(j)$，那么这个贡献也可以 $O(1)$ 计算。那么瓶颈在于计算 $x_i\geq t$ 的个数。这个可以通过埃筛来计算。</p><p>具体来说，我们直接考虑枚举质数 $p$，然后对于他的次幂，暴力计算次幂的倍数有多少个。据说时间复杂度是 $O(n\log\log n)$ 的，实测 $4\times 10 ^ 7$ 也只要 0.5s（不算读入）。有好心人发一下证明吗？</p><p>代码比较简短。放一个主函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++ j) <span class="built_in">adj</span>(pre[j] = pre[j - <span class="number">1</span>] + <span class="built_in">C</span>(n - <span class="number">1</span>, j) - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, tmp; i &lt;= n; ++ i)</span><br><span class="line"><span class="built_in">adj</span>(ans[i] = ans[i - <span class="number">1</span>] + <span class="built_in">adj</span>(<span class="built_in">adj</span>(tmp = pre[n - <span class="number">1</span>] - pre[i - <span class="number">1</span>]) -= (i == <span class="number">1</span> ? <span class="number">0</span> : pre[i - <span class="number">2</span>])) - Mod);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= mx; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (j = i &lt;&lt; <span class="number">1</span>; j &lt;= mx; j += i) st[j] = <span class="literal">true</span>;</span><br><span class="line">LL k = i;</span><br><span class="line"><span class="keyword">for</span> (cntp[j = <span class="number">1</span>] = <span class="number">0</span>; k &lt;= mx; cntp[++ j] = <span class="number">0</span>, k *= i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = k; l &lt;= mx; l += k) cntp[j] += cnt[l];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = j - <span class="number">1</span>, tmp; l; -- l)</span><br><span class="line">res = (res + (LL)<span class="built_in">adj</span>(tmp = ans[cntp[l]] - ans[cntp[l + <span class="number">1</span>]]) * l) % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一道埃筛 + 组合数学的题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="狄利克雷卷积" scheme="https://mydcwfy.github.io/tags/%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/"/>
    
  </entry>
  
  <entry>
    <title>CF843D</title>
    <link href="https://mydcwfy.github.io/2022/04/06/CF843D/"/>
    <id>https://mydcwfy.github.io/2022/04/06/CF843D/</id>
    <published>2022-04-06T13:50:25.000Z</published>
    <updated>2022-04-09T03:44:30.220Z</updated>
    
    <content type="html"><![CDATA[<p>Dijkstra 的好题。</p><span id="more"></span><p>题意：给定一张图，可能询问某点到 1 的最短距离或是给 $c$ 条边的边权加 1。$n, m\leq 10 ^ 5, q\leq 2000, \sum c\leq 10 ^ 6$。</p><p>直接考虑朴素的 Dijkstra，每次我们加边的时候，都暴力重构长度。时间复杂度 $O(mq\log n)$，很卡。<del>标算都卡的很，这还能过？</del></p><p>另一种方法是用 SPFA 代替，时间复杂度 $O(kmq)$，<del>好像被构造卡了</del>。</p><p>10 s 的时间，看样子不是什么特别优的算法，应该是 $O(mq)$。</p><p>似乎只有 BFS 可以做到这个复杂度，01 双端队列似乎可以解决！</p><p>但是我们没有考虑原来的边的边权，这个显然是有问题的，因为对于边权非 1 的情况会处理错误。那么有什么方法呢？</p><p>考虑 Dijkstra 的算法流程：</p><blockquote><ol><li>找到当前未扩展的点中，距离起点最近的点。</li><li>松弛其他点到起点的距离。</li></ol></blockquote><p>在标准的 Dijkstra 算法中，我们使用了一个堆实时维护。我们是否可以找到另外的替代呢？直接考虑最暴力的桶，于是我们得到了一个 $O(m + W)$ 的做法，其中 $W$ 是指最短路的值域范围。</p><p>每次加 $c$ 条边的边权时，到其他所有点的距离变化一定不超过 $\min\{c, n - 1\}$（最短路不超过 $n - 1$ 条边），这启示我们可以使用桶 - Dijkstra 的算法来计算增量。</p><p>但是在一般的认知中，是没有办法求最短路的增量的。可以考虑类似 Johnson 全源最短路的做法，我们设置一条边的新权值为 $e(u, v)’ = e(u, v) + dis(u) - dis(v)$。类似 Johnson 的证明，我们三角不等式易得边权仍然是非负的。而我们走到一个点的时候，他的势能加上他的新图上的距离就是原图上的最短路。而新图的距离是好求的，于是我们可以得到单次 $O(m + W) = O(m)$ 的做法了。总时间复杂度 $O(m\log m + mq)$（开始必须跑一遍 Dijkstra</p><p>注意仍然比较卡常，注意实现细节的错误可能导致 TLE。放一个代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="keyword">int</span>&gt; q[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> Lim = n - <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Lim; ++ i)</span><br><span class="line"><span class="keyword">while</span> (!q[i].<span class="built_in">empty</span>()) q[i].<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) now[i] = n;</span><br><span class="line">q[<span class="number">0</span>].<span class="built_in">push</span>(<span class="number">1</span>), now[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, x; l &lt;= mx; ++ l)</span><br><span class="line"><span class="keyword">while</span> (!q[l].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">x = q[l].<span class="built_in">front</span>();</span><br><span class="line">q[l].<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (now[x] &lt; l) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[i, v] : g[x])</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">chkmin</span>(now[v], <span class="built_in"><span class="keyword">int</span></span>(now[x] + w[i] + d[x] - d[e[i]])) &amp;&amp; now[v] &lt;= Lim)</span><br><span class="line">q[now[v]].<span class="built_in">push</span>(v), <span class="built_in">chkmax</span>(mx, now[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (d[i] &lt; (INF &gt;&gt; <span class="number">1</span>)) d[i] += now[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Dijkstra 的好题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="图论" scheme="https://mydcwfy.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>P7843</title>
    <link href="https://mydcwfy.github.io/2022/04/04/P7843/"/>
    <id>https://mydcwfy.github.io/2022/04/04/P7843/</id>
    <published>2022-04-04T13:28:17.000Z</published>
    <updated>2022-05-05T07:27:45.173Z</updated>
    
    <content type="html"><![CDATA[<p>分治的妙妙题。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给定 $m$ 个双向的 2-SAT 限制（即 $u_i$ 选了 $x_i$ 则 $v_i$ 要选 $y_i$，同样 $v_i$ 选了 $y_i$ 则 $u_i$ 要选$x_i$），$q$ 次询问 $[l, r]$ 最少能划分成多少段有解的 2-SAT 限制。</p><p>$n\leq 10 ^ 5, m\leq 6\times 10 ^ 5, q\leq 10 ^ 6$，时限 2.5 s。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>首先考虑如何判定 2-SAT 限制是否有解，发现这个 Tarjan 实质是在求联通分量（因为有双向边，联通分量一定是强连通分量）。</p><p>那么，我们可以使用一个并查集维护联通性，如果一次之后出现了 $u_i$ 和 $u_i$ 的反面在一个强连通分量，则不合法。</p><p>如何求一个区间最少划分成多少个有解的 2-SAT 问题？这个可以简单的贪心，预处理每一个限制一直向右扩展到哪一处开始不合法（显然不合法之后不可能再合法），前面的显然划为一段，如此贪心。这个贪心过程可以使用倍增优化，也就是说，如果我们能找到从一个限制一直向右扩展到哪一处开始不合法，我们可以倍增跳，做到 $O(q\log n)$ 的复杂度，显然已经足够了。问题在于如何求哪一处开始不合法。</p><p>记 $f(i)$ 为极短的 $[i, f(i)]$ 为无解的限制，这个就类似一个 DP 了。我们发现似乎没有什么方法可以做到比较优的复杂度，因为这个和一般的 DP 又不尽相同。</p><p>考虑 $f(i)$ 的性质，我们发现，$f(i)$ 显然是具有单调性的，这启示我们向 DP 的决策单调性的方向思考。</p><p>类似于决策单调性的求法，我们考虑二分，<code>solve(l, r, sl, sr)</code> 表示处理 $[l, r]$ 之间的$f(i)$，已知答案区间为 $[sl, sr]$。直接计算 $f(mid)$，然后向下递归即可。</p><p>如何计算 $f(mid)$，如果我们暴力向右扩展的话，其实复杂度是错误的。回顾决策单调性的写法与时间复杂度的证明，我们取的时候，必须只能在 $[sl, sr]$ 之间计算，也就是说，我们的时间复杂度应只与 $sr - sl$ 有关。但是这个题，我们发现，如果 $mid &lt; sl$，即使我们知道答案不会出现在这一段区间，我们还是得扫一遍，为后面判断做铺垫，而这造成了错误，使得复杂度不对。如何处理他呢？</p><p>感觉上，这个东西应该是留给上一层计算才对，于是我们强制要求<strong>在 $[r + 1, sl - 1]$ 之间的限制已经被加入并查集了</strong>。这样才能保证我们计算的时候，不会进入多余的无用的计算。递归结束时显然要撤回，所以用可撤销并查集，预处理时间复杂度 $O(m\log m\log n)$，总时间复杂度为 $O(m\log m\log n + q\log n)$。至于为什么不将 $[mid, sl - 1]$ 或是 $[l, sl - 1]$ 加入并查集，是因为这不是 $[l, r]$ 所有节点所必需的，所以先不管。具体在实现部分讲。</p><h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h2><p>这个题由于要保证 $[r + 1, sl - 1]$ 的在进入该层前已经加入了并查集了，所以我们注意我们如果要计算 $f(mid)$，要先将 $[mid, \min{r, sl - 1}]$ 的加入，然后再从 $sl$ 向右扫。如果要向左区间递归，那么 $[mid, sl - 1]$ 的保留（因为向 $[l, mid - 1]$ 递归），所以我们要将第一次加入的边保留。而向右区间，则是 $[r, f(mid) - 1]$，这个直接实现即可。</p><p>考虑复杂度，同整体二分，$O(m\log m)$，加上可撤销并查集，$O(m\log m\log n)$，可以通过。</p><p>注意可能前面上层的就已经不合法了，所以要将前面是否合法并向下递归。还要注意判断自相矛盾的情况。可能比较难写，放一个二分的代码。（到底是什么二分 / 分治呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span> &#123;</span>  &#125; dsu ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> dsu.<span class="built_in">find</span>(x) != dsu.<span class="built_in">find</span>(x ^ <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> sl, <span class="keyword">int</span> sr, <span class="keyword">bool</span> frm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// printf(&quot;Solve [%d, %d] : [%d, %d]\n&quot;, l, r, sl, sr);</span></span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (sl == sr) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++ i) f[i] = sl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, now = frm, st = dsu.top;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &lt;= r &amp;&amp; i &lt; sl; ++ i) &#123;</span><br><span class="line">dsu.<span class="built_in">merge</span>(opt[i].first, opt[i].second);</span><br><span class="line">dsu.<span class="built_in">merge</span>(opt[i].first ^ <span class="number">1</span>, opt[i].second ^ <span class="number">1</span>);</span><br><span class="line">now &amp;= <span class="built_in">check</span>(opt[i].first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> bac = dsu.top, ls = now;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = std::<span class="built_in">max</span>(sl, mid); i &lt;= sr; ++ i) &#123;</span><br><span class="line">dsu.<span class="built_in">merge</span>(opt[i].first, opt[i].second);</span><br><span class="line">dsu.<span class="built_in">merge</span>(opt[i].first ^ <span class="number">1</span>, opt[i].second ^ <span class="number">1</span>);</span><br><span class="line">now &amp;= <span class="built_in">check</span>(opt[i].first);</span><br><span class="line"><span class="keyword">if</span> (!now) &#123;</span><br><span class="line">f[mid] = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (now) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &lt;= r; ++ i) f[i] = m + <span class="number">1</span>;</span><br><span class="line">dsu.<span class="built_in">back</span>(bac);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">solve</span>(l, mid - <span class="number">1</span>, sl, sr, ls), dsu.<span class="built_in">back</span>(st);</span><br><span class="line">&#125;</span><br><span class="line">dsu.<span class="built_in">back</span>(bac), <span class="built_in">solve</span>(l, mid - <span class="number">1</span>, sl, f[mid], ls);</span><br><span class="line">dsu.<span class="built_in">back</span>(st), now = frm;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = std::<span class="built_in">max</span>(sl, r + <span class="number">1</span>); i &lt; f[mid]; ++ i) &#123;</span><br><span class="line">dsu.<span class="built_in">merge</span>(opt[i].first, opt[i].second);</span><br><span class="line">dsu.<span class="built_in">merge</span>(opt[i].first ^ <span class="number">1</span>, opt[i].second ^ <span class="number">1</span>);</span><br><span class="line">now &amp;= <span class="built_in">check</span>(opt[i].first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">solve</span>(mid + <span class="number">1</span>, r, f[mid], sr, now), dsu.<span class="built_in">back</span>(st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>, m, <span class="number">1</span>, m + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;分治的妙妙题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分治" scheme="https://mydcwfy.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="并查集" scheme="https://mydcwfy.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="2-SAT" scheme="https://mydcwfy.github.io/tags/2-SAT/"/>
    
  </entry>
  
  <entry>
    <title>高精度模板</title>
    <link href="https://mydcwfy.github.io/2022/04/04/high-precision/"/>
    <id>https://mydcwfy.github.io/2022/04/04/high-precision/</id>
    <published>2022-04-04T10:36:39.000Z</published>
    <updated>2022-04-04T11:07:17.566Z</updated>
    
    <content type="html"><![CDATA[<p>暂不支持负数，可以支持 NTT 加速。</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Polynomial &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">21</span> | <span class="number">10</span>, Mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> rev[N], wn[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x += x &gt;&gt; <span class="number">31</span> &amp; Mod; &#125;</span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL a, LL k = Mod - <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = a * a % Mod)</span><br><span class="line">(k &amp; <span class="number">1</span>) &amp;&amp; (res = res * a % Mod);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poly_bit</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (len &lt;&lt; <span class="number">1</span>)) bit ++;</span><br><span class="line"><span class="keyword">return</span> bit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poly_rev</span><span class="params">(<span class="keyword">int</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; bit); ++ i)</span><br><span class="line">rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> bit, <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">poly_rev</span>(bit);</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &lt; rev[i]) std::<span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LL ak = <span class="built_in">qpow</span>(inv == <span class="number">1</span> ? <span class="number">3</span> : (Mod + <span class="number">1</span>) / <span class="number">3</span>, (Mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">wn[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mid; ++ i) wn[i] = wn[i - <span class="number">1</span>] * ak % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> *a1 = a + i, *a2 = a + i + mid, *w = wn, *ed = a2; a1 &lt; ed; ++ a1, ++ a2, ++ w)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = *a1, y = *a2 * <span class="built_in">LL</span>(*w) % Mod;</span><br><span class="line">*a1 = <span class="built_in">adj</span>(x + y - Mod), *a2 = <span class="built_in">adj</span>(x - y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inv == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">LL Inv = <span class="built_in">qpow</span>(tot);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = a[i] * Inv % Mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Cannot calculate negative numbers</span></span><br><span class="line"><span class="comment">/// using mul(), qpow() (calculated using NTT) when necesary, otherwise use operator *, pow()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigNumber</span> &#123;</span></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> a[x]; &#125;</span><br><span class="line"><span class="built_in">BigNumber</span>() &#123;  &#125;</span><br><span class="line"><span class="built_in">BigNumber</span>(LL x) &#123; <span class="keyword">while</span> (x) a.<span class="built_in">push_back</span>(x % <span class="number">10</span>), x /= <span class="number">10</span>; <span class="keyword">if</span> (a.<span class="built_in">empty</span>()) a.<span class="built_in">push_back</span>(<span class="number">0</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">len</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a.<span class="built_in">size</span>(); &#125;</span><br><span class="line"><span class="keyword">friend</span> BigNumber <span class="keyword">operator</span> +(BigNumber a, BigNumber b)</span><br><span class="line">&#123;</span><br><span class="line">BigNumber res;</span><br><span class="line">res.a.<span class="built_in">resize</span>(std::<span class="built_in">max</span>(a.<span class="built_in">len</span>(), b.<span class="built_in">len</span>()) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>, sz = a.<span class="built_in">len</span>() + b.<span class="built_in">len</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++ i)</span><br><span class="line">t += a[i] + b[i], res[i] = t % <span class="number">10</span>, t /= <span class="number">10</span>;</span><br><span class="line"><span class="built_in">assert</span>(!t);</span><br><span class="line"><span class="keyword">while</span> (res.<span class="built_in">len</span>() &gt; <span class="number">1</span> &amp;&amp; !res.a.<span class="built_in">back</span>()) res.a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> BigNumber <span class="keyword">operator</span> +(LL a, BigNumber b) &#123; <span class="keyword">return</span> <span class="built_in">BigNumber</span>(a) + b; &#125;</span><br><span class="line"><span class="keyword">friend</span> BigNumber <span class="keyword">operator</span> +(BigNumber b, LL a) &#123; <span class="keyword">return</span> <span class="built_in">BigNumber</span>(a) + b; &#125;</span><br><span class="line">BigNumber&amp; <span class="keyword">operator</span> +=(BigNumber b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> + b; &#125;</span><br><span class="line">BigNumber&amp; <span class="keyword">operator</span> +=(LL b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> + b; &#125;</span><br><span class="line"><span class="keyword">friend</span> BigNumber <span class="keyword">operator</span> *(BigNumber a, BigNumber b)</span><br><span class="line">&#123;</span><br><span class="line">BigNumber res;</span><br><span class="line">res.a.<span class="built_in">resize</span>(a.<span class="built_in">len</span>() + b.<span class="built_in">len</span>() + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">len</span>(); ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.<span class="built_in">len</span>(); ++ j)</span><br><span class="line">res[i + j] += a[i] * b[j];</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">len</span>(); ++ i) t += res[i], res[i] = t % <span class="number">10</span>, t /= <span class="number">10</span>;</span><br><span class="line"><span class="built_in">assert</span>(!t);</span><br><span class="line"><span class="keyword">while</span> (res.<span class="built_in">len</span>() &gt; <span class="number">1</span> &amp;&amp; !res.a.<span class="built_in">back</span>()) res.a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> BigNumber <span class="keyword">operator</span> *(BigNumber a, LL b) &#123; <span class="keyword">return</span> a * <span class="built_in">BigNumber</span>(b); &#125;</span><br><span class="line">BigNumber&amp; <span class="keyword">operator</span> *=(BigNumber b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> * b; &#125;</span><br><span class="line">BigNumber&amp; <span class="keyword">operator</span> *=(LL b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> * <span class="built_in">BigNumber</span>(b); &#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(BigNumber a, BigNumber b) &#123; <span class="keyword">return</span> a.a == b.a; &#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(BigNumber a, BigNumber b) &#123;</span><br><span class="line"><span class="keyword">if</span> (a.<span class="built_in">len</span>() ^ b.<span class="built_in">len</span>()) <span class="keyword">return</span> a.<span class="built_in">len</span>() &lt; b.<span class="built_in">len</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = a.<span class="built_in">len</span>() - <span class="number">1</span>; ~j; -- j)</span><br><span class="line"><span class="keyword">if</span> (a[j] ^ b[j]) <span class="keyword">return</span> a[j] &lt; b[j];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;(BigNumber a, BigNumber b) &#123; <span class="keyword">return</span> b &lt; a; &#125;</span><br><span class="line"><span class="keyword">friend</span> BigNumber <span class="keyword">operator</span> -(BigNumber a, BigNumber b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(a &gt; b || a == b);</span><br><span class="line">BigNumber res;</span><br><span class="line">res.a.<span class="built_in">resize</span>(a.<span class="built_in">len</span>()), b.a.<span class="built_in">resize</span>(a.<span class="built_in">len</span>());</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">len</span>(); ++ i)</span><br><span class="line">t += a[i] - b[i], t += <span class="number">1000</span>, res[i] = t % <span class="number">10</span>, t /= <span class="number">10</span>, t -= <span class="number">100</span>;</span><br><span class="line"><span class="built_in">assert</span>(!t);</span><br><span class="line"><span class="keyword">while</span> (res.<span class="built_in">len</span>() &gt; <span class="number">1</span> &amp;&amp; !res.a.<span class="built_in">back</span>()) res.a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">BigNumber <span class="keyword">operator</span> -(LL b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> - <span class="built_in">BigNumber</span>(b); &#125;</span><br><span class="line">BigNumber&amp; <span class="keyword">operator</span> -=(BigNumber b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> - b; &#125;</span><br><span class="line">BigNumber&amp; <span class="keyword">operator</span> -=(LL b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> - <span class="built_in">BigNumber</span>(b); &#125;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> BigNumber <span class="title">mul</span><span class="params">(BigNumber a, BigNumber b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Polynomial;</span><br><span class="line"><span class="keyword">int</span> bit = <span class="built_in">poly_bit</span>(std::<span class="built_in">max</span>(a.<span class="built_in">len</span>(), b.<span class="built_in">len</span>()) + <span class="number">1</span>), tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">a.a.<span class="built_in">resize</span>(tot), b.a.<span class="built_in">resize</span>(tot), <span class="built_in">NTT</span>(a.a.<span class="built_in">data</span>(), bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b.a.<span class="built_in">data</span>(), bit, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = (LL)a[i] * b[i] % Mod;</span><br><span class="line"><span class="built_in">NTT</span>(a.a.<span class="built_in">data</span>(), bit, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">len</span>(); ++ i) t += a[i], a[i] = t % <span class="number">10</span>, t /= <span class="number">10</span>;</span><br><span class="line"><span class="built_in">assert</span>(!t);</span><br><span class="line"><span class="keyword">while</span> (a.a.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; !a.a.<span class="built_in">back</span>()) a.a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">friend</span> BigNumber <span class="title">pow</span><span class="params">(BigNumber a, LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">BigNumber <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>, a = a * a)</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) res = res * a;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">friend</span> BigNumber <span class="title">qpow</span><span class="params">(BigNumber a, LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">BigNumber <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>, a = <span class="built_in">mul</span>(a, a))</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) res = <span class="built_in">mul</span>(res, a);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) ;</span><br><span class="line">a.<span class="built_in">push_back</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) a.<span class="built_in">push_back</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">std::<span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">len</span>() - <span class="number">1</span>; ~j; -- j) <span class="built_in">putchar</span>(a[j] | <span class="number">48</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span> &gt;&gt;(std::istream &amp;is, BigNumber &amp;t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> &amp;a = t.a;</span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ((is &gt;&gt; c, c) &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) ;</span><br><span class="line">a.<span class="built_in">push_back</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> ((is &gt;&gt; c, c) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) a.<span class="built_in">push_back</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">std::<span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt;(std::ostream &amp;os, BigNumber t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l = t.<span class="built_in">len</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; ~i; -- i) os &lt;&lt; t[i];</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;暂不支持负数，可以支持 NTT 加速。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>狄利克雷生成函数</title>
    <link href="https://mydcwfy.github.io/2022/04/02/Dirichlet-generating-function/"/>
    <id>https://mydcwfy.github.io/2022/04/02/Dirichlet-generating-function/</id>
    <published>2022-04-01T23:40:53.000Z</published>
    <updated>2022-04-02T02:53:17.838Z</updated>
    
    <content type="html"><![CDATA[<p>解决数论函数的有利武器。</p><span id="more"></span><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>定义一个数列的<strong>狄利克雷生成函数</strong>（DGF）为：<br>$$<br>\tilde F(x) = \sum_{i\geq 1} \dfrac{f_i}{i^x}<br>$$<br>我们如果将 ${f_i}$ 看作是一个从 $\mathbb N _ +$ 到 $\mathbb Z$ 的一个函数，那么该生成函数就与一个数论函数相对应。一般来说，$f_1 = 1$。下文默认 $f_1 = 1$。</p><p>如果该函数是积性的，即满足 $\forall i\bot j, f(ij) = f(i) \times f(j)$，那么 $\tilde F(x)$ 的表达可以由质数以及质数的幂的值来表达，记作（设 $P$ 表示全体质数集合）：<br>$$<br>\tilde F(x) = \prod_{p\in P}(1 + \dfrac {f(p)}{p ^ x} + \dfrac{f(p) ^ 2}{p ^ {2x}} + …)<br>$$</p><h2 id="2-狄利克雷函数的卷积"><a href="#2-狄利克雷函数的卷积" class="headerlink" title="2. 狄利克雷函数的卷积"></a>2. 狄利克雷函数的卷积</h2><p>就是一个简单的定义。</p><p>定义：<br>$$<br>\tilde F(x)\tilde G(x) = \sum_{ij}\dfrac {f(i)g(j)}{ij}<br>$$<br>这个和 $(f * g)(x) = \sum_{d | x}f(d)g(\dfrac xd)$ 是相同的。</p><h2 id="3-常见函数"><a href="#3-常见函数" class="headerlink" title="3. 常见函数"></a>3. 常见函数</h2><h3 id="1）常值函数"><a href="#1）常值函数" class="headerlink" title="1）常值函数"></a>1）常值函数</h3><p>在数论中，我们常见到 $I(x) = 1$ 的函数，即 ${1, 1, 1, …}$ 的数列。他的 DGF 为<strong>黎曼函数</strong>，记作 $\zeta (x)$。</p><p>常值函数显然也是积性函数，我们尝试使用质数及质数的幂的值来表达，即：<br>$$<br>\tilde F(x) = \prod_{p\in P}(1 + \dfrac 1{p ^ x} + \dfrac 1{p ^ {2x}} + …)<br>$$<br>我们将质数内部的用等比数列求和展开，公比 $p^{-x}$，即为：<br>$$<br>1 + \dfrac 1{p ^ x} + \dfrac 1{p ^ {2x}} + … = \dfrac{-1}{p ^ {-x} - 1} = \dfrac 1{1 - p^{-x}}<br>$$<br>那么，我们得到黎曼函数的另外的表达方式：<br>$$<br>\zeta(x) = \prod_{p\in P}\dfrac 1{1 - p ^ {-x}}<br>$$</p><h3 id="2）标号函数"><a href="#2）标号函数" class="headerlink" title="2）标号函数"></a>2）标号函数</h3><p>（记不得叫什么了</p><p>定义 $id(x) = x$，那么我们来探究一下 ${1, 2, 3\dots}$ 的 DGF。</p><p>还是根据积性函数的性质，我们可以得到：<br>$$<br>\tilde F(x) = \prod_{p\in P}(1 + \dfrac{p}{p ^ x} + \dfrac{p ^ 2}{p ^ {2x}}+ \dots)<br>$$<br>等比数列求和，可以得到：<br>$$<br>\tilde F(x) = \prod_{p\in P}\dfrac 1{1 - p ^ {1 - x}}<br>$$<br>而这个由可以表示成黎曼函数：<br>$$<br>\tilde F(x) = \zeta(x - 1)<br>$$<br>如果我们将这个换成 $id ^ k(x) = x ^ k$，那么答案就是：<br>$$<br>\tilde F(x) = \prod_{p\in P}\dfrac 1{1 - p ^ {k - x}} = \zeta(x - k)<br>$$</p><h3 id="3）莫比乌斯函数"><a href="#3）莫比乌斯函数" class="headerlink" title="3）莫比乌斯函数"></a>3）莫比乌斯函数</h3><p>对于一般的函数，我们通常讨论在质数点的取值来得到 DGF。<br>$$<br>\tilde F(x) = \prod_{p\in P}(1 + \dfrac{-1}{p ^ x}) = \prod_{p\in P}\dfrac{p ^ x - 1}{p ^ x}<br>$$<br>这个怎样用黎曼函数表示呢？</p><p>发现 $\displaystyle \dfrac 1{\tilde F(x)} = \prod_{p\in P}\dfrac{p ^ x}{p ^ x - 1} = \prod_{p\in P}\dfrac 1{1 - p ^ {-x}} = \zeta(x)$，所以 $\tilde F(x) = \dfrac 1{\zeta(x)}$。</p><h3 id="4）欧拉函数"><a href="#4）欧拉函数" class="headerlink" title="4）欧拉函数"></a>4）欧拉函数</h3><p>同样，直接上式子：<br>$$<br>\tilde F(x) = \prod_{p\in P}(1 + \dfrac{p - 1}{p ^ x} + \dfrac{p(p - 1)}{p ^ {2x}} + \dfrac{p ^ 2(p - 1)}{p ^ {3x}} + \dots)<br>$$<br>我们直接考虑先改成封闭形式：<br>$$<br>\begin{aligned}<br>\tilde F(x) &amp;= \prod_{p\in P}(1 + \dfrac{p}{p ^ x} + \dfrac{p ^ 2}{p ^ {2x}} + \dots - \dfrac{1}{p ^ x} (1 + \dfrac{p}{p ^ x} + …))<br>\\&amp;= \prod_{p\in P}(\dfrac 1{1 - p ^ {1 - x}} - \dfrac{p ^ {-x}}{1 - p ^ {1 - x}}) \\ &amp;= \prod_{p\in P}\dfrac{1 - p ^ {-x}}{1 - p ^ {1 - x}}<br>\\ &amp;= \dfrac{\zeta(x - 1)}{\zeta(x)}<br>\end{aligned}<br>$$<br>那么，这个和 $id^0 = I$ 卷积，就可以得到：$\dfrac{\zeta(x - 1)}{\zeta(x)} * \zeta(x) = \zeta(x - 1)$。这对应着 $id(x)$。</p><h3 id="5）约数-k-次幂"><a href="#5）约数-k-次幂" class="headerlink" title="5）约数 k 次幂"></a>5）约数 k 次幂</h3><p>首先定义 $\sigma_0(x) = \sum_{d | x}$，表示约数个数。而 $\sigma_k(x) = \sum_{d | x}d ^ k$。这里给出 $\sigma_1(k)$ 的推导。<br>$$<br>\begin{aligned}<br>\tilde F(x) &amp;= \prod_{p\in P}(1 + \dfrac{p ^ 2 - 1}{p ^ x(p - 1)} + \dfrac{p ^ 3 - 1}{p ^ {2x}(p - 1)} + \dots)<br>\\ &amp;= \prod_{p\in P}\dfrac 1{p - 1}((\dfrac{p}{p ^ {0x}} + \dfrac{p ^ 2}{p ^ x} + \dots) - (\dfrac{1}{p ^ {0x}} + \dfrac{1}{p ^ {x}} + \dots))<br>\\ &amp;= \prod_{p \in P}\dfrac 1{p - 1}(\dfrac{p}{1 - p ^ {1 - x}} - \dfrac{1}{1 - p ^ {-x}})<br>\\ &amp;= \prod_{p\in P}\dfrac 1{p - 1}\dfrac{p - 1}{(1 - p ^ {1 - x})(1 - p ^ {-x})}<br>\\ &amp;= \prod_{p\in P}\dfrac{1}{(1 - p^{-x})(1 - p^{1 - x})}<br>\\ &amp;= \zeta(x)\zeta(x - 1)<br>\end{aligned}<br>$$<br>而对于 $\sigma_k(x) = \sum_{d | x}d ^ k$，我们有：$\tilde F(x) = \zeta(x)\zeta(x - k)$。本处证明略去。</p><h3 id="6）乘上-x-k"><a href="#6）乘上-x-k" class="headerlink" title="6）乘上  $x^k$"></a>6）乘上  $x^k$</h3><p><strong>结论：</strong>若 $f(x)$ 的 DGF 是 $\tilde F(x)$，那么 $g(x) = f(x)\times x ^ k$ 的 DGF 是 $\tilde G(x) = \tilde F(x - k)$。这个可以通过改变质数处的取值得到。证明略去。</p><h2 id="4-例题"><a href="#4-例题" class="headerlink" title="4. 例题"></a>4. 例题</h2><h3 id="T1：简单的数学题"><a href="#T1：简单的数学题" class="headerlink" title="T1：简单的数学题"></a>T1：简单的数学题</h3><p>求 $\sum_{i = 1}^n i ^ 2\varphi(i)$，使用杜教筛。</p><p>直接使用 $\tilde F(x) = \dfrac{\zeta(x - 3)}{\zeta(x - 2)}$，那么 $f(i) * id^2(i) = id^3(i)$。直接筛就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">get_sphi</span><span class="params">(LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; N) <span class="keyword">return</span> sphi[n];</span><br><span class="line"><span class="keyword">if</span> (Sphi.<span class="built_in">find</span>(n) != Sphi.<span class="built_in">end</span>()) <span class="keyword">return</span> Sphi[n];</span><br><span class="line">LL ans = <span class="built_in">sum3</span>(n);</span><br><span class="line"><span class="keyword">for</span> (ll l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">ans = (-(<span class="built_in">sum2</span>(r) - <span class="built_in">sum2</span>(l - <span class="number">1</span>)) * <span class="built_in">get_sphi</span>(n / l) % Mod + ans + Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Sphi[n] = ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;解决数论函数的有利武器。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>NOI Online 2022 游记</title>
    <link href="https://mydcwfy.github.io/2022/04/01/NOI-Online-2022/"/>
    <id>https://mydcwfy.github.io/2022/04/01/NOI-Online-2022/</id>
    <published>2022-04-01T10:25:26.000Z</published>
    <updated>2022-04-01T23:46:30.026Z</updated>
    
    <content type="html"><![CDATA[<p>考的似乎比较套路，没有去年的思维 / 数学。</p><span id="more"></span><p>以考试当天为 Day 0。</p><h2 id="Day-？"><a href="#Day-？" class="headerlink" title="Day ？"></a>Day ？</h2><p>很早就报名了，都快忘记这件事了（</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>在学校考试。</p><p>校内又说什么要占机房考试，好不容易在 8：20 的时候才到机房安心坐下来。</p><p>8：30 开题，还好没咕，不像 NOI 线上，一个小时还没拿到题。</p><p>结果盯着 T1 发呆了许久，满脑子里都是二维数点 $O(n\log^2 n)$，根本做不了这题。半个小时过去了，没有任何收获。</p><p>意识到事情没对，马上开 T2，发现是一个输出一个方案即可的题，似乎哪年 NOI 考过这样的题，还是随机化过去的？</p><p>tg 应该不是这类题目，推了推性质，发现可以按 <code>size</code> 分类，相同 <code>size</code> 的只可能不交或是完全相同，否则一定合法。</p><p>胡了一个只用判 <code>size</code> 相邻的做法，发现没对，可以按 <code>size</code> 倒序插入，用桶维护哪个点被那个集合覆盖，如果新来的一个集合覆盖的颜色不止一种，一定合法。</p><p>赛时没想清楚，随便输出一个颜色，考后才发现要输出不同颜色中 <code>size</code> 最小的。</p><p>写完 T2，过样例，由于不会造数据，只好跳过。此时 10：10。</p><p>发现 T3 似乎是一个简单题，拆一拆贡献，记录每一个位置的数被统计为最大值 / 最小值了多少次，发现剩下的是一个三维偏序（才没想什么还可以转化为二维偏序的方法），可以 $O(n\log^2 n)$，做 8 次，感觉有点卡。</p><p>马上开始码，还算顺利，没调多久就过了所有样例，极限数据 1.79 s，感觉很稳。</p><p>回过头来看 T1，已是 10：50。大力猜一手结论，应该是直接找到后面第一个比自己大的，然后如果颜色相同一直向前跳，扫描线处理询问，可以做到 $O(n\log n)$（不算向前跳的假的复杂度）。</p><p>发现要码 2 个线段树，心态不好，看到自己只有 30 min 左右的时间了，结果写完死活过不了大样例，此时已经是 11：40 了。</p><p>发现中间有一步不应该将因颜色相同而跳过的点删去，改了过后，过了大样例，还只要 0.5 s，马上交上去，11：47。</p><p>跳了过程可以用并查集优化，快速码了一个，11：51，<del>发现自己 AK 了</del>，<strong>交不上去了！</strong></p><p>最后 10 min 中，在狂躁之中度过，发现一点转机都没有，守到 12 点，唉声叹气地走了。</p><p>出来议论，发现一些人做出来 T1 了，连低一个年级的同学都有人做出来。可惜我没交上去（悲</p><p>但是大家似乎没做出来 T3，似乎随便写写，得了个暴力 + 部分分。赶紧去食堂吃饭了。</p><p>下午还得考试，又回到机房，12：28，了转反，<strong>考试延期了半个小时！</strong></p><p>确认一下是不是真的，马上将自己的 T1 交了上去。不知道自己怎么样了呢。</p><p>水了一会，又去看各大 OJ 有没有测的，发现 InfOJ 可以测，<del>但是已经排了 24 页的提交记录了</del>。</p><p>13：30 左右，lg 可以测了，发现 T1，T2，T3 都过了，心态很不错。看到 T2 有人说要取 <code>size</code> 最小的，没在意。</p><p>等到看到 InfOJ 可以测 T2 时，发现只有 Subtask 2 没过，连 Subtask 6 都过了，80 pts。我相信 CCF 的数据应该不强（flag</p><p>lg 加强了几次 T2 数据，结果随便就过了，不知道该相信哪边（<del>事后看显然是 InfOJ</del></p><p>等 CCF 数据。</p><h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><p>看到 CCF 出了一个“成绩公示”，结果什么都是访问异常，啥也看不到。</p><p>看到有人说用另外的网址可以看到成绩，<strong>开幕雷击</strong>，一车人直接 AK 了！</p><p>发现 CCF 数据实在是强，直接 10 个点卡了我四个点，T2 直接 60 pts，和随机化寻找一个分了（<del>我可是写挂了正解呀</del></p><p>$100 + 60 + 100 = 260$。</p><p>结果 lg 上一车人说数据过水，痛苦面具。水一点该多好啊，<del>难得接近 AK 一次</del>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于这种偏结论或乱搞的题目，感觉自己很多细节没有想清楚，这种东西赛时很难检查到，赛后后悔也来不及了。还是多做这种结论题吧。</p><p>还有，怎么没考 DP？一考大概率裂开。</p><p>等联合省选。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;考的似乎比较套路，没有去年的思维 / 数学。&lt;/p&gt;</summary>
    
    
    
    
    <category term="游记" scheme="https://mydcwfy.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF Round#775</title>
    <link href="https://mydcwfy.github.io/2022/03/08/CF-Round-775/"/>
    <id>https://mydcwfy.github.io/2022/03/08/CF-Round-775/</id>
    <published>2022-03-08T10:30:50.000Z</published>
    <updated>2022-03-08T12:38:20.701Z</updated>
    
    <content type="html"><![CDATA[<p>状态不错，F 只想得到线段树，思路还没清晰，就结束了……</p><p>比赛记录：ABCDE Accepted，Scores：6328，Rank #7，Rating 1663 -&gt; 1962。</p><p>改题进度：ABCDE Accepted。</p><p><a href="https://codeforces.com/contest/1649/">比赛传送门</a></p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h3><p>题意不描述了。</p><p>签到题，从左端点一直向右走，从右端点一直向左走，遇上了就是 0，否则答案就是两点距离。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n &amp;&amp; a[i]) i ++;</span><br><span class="line"><span class="keyword">if</span> (i &gt; n) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j = n;</span><br><span class="line"><span class="keyword">while</span> (j &amp;&amp; a[j]) j --;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, j - i + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B."></a>B.</h3><p>题意：有 $n$ 个人传球，已知每个人传出的次数，可以拿到球后不传，问至少要多少个球。</p><p>考虑贪心，要满足传出次数最多的人，就让剩下的人都传给他，如果还不能满足，剩余的传出次数，每一个都要一个球。否则一个球就可以完成。</p><p>注意特判全是 0 的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) flag |= !!a[i];</span><br><span class="line"><span class="keyword">if</span> (!flag) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">LL sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) sum += a[i];</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">LL</span>(*std::<span class="built_in">max_element</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>)) &lt;&lt; <span class="number">1</span>) &lt;= sum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="number">2LL</span> * (*std::<span class="built_in">max_element</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>)) - sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h3><p>题意：给出 $n\times m$ 的矩形，每个点有一个颜色，求所有颜色相同的点两两之间的曼哈顿距离和。$n\times m \leq 10^5,c_{i, j}\leq 10^5$。</p><p>也许我的做法劣一些，但是也不慢，多一只 $\log$。</p><p>考虑将所有颜色相同的点按 $x$ 排序，统计答案的时候，由 $y$ 的情况分为两种：$y \leq y_{now}, y &gt; y_{now}$。分别用树状数组维护即可，时间复杂度 $O(nm\log m)$。</p><p>似乎可以直接拆贡献计算做到 $O(nm)$？没管。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span>  &#125; f, g, cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt; N; ++ c)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : al[c]) &#123;</span><br><span class="line">res += (LL)cnt.<span class="built_in">ask</span>(p.y) * (p.x + p.y) + f.<span class="built_in">ask</span>(p.y);</span><br><span class="line">res += (LL)(cnt.<span class="built_in">ask</span>(m) - cnt.<span class="built_in">ask</span>(p.y)) * (p.x - p.y) + (g.<span class="built_in">ask</span>(m) - g.<span class="built_in">ask</span>(p.y));</span><br><span class="line">f.<span class="built_in">add</span>(p.y, -p.x - p.y), g.<span class="built_in">add</span>(p.y, p.y - p.x), cnt.<span class="built_in">add</span>(p.y, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : al[c]) &#123;</span><br><span class="line">f.<span class="built_in">add</span>(p.y, p.x + p.y), g.<span class="built_in">add</span>(p.y, p.x - p.y), cnt.<span class="built_in">add</span>(p.y, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D."></a>D.</h3><p>题意：判断一个集合是否满足 $\forall x, y\in S\land x\geq y, s.t. \left\lfloor\dfrac xy \right\rfloor \in S$。$|S|\leq 10^6, \forall x \in S, x\leq 10^6$。</p><p>暴力枚举显然是 $O(n ^ 2)$ 的。</p><p>我们可以考虑枚举 $x$ 和 $\left\lfloor\dfrac yx\right\rfloor = k$，如果 $x$ 存在，$[kx, (k + 1)x)$ 中间也有数，那么 $k$ 必须存在，否则不合法。</p><p>看似是 $O(n ^ 2)$ 的，但是我们发现对于每个 $x$，需要枚举的 $k$ 仅为 $\dfrac{C}{x}$，其中 $C$ 为最大的数。</p><p>所以时间复杂度为 $O(C + \dfrac C2 + \dfrac C3 + …)$，为调和级数，$O(C\ln C)$。</p><p>至于怎么统计一个区间出现过没有数，直接前缀和即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++ i) h[i] += h[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++ i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = i, r, j = <span class="number">0</span>; l &lt;= c; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (h[i] == h[i - <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">r = std::<span class="built_in">min</span>(c, l + i - <span class="number">1</span>), j ++;</span><br><span class="line"><span class="keyword">if</span> (h[r] == h[l - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (h[j] == h[j - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E."></a>E.</h3><p>题意：给定由数字组成的字符串 $s$ 和 $t$，求有多少种重排后的 $s$ 满足 $s$ 的字典序小于 $t$，答案对 998244353 取模。$|s|, |t|\leq 2\cdot 10^5, s_i, t_i\leq 2\cdot 10^5$。</p><p>比较思维的一个组合计数，但不是特别难。</p><p>考虑类似数位 DP 的方法，枚举出现差异为第 $i$ 位，那么前 $i - 1$ 项都是相同的。</p><p>假设我们暴力的话，我们枚举 $i$ 填入的数，显然填入的数 $x &lt; b_i$，那么剩下的位置就可以随意组织了。因为有重复元素，不直接是阶乘，而是：<br>$$<br>ans = \dfrac{(n - i)!}{cnt_1!cnt_2!cnt_3!…}<br>$$<br>现在我们考虑快速将所有填入的 $x$ 的答案全部统计了。</p><p>假设我们不限制这一位，答案是：<br>$$<br>ans = \dfrac{(n - i + 1)!}{cnt_1!cnt_2!…cnt_x!…}<br>$$<br>限制之后，答案是：<br>$$<br>ans = \dfrac{(n - i)!}{cnt_1!cnt_2!…(cnt_x - 1)!…}<br>$$<br>所以我们要在原来的基础上乘以 $\dfrac{cnt_x}{n - i + 1}$。</p><p>所以我们直接维护 $cnt_x$ 的前缀和，用树状数组就可以在 $O(\log n)$ 的时间内维护。</p><p>至于如何维护不限制情况下的答案，我们也可以使用类似的办法。</p><p>填这一位之前：<br>$$<br>ans = \dfrac{(n - i + 1)!}{cnt_1!cnt_2!…cnt_x!…}<br>$$<br>假设 $b_i = x$，也就是我们要填入 $x$，那么答案变为了：<br>$$<br>ans = \dfrac{(n - i)!}{cnt_1!cnt_2!…(cnt_x - 1)!…}<br>$$<br>所以答案乘上了 $\dfrac{cnt_x}{n - i + 1}$，先维护每个数的逆元就可以 $O(1)$ 维护了。</p><p>可能无法在 $i$ 处填入 $b_i$，注意要快速退出。</p><p>注意如果 $n &lt; m$ 且前 $n$ 个都可以填入，答案要加 1（因为前面一样，长度小的排前面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span>  &#125; bt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = std::<span class="built_in">min</span>(n, m);</span><br><span class="line">LL res = <span class="number">0</span>, now = fact[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cnt[a[i]] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) now = now * infact[cnt[i]] % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) bt.<span class="built_in">add</span>(i, cnt[i]);</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">res = (res + bt.<span class="built_in">ask</span>(b[i] - <span class="number">1</span>) * now % Mod * inv[n - i + <span class="number">1</span>]) % Mod;</span><br><span class="line"><span class="keyword">if</span> (!cnt[b[i]]) &#123;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">bt.<span class="built_in">add</span>(b[i], <span class="number">-1</span>), now = now * inv[n - i + <span class="number">1</span>] % Mod * (cnt[b[i]] --) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (res + ((n &lt; m) &amp;&amp; flag)) % Mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;状态不错，F 只想得到线段树，思路还没清晰，就结束了……&lt;/p&gt;
&lt;p&gt;比赛记录：ABCDE Accepted，Scores：6328，Rank #7，Rating 1663 -&amp;gt; 1962。&lt;/p&gt;
&lt;p&gt;改题进度：ABCDE Accepted。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1649/&quot;&gt;比赛传送门&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>CF Round#773</title>
    <link href="https://mydcwfy.github.io/2022/02/25/CF-Round-773/"/>
    <id>https://mydcwfy.github.io/2022/02/25/CF-Round-773/</id>
    <published>2022-02-25T11:55:12.000Z</published>
    <updated>2022-02-25T13:54:48.552Z</updated>
    
    <content type="html"><![CDATA[<p>Div 2 当场降智，直接变成了 SpeedForces 了。</p><p>比赛记录：ABC Accepted，Scores：2247，Rank：872。</p><p>改题进度：ABCF Accepted。</p><span id="more"></span><h4 id="A"><a href="#A" class="headerlink" title="A"></a>A</h4><p>题意：给一个三角形，求不能通过不穿过三角形的直线到达 y 轴的线段长度。</p><p>显然如果想要不能到达 y 轴，一定是平行于 y 轴的线才有可能。</p><p>如果第三个点在这两个点的上方，答案也显然是 0：</p><img src="/2022/02/25/CF-Round-773/A.png" class=""><p>按 y 坐标排序即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PDD p[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++ i)</span><br><span class="line">std::cin &gt;&gt; p[i].first &gt;&gt; p[i].second;</span><br><span class="line">std::<span class="built_in">sort</span>(p, p + <span class="number">3</span>, [](PDD a, PDD b) &#123; <span class="keyword">return</span> a.second &lt; b.second ;&#125;);</span><br><span class="line"><span class="keyword">if</span> (p[<span class="number">1</span>].second != p[<span class="number">2</span>].second) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>, std::<span class="built_in">abs</span>(p[<span class="number">1</span>].first - p[<span class="number">2</span>].first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B"><a href="#B" class="headerlink" title="B"></a>B</h4><p>题意：给一个长度为 $n$ 的数组，对于每一个 $k\in[1, n]$，求出划分为 $k$ 个集合后，求每一个集合的不同元素的个数总和的最小值。</p><p>显然我们将相同的元素放在一起，答案也至少是这个数组中数的不同的个数 $j$。</p><p>显然答案 $\geq k$。尝试证明答案 $ans_k = \max(k, j)$。</p><p>当 $k &lt; j$ 的时候，我们将相同的放在一起，会出现 $j$ 个集合，然后任意合并一些，答案不变，所以 $ans_k = j$。</p><p>当 $k \geq j$ 的时候，我们仍然将相同的放在一起，然后操作 $k - j$ 次，每一次分裂一个集合。显然答案每次加 1，总答案为 $j + (k - j) = k$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (a[i] != a[i - <span class="number">1</span>]) cnt ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, cnt);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cnt + <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br></pre></td></tr></table></figure><h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><p>题意：定义一个数列是好的，为可以划分为 $\dfrac n2$ 对（显然 $n$ 为偶数），每一对中两数之商为 $x$。给一个序列，添加最少的数使得序列是好的。$n\leq 2\cdot 10^5,2\leq x \leq10^6$。</p><p>我们直接找到可以匹配的最大对数，让剩下的每一个都加一个数与之匹配即可。问题转化为求最大匹配数。</p><p>直接将所有数扔入一个 <code>multiset</code>，然后从小向大枚举。如果还没有匹配的话，说明不能和小的匹配，直接找一个 $a_i \cdot x$，看一下有没有，有就删一个。</p><p>最后直接输出 <code>multiset</code> 的 <code>size()</code> 即可。</p><p>注意如果只删一个数，应该写为 <code>erase(find(x))</code> 而不是 <code>erase(x)</code>，那样会删掉所有的相同元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::multiset&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>(); iter ++)</span><br><span class="line">&#123;</span><br><span class="line">LL now = *iter;</span><br><span class="line"><span class="keyword">auto</span> t = a.<span class="built_in">find</span>(now * x);</span><br><span class="line"><span class="keyword">if</span> (t != a.<span class="built_in">end</span>()) a.<span class="built_in">erase</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in"><span class="keyword">int</span></span>(a.<span class="built_in">size</span>()));</span><br></pre></td></tr></table></figure><h4 id="F"><a href="#F" class="headerlink" title="F"></a>F</h4><p>给定 $n$ 个长度为 $m$ 的数组，每个数组有一个权值 $w$，找到两个数组使得数字没有重复，求这两个数组权值和的最小值。$n \leq 10^5, m\leq 5$，保证一个数组内数字没有重复。</p><p>比赛直接降智，胡了个错误的 Tarjan，没想到暴力就过去了……</p><p>笔者也不会题解主要介绍的方法 $O(n2^m)$，但是 $O(\dfrac{n^2m}\omega)$ 的算法就是香啊！</p><p>我们直接考虑暴力怎么做：直接枚举每一个数，将包含这个数的所有数组互相都设为不可用。即开一个二维 <code>boolean</code> 数组，$a[i][j]$ 表示 $i, j$ 数组能不能选在一起。枚举每一个数时，设包含这个数的数组集合为 $S$，则 $[i \in S][j \in S] a[i][j] \leftarrow 0$。</p><p>看到我们只用枚举每个数，我们可以先存下来每一个数对应的 $S$（？，然后枚举到一个数组的时候，直接 &amp;$S$ 即可。时空复杂度均为 $O(\dfrac{n^2m}\omega)$，然后就成功 MLE（还不是最惨的，我加了些优化，变为了 $O(\dfrac {n^2}\omega)$）：</p><img src="/2022/02/25/CF-Round-773/F_submission.png" class=""><p>怎么办呢？</p><p>我们发现，有很多 $S$ 只有一两个位置有 $1$，但是我们却存了不知多少个 0。我们直接考虑设定阈值 $T$，当 $\mid S \mid \leq T$ 时我们直接让 $S$ 暴力更新即可。可以发现，最多有 $\dfrac {nm}T$ 个数我们要开 $\text{bitset}$，所以空间复杂度为 $O(nm + \dfrac{n^2m}{T\omega})$，时间复杂度为 $O(nmT + \dfrac{n^2m}{w})$，取 $T = 500\sim 1000$ 比较合适的样子。（但是我开的 50 也过了</p><p>注意指针等的使用，可能有些难写，给出整个代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, Block = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arr</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>], w;</span><br><span class="line">&#125; c[N];</span><br><span class="line">std::bitset&lt;N&gt; bt[<span class="number">505</span>], tmp, *bk[N &lt;&lt; <span class="number">3</span>], *it = bt;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; al, ha[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">al.<span class="built_in">reserve</span>(n * m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i].a[j]);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i].w);</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(c + <span class="number">1</span>, c + n + <span class="number">1</span>, [&amp;](<span class="keyword">const</span> Arr &amp;c1, <span class="keyword">const</span> Arr &amp;c2) &#123; <span class="keyword">return</span> c1.w &lt; c2.w; &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">al.<span class="built_in">push_back</span>(c[i].a[j]);</span><br><span class="line">std::<span class="built_in">sort</span>(al.<span class="built_in">begin</span>(), al.<span class="built_in">end</span>());</span><br><span class="line">al.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(al.<span class="built_in">begin</span>(), al.<span class="built_in">end</span>()), al.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">int</span> sz = al.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">c[i].a[j] = std::<span class="built_in">lower_bound</span>(al.<span class="built_in">begin</span>(), al.<span class="built_in">end</span>(), c[i].a[j]) - al.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) ha[c[i].a[j]].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (ha[i].<span class="built_in">size</span>() &lt;= Block) <span class="keyword">continue</span>;</span><br><span class="line">bk[i] = it ++, bk[i]-&gt;<span class="built_in">set</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> pos : ha[i]) bk[i]-&gt;<span class="built_in">reset</span>(pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">2e9</span> + <span class="number">7</span>, t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">std::bitset&lt;N&gt; now;</span><br><span class="line">now.<span class="built_in">set</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line"><span class="keyword">if</span> (ha[c[i].a[j]].<span class="built_in">size</span>() &lt;= Block)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> pos : ha[c[i].a[j]]) now[pos] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> now &amp;= *bk[c[i].a[j]];</span><br><span class="line"><span class="keyword">if</span> ((t = now._Find_next(<span class="number">0</span>)) &lt;= n) ans = std::<span class="built_in">min</span>(ans, c[i].w + c[t].w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Div 2 当场降智，直接变成了 SpeedForces 了。&lt;/p&gt;
&lt;p&gt;比赛记录：ABC Accepted，Scores：2247，Rank：872。&lt;/p&gt;
&lt;p&gt;改题进度：ABCF Accepted。&lt;/p&gt;</summary>
    
    
    
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>Min_25 筛</title>
    <link href="https://mydcwfy.github.io/2022/02/13/Min-25-Sieve/"/>
    <id>https://mydcwfy.github.io/2022/02/13/Min-25-Sieve/</id>
    <published>2022-02-13T04:57:51.000Z</published>
    <updated>2022-04-28T13:48:36.580Z</updated>
    
    <content type="html"><![CDATA[<p>非常 NB 的一个筛法，虽然复杂度可能会趋近线性 $O(n ^ {1 - \epsilon})$，但是在 OI 范围内非常不错。</p><span id="more"></span><h2 id="1-算法介绍"><a href="#1-算法介绍" class="headerlink" title="1. 算法介绍"></a>1. 算法介绍</h2><p>要么是 $O(\dfrac{n ^ {\frac34}}{\log n})$，还有一种是 $O(n ^ {1 - \epsilon})$，反正可以在 $10^{10}$ 范围内跑 1s 左右。</p><h2 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2. 算法流程"></a>2. 算法流程</h2><p>感觉比杜教筛更好构造。</p><p>假设 $f(x)$ 的前缀和是我们要求的。</p><p>分为两步：先求出在当 $x \in P$（表示 $x$ 是质数）的 $f(x)$ 的前缀和，第二步通过质数的前缀和求出整个的前缀和。</p><h3 id="1）求-g-x-f-x-x-in-P-的前缀和"><a href="#1）求-g-x-f-x-x-in-P-的前缀和" class="headerlink" title="1）求 $g(x) = f(x)[x \in P]$  的前缀和"></a>1）求 $g(x) = f(x)[x \in P]$  的前缀和</h3><p>我们找到一个多项式 $g(x)$，使得 $x \in P$ 的时候 $f(x) = g(x)$。</p><p>定义 $\text{lpf}(x)$ 是 $x$ 的最小质因数，$p_x$ 表示第 $x$ 个质数。</p><p>先将多项式拆为多个 $x ^ k$，这样的话 $g(x)$ 就是一个完全积性函数了，即满足 $g(ab) = g(a) \cp g(b)$。</p><p>我们定义 $h(n, k) = \sum_{i = 1}^n [i \in P \lor \text{lpf}(i) &gt; p_k]g(i)$。</p><p><del>（显然状态数比 $n$ 还大）</del></p><p>我们考虑从 $h(…, k - 1)$ 转移到 $h(n, k)$。</p><p>考虑 $h(n, k - 1)$ 变为 $h(n, k)$，需要减去 $\text{lpf}(x) = p_k$ 的数。</p><p>如果我们将 $x$ 除以 $p_k$，又怎么样呢？</p><p>那么剩下的变为 $\text{lpf}(\dfrac x{p_k})\geq p_k$。至于为什么是 $\geq$，是因为可能有单个数可能有多个 $p_k$ 质因子。</p><p>这不和 $h(\dfrac n{p_k}, k - 1)$ 定义很像了吗！</p><p>对比一下：<br>$$<br>\begin{aligned}<br>h(\dfrac n{p_k}, k - 1) &amp;= \sum_{i = 1}^{\frac n{p_k}}[i \in P \lor \text{lpf}(i) \geq p_k]g(i)\\<br>&amp;= \sum_{i = 1}^{\frac n{p_k}}[\text{lpf}(i) \geq p_k]g(i) + h(p_{k - 1}, p_{k - 1})<br>\end{aligned}<br>$$<br>其中为什么要加 $h(p_{k - 1}, p_{k - 1})$ 呢？因为 $h(\dfrac n{p_k}, k - 1)$ 包含了 $[1, \dfrac{n}{p_k}]$ 所有质数，而小于 $p_k$ 的质数我们前面的是没有计算到的，所以要加上 $[1, p_{k - 1}]$ 的所有质数的函数值，显然 $g(p_{k - 1}, p_{k - 1})$ 就可以满足要求。这样我们就可以得出：<br>$$<br>\begin{aligned}<br>\sum_{i = 1}^{\frac n{p_k}}[\text{lpf}(i) \geq p_k]g(i) = h(\dfrac n{p_k}, k - 1) - h(p_{k - 1}, p_{k - 1})<br>\end{aligned}<br>$$<br>又由于 $g$ 是完全积性函数（记得前面我们拆开多项式的目的吗？），我们可以得到这样的递推式：<br>$$<br>\begin{aligned}<br>h(n, k) &amp;= h(n, k - 1) - \sum_{i = 1}^n [\text{lpf}(i) = p_k] g(i)\\<br>&amp;= h(n, k - 1) - g(p_k)\sum_{i = 1}^{\frac n{p_k}} [\text{lpf}(i) \geq p_k]g(i)\\<br>&amp;= h(n, k - 1) - g(p_k)(h(\dfrac n{p_k}, k - 1) - h(p_{k - 1}, k - 1))<br>\end{aligned}<br>$$<br>按照这个递推，最后我们就可以得到所有质数位置的值的前缀和，即为 $h(n, k)$，其中 $p_k &gt; \sqrt n$。</p><h3 id="2）根据质数点的值求整个的前缀和"><a href="#2）根据质数点的值求整个的前缀和" class="headerlink" title="2）根据质数点的值求整个的前缀和"></a>2）根据质数点的值求整个的前缀和</h3><p>现在我们经过第一步的计算，已经知道了只有质数点的值 $g(x) = [x \in P]f(x)$ 的前缀，记为 $r(x)$。</p><p>我们定义 $S(n, k)$ 表示 $\displaystyle \sum_{i = 2}^n [\text{lpf}(i) &gt; p_k]f(k)$。</p><p>类似刚刚推导 $h(n, k)$ 的方法，我们可以较为简单的求，注意是积性函数而不是完全积性函数。</p><p>我们考虑最小的质因数 $p_v &gt; p_k$，然后枚举 $p_v$ 的指数。如是就可以从 $S(\dfrac n{p_v^e}, v)$ 转移，因为剩下的质因数都得大于 $p_v$。</p><p>注意我们的 $S(n, k)$ 没有定义 1，所以我们还要先加上 $&gt; p_k$ 的质数的所有的和，这样我们就可以直接使用 $r(n) - h(p_k, k)$ 代替。</p><p>注意如果 $e \not= 1$，$p_v^e$ 本身就是合数，没有包含在 $r(n) - h(p_k, k)$ 中，所以我们要加上他们。</p><p>根据积性函数的定义，我们可以得到：<br>$$<br>\begin{aligned}<br>S(n, k) = r(n) - h(p_k, k) + \sum_{v = i + 1}^{p_v \leq n}\sum_{e = 1}^{p_v^e \leq n} f(p_v^e)(S(\dfrac n{p_e^v}, v) + [v\not= 1])<br>\end{aligned}<br>$$</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p>显然，如果一个数不是质数，那么 $\text{lpf}(n) \leq \sqrt n$，所以我们计算 $h(n, k)$ 的时候可以直接处理 $[1, \sqrt n]$ 的所有质数就可以了。</p><p>但是我们如果直接循环 $h(i, k)(i \in [1, n], p_k \leq \sqrt n)$，那么肯定暴力都跑不过。</p><p>可以发现，除了 $h(p_{k - 1}, k - 1)$，其余都是和 $n$ 有关。又有一个整除的小定理：<br>$$<br>\left\lfloor\dfrac{\left\lfloor\dfrac na\right\rfloor}{b}\right\rfloor = \left\lfloor\dfrac n{ab}\right\rfloor<br>$$<br>这说明，不管我们除什么，前面的 $h(n, k), h(\dfrac n{p_k}, k - 1)$ 都只会访问到 $\dfrac ni(i \in [1, n])$，而这个最多只有 $O(\sqrt n)$ 个取值。</p><p>这个实现可以直接整除分块，将可以访问到的值存到两个数组，可以表示为：<br>$$<br>id(x) =<br>\begin{cases}<br>id1(x) (x \leq \sqrt n)\\<br>id2(\left\lfloor\dfrac nx\right\rfloor) (x &gt; \sqrt n)<br>\end{cases}<br>$$<br>当然偷懒的话可以多一个 $\log$ 的 <code>map</code>，但是似乎也不难，直接写整除分块了（本身算法就有点卡，还是不要给自己添麻烦吧 qwq</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_id</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x &lt;= sq ? id1[x] : id2[n / x];&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (LL l = <span class="number">1</span>, r, t; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = n / (n / l), t = n / r;</span><br><span class="line">a[++ tot] = t;<span class="comment">//a 存的是这个位置存的是哪个数</span></span><br><span class="line"><span class="keyword">if</span> (t &lt;= sq) id1[t] = tot;</span><br><span class="line"><span class="keyword">else</span> id2[n / t] = tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接着简单的分析复杂度：枚举质数 $O(\dfrac{\sqrt n}{\ln \sqrt n})$，枚举 $O(\sqrt n)$ 个数，前面时间复杂度为 $O(\dfrac n{\ln \sqrt n})$，显然跑不进 1s。</p><p>我们还有一个优化：在枚举 $h(n, k)$ 的时候，我们可以发现 $h(\dfrac n{p_k}, k - 1) - h(p_{k - 1}, k - 1)$ 有贡献时，肯定需要满足 $\dfrac{n}{p_k} \geq p_k$，否则 $h(\dfrac n{p_k}, k - 1)$ 就全是质数，并且只有 $[1, p_k)$ 中的质数，也就是 $h(p_{k - 1}, k - 1)$，那么后面贡献就是 0。所以我们只需枚举 $n$ 到 $p_k ^ 2$。</p><p>另外，$h(p_{k - 1}, k - 1)$ 最多也只有 $O(\dfrac{\sqrt n}{\ln \sqrt n})$ 个，我们直接预处理就可以了。这个我们记为 $sp_{k - 1}$。</p><p>（代码用的是 $g(n, k)$ 表示 $h(n, k)$，且只开了一维数组，因为访问的时候一定是标号小（即对应的 <code>a[]</code> 大）的从小的转移，可以用标号从小到大）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">LL le = (LL)prime[i] * prime[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; a[j] &gt;= le; ++ j)</span><br><span class="line">g[j] -= g[<span class="built_in">get_id</span>(a[j] / prime[i])] - sp[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于后面是同样的，我们计算 $S(n, k)$ 时，如果 $p_v^2 &gt; n$，只能枚举 $e = 1$，那么 $[e \not= 1] = 0$，$S(\dfrac{n}{p_v}, v)$ 由于 $\dfrac n{p_v} &lt; p_v$ 所以就为 0，我们就无需枚举。</p><p>反正后面 $S(n, k)$ 是不需要记忆化的（跑得还挺快</p><p>最后注意 $S(n, 0) = \sum_{i = 2}^n f(i)$，返回这个，需要加 $f(1)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">S</span><span class="params">(LL n, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (prime[i] &gt;= n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> now = <span class="built_in">get_id</span>(n);</span><br><span class="line">LL res = (f[now] - sp[i] + Mod) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nw = i + <span class="number">1</span>; nw &lt; cnt &amp;&amp; ((LL)prime[nw]) * prime[nw] &lt;= n; ++ nw)</span><br><span class="line"><span class="keyword">for</span> (LL now = prime[nw], k = <span class="number">1</span>; now &lt;= n; k ++, now *= prime[nw])&#123;</span><br><span class="line">LL t = now % Mod;</span><br><span class="line">res = (res + <span class="built_in">f</span>(now) % Mod * ((<span class="built_in">S</span>(n / now, nw) + (k != <span class="number">1</span>)) % Mod) % Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-例题"><a href="#4-例题" class="headerlink" title="4. 例题"></a>4. 例题</h2><h4 id="T1：区间素数个数"><a href="#T1：区间素数个数" class="headerlink" title="T1：区间素数个数"></a>T1：区间素数个数</h4><p><a href="https://loj.ac/p/6235">题目传送门 LOJ</a></p><p>观察到这个函数并不是积性函数，所以我们似乎没法使用杜教筛等算法求解。</p><p><del>观察标题可得，</del>我们可以发现，$h(n, x)(p_x &gt; \sqrt n)$ 就是 $\sum_{i = 1}^n[i \in P]g(i)$，我们直接让 $g(x) = 1$，即可求出 $[1, n]$ 的质数个数即可。</p><details><summary> 点击查看代码 </summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> id1[N], id2[N], tot, prime[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line">LL g[N], n, sq, a[N], sp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">st[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) prime[cnt ++] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; i * prime[j] &lt; N; ++ j)</span><br><span class="line">&#123;</span><br><span class="line">st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_id</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x &lt;= sq ? id1[x] : id2[n / x];&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this problem has a times 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solveg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i) sp[i] = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) g[i] = a[i] - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">LL le = (LL)prime[i] * prime[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; a[j] &gt;= le; ++ j)</span><br><span class="line">g[j] -= g[<span class="built_in">get_id</span>(a[j] / prime[i])] - sp[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line">sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="built_in">sieve</span>(sq + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (LL l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">a[++ tot] = n / r;</span><br><span class="line"><span class="keyword">if</span> (n / r &lt;= sq) id1[n / r] = tot;</span><br><span class="line"><span class="keyword">else</span> id2[n / (n / r)] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">solveg</span>();</span><br><span class="line">std::cout &lt;&lt; g[<span class="built_in">get_id</span>(n)] &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h4 id="T2：简单的函数"><a href="#T2：简单的函数" class="headerlink" title="T2：简单的函数"></a>T2：简单的函数</h4><p><a href="https://loj.ac/p/6053">题目传送门 LOJ</a></p><p>首先有一个小学老师教的结论：偶质数只有 2。</p><p>那么，$f(i) = i\oplus 1 (i \in P)$ 就是：<br>$$<br>\begin{cases}<br>i - 1 (i \not= 2)\\<br>i - 1 + 2 (i = 2)<br>\end{cases}<br>$$<br>我们就可以通过先筛 $g(i) = i,g(i) = 1$ 来得到 $f(i)(i \in P)$。</p><p>最后，我们计算 $\sum_{i = 1}^n f(i)$ 的时候，由于 $f(2) = 3$，所以我们在筛到 $2$ 的时候应该加上 2。</p><p>具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">S</span><span class="params">(LL n, <span class="keyword">int</span> x)</span><span class="comment">//x 从 0  开始标号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (prime[x] &gt;= n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">LL res = (f[<span class="built_in">get_id</span>(n)] - sp[x] + Mod + <span class="number">2</span> * (x == <span class="number">-1</span> &amp;&amp; n &gt; <span class="number">1</span>)) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nw = x + <span class="number">1</span>; (LL)prime[nw] * prime[nw] &lt;= n &amp;&amp; nw &lt; cnt; ++ nw)</span><br><span class="line"><span class="keyword">for</span> (LL k = <span class="number">1</span>, pk = prime[nw]; pk &lt;= n; ++ k, pk *= prime[nw])</span><br><span class="line">res += (prime[nw] ^ k) * (<span class="built_in">S</span>(n / pk, nw) + (k != <span class="number">1</span>)) % Mod;</span><br><span class="line"><span class="keyword">return</span> res % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3：DIVCNTK"><a href="#T3：DIVCNTK" class="headerlink" title="T3：DIVCNTK"></a>T3：DIVCNTK</h4><p><a href="https://www.spoj.com/problems/DIVCNTK/">题目传送门 SPOJ</a></p><p>要求 $\sum_{i = 1}^n d(i ^ k)\bmod 2^{64}$，其中 $d(x)$ 代表 $x$ 的约数个数。</p><p>我们可以简单的发现，$d(x ^ k)$ 是积性函数：$d(a^kb^k) = d(a^k)d(b^k) (a \perp b)$。</p><p>令 $f(x) = d(x ^ k)$，我们再尝试推一下 $f(p ^ c) = c(k + 1)$。发现这是一个简单的多项式，我们尝试拆开 $f(p^c) = c$，Min_25 筛即可。</p><p>代码不给了，留作练习题<del>（逃</del></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;非常 NB 的一个筛法，虽然复杂度可能会趋近线性 $O(n ^ {1 - \epsilon})$，但是在 OI 范围内非常不错。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="Min_25" scheme="https://mydcwfy.github.io/tags/Min-25/"/>
    
  </entry>
  
</feed>
