<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mydcwfy&#39;s Blog</title>
  
  
  <link href="https://mydcwfy.github.io/atom.xml" rel="self"/>
  
  <link href="https://mydcwfy.github.io/"/>
  <updated>2022-07-22T14:03:10.527Z</updated>
  <id>https://mydcwfy.github.io/</id>
  
  <author>
    <name>mydcwfy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TopCoder12141</title>
    <link href="https://mydcwfy.github.io/2022/07/22/TopCoder12141/"/>
    <id>https://mydcwfy.github.io/2022/07/22/TopCoder12141/</id>
    <published>2022-07-22T13:46:10.000Z</published>
    <updated>2022-07-22T14:03:10.527Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给出 $n$ 个点，每个点有一个权值，$a_i\geq 0$ 表示这个点是好的，否则是不好的。任意构造一棵生成树，定义和至少一个好点连边的点是非常好的。求所有非常好的点权值和 $\leq lim$ 的方案数。$n\leq 40$，$-1\leq a_i\leq 2.5\times 10 ^ 8$，$lim\leq 10 ^ 9$。</p><span id="more"></span><p>首先一个比较明显的特征为权值和 $\leq lim$，但是 $lim$ 又是不可压缩的级别。注意到 $n = 40 = 2\times 20$，我们可以使用 meet-in-the-middle 把所有满足权值和 $\leq lim$ 的方案求出来。</p><p>然后注意到一个事实为一旦我们知道了非常好的点的数量，其实他们到底是谁并不重要，我们只需要求出该数量有多少个合法的生成树即可。</p><p>考虑枚举 $k(k\in [0, n])$，计算非常好的点恰好有 $k$ 个的方案数。一个显然的想法是这 $k$ 个点只能和不好的点连边，好的点和好不好的点都可以连边。然后直接使用矩阵树定理就可以求出生成树的数量。</p><p>但是我们又发现了一个问题：这样只能保证好的点一定不是非常好的点，但是无法保证钦定的非常好的点一定就是非常好的点。</p><p>我们可以考虑容斥，假设一个只有 $i$ 个非常好的点的生成树，那么他会在我钦定非常好的点的时候计算 $\displaystyle \binom ki$ 次，那么我们就可以得到以下式子：<br>$$<br>f(k) = \det(k) - \sum_{i = 0} ^ {k - i} f(i) \binom ki<br>$$<br>$\det(k)$ 表示矩阵树定理得到的答案。</p><p>直接计算即可，时间复杂度 $O(2 ^ {\frac n2} + n ^ 4)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">det</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; ++ j)</span><br><span class="line"><span class="keyword">if</span> (a[j][i]) &#123;</span><br><span class="line">t = j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!~t) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i != t) std::<span class="built_in">swap</span>(a[i], a[t]), x ^= <span class="number">1</span>;</span><br><span class="line">LL Inv = <span class="built_in">qpow</span>(a[i][i]);</span><br><span class="line">res = (LL) res * a[i][i] % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; ++ j) a[i][j] = (LL) a[i][j] * Inv % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line"><span class="keyword">if</span> (a[j][i])</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = n; k &gt;= i; -- k)</span><br><span class="line">a[j][k] = (a[j][k] + (LL) (Mod - a[i][k]) * a[j][i]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x ? <span class="built_in">adj</span>(res = -res) : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> ed, <span class="type">int</span> cur, <span class="type">int</span> ct, std::vector&lt;<span class="type">int</span>&gt; *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (id &gt; ed) <span class="keyword">return</span> v[ct].<span class="built_in">push_back</span>(cur);</span><br><span class="line"><span class="built_in">dfs</span>(id + <span class="number">1</span>, ed, cur, ct, v);</span><br><span class="line"><span class="keyword">if</span> (cur + abl[id] &lt;= lim)</span><br><span class="line"><span class="built_in">dfs</span>(id + <span class="number">1</span>, ed, cur + abl[id], ct + <span class="number">1</span>, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; i &lt; N; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = C[i][<span class="number">0</span>] = <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line"><span class="built_in">adj</span>(C[i][j] = C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j] - Mod);</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vl[N]&#123;&#125;, vr[N]&#123;&#125;;</span><br><span class="line"><span class="type">int</span> ok[N]&#123;&#125;, ans[N]&#123;&#125;;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (v[i] &gt;= <span class="number">0</span>) abl[++ cnt] = v[i];</span><br><span class="line"><span class="type">int</span> lcnt = cnt / <span class="number">2</span>, rcnt = cnt - cnt / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>, cnt / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, vl), <span class="built_in">dfs</span>(cnt / <span class="number">2</span> + <span class="number">1</span>, cnt, <span class="number">0</span>, <span class="number">0</span>, vr);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lcnt; ++ i) std::<span class="built_in">sort</span>(vl[i].<span class="built_in">begin</span>(), vl[i].<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= rcnt; ++ i) std::<span class="built_in">sort</span>(vr[i].<span class="built_in">begin</span>(), vr[i].<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lcnt; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= rcnt; ++ j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> r = vr[j].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;x : vl[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (r &gt;= <span class="number">0</span> &amp;&amp; vr[j][r] + x &gt; lim) r --;</span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">adj</span>(ok[i + j] += r + <span class="number">1</span> - Mod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ncnt = <span class="number">0</span>; ncnt &lt;= cnt; ++ ncnt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) a[i][j] = i != j;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt - ncnt; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt - ncnt; ++ j) a[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt - ncnt; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++ j) a[i][j] = a[j][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) t += a[i][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line"><span class="keyword">if</span> (a[i][j]) a[i][j] = Mod - a[i][j];</span><br><span class="line">a[i][i] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for (int i = 1; i &lt;= n; ++ i, puts(&quot;&quot;))</span></span><br><span class="line"><span class="comment">for (int j = 1; j &lt;= n; ++ j) printf(&quot;%d &quot;, a[i][j]);*/</span></span><br><span class="line">ans[ncnt] = <span class="built_in">det</span>(n - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; ncnt &lt;&lt; &#x27; &#x27; &lt;&lt; ans[ncnt] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ex = <span class="number">0</span>; ex &lt; ncnt; ++ ex)</span><br><span class="line">ans[ncnt] = (ans[ncnt] + (LL) (Mod - ans[ex]) * C[ncnt][ex]) % Mod;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; ncnt &lt;&lt; &#x27; &#x27; &lt;&lt; ok[ncnt] &lt;&lt; &#x27; &#x27; &lt;&lt; ans[ncnt] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">res = (res + (LL) ans[ncnt] * ok[ncnt]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SweetFruits</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">countTrees</span><span class="params">(std::vector&lt;<span class="type">signed</span>&gt; val, <span class="type">signed</span> _lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n = val.<span class="built_in">size</span>(), lim = _lim;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) v[i] = val[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">work</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给出 $n$ 个点，每个点有一个权值，$a_i\geq 0$ 表示这个点是好的，否则是不好的。任意构造一棵生成树，定义和至少一个好点连边的点是非常好的。求所有非常好的点权值和 $\leq lim$ 的方案数。$n\leq 40$，$-1\leq a_i\leq 2.5\times 10 ^ 8$，$lim\leq 10 ^ 9$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="矩阵树定理" scheme="https://mydcwfy.github.io/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"/>
    
    <category term="暴力" scheme="https://mydcwfy.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>TopCoder13444 CountTables</title>
    <link href="https://mydcwfy.github.io/2022/07/22/TopCoder13444/"/>
    <id>https://mydcwfy.github.io/2022/07/22/TopCoder13444/</id>
    <published>2022-07-22T13:32:21.000Z</published>
    <updated>2022-07-22T13:42:55.721Z</updated>
    
    <content type="html"><![CDATA[<p>题意：问在 $n\times m$ 的网格上染 $c$ 种颜色，问满足任意两行都不相同、任意两列都不相同的方案数。$n, m\leq 4000$，对 $10 ^ 9 + 7$ 取模。</p><span id="more"></span><p>首先如果我们只满足任意两列都不相同是容易做的，答案就是从 $c ^ n$ 种染法中依次选择 $m$ 种不相同的染色方案了，答案显然为 $\displaystyle \binom{c ^ n}m m!$。</p><p>对于任意两行都不相同，这个是不好做的，我们考虑容斥。设 $f_i$ 表示只考虑 $i\times m$ 网格的答案。假设最后有 $j$ 个互不相同的，那么这个的贡献就是 $f_j$。另外，我们需要把 $i$ 个行划分为 $j$ 个不相同的数，这个其实就是 $\displaystyle i\brace j$。</p><p>这样预处理第二类斯特林数即可，时间复杂度 $O(nm + n ^ 2)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountTables</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = s[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; i &lt; N; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line">s[i][j] = (s[i - <span class="number">1</span>][j - <span class="number">1</span>] + (LL) j * s[i - <span class="number">1</span>][j]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; n - m; -- i) cur = (LL) cur * i % Mod;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">howMany</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">f[i] = <span class="built_in">A</span>(<span class="built_in">qpow</span>(c, i), m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++ j)</span><br><span class="line">f[i] = (f[i] + (LL) (Mod - f[j]) * s[i][j]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：问在 $n\times m$ 的网格上染 $c$ 种颜色，问满足任意两行都不相同、任意两列都不相同的方案数。$n, m\leq 4000$，对 $10 ^ 9 + 7$ 取模。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="斯特林数" scheme="https://mydcwfy.github.io/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3864 Hero meet devil</title>
    <link href="https://mydcwfy.github.io/2022/07/22/BZOJ3864/"/>
    <id>https://mydcwfy.github.io/2022/07/22/BZOJ3864/</id>
    <published>2022-07-22T13:10:21.000Z</published>
    <updated>2022-07-22T13:29:39.254Z</updated>
    
    <content type="html"><![CDATA[<p>题意：有一个字符集为 <code>A, C, G, T</code> 的字符串 $S$，问有多少个长度为 $n$ 的字符串 $T$ 满足 $\mathrm{LCS}(S, T) = i$。你需要输出所有 $i\in [0, |S|]$ 的答案。$|S|\leq 15$，$n\leq 1000$。</p><span id="more"></span><p>DP of DP 模板题。</p><p>首先考虑如果我们已经知道了 $T$，怎么计算 $\mathrm{LCS}(S, T)$。DP 过程不再赘述，这个 DP 过程结果可以由 $|S|$ 个数来代表，分别为每一个前缀和 $T$ 的 $\mathrm{LCS}$。</p><p>注意到一旦我们知道了这 $|S|$ 个数，前面的 $T$ 如何我们其实是不关心的。也就是说，我们可以把这 $|S|$ 个数变成状态，然后枚举 $T$ 的下一个字符，直接转移就可以做完。</p><p>但是注意到一个问题是这 $|S|$ 个数可能都比较大，不好压入状态。但是 $\mathrm{LCS}$ 的特殊性质告诉我们 $dp_i\leq dp_{i - 1} + 1$。因为一旦 $dp_i$ 匹配到了一个 $&gt;dp_{i - 1} + 1$ 的东西，删掉最后一个数就可以得到 $dp_i - 1$ 更新 $dp_{i - 1}$。</p><p>这样我们就可以把差分数组压入状态，容易发现最多只有 $2 ^ {|S|}$ 种状态，就可以计算了，时间复杂度 $O(n 2^{|S|} \sum)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; s &gt;&gt; m;</span><br><span class="line">n = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; (<span class="number">1</span> &lt;&lt; n); ++ sta)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++ j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> f[N], g[N];</span><br><span class="line">f[<span class="number">0</span>] = sta &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) f[i] = f[i - <span class="number">1</span>] + (sta &gt;&gt; i &amp; <span class="number">1</span>);</span><br><span class="line">g[<span class="number">0</span>] = f[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (s[<span class="number">0</span>] == ch[j]) <span class="built_in">chkmax</span>(g[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">g[i] = g[i - <span class="number">1</span>], <span class="built_in">chkmax</span>(g[i], f[i]);</span><br><span class="line"><span class="keyword">if</span> (s[i] == ch[j]) <span class="built_in">chkmax</span>(g[i], f[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> to = g[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (g[i] != g[i - <span class="number">1</span>]) to |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line"><span class="comment">/*std::cout &lt;&lt; &quot;Check &quot; &lt;&lt; sta &lt;&lt; &#x27; &#x27; &lt;&lt; j &lt;&lt; &#x27; &#x27; &lt;&lt; to &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; n; ++ i) printf(&quot;%d &quot;, g[i]);</span></span><br><span class="line"><span class="comment">puts(&quot;&quot;);*/</span></span><br><span class="line">trs[sta][j] = to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; (<span class="number">1</span> &lt;&lt; n); ++ sta) f[<span class="number">0</span>][sta] = !sta;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; (<span class="number">1</span> &lt;&lt; n); ++ sta) f[i &amp; <span class="number">1</span>][sta] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; (<span class="number">1</span> &lt;&lt; n); ++ sta)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++ j)</span><br><span class="line"><span class="built_in">adj</span>(f[i &amp; <span class="number">1</span>][trs[sta][j]] += f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][sta] - Mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> ans[N + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) ans[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line"><span class="built_in">adj</span>(ans[__builtin_popcount(s)] += f[m &amp; <span class="number">1</span>][s] - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：有一个字符集为 &lt;code&gt;A, C, G, T&lt;/code&gt; 的字符串 $S$，问有多少个长度为 $n$ 的字符串 $T$ 满足 $\mathrm{LCS}(S, T) = i$。你需要输出所有 $i\in [0, |S|]$ 的答案。$|S|\leq 15$，$n\leq 1000$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>CF1114F Please, another Queries on Array?</title>
    <link href="https://mydcwfy.github.io/2022/07/22/CF1114F/"/>
    <id>https://mydcwfy.github.io/2022/07/22/CF1114F/</id>
    <published>2022-07-22T12:58:04.000Z</published>
    <updated>2022-07-22T13:06:11.041Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一个长度为 $n$ 的序列 $a$，修改为区间乘 $x$，询问为求 $\varphi(\prod_{i = l} ^ r a_i)$。$n\leq 4\times 10 ^ 5$，$q\leq 2\times 10 ^ 5$，$a_i, x\leq 300$。</p><span id="more"></span><p>首先考虑 $\varphi(n) = n\prod_p \dfrac{p - 1}p$，那么我们现在就相当于是需要知道所有数有没有每一个质数。我们发现 300 以内的数只有 62 个，这给了我们一定的启发。</p><p>首先线段树维护区间乘积肯定是必需的，另外，我们定义一个状态 $s$，表示包含了 $s$ 内的质数。容易发现这个修改时很好做的，也就是说我们只需要根据 $s$ 内部的状态乘上对应的 $\dfrac{p - 1}p$ 即可。</p><p>时间复杂度 $O(q\log n + (n + q)\dfrac{a}{\ln a})$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MulSegment</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line"><span class="type">int</span> res, lt;</span><br><span class="line">&#125; tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; tr[x].res = (LL) tr[x &lt;&lt; <span class="number">1</span>].res * tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].res % Mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[x] = &#123;l, r, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> tr[x].res = a[l], <span class="built_in">void</span>();</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[x].res = (LL) tr[x].res * <span class="built_in">qpow</span>(c, tr[x].r - tr[x].l + <span class="number">1</span>) % Mod;</span><br><span class="line">tr[x].lt = (LL) tr[x].lt * c % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].lt == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span>, tr[x].lt), <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tr[x].lt);</span><br><span class="line">tr[x].lt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt; r || tr[x].r &lt; l) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> <span class="built_in">update</span>(x, c);</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span>, l, r, c), <span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, c);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt; r || tr[x].r &lt; l) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> tr[x].res;</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="keyword">return</span> (LL) <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span>, l, r) * <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125; seg1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OrSegment</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line">LL res, lt;</span><br><span class="line">&#125; tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; tr[x].res = tr[x &lt;&lt; <span class="number">1</span>].res | tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].res; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[x] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, LL c)</span> </span>&#123; tr[x].res |= c, tr[x].lt |= c; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tr[x].lt) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span>, tr[x].lt), <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tr[x].lt);</span><br><span class="line">tr[x].lt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, LL c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt; r || tr[x].r &lt; l) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> <span class="built_in">update</span>(x, c);</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span>, l, r, c), <span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, c);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt; r || tr[x].r &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> tr[x].res;</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span>, l, r) | <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">&#125;</span><br><span class="line">&#125; seg2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> N = <span class="number">301</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) prime[cnt ++] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; i * prime[j] &lt; N; ++ j)</span><br><span class="line">&#123;</span><br><span class="line">st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i) invp[i] = <span class="built_in">qpow</span>(prime[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sieve</span>();</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">seg1.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n), seg2.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">LL s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; prime[j] &lt;= a[i]; ++ j)</span><br><span class="line"><span class="keyword">if</span> (a[i] % prime[j] == <span class="number">0</span>) s |= <span class="number">1LL</span> &lt;&lt; j;</span><br><span class="line">seg2.<span class="built_in">modify</span>(<span class="number">1</span>, i, i, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> l, r, x;</span><br><span class="line"><span class="keyword">while</span> (m --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, s, &amp;l, &amp;r);</span><br><span class="line"><span class="keyword">if</span> (std::<span class="built_in">string</span>(s) == <span class="string">&quot;MULTIPLY&quot;</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">LL s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; ++ j)</span><br><span class="line"><span class="keyword">if</span> (x % prime[j] == <span class="number">0</span>) s |= <span class="number">1LL</span> &lt;&lt; j;</span><br><span class="line">seg1.<span class="built_in">modify</span>(<span class="number">1</span>, l, r, x), seg2.<span class="built_in">modify</span>(<span class="number">1</span>, l, r, s);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">string</span>(s) == <span class="string">&quot;TOTIENT&quot;</span>) &#123;</span><br><span class="line"><span class="type">int</span> res = seg1.<span class="built_in">query</span>(<span class="number">1</span>, l, r);</span><br><span class="line">LL s = seg2.<span class="built_in">query</span>(<span class="number">1</span>, l, r);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">62</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (s &gt;&gt; i &amp; <span class="number">1</span>) res = (LL) res * invp[i] % Mod * (prime[i] - <span class="number">1</span>) % Mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Failed&quot;</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一个长度为 $n$ 的序列 $a$，修改为区间乘 $x$，询问为求 $\varphi(\prod_{i = l} ^ r a_i)$。$n\leq 4\times 10 ^ 5$，$q\leq 2\times 10 ^ 5$，$a_i, x\leq 300$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="线段树" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>LOJ3330 [WC2020]猜数游戏</title>
    <link href="https://mydcwfy.github.io/2022/07/22/LOJ3330/"/>
    <id>https://mydcwfy.github.io/2022/07/22/LOJ3330/</id>
    <published>2022-07-22T12:28:40.000Z</published>
    <updated>2022-07-22T12:51:34.713Z</updated>
    
    <content type="html"><![CDATA[<p>题意过于神秘，就没有简述了。</p><span id="more"></span><p>首先考虑如何判断 $a_i$ 能否表示 $a_j$。如果 $a_i$ 是 $q(p = q ^ k)$ 的话，那么容易发现不超过 $k$ 次幂就一定会变成 0，这样直接暴力查表即可，时间复杂度 $O(n\log n)$ 或者 $O(n\log ^ 2n)$。否则的话，一定可以发现 $a_i$ 可以在原根下有离散对数，这样是否有次幂就可以看作是否在模意义下有倍数，即是否存在一个 $t$ 满足 $t\times \ln a_i\equiv \ln a_j\pmod {\varphi(p)}$。这个的检验显然就是判断 $\gcd(\ln a_j, \varphi(p))$ 是否整除 $\ln a_i$。</p><p>求原根时间复杂度不计，求离散对数时间复杂度 $O(n\sqrt p)$，两两判断是 $O(n ^ 2\log n)$ 的，不过 $\log$ 是 $\gcd$ 的，比较小，可以接受。</p><p>接下来考虑如何计算至少需要的次数。如果我们把 $a_i\to a_j$ 的有向边表示 $a_i$ 能表示 $a_j$ 的话，那么相当于是统计入度为 0 的点的个数。一个显然的结论是这个图是一个传递闭包，因为 $a_i\to a_j$，$a_j\to a_k$，那么 $a_i$ 一定能表示 $a_k$。</p><p>首先我们从 DAG 入手。把每个点被选的概率分开看，那么能到达他的点一定不能被选，自己一定要选，这样就可以计算概率。</p><p>不是 DAG 的情况，直接缩点后按照上面的做法计算即可。时间复杂度 $O(n\sqrt p + n ^ 2\log n)$，可以接受，比较卡常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BSGS</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">1</span> || P == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> __gnu_pbds::gp_hash_table&lt;<span class="type">int</span>, <span class="type">int</span>&gt; H;</span><br><span class="line"><span class="keyword">if</span> (H.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cur = <span class="number">1</span>, K = std::<span class="built_in">sqrt</span>(P) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; K; ++ i, cur = (LL) cur * a % P)</span><br><span class="line">H[cur] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cur, ak, K = std::<span class="built_in">sqrt</span>(P) + <span class="number">1</span>, x, y;</span><br><span class="line">cur = ak = <span class="built_in">qpow</span>(a, K);</span><br><span class="line"><span class="built_in">ExGcd</span>(b, P, x, y), x = (x % P + P) % P, cur = (LL) cur * x % P;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= K; ++ i, cur = (LL) cur * ak % P)</span><br><span class="line"><span class="keyword">if</span> (H.<span class="built_in">find</span>(cur) != H.<span class="built_in">end</span>()) <span class="keyword">return</span> i * K - H[cur];</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Phi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; ++ i)</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">res = res / i * (i - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n != <span class="number">1</span>) res = res / n * (n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findrt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; fac;</span><br><span class="line"><span class="type">int</span> phi = <span class="built_in">Phi</span>(P), n = phi;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; ++ i)</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">fac.<span class="built_in">push_back</span>(phi / i);</span><br><span class="line"><span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n ^ <span class="number">1</span>) fac.<span class="built_in">push_back</span>(phi / n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> p : fac)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">qpow</span>(x, p) == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; phi; ++ i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(i)) <span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++ *dfn, ins[stk[++ top] = x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (!dfn[v]) <span class="built_in">tarjan</span>(v), <span class="built_in">chkmin</span>(low[x], low[v]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ins[v]) <span class="built_in">chkmin</span>(low[x], dfn[v]);</span><br><span class="line"><span class="keyword">if</span> (low[x] ^ dfn[x]) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> cur;</span><br><span class="line">++ *bel;</span><br><span class="line"><span class="keyword">do</span> ins[cur = stk[top --]] = <span class="literal">false</span>, bel[cur] = *bel, sz[*bel] ++; <span class="keyword">while</span> (cur != x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; inv = [&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line"><span class="keyword">return</span> i == <span class="number">1</span> ? <span class="number">1</span> : (LL) (Mod - Mod / i) * <span class="built_in">inv</span>(Mod % i) % Mod;</span><br><span class="line">&#125;;</span><br><span class="line">pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) <span class="built_in">adj</span>(pw[i] = pw[i - <span class="number">1</span>] * <span class="number">2</span> - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++ i) ipw[i] = <span class="built_in">inv</span>(pw[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; P;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="type">int</span> phi = <span class="built_in">Phi</span>(P), G = <span class="built_in">findrt</span>(), frm = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (; P % frm; ++ frm);</span><br><span class="line">__gnu_pbds::gp_hash_table&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (a[i] % frm) a[i] = <span class="built_in">BSGS</span>(G, a[i]);</span><br><span class="line"><span class="keyword">else</span> mp[a[i]] = i, pp[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// exit(0);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (pp[i]) &#123;</span><br><span class="line"><span class="type">int</span> cur = (LL) a[i] * a[i] % P;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; a[i] &lt;&lt; &quot; Start\n&quot;;</span></span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mp.<span class="built_in">find</span>(cur) != mp.<span class="built_in">end</span>()) g[i].<span class="built_in">push_back</span>(mp[cur]);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; cur &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">cur = (LL) cur * a[i] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;End\n&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line"><span class="keyword">if</span> (!pp[i] &amp;&amp; !pp[j] &amp;&amp; i != j &amp;&amp; a[j] % <span class="built_in">Gcd</span>(phi, a[i]) == <span class="number">0</span>)</span><br><span class="line">g[i].<span class="built_in">push_back</span>(j);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (bel[x] != bel[v])</span><br><span class="line">h[bel[v]].<span class="built_in">push_back</span>(bel[x]);</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= *bel; ++ x)</span><br><span class="line">&#123;</span><br><span class="line">std::<span class="built_in">sort</span>(h[x].<span class="built_in">begin</span>(), h[x].<span class="built_in">end</span>()), h[x].<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(h[x].<span class="built_in">begin</span>(), h[x].<span class="built_in">end</span>()), h[x].<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : h[x])</span><br><span class="line">cur = (LL) cur * ipw[sz[v]] % Mod;</span><br><span class="line">res = (res + (LL) cur * (pw[sz[x]] - <span class="number">1</span>) % Mod * ipw[sz[x]]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">res = (LL) res * pw[n] % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意过于神秘，就没有简述了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Tarjan" scheme="https://mydcwfy.github.io/tags/Tarjan/"/>
    
    <category term="期望" scheme="https://mydcwfy.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
    <category term="离散对数" scheme="https://mydcwfy.github.io/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1488 [HNOI2009]图的同构</title>
    <link href="https://mydcwfy.github.io/2022/07/20/BZOJ1488/"/>
    <id>https://mydcwfy.github.io/2022/07/20/BZOJ1488/</id>
    <published>2022-07-20T13:42:55.000Z</published>
    <updated>2022-07-21T01:01:01.635Z</updated>
    
    <content type="html"><![CDATA[<p>题意：问点数为 $n$ 的本质不同无向图个数。$n\leq 60$，对 997 取模。</p><span id="more"></span><p>本质不同，显然是群论知识了。</p><p>有没有可以使用 2 种颜色来表示，现在就相当于是无向完全图个数计数。</p><p>容易发现一共有 $n!$ 种不同的点置换。现在考虑对于每种不同的置换求不动点的个数。</p><p>对于一个置换长度为 $k$ 内部的循环，有 $\lfloor\dfrac k2\rfloor$ 种不同的等价类，画画图就知道了。</p><p>对于两个长度为 $k_1, k_2$ 的点置换之间的边，我们可以一直转的话，可以得到下面这种情况：</p><img src="/2022/07/20/BZOJ1488/sample.png" class=""><p>容易发现这样中间的 6 条边都是一个等价类。该图比较特殊，如果画一些 $k_1 = 4, k_2 = 6$ 之类的情况的话会发现有 $\gcd(k_1, k_2)$ 个等价类。</p><p>这样算下来一共等价类的个数为：<br>$$<br>\sum_k \lfloor\dfrac k2\rfloor + \sum_{k_1} \sum_{k_2} \gcd(k_1, k_2)<br>$$<br>注意上面的 $k_1, k_2$ 不能来自同一个置换。</p><p>这样直接计算是 $O(n!)$ 的，无法接受。</p><p>注意到我们只需要找到每一个循环的长度即可，然后考虑如果我们只枚举所有循环的长度如何计算。这样其实是整数划分的个数，大概为 $O(\dfrac{10 ^ {\sqrt n}}{n})$，可以接受。</p><p>如果我们已经定义了每一个长度为 $b_i$，每一个长度的循环个数为 $c_i$，那么首先每一个置换是一个圆排列，所以需要除以 $b_i$，然后不同长度的可以任意变换，需要除以 $c_i!$，那么整个的答案就是：<br>$$<br>\dfrac 1{n!} \sum_{b_1, b_2, \dots} \dfrac{n!}{\prod b_i \prod c_i!}<br>$$<br>$n!$ 可以消去，直接计算即可。时间复杂度 $O(\dfrac{10 ^ {\sqrt n}}{n}\mathrm{poly} n)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// puts(&quot;One Division&quot;);</span></span><br><span class="line"><span class="comment">// for (int i = 1; i &lt;= tot; ++ i) printf(&quot;%d cnt = %d\n&quot;, p[i], cnt[i]);</span></span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>, ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line">k += p[i] / <span class="number">2</span> * cnt[i] + p[i] * cnt[i] * (cnt[i] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= tot; ++ j)</span><br><span class="line">k += g[p[i]][p[j]] * cnt[i] * cnt[j];</span><br><span class="line">ans = <span class="built_in">qpow</span>(<span class="number">2</span>, k);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line">ans = (LL) ans * <span class="built_in">qpow</span>(p[i], Mod - <span class="number">1</span> - cnt[i]) % Mod * infact[cnt[i]] % Mod;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="built_in">adj</span>(res += ans - Mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> ls, <span class="type">int</span> rem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rem == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">solve</span>();</span><br><span class="line">++ tot;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = ls + <span class="number">1</span>; i &lt;= rem; ++ i)</span><br><span class="line"><span class="keyword">for</span> (p[tot] = i, cnt[tot] = <span class="number">1</span>; cnt[tot] * i &lt;= rem; ++ cnt[tot])</span><br><span class="line"><span class="built_in">dfs</span>(i, rem - i * cnt[tot]);</span><br><span class="line">-- tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++ j)</span><br><span class="line">g[i][j] = <span class="built_in">Gcd</span>(i, j);</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>, n);</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：问点数为 $n$ 的本质不同无向图个数。$n\leq 60$，对 997 取模。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="群论" scheme="https://mydcwfy.github.io/tags/%E7%BE%A4%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>CF908E New Year and Entity Enumeration</title>
    <link href="https://mydcwfy.github.io/2022/07/20/CF908E/"/>
    <id>https://mydcwfy.github.io/2022/07/20/CF908E/</id>
    <published>2022-07-20T12:56:42.000Z</published>
    <updated>2022-07-20T13:26:31.255Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定 $n$ 个二进制下 $m$ 位的数，问有多少个集合 $S$ 包含这 $n$ 个数并且满足取反、与运算封闭（即任意对 $S$ 集合内部元素取反或者是与运算操作得到的数都 $\in S$），问都多少个这样的 $S$。$m\leq 1000$，$n\leq 50$，对 $10 ^ 9 + 7$ 取模。</p><span id="more"></span><p>首先容易发现一个结论：或和异或操作都是可以实现的。</p><p>一顿构造得到：$a|b = \sim((\sim a)\odot (\sim b))$，$a\oplus b = (a | b)\odot (\sim(a\odot b))$。那么下面相当于 3 种基本运算都可以使用并且是封闭的。</p><p>假设一个集合 $\{x_1, x_2, \dots, x_k\}$ 在 $n$ 个数中，这些位置出现 01 是相同的（即要么都出现 0，要么都出现 1）。考虑以下一个结论：$S$ 和这样的集合划分一一对应。</p><p>首先如果一个集合内出现了一个不和别人相同的，那么比如在某一位 $x_1 = 0$，$x_2 = 1$，那么我们取反就可以得到 $x_1 = 1, x_2 = 0$ 的情况，这样下去，那么 $x_1$ 和 $x_2$ 就不是一个集合的了。</p><p>一个集合会一起出现 01 两种情况，不同集合之间随意组合，然后就可以得到 $S$ 的所有元素了。</p><p>容易发现如果两个位置在某个数出现的是不同的，那么这两个永远不可能成为一个集合。也就是说我们只需要关心每个数出现的 bit 都是相同的，这些位置的才可能被划分为一个集合。</p><p>怎样固定大小求集合划分计数呢？容易发现这个就是 Bell 数，当然其实也是第二类斯特林数一行的和。随便做做就可以 $O(m ^ 2)$ 啦。</p><p>最后复杂度不高，可以轻松通过。判断每个 bit 是不是相同显然可以压位扔到 <code>std::map</code> 里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) fact[i] = (LL) fact[i - <span class="number">1</span>] * i % Mod;</span><br><span class="line">infact[N - <span class="number">1</span>] = <span class="built_in">qpow</span>(fact[N - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = N - <span class="number">2</span>; i; -- i) infact[i] = (LL) infact[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % Mod;</span><br><span class="line">B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++ j) B[i + <span class="number">1</span>] = (B[i + <span class="number">1</span>] + (LL) <span class="built_in">C</span>(i, j) * B[j]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>, t; j &lt;= m; ++ j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>, &amp;t);</span><br><span class="line"><span class="keyword">if</span> (t) s[j] |= <span class="number">1LL</span> &lt;&lt; i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) ++ F[s[i]];</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [s, cnt] : F) res = (LL) res * B[cnt] % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定 $n$ 个二进制下 $m$ 位的数，问有多少个集合 $S$ 包含这 $n$ 个数并且满足取反、与运算封闭（即任意对 $S$ 集合内部元素取反或者是与运算操作得到的数都 $\in S$），问都多少个这样的 $S$。$m\leq 1000$，$n\leq 50$，对 $10 ^ 9 + 7$ 取模。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>CF891E Lust</title>
    <link href="https://mydcwfy.github.io/2022/07/20/CF891E/"/>
    <id>https://mydcwfy.github.io/2022/07/20/CF891E/</id>
    <published>2022-07-20T12:33:15.000Z</published>
    <updated>2022-07-20T12:52:55.550Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定长度为 $n$ 序列 $a$，每次随机选择 $i\in [1, n]$，将 $r$ 加上 $\prod_{j\ne i} a_j$，然后让 $a_i$ 减 1。问 $k$ 次操作后，$r$ 的期望。$n\leq 5000$，$k\leq 10 ^ 9$，对 $10 ^ 9 + 7$ 取模。</p><span id="more"></span><p>首先给出一个结论：<br>$$<br>r = \prod_{i = 1} ^ n a_i - \prod_{i = 1} ^ n a_i’<br>$$<br>表示前后 $a_i$ 乘积的变化量。这个可以通过分每一步看来得到，既然单步是正确的，那么合并起来也是正确的。</p><p>现在显然是求变化后的期望。</p><p>考虑使用 EGF 计算每一步改变的哪一个位置，然后合并。单个的 EGF 可以写作：$\sum_{i = 0} \dfrac{x ^ i}{i!} (a - i)$。</p><p>那么最后变化后的期望就是：<br>$$<br>\dfrac{k!}{n ^ k} [x ^ k] \prod_{i = 1} ^ n \sum_{j = 0} \dfrac{x ^ j}{j!}(a_j - x)<br>$$<br>不是封闭形式不好计算，考虑对每一个 $\sum_{i = 0} \dfrac{x ^ i} {i!} (a - i)$ 变换来尝试得到封闭形式：<br>$$<br>\begin{aligned}<br>&amp; \sum_{j = 0} \dfrac{x ^ j}{j!} (a - j)\\<br>=&amp; \sum_{j = 0} \dfrac{x ^ ja}{j!} - \sum_{j = 0} \dfrac{x ^ jj}{j!}\\<br>=&amp; ae ^ x - \sum_{j = 1} \dfrac{xx ^ {j - 1}}{(j - 1!)}\\<br>=&amp; (a - x) e ^ x<br>\end{aligned}<br>$$<br>这样就变成的封闭形式。</p><p>乘起来可以得到：<br>$$<br>\dfrac{k!}{n ^ k} [x ^ k] e ^ {nx} \prod_{i = 1} ^ n (a_i - x)<br>$$<br>后面这个式子可以 $O(n\log ^ 2 n)$ 计算，但是直接 $O(n ^ 2)$ DP 计算每一位也不是不行。</p><p>下面对后面是贡献 $x ^ t$ 时 $x ^ k$ 的系数计算：<br>$$<br>\dfrac{k!}{n ^ k} \times \dfrac{c_t n ^ {k - t}}{(k - t)!}<br>$$<br>虽然 $k$ 很大，但是 $t$ 不大，这些都可以约到 $t$ 项，而且不同的 $t$ 可以递推计算，所以这不是难事，可以在 $O(n)$ 或者 $O(n\log k)$ 的时间内求出所有 $t\in [0, n]$ 的贡献。</p><p>总时间复杂度 $O(n ^ 2)$，<del>狗都不写 MTT</del>。注意代码中的 <code>f[t]</code> 求的是 $n - t$ 的系数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) std::cin &gt;&gt; a[i];</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; ~j; -- j)</span><br><span class="line">f[j + <span class="number">1</span>] = (f[j + <span class="number">1</span>] + (LL) f[j] * a[i]) % Mod;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>, cur = k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; i &lt;= k; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>))</span><br><span class="line">res = (res + (LL) (Mod - cur) * <span class="built_in">qpow</span>(n, k - i) % Mod * f[n - i]) % Mod;</span><br><span class="line"><span class="keyword">else</span> res = (res + (LL) cur * <span class="built_in">qpow</span>(n, k - i) % Mod * f[n - i]) % Mod;</span><br><span class="line">cur = (LL) cur * (k - i) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">res = (LL) res * <span class="built_in">qpow</span>(n, Mod - <span class="number">1</span> - k) % Mod;</span><br><span class="line"><span class="comment">// adj(res = f[n] - res);</span></span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定长度为 $n$ 序列 $a$，每次随机选择 $i\in [1, n]$，将 $r$ 加上 $\prod_{j\ne i} a_j$，然后让 $a_i$ 减 1。问 $k$ 次操作后，$r$ 的期望。$n\leq 5000$，$k\leq 10 ^ 9$，对 $10 ^ 9 + 7$ 取模。&lt;/p&gt;</summary>
    
    
    
    
    <category term="生成函数" scheme="https://mydcwfy.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
    <category term="期望" scheme="https://mydcwfy.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>ARC Round#130</title>
    <link href="https://mydcwfy.github.io/2022/07/14/ARC-Round-130/"/>
    <id>https://mydcwfy.github.io/2022/07/14/ARC-Round-130/</id>
    <published>2022-07-14T10:44:53.000Z</published>
    <updated>2022-07-14T12:09:48.295Z</updated>
    
    <content type="html"><![CDATA[<p>顺风场，vp 的时候打到了 rk 27 左右，补题也还不算很困难。</p><span id="more"></span><p>A、B 略去。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定两个数位不包含 0 的数 $a, b$，要求重排后两个数的和的数位和最小。求重排后的 $a, b$。$a, b\leq 10 ^ {100000}$。</p><p>容易发现肯定是需要进位最多。进位有 3 个源头：</p><ol><li>最低位满足两个数加起来 $\geq 10$。</li><li>从低位向高位一段区间，满足两个数加起来 $\geq 9$。</li><li>$a, b$ 位数不同，假设 $b$ 更高，$b$ 从 $a$ 没有的位置开始有一段 9，且 $a$ 有的位置都产生了进位。</li></ol><p>首先容易发现不管是 $\geq 10$ 还是 $\geq 9$，我们都是一种双指针的策略贪心选取合法匹配中最小的一组。第一种情况和其他情况不同，我们暴力枚举 $a, b$ 的最低位知多少，然后高位直接贪心匹配 1 和 8，2 和 7，3 和 6……不能匹配就把后面的 +1，继续匹配。</p><p>由贪心易得正确性。不同答案的合并直接判进位次数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(std::string cura, std::string curb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::<span class="built_in">reverse</span>(cura.<span class="built_in">begin</span>(), cura.<span class="built_in">end</span>());</span><br><span class="line">std::<span class="built_in">reverse</span>(curb.<span class="built_in">begin</span>(), curb.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">while</span> (cura.<span class="built_in">size</span>() &lt; curb.<span class="built_in">size</span>()) cura += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, ls = <span class="number">0</span>; i &lt; (<span class="type">int</span>) curb.<span class="built_in">size</span>(); ++ i)</span><br><span class="line">ls = cura[i] - <span class="string">&#x27;0&#x27;</span> + curb[i] - <span class="string">&#x27;0&#x27;</span> + ls &gt;= <span class="number">10</span>, cnt += ls;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> _a, <span class="type">int</span> _b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;Solve &quot; &lt;&lt; _a &lt;&lt; &#x27; &#x27; &lt;&lt; _b &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">auto</span> ta = cnta, tb = cntb;</span><br><span class="line">std::string cura, curb;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">9</span>, j = <span class="number">1</span>; i; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= <span class="number">9</span> &amp;&amp; ta[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (i + j &lt; <span class="number">9</span>) &#123;</span><br><span class="line">++ j;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> del = std::<span class="built_in">min</span>(ta[i], tb[j]);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; j &lt;&lt; &#x27; &#x27; &lt;&lt; del &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">cura += std::<span class="built_in">string</span>(del, i | <span class="number">48</span>), curb += std::<span class="built_in">string</span>(del, j | <span class="number">48</span>);</span><br><span class="line">ta[i] -= del, tb[j] -= del;</span><br><span class="line"><span class="keyword">if</span> (!tb[j]) ++ j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">9</span>; i; -- i) cura += std::<span class="built_in">string</span>(ta[i], i | <span class="number">48</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">9</span>; i; -- i) curb += std::<span class="built_in">string</span>(tb[i], i | <span class="number">48</span>);</span><br><span class="line">std::<span class="built_in">reverse</span>(cura.<span class="built_in">begin</span>(), cura.<span class="built_in">end</span>());</span><br><span class="line">std::<span class="built_in">reverse</span>(curb.<span class="built_in">begin</span>(), curb.<span class="built_in">end</span>());</span><br><span class="line">cura.<span class="built_in">push_back</span>(_a | <span class="number">48</span>), curb.<span class="built_in">push_back</span>(_b | <span class="number">48</span>);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; cura &lt;&lt; &#x27; &#x27; &lt;&lt; curb &lt;&lt; &#x27; &#x27; &lt;&lt; getsum(cura, curb) &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">getsum</span>(cura, curb) &gt; <span class="built_in">getsum</span>(resa, resb) || resa.<span class="built_in">empty</span>()) resa = cura, resb = curb;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="type">bool</span> rev = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>()) std::<span class="built_in">swap</span>(a, b), rev = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> &amp;c : a) cnta[c &amp; <span class="number">15</span>] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> &amp;c : b) cntb[c &amp; <span class="number">15</span>] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; ++ j)</span><br><span class="line"><span class="keyword">if</span> (cnta[i] &amp;&amp; cntb[j]) &#123;</span><br><span class="line">cnta[i] --, cntb[j] --;</span><br><span class="line"><span class="built_in">solve</span>(i, j);</span><br><span class="line">cnta[i] ++, cntb[j] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!rev) std::cout &lt;&lt; resa &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; resb &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> std::cout &lt;&lt; resb &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; resa &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：要将 $[1, n]$ 的排列放入一个 $n$ 个点的树，每个点对应一个权值，使得每个点都是局部最小或最大（比相邻点都大 / 小），问有多少种方案，对 998244353 取模。$n\leq 3000$。</p><p>套路树形 DP + 背包。记录 $f(i, j, k)$ 表示 $i$ 所在子树内 $i$ 是局部最小值还是最大值（$k = 0$ 表示最小，$k = 1$ 表示最大），且 $i$ 在子树内的排名是 $j$。直接暴力合并，即可得到答案。</p><p>看似我们需要枚举 $u, v$ 在对应子树内的排名，是 $O(n ^ 3)$ 的，但是容易发现枚举的排名都是 $O(sz)$ 的。考虑每一对点对 $(x, y)$，他们都只会在 $lca$ 处枚举到，而他的代价和 $O(sz)$ 枚举的代价相同，于是原问题也是 $O(n ^ 2)$ 的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sz[x] = <span class="number">1</span>, dp[x][<span class="number">0</span>][<span class="number">1</span>] = dp[x][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v, x);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> tmp[N], sum[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz[x] + sz[v]; ++ i) tmp[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz[v] + <span class="number">1</span>; ++ i) sum[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = sz[v]; i; -- i) <span class="built_in">adj</span>(sum[i] = sum[i + <span class="number">1</span>] + dp[v][<span class="number">1</span>][i] - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz[x]; ++ i) <span class="comment">// sz[x] - i</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sz[v]; ++ j) <span class="comment">// sz[v] - j</span></span><br><span class="line">tmp[i + j] = (tmp[i + j] + (LL) dp[x][<span class="number">0</span>][i] * sum[j + <span class="number">1</span>] % Mod * <span class="built_in">C</span>(i + j - <span class="number">1</span>, i - <span class="number">1</span>)</span><br><span class="line">% Mod * <span class="built_in">C</span>(sz[x] + sz[v] - i - j, sz[x] - i)) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz[x] + sz[v]; ++ i) dp[x][<span class="number">0</span>][i] = tmp[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz[x] + sz[v]; ++ i) tmp[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz[v]; ++ i) sum[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz[v]; ++ i)</span><br><span class="line"><span class="built_in">adj</span>(sum[i] = sum[i - <span class="number">1</span>] + dp[v][<span class="number">0</span>][i] - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz[x]; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= sz[v]; ++ j)</span><br><span class="line">tmp[i + j] = (tmp[i + j] + (LL) dp[x][<span class="number">1</span>][i] * sum[j] % Mod * <span class="built_in">C</span>(i + j - <span class="number">1</span>, i - <span class="number">1</span>)</span><br><span class="line">% Mod * <span class="built_in">C</span>(sz[x] + sz[v] - i - j, sz[x] - i)) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz[x] + sz[v]; ++ i) dp[x][<span class="number">1</span>][i] = tmp[i];</span><br><span class="line"></span><br><span class="line">sz[x] += sz[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">g[u].<span class="built_in">push_back</span>(v), g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">adj</span>(res += dp[<span class="number">1</span>][<span class="number">0</span>][i] - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">adj</span>(res += dp[<span class="number">1</span>][<span class="number">1</span>][i] - Mod);</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：对一个正整数序列 $A$ 操作 $k$ 次，单次操作为把一个最小值 +1。最后得到一个长度为 $k$ 的序列 $id$，为每次 +1 的数的位置。现已知 $id$，求是否存在一个 $A$ 满足能得到 $id$，如果存在输出字典序最小的 $A$。$n, k\leq 3\times 10 ^ 5$。</p><p>和官方题解做法似乎不同，来自 jiangly 的代码。</p><p>首先有一个关键的性质：</p><blockquote><p>结论：答案序列 $A$ 在操作过程中一定出现了一次所有数都相同的时候。</p><p>证明：首先考虑至少出现了一次的数。当操作完之后，所有数一定都满足任意数差都不超过 1，因为一旦出现这种情况，小的那个数一定会在大的那个数操作第一次前就和他靠近距离，最后一定差不超过 1。而最后几次操作一定是对着 $val + 1$ 去的（设最小值为 $val$），那么消完所有的 $val + 1$ 后，都是 $val$ 了。另外，对于没有操作的数，他们至少是 $val$，否则会被操作一次；另外 $&gt; val$ 就不优了，因为 $=val$ 可以满足条件。</p></blockquote><p>容易发现如果我们找到这个时候和这个时候所有数的权值，原序列很容易求出了。</p><p>尝试对原操作序列进行分段，使得每一段操作的数的最小值相同。容易发现一段一定不包含任何重复的数字，并且区间长度等于右端点前面出现不同数字的总和。那么可以得到结论中提到的位置就是倒数第二段的右端点，而权值就是前面段数 +1（减掉段数次后还得是正整数）。</p><p>考虑逐个计算以 $i$ 结尾的段数。维护一个 $mx$ 表示倒序扫描扫到第一个重复数字的位置。容易发现最后一段划分位置不能在 $mx$ 之前。另外，转移的时候肯定是从 $i - cnt$ 划分（如果合法）。</p><p>然后从最后的 $mx$ 向后扫描，看能否找到一个合法划分的，如果能的话，找一个段数最小的，段数相同肯定位置较大的更优。找到之后模拟即可。时间复杂度线性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, id + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cur[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">ls[i] = cur[id[i]], cur[id[i]] = i;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, cnt = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">chkmax</span>(mx, ls[i]), cnt += !~ls[i];</span><br><span class="line"><span class="keyword">if</span> (mx + cnt &gt; i) cov[i] = INF;</span><br><span class="line"><span class="keyword">else</span> cov[i] = cov[i - cnt] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fin = INF, pos = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = mx; i &lt; m; ++ i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">chkmin</span>(fin, cov[i]), fin == cov[i]) pos = i;</span><br><span class="line"><span class="keyword">if</span> (fin &gt; INF / <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = fin + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = pos; i; -- i) -- a[id[i]];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：给出一个序列，令 $j = \dfrac{i + k}2$，可以把 $a_j\leftarrow \lfloor \dfrac{a_i + a_k}{2} \rfloor$，求任意操作之后得到的 $\sum a$ 的最小值。$n\leq 3\times 10 ^ 5, n\leq 10 ^ {12}$。</p><p>其实感觉很神秘的一个题目，其实似乎没有 E 难？</p><p>容易发现如果 $a_j &gt; \dfrac{a_i + a_k}{2}$，我们操作一波之后其实变成了这样：</p><img src="/2022/07/14/ARC-Round-130/ARC130F1.png" class=""><p>这样操作相当于把下凸的部分砍掉了，那么剩下的部分其实就是一个 $(i, a_i)$ 的上凸包不会被消灭。</p><p>如果是实数的话，这个题就做完了，直接计算新的这个点会落在那两个关键点之间，然后用斜率算算即可。求凸包可以直接单调栈做到线性。</p><p>问题就在于还有一个神秘的下取整。容易发现不同段之间其实还是没有影响，因为不可能把原来的关键点给弄没了的。主要就在于把区间内部的搞好。</p><p>大概目前看到的最简洁的做法是把区间内按照原来构造直接下取整的数组构造出来，差分后直接排序，再放回去前缀和。容易发现这个还是不影响段间的情况。</p><p>其实这么做的原因是由于负数除法的时候会向 0 取整，出一些锅，好像只有正数（相邻两个关键点变化量为正）时没有问题吧。没验证过，还不太清楚。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">LL x, y;</span><br><span class="line">Point <span class="keyword">operator</span> -(Point t) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;; &#125;</span><br><span class="line">LL <span class="keyword">operator</span> *(Point t) <span class="type">const</span> &#123; <span class="keyword">return</span> x * t.y - y * t.x; &#125;</span><br><span class="line">&#125; p[N];</span><br><span class="line"><span class="type">int</span> n, stk[N];</span><br><span class="line">LL a[N], b[N], del[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) std::cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) p[i] = &#123;i, a[i]&#125;;</span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; (p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top - <span class="number">1</span>]]) &lt;= <span class="number">0</span>)</span><br><span class="line">top --;</span><br><span class="line">stk[++ top] = i;</span><br><span class="line">&#125;</span><br><span class="line">b[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; top; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = stk[i] + <span class="number">1</span>; j &lt;= stk[i + <span class="number">1</span>]; ++ j)</span><br><span class="line">b[j] = a[stk[i]] + (a[stk[i + <span class="number">1</span>]] - a[stk[i]]) * (j - stk[i]) / (stk[i + <span class="number">1</span>] - stk[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) del[i] = b[i + <span class="number">1</span>] - b[i];</span><br><span class="line">std::<span class="built_in">sort</span>(del + <span class="number">1</span>, del + n);</span><br><span class="line">b[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) b[i + <span class="number">1</span>] = b[i] + del[i];</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) res += b[i];</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;顺风场，vp 的时候打到了 rk 27 左右，补题也还不算很困难。&lt;/p&gt;</summary>
    
    
    
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>ARC141F Well-defined Abbreviation</title>
    <link href="https://mydcwfy.github.io/2022/07/13/ARC141F/"/>
    <id>https://mydcwfy.github.io/2022/07/13/ARC141F/</id>
    <published>2022-07-13T13:20:33.000Z</published>
    <updated>2022-07-13T14:00:11.438Z</updated>
    
    <content type="html"><![CDATA[<p>题意：有 $n$ 个串只包含 <code>A, B, C, D</code> 的 $S_i$，问是否存在一个 $T$，经过删除 $T$ 中存在的 $S_i$ 直到不存在任意一个 $S_i$ 后，可以得到不同的串。$n, \sum |S_i|\leq 2\times 10 ^ 6$，8s。</p><span id="more"></span><p>神仙 AC 自动机 + Hash 随机化分析。</p><p>首先分析几个结论：</p><blockquote><p>结论 1：如果一个 $S_i$ 被其他串组合后完全删除，那么这个串是没有意义的。</p></blockquote><p>证明：显然如果要删这个串的话，可以删除组成他的所有串。</p><blockquote><p>结论 2：如果一个 $S_i$ 被其他串所删除但是没有完全删除，那么答案一定是 Yes。</p></blockquote><p>证明：直接取 $T = S_i$，至少会得到空串和没有完全删除的串，已经符合题目条件。</p><p>有了上面两个结论之后，我们可以通过使用 AC 自动机暴力匹配，用一个栈记录匹配过程，如果匹配到了一个串的话，直接倒回到还没有加入串前的状态。这样一定不会出现贪心匹配没有完全匹配的情况（即有其他方案使得该串被完全删除），因为一旦出现这种情况，答案就是 Yes。</p><p>下面所有的串一定不会出现一个是另一个子串的问题了。</p><p>再来一个结论：</p><blockquote><p>结论 3：如果出现两个串 $S_i$ 和 $S_j$（$i, j$ 可能相同），$S_i$ 的某个后缀和 $S_j$ 的某个前缀是相同的，并且剩余部分不同，那么答案一定是 Yes。</p></blockquote><p>证明：构造一个串为 $S_i$ 去掉相同后缀的前缀 + 共同后缀 / 前缀 + $S_j$ 去掉相同前缀的后缀。我们前面说到，不会再出现一个串是另一个子串的情况。那么 $S_i, S_j$ 分别删除后，剩下的两个串不同且无法消去，于是答案就是 Yes。</p><p>最后一个结论：</p><blockquote><p>结论 4：不满足结论 3 的条件，答案一定是 No。</p></blockquote><p>因为如果一个答案是 Yes 的话，一定出现了两个串相交的情形（否则没有相干，自己删自己的），而又不会出现子串的情形，所以肯定只有结论 3 的情况才会出现 Yes 的可能性。</p><p>下面就是需要判断 $S_i$ 的后缀和某个 $S_j$ 的前缀匹配，并且 $S_i, S_j$ 的剩余部分不同。有接着使用 AC 自动机做法，但人懒了，直接大力 Hash 做。</p><p>具体的，可以考虑枚举每一个后缀，将其 Hash 值和剩余部分的 Hash 值存下来，然后再枚举每个前缀，尝试匹配一些后缀。时间复杂度 $O(\sum |S|)$ 或 $O(\sum |S|\log \sum |S|)$。</p><p>最后一个问题就是众所周知的 Hash 冲突问题。其实一般想卡 Hash 是比较难的，因为 Hash 自选模数，自选 base，很不好卡，不同的字符串相当于是随机数对撞。注意到如果选取模数为 $P$ 的话，那么存的个数不能超过 $O(\sqrt P)$ 个，反过来，如果我们存了 $\sum |S|$ 个数，为了使不同的字符串分开，我们至少需要 $O((\sum|S|) ^ 2)$ 的 $P$，在本题中是 $10 ^ {13}$，所以一般的模数例如 998244353，$10 ^ 9 + 7$ 之类的会 WA 一些点。</p><p>写起来还是有亿点点难写，注意由于没有多测，不要看到过了一些点就觉得自己只是 corner case 没考虑到。WA 了 16 发才过……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> LL Mod = <span class="built_in">LL</span>(<span class="number">1e15</span>) + <span class="number">37</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> ch[<span class="number">4</span>], fa;</span><br><span class="line">&#125; tr[N];</span><br><span class="line"><span class="type">int</span> n, tot, len[N], edid[N];</span><br><span class="line">LL pw[N], hash[N];</span><br><span class="line"><span class="type">bool</span> hav[N];</span><br><span class="line">std::string s[N];</span><br><span class="line">std::map&lt;LL, std::vector&lt;PII&gt;&gt; mp[N];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">chkmax</span><span class="params">(T &amp;x, T y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ? x = y, <span class="number">1</span> : <span class="number">0</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, c; s[i]; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!tr[u].ch[c = s[i] - <span class="string">&#x27;A&#x27;</span>])</span><br><span class="line">len[tr[u].ch[c] = ++ tot] = i + <span class="number">1</span>;</span><br><span class="line">u = tr[u].ch[c];</span><br><span class="line">&#125;</span><br><span class="line">edid[u] = id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (tr[<span class="number">0</span>].ch[i]) q.<span class="built_in">push</span>(tr[<span class="number">0</span>].ch[i]);</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">chkmax</span>(edid[x], edid[tr[x].fa]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!tr[x].ch[i]) tr[x].ch[i] = tr[tr[x].fa].ch[i];</span><br><span class="line"><span class="keyword">else</span> tr[tr[x].ch[i]].fa = tr[tr[x].fa].ch[i], q.<span class="built_in">push</span>(tr[x].ch[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fail</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>, <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) pw[i] = pw[i - <span class="number">1</span>] * <span class="number">5</span> % Mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">LL <span class="title">gethash</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ((r &lt; <span class="number">0</span> ? <span class="number">0</span> : hash[r]) + (s128) (Mod - pw[r - l + <span class="number">1</span>]) * (l == <span class="number">0</span> ? <span class="number">0</span> : hash[l - <span class="number">1</span>])) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inithash</span><span class="params">(std::string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">hash[<span class="number">0</span>] = s[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i]; ++ i) hash[i] = (hash[i - <span class="number">1</span>] * <span class="number">5LL</span> + s[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>) % Mod;</span><br><span class="line">hash[s.<span class="built_in">size</span>()] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>(), std::cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) std::cin &gt;&gt; s[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">insert</span>(s[i].<span class="built_in">c_str</span>(), i);</span><br><span class="line"><span class="built_in">build</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> id = <span class="number">1</span>; id &lt;= n; ++ id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> stk[N];</span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>, bac = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, u = <span class="number">0</span>, c, mat; s[id][i]; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">c = s[id][i] - <span class="string">&#x27;A&#x27;</span>, u = tr[u].ch[c];</span><br><span class="line">stk[++ top] = u, mat = edid[u];</span><br><span class="line"><span class="keyword">if</span> (mat == id) mat = edid[tr[u].fa];</span><br><span class="line"><span class="keyword">if</span> (mat) bac = <span class="number">1</span>, u = stk[top -= s[mat].<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!top) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (bac) <span class="built_in">fail</span>();</span><br><span class="line">hav[id] = <span class="literal">true</span>, <span class="built_in">inithash</span>(s[id]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) s[id].<span class="built_in">size</span>(); ++ i)</span><br><span class="line">mp[s[id].<span class="built_in">size</span>() - i][<span class="built_in">gethash</span>(i, s[id].<span class="built_in">size</span>() - <span class="number">1</span>)].<span class="built_in">push_back</span>(&#123;<span class="built_in">gethash</span>(<span class="number">0</span>, i - <span class="number">1</span>), i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> id = <span class="number">1</span>; id &lt;= n; ++ id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!hav[id]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">inithash</span>(s[id]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (<span class="type">int</span>) s[id].<span class="built_in">size</span>(); ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!mp[i].<span class="built_in">count</span>(<span class="built_in">gethash</span>(<span class="number">0</span>, i - <span class="number">1</span>))) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">LL curhash = <span class="built_in">gethash</span>(i, (<span class="type">int</span>) s[id].<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> curlen = s[id].<span class="built_in">size</span>() - i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [nxthash, nxtlen] : mp[i][<span class="built_in">gethash</span>(<span class="number">0</span>, i - <span class="number">1</span>)])</span><br><span class="line"><span class="keyword">if</span> (curhash != nxthash || nxtlen != curlen) flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="built_in">fail</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：有 $n$ 个串只包含 &lt;code&gt;A, B, C, D&lt;/code&gt; 的 $S_i$，问是否存在一个 $T$，经过删除 $T$ 中存在的 $S_i$ 直到不存在任意一个 $S_i$ 后，可以得到不同的串。$n, \sum |S_i|\leq 2\times 10 ^ 6$，8s。&lt;/p&gt;</summary>
    
    
    
    
    <category term="随机化" scheme="https://mydcwfy.github.io/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"/>
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="字符串" scheme="https://mydcwfy.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="AC 自动机" scheme="https://mydcwfy.github.io/tags/AC-%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>ARC Round#141</title>
    <link href="https://mydcwfy.github.io/2022/07/13/ARC-Round-141/"/>
    <id>https://mydcwfy.github.io/2022/07/13/ARC-Round-141/</id>
    <published>2022-07-13T12:27:12.000Z</published>
    <updated>2022-07-13T14:02:41.215Z</updated>
    
    <content type="html"><![CDATA[<p>有趣的比赛，做题 + 改题一共交了 35 次……</p><span id="more"></span><p>A、B 略去。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：有一个括号序列 $S$，在 $[1, 2n]$ 的所有排列中，对应括号序列合法且最小的排列记为 $P$，对应括号序列合法且最大的排列记为 $Q$，已知 $P, Q$，求 $S$ 或报告无解。$n\leq 2\times 10 ^ 5$。</p><p>首先如果 $P_{2i - 1} &gt; P_{2i}$ 的话，那么 $S_{P_{2i - 1}}$ 一定是 <code>(</code>，而 $S_{P_{2i}}$ 一定是 <code>)</code>，否则我们一定可以交换 $P_{2i - 1}$ 和 $P_{2i}$。$Q$ 能确定的为如果 $Q_{2i - 1} &lt; Q_{2i}$ 的话，那么 $Q_{2i - 1}$ 一定是 <code>(</code>，$Q_{2i}$ 一定是 <code>)</code>，证明同理。</p><p>考虑一下结论：</p><blockquote><p>结论：如果在这时还有多个 $S$ 合法的话，那么就没有合法的 $S$。</p><p>证明：首先假设有合法的 $S$。容易发现一个括号序列一定是由一些合法的括号序列或者是合法的括号序列翻转后拼接得到的。我们先只考虑 $S$ 是合法的括号序列的情况。那么我们假设 <code>(</code> 出现的位置是 $L_{1\cdots n}$，<code>)</code> 出现的位置是 $R_{1\cdots n}$，显然有 $L_1 &lt; R_1, L_2 &lt; R_2, \cdots$，那么 $Q$ 的排列一定是 $(L_n, R_n, L_{n - 1}\cdots)$。按照刚刚的构造方法，我们可以根据 $Q$ 还原出唯一的 $S$（$L_n &lt; R_n$ 可以还原 $S_{L_n}$ 是 <code>(</code>，$S_{R_n}$ 是 <code>)</code>，一起类推）。翻转过来我们可以通过 $P$ 类似的唯一还原 $S$。</p><p>注意到一个合法括号序列一定长度是偶数，那么其实我们只需要比较 $P_{2i - 1}$ 和 $P_{2i}$，就可以维护还原 $S$。而反之如果我们不能还原唯一的 $S$，那么就一定都不合法。</p></blockquote><p>这样我们只需要根据现有的限制随便构造一组解，然后用 $S$ 还原 $P, Q$，看一下 $S$ 是否合法即可。（注意不是 $P, Q$ 分别还原 $S$ 比较）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fail</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">force</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a[pos] == (val ^ <span class="number">1</span>)) <span class="built_in">fail</span>();</span><br><span class="line">a[pos] = val;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, p + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, q + i);</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">-1</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * n; i += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> (p[i] &gt; p[i + <span class="number">1</span>]) force(p[i], <span class="number">1</span>), force(p[i + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * n; i += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> (q[i] &lt; q[i + <span class="number">1</span>]) force(q[i], <span class="number">1</span>), force(q[i + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, op = <span class="number">0</span>; i &lt;= <span class="number">2</span> * n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!~a[p[i]]) a[p[i]] = op = op ^ <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i) vis[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, tot = <span class="number">0</span>, top = <span class="number">0</span>; i &lt;= <span class="number">2</span> * n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!top) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= <span class="number">2</span> * n &amp;&amp; (vis[j] || !a[j])) ++ j;</span><br><span class="line">vis[chkp[++ tot] = j] = <span class="literal">true</span>, top ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) vis[chkp[++ tot] = i] = <span class="literal">true</span>, top += a[i] ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (p[i] != chkp[i]) <span class="built_in">fail</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i) vis[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * n, j = <span class="number">2</span> * n, tot = <span class="number">0</span>, top = <span class="number">0</span>; i; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!top) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &amp;&amp; (vis[j] || !a[j])) -- j;</span><br><span class="line">vis[chkp[++ tot] = j] = <span class="literal">true</span>, top ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) vis[chkp[++ tot] = i] = <span class="literal">true</span>, top += a[i] ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (q[i] != chkp[i]) <span class="built_in">fail</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i) <span class="built_in">putchar</span>(a[i] ? <span class="string">&#x27;(&#x27;</span> : <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定一个 $n$ 个数的集合 $S$，每一个数都 $\leq 2m$，问对于每一个数，当选定这一个数后，还能不能选出一个大小为 $m$ 的集合（加上选出的这个数），使得集合内部没有倍数关系。$n, m\leq 2\times 10 ^ 5$。</p><p>注意到恰好大小为 $m$，而所有数都满足 $\leq 2m$。什么东西恰好有 $m$ 个呢？这里就要用到构造，恰好有 $m$ 个奇数。我们把每个数按照 $a\times 2 ^ b$（$a$ 为奇数）拆分，然后塞到 $a$ 这个桶内部。容易发现 $m$ 个桶，每个桶都最多只有一个数被选。那么如果出现一个桶没有数，就一定没有解。否则假设选出来的数的 2 的次幂为 $v_i$。</p><p>此外，不同桶之间还可能存在倍数关系，比如 $a\times 2 ^ x$ 是 $b\times 2 ^ y$ 的倍数当且仅当 $b|a$ 并且 $x\geq y$。那么对于成倍数的 $(a, b)$ 的 <code>std::pair</code>，那么一定需要保证 $v_a &lt; v_b$。</p><p>如何判断一个数能否出现在合法的集合中呢？我们可以考虑对于每一个 $i$，计算 $v_i$ 的区间。具体的，如果需要计算最大值的话，顺序扫一遍，计算完一个数后更新他的倍数。计算最小值的时候倒序扫一遍，计算这个数的最小值时从他的倍数更新过来。复杂度都是 $O(m\log m)$ 的。</p><p>最后来一个数判一判在不在区间里即可。注意这个区间的上界和下界对应的数都是存在于原来的集合的，否则整个都无解。</p><p><del>赛后改题唯一一个 1 遍过的题目，其他的题目都不知错了多少发</del>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (n --) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) g[a[i] &gt;&gt; <span class="built_in">ctz</span>(a[i])].<span class="built_in">push_back</span>(<span class="built_in">ctz</span>(a[i]));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= m) j &lt;&lt;= <span class="number">1</span>, R[i] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * m; ++ i) L[i] = <span class="number">-1e9</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (g[i].<span class="built_in">empty</span>() || g[i].<span class="built_in">front</span>() &gt; R[i]) <span class="built_in">fail</span>();</span><br><span class="line">R[i] = *-- std::<span class="built_in">upper_bound</span>(g[i].<span class="built_in">begin</span>(), g[i].<span class="built_in">end</span>(), R[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">2</span>; d * i &lt;= <span class="number">2</span> * m; ++ d) <span class="built_in">chkmin</span>(R[i * d], R[i] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * m; i; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">2</span>; d * i &lt;= <span class="number">2</span> * m; ++ d) <span class="built_in">chkmax</span>(L[i], L[i * d] + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; L[i] &lt;&lt; &#x27; &#x27; &lt;&lt; g[i].back() &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">if</span> (g[i].<span class="built_in">empty</span>() || g[i].<span class="built_in">back</span>() &lt; L[i]) <span class="built_in">fail</span>();</span><br><span class="line">L[i] = *std::<span class="built_in">lower_bound</span>(g[i].<span class="built_in">begin</span>(), g[i].<span class="built_in">end</span>(), L[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> y = <span class="built_in">ctz</span>(a[i]), x = a[i] &gt;&gt; y;</span><br><span class="line"><span class="keyword">if</span> (y &gt;= L[x] &amp;&amp; y &lt;= R[x]) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：给定一个 $n\times n$ 的网格，标号从 0 开始，$m$ 次给定 $a, b, c, d$，把 $((a + i)\bmod n, (b + i)\bmod n)$ 和 $((c + i)\bmod n, (d + i)\bmod n)$ 连接起来，每次操作后问连通块数目。$n, m\leq 2\times 10 ^ 5$。</p><p>容易发现按照 $(b - a)\bmod n$ 分类，然后使用并查集，这样连边的时候相当于只是在 2 个集合中间按照一定的 $\Delta$ 量连边。这样考虑怎怎样动态维护这个 $\Delta$ 量。</p><p>首先显然需要维护该集合到根所代表的集合，其 $\Delta$ 是多少（即 根的 $(0, x)$ 连到该集合的 $(\Delta, \Delta + y)$）。然后可能出现连边两个原来就联通的集合，那么我们注意，并不一定是毫无用处，比如：</p><img src="/2022/07/13/ARC-Round-141/ARC141E1.png" class=""><p>这样蓝边后加入，虽然没有改变不同集合联通性，但是我们发现，一个集合内部出现的连边，他们每 3 个就连在了一起。于是我们还需要维护该集合内部循环长度是多少。两个合并的时候，其实就是 $\gcd$，手玩一下即可。循环长度也就是该集合总共的连通块个数，直接维护答案变化即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == f[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="type">int</span> rt = <span class="built_in">find</span>(f[x]);</span><br><span class="line">dis[x] = (dis[x] + dis[f[x]]) % del[rt];</span><br><span class="line"><span class="keyword">return</span> f[x] = rt;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) f[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) del[i] = n;</span><br><span class="line">LL ans = (LL) n * n;</span><br><span class="line"><span class="type">int</span> a, b, c, d;</span><br><span class="line"><span class="keyword">while</span> (m --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line"><span class="type">int</span> x = (b - a + n) % n, y = (d - c + n) % n, de = (d - b + n) % n,</span><br><span class="line">fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span> (fx == fy) &#123;</span><br><span class="line">ans -= del[fx];</span><br><span class="line">del[fx] = <span class="built_in">Gcd</span>(del[fx], dis[x] - dis[y] + del[fx] + de);</span><br><span class="line">ans += del[fx];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ans -= del[fx] + del[fy];</span><br><span class="line">del[fx] = <span class="built_in">Gcd</span>(del[fx], del[fy]);</span><br><span class="line">f[fy] = fx, dis[fy] = (dis[x] - dis[y] + n + de) % del[fx];</span><br><span class="line">ans += del[fx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>见 <a href="/2022/07/13/ARC141F/">ARC141F</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有趣的比赛，做题 + 改题一共交了 35 次……&lt;/p&gt;</summary>
    
    
    
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="AtCoder" scheme="https://mydcwfy.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3473 字符串</title>
    <link href="https://mydcwfy.github.io/2022/07/09/BZOJ3473/"/>
    <id>https://mydcwfy.github.io/2022/07/09/BZOJ3473/</id>
    <published>2022-07-09T03:38:30.000Z</published>
    <updated>2022-07-09T06:00:55.748Z</updated>
    
    <content type="html"><![CDATA[<p>经典 SAM 题目，似乎有很简洁的做法，但没写……</p><span id="more"></span><p>题意：给定 $n$ 个字符串，对于每个字符串，求有多少个本质不同的子串满足在至少 $k$ 个串中出现过。$n, k, \sum |S|\leq 10 ^ 5$。</p><p>看到 $n$ 个串的本质不同统计，先建广义 SAM、</p><p>我们现在要干的事情是统计每一个子串在多少个字符串中出现过。组合一道广义 SAM 和普通 SAM 略有不同，如果直接打标记按照 parent 树上传的话，会出现重复的情况。于是我们使用线段树合并，这样就可以把相同位置重复的去掉了。于是时空复杂度都是 $O(\sum|S|\log \sum|S|)$，我们可以得到每一个子串在 $n$ 个字符串的那几个所覆盖，可以接受。</p><p>这里可以不用线段树合并，直接大力标记，遇到标记过的就跳过，这样可以平衡规划证得时间复杂度为 $O(\sum |S|\sqrt{\sum |S|})$，仍然可以通过。</p><p>然后考虑如何统计每一个串的答案。直接在广义 SAM 上跑匹配，因为一个字符串一旦合法，他 parent 的父亲都合法，我们不需要向上再跳，直接假设当前节点的最大值即可。这里是线性的。</p><p>于是可以在 $O(\sum |S| \log \sum |S|)$ 可以解决，注意一下应该在哪个节点加上该位置标记的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment_Tree</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> lc, rc, cnt;</span><br><span class="line">&#125; tr[N &lt;&lt; <span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!rt) rt = ++ cnt;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in">void</span>(tr[rt].cnt = <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (pos &lt;= mid) <span class="built_in">insert</span>(tr[rt].lc, l, mid, pos);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">insert</span>(tr[rt].rc, mid + <span class="number">1</span>, r, pos);</span><br><span class="line">tr[rt].cnt = tr[tr[rt].lc].cnt + tr[tr[rt].rc].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> p | q;</span><br><span class="line"><span class="type">int</span> cur = ++ cnt, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> tr[cur].cnt = tr[p].cnt | tr[q].cnt, cur;</span><br><span class="line">tr[cur].lc = <span class="built_in">merge</span>(tr[p].lc, tr[q].lc, l, mid);</span><br><span class="line">tr[cur].rc = <span class="built_in">merge</span>(tr[p].rc, tr[q].rc, mid + <span class="number">1</span>, r);</span><br><span class="line">tr[cur].cnt = tr[tr[cur].lc].cnt + tr[tr[cur].rc].cnt;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125; seg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SAM</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> ch[<span class="number">26</span>], len, fa;</span><br><span class="line">&#125; tr[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> rt[N &lt;&lt; <span class="number">1</span>], sz[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; g[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="built_in">SAM</span>() : <span class="built_in">tot</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> ls, <span class="type">int</span> c, <span class="type">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[ls].ch[c]) &#123;</span><br><span class="line"><span class="type">int</span> p = ls, q = tr[p].ch[c];</span><br><span class="line"><span class="keyword">if</span> (tr[q].len == tr[p].len + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> seg.<span class="built_in">insert</span>(rt[q], <span class="number">1</span>, n, col), q;</span><br><span class="line"><span class="type">int</span> nq = ++ tot;</span><br><span class="line">seg.<span class="built_in">insert</span>(rt[nq], <span class="number">1</span>, n, col);</span><br><span class="line">tr[nq] = tr[q], tr[nq].len = tr[p].len + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; tr[p].ch[c] == q; p = tr[p].fa) tr[p].ch[c] = nq;</span><br><span class="line"><span class="keyword">return</span> tr[q].fa = nq, nq;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> p = ls, np = ++ tot;</span><br><span class="line">tr[np].len = tr[p].len + <span class="number">1</span>;</span><br><span class="line">seg.<span class="built_in">insert</span>(rt[np], <span class="number">1</span>, n, col);</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; !tr[p].ch[c]; p = tr[p].fa) tr[p].ch[c] = np;</span><br><span class="line"><span class="keyword">if</span> (!p) tr[np].fa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> q = tr[p].ch[c];</span><br><span class="line"><span class="keyword">if</span> (tr[q].len == tr[p].len + <span class="number">1</span>)</span><br><span class="line">seg.<span class="built_in">insert</span>(rt[q], <span class="number">1</span>, n, col), tr[np].fa = q;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> nq = ++ tot;</span><br><span class="line">seg.<span class="built_in">insert</span>(rt[nq], <span class="number">1</span>, n, col);</span><br><span class="line">tr[nq] = tr[q], tr[nq].len = tr[p].len + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; tr[p].ch[c] == q; p = tr[p].fa) tr[p].ch[c] = nq;</span><br><span class="line">tr[np].fa = tr[q].fa = nq;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> np;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x])</span><br><span class="line"><span class="built_in">dfs</span>(v), rt[x] = seg.<span class="built_in">merge</span>(rt[x], rt[v]);</span><br><span class="line">sz[x] = seg.tr[rt[x]].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= tot; ++ i) g[tr[i].fa].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; sam;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, ls; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">std::cin &gt;&gt; s[i];</span><br><span class="line">ls = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : s[i]) ls = sam.<span class="built_in">extend</span>(ls, c - <span class="string">&#x27;a&#x27;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">sam.<span class="built_in">work</span>();</span><br><span class="line"><span class="comment">// exit(0);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : s[i])</span><br><span class="line">&#123;</span><br><span class="line">p = sam.tr[p].ch[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">while</span> (p != <span class="number">1</span> &amp;&amp; sam.sz[p] &lt; k) p = sam.tr[p].fa;</span><br><span class="line"><span class="keyword">if</span> (sam.sz[p] &gt;= k) res += sam.tr[p].len;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典 SAM 题目，似乎有很简洁的做法，但没写……&lt;/p&gt;</summary>
    
    
    
    
    <category term="字符串" scheme="https://mydcwfy.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="后缀数据结构" scheme="https://mydcwfy.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线段树合并" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>LOJ2720 [NOI2018]你的名字</title>
    <link href="https://mydcwfy.github.io/2022/07/09/LOJ2720/"/>
    <id>https://mydcwfy.github.io/2022/07/09/LOJ2720/</id>
    <published>2022-07-09T03:19:47.000Z</published>
    <updated>2022-07-09T03:43:20.503Z</updated>
    
    <content type="html"><![CDATA[<p>现在才来补 NOI 经典题 /kk</p><span id="more"></span><p>题意：给定一个串 $S$，$q$ 次询问，每次给出 $T, l, r$，问 $T$ 中不是 $S[l\to r]$ 的子串的本质不同子串个数。$|S|, q, |T|\leq 5\times 10 ^ 5$，$\sum |T|\leq 10 ^ 6$，4s。</p><p>考虑 $l = 1, r = n$ 怎么做。由于是求本质不同的串，考虑对 $T$ 建后缀自动机，对于每个节点统计答案。</p><p>还是要建 $S$ 的后缀自动机，然后把每一个前缀的最大匹配后缀找出来，于是这些不合法后缀的后缀都是不合法的，其他的都是合法的。</p><p>找到该前缀在 $T$ 的后缀自动机中对应的位置，那么一个节点的最大覆盖长度就是 parent 树子树下的覆盖长度的最大值。在 parent 树上做做就可以做到单次 $O(|T|)$ 的复杂度。</p><p>下面考虑 $S$ 有 $[l, r]$ 该如何计算。现在我们计算一个前缀是否能匹配，不再是看一个点有没有 <code>ch[c]</code> 这个儿子，还需要看 <code>ch[c]</code> 这个儿子有没有出现在 $[l, r]$ 区间完整出现。注意到我们相当于是看 $\text{endpos}$ 是否在 $[l + len - 1, r]$ 区间出现过。而维护每一个节点的 $\text{endpos}$，可以使用线段树合并做到 $O(|S|\log|S|)$ 的时空复杂度，单次 $O(\log|S|)$ 查询。</p><p>于是本题可以做到 $O(|S|\log|S| + \sum|T|\log|S|)$，可以通过。实现的时候注意 parent 树统计子树答案的时候用 bfs 拓扑序算而不是 dfs。另外，匹配的时候需要每一个 $len$ 都判一遍，而不是像直接跳到父亲，单次减少的 $len$ 比较大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SAM</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> ch[<span class="number">26</span>], len, fa;</span><br><span class="line">&#125; tr[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> ls, tot, pos[N &lt;&lt; <span class="number">1</span>], cov[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; ls = tot = <span class="number">1</span>, tr[<span class="number">1</span>] = &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> curpos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> p = ls, np = ++ tot;</span><br><span class="line">tr[np] = &#123;&#125;, pos[np] = curpos, ls = tot, tr[np].len = tr[p].len + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; !tr[p].ch[c]; p = tr[p].fa) tr[p].ch[c] = np;</span><br><span class="line"><span class="keyword">if</span> (!p) tr[np].fa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> q = tr[p].ch[c];</span><br><span class="line"><span class="keyword">if</span> (tr[q].len == tr[p].len + <span class="number">1</span>) tr[np].fa = q;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> nq = ++ tot;</span><br><span class="line">pos[nq] = <span class="number">0</span>, tr[nq] = tr[q], tr[nq].len = tr[p].len + <span class="number">1</span>;</span><br><span class="line">tr[np].fa = tr[q].fa = nq;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; tr[p].ch[c] == q; p = tr[p].fa) tr[p].ch[c] = nq;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Twork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) g[i].<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= tot; ++ i) g[tr[i].fa].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="type">int</span> hh = <span class="number">1</span>, tt = <span class="number">1</span>;</span><br><span class="line">q[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = q[hh ++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x])</span><br><span class="line">q[++ tt] = v;</span><br><span class="line">&#125;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = tt, x; i &gt; <span class="number">1</span>; -- i)</span><br><span class="line">&#123;</span><br><span class="line">x = q[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x])</span><br><span class="line"><span class="built_in">chkmax</span>(cov[x], cov[v]);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; cov[x] &lt;&lt; &#x27; &#x27; &lt;&lt; tr[x].len &lt;&lt; &#x27; &#x27; &lt;&lt; tr[tr[x].fa].len &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">if</span> (cov[x] &lt;= tr[x].len)</span><br><span class="line">res += tr[x].len - std::<span class="built_in">max</span>(cov[x], tr[tr[x].fa].len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125; sams, samt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> lc, rc, cnt;</span><br><span class="line">&#125; tr[(<span class="type">int</span>) <span class="number">3e7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> p | q;</span><br><span class="line"><span class="type">int</span> cur = ++ tot, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> tr[cur].cnt = tr[p].cnt + tr[q].cnt, cur;</span><br><span class="line">tr[cur].lc = <span class="built_in">merge</span>(tr[p].lc, tr[q].lc, l, mid);</span><br><span class="line">tr[cur].rc = <span class="built_in">merge</span>(tr[p].rc, tr[q].rc, mid + <span class="number">1</span>, r);</span><br><span class="line">tr[cur].cnt = tr[tr[cur].lc].cnt + tr[tr[cur].rc].cnt;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!rt) rt = ++ tot;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in">void</span>(tr[rt].cnt ++);</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (pos &lt;= mid) <span class="built_in">insert</span>(tr[rt].lc, l, mid, pos);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">insert</span>(tr[rt].rc, mid + <span class="number">1</span>, r, pos);</span><br><span class="line">tr[rt].cnt = tr[tr[rt].lc].cnt + tr[tr[rt].rc].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findlast</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x || l &gt; qr || r &lt; ql) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line"><span class="type">int</span> t, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((t = <span class="built_in">findlast</span>(tr[x].rc, mid + <span class="number">1</span>, r, ql, qr))) <span class="keyword">return</span> t;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">findlast</span>(tr[x].lc, l, mid, ql, qr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> L, R, m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, s + <span class="number">1</span>, &amp;L, &amp;R);</span><br><span class="line">samt.<span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span> (m = <span class="number">1</span>; s[m]; ++ m) samt.<span class="built_in">extend</span>(s[m] - <span class="string">&#x27;a&#x27;</span>, m);</span><br><span class="line">-- m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u = <span class="number">1</span>, len = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>, cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((!sams.tr[u].ch[c] || (cur = <span class="built_in">findlast</span>(rt[sams.tr[u].ch[c]], <span class="number">1</span>, n, L, R)) &lt; L + len)</span><br><span class="line">&amp;&amp; len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((-- len) &lt;= sams.tr[sams.tr[u].fa].len) u = sams.tr[u].fa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; u &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sams.tr[u].ch[c] &amp;&amp; <span class="built_in">findlast</span>(rt[sams.tr[u].ch[c]], <span class="number">1</span>, n, L, R) &gt;= L + len)</span><br><span class="line">len ++, u = sams.tr[u].ch[c];</span><br><span class="line">mxlen[i] = len;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; len &lt;&lt; &#x27; &#x27; &lt;&lt; cur &lt;&lt; &#x27; &#x27; &lt;&lt; u &lt;&lt; &#x27; &#x27; &lt;&lt; c &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= samt.tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (samt.pos[i]) samt.cov[i] = mxlen[samt.pos[i]];</span><br><span class="line"><span class="keyword">else</span> samt.cov[i] = <span class="number">0</span>;</span><br><span class="line">std::cout &lt;&lt; samt.<span class="built_in">Twork</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> Fly727</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;name.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;name.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">sams.<span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>; s[n]; ++ n) sams.<span class="built_in">extend</span>(s[n] - <span class="string">&#x27;a&#x27;</span>, n);</span><br><span class="line">-- n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= sams.tot; ++ i) g[sams.tr[i].fa].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="type">int</span> hh = <span class="number">1</span>, tt = <span class="number">1</span>;</span><br><span class="line">q[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = q[hh ++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x])</span><br><span class="line">q[++ tt] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;Check &quot; &lt;&lt; sams.tr[4].ch[0] &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">// for (int i = 2; i &lt;= sams.tot; ++ i) printf(&quot;%d &quot;, sams.pos[i]);</span></span><br><span class="line"><span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = tt, x; i; -- i)</span><br><span class="line">&#123;</span><br><span class="line">x = q[i];</span><br><span class="line"><span class="keyword">if</span> (sams.pos[x]) <span class="built_in">insert</span>(rt[x], <span class="number">1</span>, n, sams.pos[x]);</span><br><span class="line">rt[sams.tr[x].fa] = <span class="built_in">merge</span>(rt[sams.tr[x].fa], rt[x], <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">std::cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T --) <span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在才来补 NOI 经典题 /kk&lt;/p&gt;</summary>
    
    
    
    
    <category term="字符串" scheme="https://mydcwfy.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="后缀数据结构" scheme="https://mydcwfy.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线段树合并" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2627 JZPKIL</title>
    <link href="https://mydcwfy.github.io/2022/07/09/BZOJ2627/"/>
    <id>https://mydcwfy.github.io/2022/07/09/BZOJ2627/</id>
    <published>2022-07-09T02:40:37.000Z</published>
    <updated>2022-07-09T03:04:45.309Z</updated>
    
    <content type="html"><![CDATA[<p>nb 莫比乌斯反演题，和常规套路不同。</p><span id="more"></span><p>题意：<br>$$<br>\sum_{i = 1} ^ n \gcd(i, n) ^ x \text{lcm}(i, n) ^ y \bmod 10 ^ 9 + 7<br>$$<br>$T(T\leq 100)$ 次询问，每次给出 $n, x, y$，$n\leq 10 ^ {18}$，$x, y\leq 3000$。</p><p>看到 $n\leq 10 ^ {18}$ 似乎不对劲，但还是先套路莫反。<br>$$<br>\begin{aligned}<br>&amp;\sum_{i = 1} ^ n \sum_{d = 1} ^ n [\gcd(i, n) = d] d ^ x (\dfrac{in}d) ^ y\\<br>=&amp; \sum_{d | n} \sum_{i = 1} ^ {\frac nd} d ^ x (in) ^ y [\gcd(i, \dfrac nd) = 1]\\<br>=&amp; \sum_{d | n} d ^ x \sum_{i = 1} ^ n d ^ x (in) ^ y \sum_{s | i, s | \frac nd} \mu(s)\\<br>=&amp; n ^ y \sum_{d | n} d ^ x \sum_{s | \frac nd}\mu(s) s ^ y \sum_{i = 1} ^ {\frac n{ds}} i ^ y<br>\end{aligned}<br>$$<br>做到这里，似乎再化开，令 $T = ds$ 没有意义了，因为至少需要枚举 $T$，少说也得整除分块，复杂度 $O(\sqrt n)$ 不可接受。</p><p>发现一个绊脚石是 $\sum_{i = 1} ^ {\frac n{ds}}i ^ y$，这个自然数幂导致我们没法快速计算，因为前面的函数 $d ^ x, \mu(s) s ^ y$ 都可以狄利克雷卷积，但这个没法。</p><p>考虑使用伯努利数，把这样的一个式子写成 $\dfrac n{ds}$ 的次幂和：<br>$$<br>\begin{aligned}<br>&amp;\sum_{i = 1} ^ {\frac n {ds}} i ^ y\\<br>=&amp; \sum_{k = 0} ^ y \binom{y + 1}k B_k ^ + (\dfrac n{ds}) ^ {y + 1 - k}<br>\end{aligned}<br>$$<br>其中 $B_k^+$ 和 $B_k$ 的伯努利数略有区别，$B_k^+$ 在 $B_1^+$ 时取的 $\dfrac 12$，而 $B_k$ 在 $B_1$ 取的是 $-\dfrac 12$。伯努利数可以在 $O(y ^ 2)$ 的时间内递推出前 $y$ 项，不再赘述，可以接受。</p><p>带入原式，大力计算：<br>$$<br>\begin{aligned}<br>&amp; n ^ y \sum_{d | n} d ^ x \sum_{s | \frac nd}\mu(s) s ^ y \sum_{i = 1} ^ {\frac n{ds}} i ^ y\\<br>=&amp; \dfrac{n ^ y}{y + 1} \sum_{d | n} d ^ x \sum_{s | \frac nd}\mu(s) s ^ y \sum_{k = 0} ^ y \binom{y + 1}k B_k^+ (\dfrac n{ds}) ^ {y + 1 - k}\\<br>=&amp; \dfrac{n ^ y}{y + 1} \sum_{k = 0} ^ y \binom{y + 1}k B_k ^ + \sum_{d | n} d ^ x \sum_{s | \frac nd} \mu(s) s ^y (\dfrac{n}{ds}) ^ {y + 1 - k}<br>\end{aligned}<br>$$<br>枚举 $k$ 是可以接受的，那么现在考虑怎么计算后面的 $\sum_{d | n} d ^ x \sum_{e | \frac nd} \mu(s)s ^ y(\dfrac n{ds}) ^ {y + 1 - k}$。发现这个其实一个积性函数，是 $id ^ x \times (\mu\cdot id ^ y)\times id ^ {y + 1 - k}$，可以拆开每一个质数计算答案。而每一个质数计算的时候，相当于计算 $f(p ^ c)$，由于 $\mu$ 的有效位置只有 $1, p$ 两个位置，只需要考虑剩下的两个分配次幂即可。得到质因数的办法显然 Pollard-Rho，时间复杂度 $O(\sqrt p)$。</p><p>那么预处理时间复杂度为 $O(y ^ 2)$，单次询问时间复杂度 $O(n ^ {\frac 14} + y\cdot \text{poly}\log n)$，可以通过。</p><p>代码比较冗长，主要是 Pollard-Rho 太长了，就放一个求解函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL n;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">std::vector&lt;LL&gt; tmpfac = <span class="built_in">Pollard_Rho</span>(n);</span><br><span class="line">LL tmp = n;</span><br><span class="line">std::vector&lt;PLI&gt; fac;</span><br><span class="line"><span class="keyword">for</span> (LL &amp;x : tmpfac)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (tmp % x == <span class="number">0</span>) cnt ++, tmp /= x;</span><br><span class="line">fac.<span class="built_in">push_back</span>(&#123;x, cnt&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= y; ++ k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [p, t] : fac)</span><br><span class="line">&#123;</span><br><span class="line">p %= Mod;</span><br><span class="line"><span class="type">int</span> mul = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= t; ++ i)</span><br><span class="line"><span class="built_in">adj</span>(mul += <span class="built_in">qpow</span>(p, i * (y + <span class="number">1</span> - k) + (t - i) * x) - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++ i)</span><br><span class="line"><span class="built_in">adj</span>(mul -= <span class="built_in">qpow</span>(p, i * (y + <span class="number">1</span> - k) + y + (t - i - <span class="number">1</span>) * x));</span><br><span class="line">cur = (LL) cur * mul % Mod;</span><br><span class="line">&#125;</span><br><span class="line">res = (res + (LL) cur * <span class="built_in">C</span>(y + <span class="number">1</span>, k) % Mod * B[k]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">res = (LL) res * <span class="built_in">qpow</span>(n % Mod, y) % Mod * <span class="built_in">qpow</span>(y + <span class="number">1</span>) % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;nb 莫比乌斯反演题，和常规套路不同。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="莫比乌斯反演" scheme="https://mydcwfy.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="生成函数" scheme="https://mydcwfy.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3811 玛里苟斯</title>
    <link href="https://mydcwfy.github.io/2022/07/08/BZOJ3811/"/>
    <id>https://mydcwfy.github.io/2022/07/08/BZOJ3811/</id>
    <published>2022-07-08T13:34:07.000Z</published>
    <updated>2022-07-08T14:02:48.627Z</updated>
    
    <content type="html"><![CDATA[<p>利用好了期望的性质，除了线性基几乎没有卡点，非常有意思。</p><span id="more"></span><p>题意：给定一个长度为 $n$ 的序列 $a$，任选一个子序列，求 $(\oplus_{i\in S} a_i) ^ k$ 的期望并输出准确值。$n\leq 10 ^ 5$，保证答案小于 $2 ^ {63}$，$k\leq 5$。</p><p>答案不超过 $2 ^ {63}$ 大概提示我们对于不同的 $k$ 有不同的 $a_i$ 数据范围。</p><p>首先 $k = 1$ 的情况是好做的，根据期望的线性性，每位计算，如果有一个数的某一位出现了 1，那么选与不选的概率相同，也就是 01 的概率相同。那么最后的答案就是或的和除以 2。</p><p>然后考虑 $k = 2$ 的情况。一个经典的做法是枚举两位（可以相同），计算同时为 1 的概率并乘上贡献。全是 00 贡献为 0，如果全是 00 或 11，那么两位只绑在一起的，概率为 $\dfrac 12$。否则出现一个 01 或者 10 的话，假设前面都是 11 或 00，那么出现 11 的概率和 00 的概率都是 $\dfrac 12$。来了一个 01 或者 10，11 和 00 想要不变，就不能选，那么 11 和 00 的概率都变成了 $\dfrac 14$。而 01 和 10 的概率也都变成了 $\dfrac 14$。四者概率相同后，后面的就没法再改变了。于是出现 01 或 10 的情况，就是 $\dfrac 14$ 的概率。</p><p>这时答案的二倍一定是整数，因为如果两个选择的都是最低位的话，概率不会是 $\dfrac 14$，所以最后判一下是奇数还是偶数，除以 2 输出即可。</p><p>然后考虑 $k\geq 3$ 的情况。这时由于线性基一定能表示原来所有数能表示的范围，但是线性基现在只有不超过 $21$ 位，那么我们直接暴力枚举所有可能的情况即可。其实对于剩下能被线性基元素线性表示的元素是没有意义的，因为如果选了这个元素，相当于线性基内表示他的元素出现次数 $\oplus 1$。这样只需考虑线性基内的元素，直接爆搜即可。</p><p>最后一个问题就是最后的小数如何输出。可能爆 <code>unsigned long long</code>，所以把小数部分和整数部分分开存，这样都不会爆。还有一个结论是答案的二倍还是整数。证明可以考虑类似 $k = 2$ 的证法，比较麻烦，就不讲了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LinearBasis</span> &#123;</span><br><span class="line">ULL a[N];</span><br><span class="line">ULL&amp; <span class="keyword">operator</span> [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> a[x]; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(ULL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">63</span>; ~i; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!(x &gt;&gt; i &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (!a[i]) <span class="keyword">return</span> a[i] = x, <span class="literal">true</span>;</span><br><span class="line">x ^= a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; chk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%llu&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">ULL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) res |= a[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu&quot;</span>, res &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (res &amp; <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;.5&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">2</span>) &#123;</span><br><span class="line">ULL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> b1 = <span class="number">0</span>; b1 &lt; <span class="number">32</span>; ++ b1)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> b2 = <span class="number">0</span>; b2 &lt; <span class="number">32</span>; ++ b2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> flag1 = <span class="literal">false</span>, flag2 = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; (!flag1 || !flag2); ++ i)</span><br><span class="line">flag1 |= a[i] &gt;&gt; b1 &amp; <span class="number">1</span>, flag2 |= a[i] &gt;&gt; b2 &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (!flag1 || !flag2) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">bool</span> dif = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; !dif; ++ i)</span><br><span class="line"><span class="keyword">if</span> ((a[i] &gt;&gt; b1 &amp; <span class="number">1</span>) ^ (a[i] &gt;&gt; b2 &amp; <span class="number">1</span>)) dif = <span class="literal">true</span>;</span><br><span class="line">res += <span class="number">1ULL</span> &lt;&lt; (b1 + b2 - dif);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu&quot;</span>, res &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (res &amp; <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;.5&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sz = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) sz += chk.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">ULL res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">std::vector&lt;ULL&gt; all;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">63</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (chk[i]) all.<span class="built_in">push_back</span>(chk[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; sz); ++ s)</span><br><span class="line">&#123;</span><br><span class="line">ULL cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; ++ i)</span><br><span class="line"><span class="keyword">if</span> (s &gt;&gt; i &amp; <span class="number">1</span>) cur ^= all[i];</span><br><span class="line">ULL a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> cs = <span class="number">1</span>; cs &lt;= k; ++ cs)</span><br><span class="line">a *= cur, b *= cur, a += b &gt;&gt; sz, b &amp;= (<span class="number">1</span> &lt;&lt; sz) - <span class="number">1</span>;</span><br><span class="line">res1 += a, res2 += b;</span><br><span class="line">&#125;</span><br><span class="line">res1 += res2 &gt;&gt; sz, res2 &amp;= (<span class="number">1</span> &lt;&lt; sz) - <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; res1;</span><br><span class="line"><span class="keyword">if</span> (res2) <span class="built_in">puts</span>(<span class="string">&quot;.5&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;利用好了期望的性质，除了线性基几乎没有卡点，非常有意思。&lt;/p&gt;</summary>
    
    
    
    
    <category term="线性基" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
    <category term="期望" scheme="https://mydcwfy.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>CF Educational Round#125</title>
    <link href="https://mydcwfy.github.io/2022/07/08/CF-Round-Edu125/"/>
    <id>https://mydcwfy.github.io/2022/07/08/CF-Round-Edu125/</id>
    <published>2022-07-08T00:02:00.000Z</published>
    <updated>2022-07-08T00:56:18.446Z</updated>
    
    <content type="html"><![CDATA[<p>赛时偷瞄 F 难度，不小心看到了做法，结果还是不会……</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：$T(T\leq 3000)$ 给定 $x, y$，问在每步距离只能走整数长度情况下，最少游走几步能从 $(0, 0)$ 走到 $(x, y)$。$0\leq x, y\leq 50$。</p><p>容易发现答案不超过 2，因为 $(0, 0)\to (0, y)\to (x, y)$ 就可以两步完成。一步和不走的情况判一下就可以了。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：有一个长度为 $n + 1$ 的序列 $a$，已知 $a_0 = 0$，$a_i$ 只能在 $a_{i - 1}$ 的基础上加 $x$ 或者减 $y$，并且每一项不能超过 $B$，求最大和。$n\leq 2\times 10 ^ 5$，$1\leq x, y, B\leq 10 ^ 9$。</p><p>容易发现一个贪心：能加则加，否则减。简单的证明一下：容易发现反面就是 $a_{i - 1} + x\leq B$，但是 $a_i = a_{i - 1} - y$。这时如果找不到后面的一个 $j$ 是 $a_{j - 1} + x$ 的话，显然可以把这一步替换成 $+x$。否则的话，我们交换 $i, j$ 的操作，容易发现 $[i, j)$ 这一段是递减的，$a_i\leq B$，那么所有都符合 $\leq B$ 的条件，而 $a_j$ 不变。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定一个 $n$ 的括号序列，要求每次找到一个好的最短前缀，然后删除这个前缀。一个括号序列是好的当且仅当它是一个合法的括号序列或者是一个回文串且长度不小于 2。问会删除多少次，最后剩下长度是多少。$\sum n\leq 5\times 10 ^ 5$。</p><p>容易发现我们拿一个指针向前扫，然后实时判断该段区间是否合法，即可做到 $O(n)$ 次询问一段区间是否合法。</p><p>首先第一个条件，由于是双指针，$r$ 右指针的变化量是 $O(1)$ 的，可以动态维护是不是合法的括号序列。当且仅当 $cnt = 0$，且任意时刻 $cnt\geq 0$，表示左括号减右括号。</p><p>第二个条件随便 Hash 一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gethash1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (hash1[r] + (LL) (Mod - pw3[r - l + <span class="number">1</span>]) * hash1[l - <span class="number">1</span>]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gethash2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (hash2[l] + (LL) (Mod - pw3[r - l + <span class="number">1</span>]) * hash2[r + <span class="number">1</span>]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((r - l + <span class="number">1</span>) &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">gethash1</span>(l, mid) == <span class="built_in">gethash2</span>(mid, r);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gethash1</span>(l, mid) == <span class="built_in">gethash2</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s + <span class="number">1</span>);</span><br><span class="line">pw3[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) pw3[i] = pw3[i - <span class="number">1</span>] * <span class="number">3LL</span> % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">hash1[i] = (hash1[i - <span class="number">1</span>] * <span class="number">3LL</span> + (s[i] == <span class="string">&#x27;)&#x27;</span>)) % Mod;</span><br><span class="line">hash2[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n; i; -- i)</span><br><span class="line">hash2[i] = (hash2[i + <span class="number">1</span>] * <span class="number">3LL</span> + (s[i] == <span class="string">&#x27;)&#x27;</span>)) % Mod;</span><br><span class="line"><span class="type">int</span> i, j, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i = j + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>, flag = <span class="number">1</span>;</span><br><span class="line">j = i;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= n &amp;&amp; !<span class="built_in">check</span>(i, j))</span><br><span class="line">&#123;</span><br><span class="line">top += s[j] == <span class="string">&#x27;(&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (top &lt; <span class="number">0</span>) flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">0</span> &amp;&amp; flag) <span class="keyword">break</span>;</span><br><span class="line">++ j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; n) <span class="keyword">break</span>;</span><br><span class="line">cnt ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, cnt, n - i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：有 $n$ 种剑，每一种有每秒攻击力 $d_i$ 和 生命值 $h_i$，以及单价 $c_i$ 金币。有 $m$ 只怪兽，每秒攻击力为 $D_i$，生命值为 $H_i$。攻击一个怪兽只能买一种剑，但个数不限。攻击时间是连续的，也就是说击败时间可以不是整数。你能获胜当且仅当怪兽死亡的时间严格比你任意一把剑死亡的时间短。问能否在 $C$ 个金币内买剑，使得你一定能获胜，如果能输出最小金币数。$n, m\leq 3\times 10 ^ 5$，$C\leq 10 ^ 6$，$d_i, h_i, D_i\leq 10 ^ 6$，$H_i\leq 10 ^ {12}$。</p><p>注意到能获胜当且仅当 $cnt\times d_i\times h_i &gt; D\times H$，$cnt$ 表示买的数量。一下把 $cnt\times d_i\times h_i$ 称作权值。</p><p>很明显 $d, h$ 范围都很大，无法做文章。看到 $C$ 很小，考虑变换思路，设 $s_i$ 表示 $i$ 个金币内最多能买到的权值。</p><p>我们有了 $s_i$ 过后，可以去更新他的倍数，这样我们可以在 $O(C\log C)$ 的时间内得到 $s$。</p><p>后面直接在 $s$ 上二分查找第一个大于怪兽权值的位置即可，注意特判无法做到的情况。</p><p>时间复杂度 $O(n + (m + C)\log C)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m, C;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; C;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, c, d, h; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;c, &amp;d, &amp;h);</span><br><span class="line"><span class="built_in">chkmax</span>(mx[c], (LL) d * h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= C; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">chkmax</span>(mx[i], mx[i - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">2</span>; i * d &lt;= C; ++ d)</span><br><span class="line"><span class="built_in">chkmax</span>(mx[i * d], mx[i] * d);</span><br><span class="line">&#125;</span><br><span class="line">std::cin &gt;&gt; m;</span><br><span class="line">LL d, h;</span><br><span class="line"><span class="keyword">while</span> (m --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;d, &amp;h), d *= h;</span><br><span class="line"><span class="keyword">if</span> (mx[C] &lt;= d) <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, std::<span class="built_in">upper_bound</span>(mx + <span class="number">1</span>, mx + C + <span class="number">1</span>, d) - mx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：问有多少张点数为 $n$ 的带边权完全图，边权 $\in [1, k]$，并且以 1 为根的菊花是原图的一棵最小生成树，对 998244353 取模。$n, k\leq 250$，4s。</p><p>简单计数题。</p><p>容易发现我们把 $(1, i)$ 的连边的权值放在 $i$ 上，相当于 $w(i, j)\geq \max\{a(i), a(j)\}$，考虑顺序枚举 $[1, k]$ 中出现的次数，然后用 EGF 类似的形式计算答案。记录 $f_{i, s}$ 表示当前最大值为 $i$，且已经有 $s$ 个点被选的方案数。大力转移，随便做做满足 $w(x, y)\geq i$ 的个数即可。时间复杂度 $O(n ^ 2k)$ 或 $O(n ^ 2k\log n)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k, -- n;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt;= n; ++ s) g[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt;= n; ++ s)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> nxt = <span class="number">1</span>; nxt + s &lt;= n; ++ nxt)</span><br><span class="line">g[s + nxt] = (g[s + nxt] + (LL) f[s] * infact[nxt] % Mod *</span><br><span class="line"><span class="built_in">qpow</span>(k - i + <span class="number">1</span>, nxt * s + (nxt - <span class="number">1</span>) * nxt / <span class="number">2</span>)) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt;= n; ++ s) <span class="built_in">adj</span>(f[s] += g[s] - Mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt;= n; ++ s) f[s] = (LL) f[s] * fact[s] % Mod;</span><br><span class="line">std::cout &lt;&lt; f[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：在一棵 $n$ 个点的树上，每个点可以选择一个字符，有 $q$ 个限制：$(x_i, y_i)$ 的路径组成的串，要么是 $s_i$，要么是 $s_i$ 翻转，记作 $\overline s$。问是否存在一种合法的解，若存在则给出一组。$n, q, \sum s_i\leq 4\times 10 ^ 5$，9s。</p><p>注意到”要么……要么……“，想一想发现这其实是一个 2-SAT 的模型。考虑对每一个限制设一个 <code>bool</code> 变量，表示是否翻转。但是如果我们把 26 个字母在同一个点上都设出来，显然不是一个 2-SAT 模型了。</p><p>容易发现其实一个位置如果一旦被一个点覆盖，那么他一定最多只有两种字符选择，那么这时就可以转化成一个 2-SAT 模型。设 $c_{i, j}$ 表示 $i$ 位置的 $j$ 选择，如果 $c_{i, j}$ 不对应 $s$，那么就会连向 $\overline s$，而反过来 $s$ 就会连向 $c_{i, \neg j}$。其他同理。于是需要开 $2\times n + 2\times m$ 个点，跑一下是否满足条件即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[x] = low[x] = ++ *dfn, ins[stk[++ top] = x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[x], v; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (!dfn[v = e[i]]) <span class="built_in">tarjan</span>(v), <span class="built_in">chkmin</span>(low[x], low[v]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ins[v]) <span class="built_in">chkmin</span>(low[x], dfn[v]);</span><br><span class="line"><span class="keyword">if</span> (low[x] ^ dfn[x]) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> cur;</span><br><span class="line">++ *bel;</span><br><span class="line"><span class="keyword">do</span> bel[cur = stk[top --]] = *bel, ins[cur] = <span class="literal">false</span>; <span class="keyword">while</span> (cur != x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dep[x] = dep[fa] + <span class="number">1</span>, f[x] = fa;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (v != fa) <span class="built_in">dfs</span>(v, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">getpath</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; pth1, pth2;</span><br><span class="line"><span class="keyword">while</span> (u != v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dep[u] &gt; dep[v]) pth1.<span class="built_in">push_back</span>(u), u = f[u];</span><br><span class="line"><span class="keyword">else</span> pth2.<span class="built_in">push_back</span>(v), v = f[v];</span><br><span class="line">&#125;</span><br><span class="line">pth1.<span class="built_in">push_back</span>(u);</span><br><span class="line">std::<span class="built_in">reverse</span>(pth2.<span class="built_in">begin</span>(), pth2.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;x : pth2) pth1.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="keyword">return</span> pth1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n + <span class="number">2</span> * m; ++ i) h[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">g[u].<span class="built_in">push_back</span>(v), g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> getid = [&amp;](<span class="type">int</span> u, <span class="type">char</span> c) &#123;</span><br><span class="line"><span class="keyword">if</span> (!gt[u][<span class="number">0</span>]) gt[u][<span class="number">0</span>] = c;</span><br><span class="line"><span class="keyword">if</span> (gt[u][<span class="number">0</span>] == c) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!gt[u][<span class="number">1</span>]) gt[u][<span class="number">1</span>] = c;</span><br><span class="line"><span class="keyword">if</span> (gt[u][<span class="number">1</span>] == c) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> id = <span class="number">1</span>, u, v; id &lt;= m; ++ id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;u, &amp;v, s);</span><br><span class="line"><span class="keyword">auto</span> path = <span class="built_in">getpath</span>(u, v);</span><br><span class="line"><span class="type">int</span> sz = path.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">2</span>; ++ x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">getid</span>(path[i], s[i]) != x) &#123;</span><br><span class="line"><span class="built_in">add</span>(path[i] + x * n, <span class="number">2</span> * n + id);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">2</span> * n + m + id, path[i] + !x * n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">getid</span>(path[i], s[sz - i - <span class="number">1</span>]) != x) &#123;</span><br><span class="line"><span class="built_in">add</span>(path[i] + x * n, <span class="number">2</span> * n + m + id);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">2</span> * n + id, path[i] + !x * n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!gt[i][<span class="number">0</span>]) gt[i][<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!gt[i][<span class="number">1</span>]) gt[i][<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n + <span class="number">2</span> * m; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (bel[i] == bel[i + n]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>), <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * n + <span class="number">1</span>; i &lt;= <span class="number">2</span> * n + m; ++ i)</span><br><span class="line"><span class="keyword">if</span> (bel[i] == bel[i + m])</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>), <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">putchar</span>(gt[i][bel[i + n] &lt; bel[i]]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;赛时偷瞄 F 难度，不小心看到了做法，结果还是不会……&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>AT Code Festival 2017 Qual B F Largest Smallest Cyclic Shift</title>
    <link href="https://mydcwfy.github.io/2022/07/07/AT-Code-Festival-2017-Qual-B-F/"/>
    <id>https://mydcwfy.github.io/2022/07/07/AT-Code-Festival-2017-Qual-B-F/</id>
    <published>2022-07-07T09:53:25.000Z</published>
    <updated>2022-07-07T11:03:26.569Z</updated>
    
    <content type="html"><![CDATA[<p>神秘贪心 + 构造题。</p><span id="more"></span><p>题意：有 $x$ 个 <code>a</code>，$y$ 个 <code>b</code>，$z$ 个 <code>c</code>，所有由这些字符组成的字符串中，设 $f(S)$ 为 $S$ 的最小表示，求最大的 $f(S)$。$A + B + C\leq 50$。</p><p>有一个神秘的做法：首先需要保证 $S = f(S)$，然后保证 $S$ 最大；维护一个 <code>std::multiset</code>，表示所有待合并的字符串。每次拿出最小的和最大的，拼起来放回去，最后就可以得到答案。</p><p>怎么证明？不太会，谁叫官方题解和这个做法一点关系没有 /kk，网上的证明大多是没有说明白的，找到了 CF 上的 <a href="https://codeforces.com/blog/entry/55027#comment-389844">讨论</a>，大概知道了。</p><p>首先我们需要判断这两个构造方案是相同的。打一个表就可以发现时刻 <code>std::multiset</code> 里面都只有 3 种串。也是好证明的，因为我们拿着两种串”厮杀“，最后肯定会有一个串没有了，产生的串都是一种，所以时刻都只有 3 种串。接着自己手动推一下，其实就是 CF 讨论的构造方法。</p><p>下面我们来证明一下正确性。首先我们看到剩下的 3 种串一定都是严格有比较大小的，也就是我们把 <code>a</code> 放在开头一定是比 <code>b</code>  放在开头小，<code>b</code> 比 <code>c</code> 放在开头小。对于第一种变化后的情况 <code>ac, b, c</code>，开头不一样，显然合法。<code>a, ac, b</code>，虽然 <code>a</code> 和 <code>ac</code> 相同，但是我们找不到其他的前缀满足接在 <code>a</code> 后面还能和 <code>ac</code> 相同的，所以一旦 <code>a</code> 放在前面，肯定比 <code>ac</code> 放在前面小。</p><p>那么根据上面的说法，我们很容易得到最小表示的开头一定是 <code>a</code>，显然考虑贪心，我们如果在所有的 <code>a</code> 后面都接上 <code>c</code>，这样的最小表示一定是最大的，我们就可以递归下去计算答案；如果 <code>a</code> 无法全部接 <code>c</code>，那么剩余的 <code>a</code> 也是剩下的 3 种串中最小的，我们还是在 <code>a</code> 的后面接最大的串，这个其实又是相当于递归计算的过程了。</p><p>综上，我们就可以得到该算法的正确性了。下面有 <code>std::multiset</code> 和递归写法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> A, B, C;</span><br><span class="line">std::cin &gt;&gt; A &gt;&gt; B &gt;&gt; C;</span><br><span class="line"><span class="keyword">while</span> (A --) all.<span class="built_in">insert</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (B --) all.<span class="built_in">insert</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (C --) all.<span class="built_in">insert</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (all.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> itera = all.<span class="built_in">begin</span>(), iterb = -- all.<span class="built_in">end</span>();</span><br><span class="line">std::string add = *itera + *iterb;</span><br><span class="line">all.<span class="built_in">erase</span>(itera), all.<span class="built_in">erase</span>(iterb), all.<span class="built_in">insert</span>(add);</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; *all.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">solve</span><span class="params">(std::vector&lt;std::string&gt; s, std::vector&lt;<span class="type">int</span>&gt; cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!cnt[<span class="number">0</span>] &amp;&amp; !cnt[<span class="number">2</span>]) <span class="keyword">return</span> s[<span class="number">1</span>] * cnt[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (cnt[<span class="number">0</span>] &amp;&amp; cnt[<span class="number">2</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> (cnt[<span class="number">0</span>] &gt;= cnt[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">solve</span>(&#123;s[<span class="number">0</span>], s[<span class="number">0</span>] + s[<span class="number">2</span>], s[<span class="number">1</span>]&#125;, &#123;cnt[<span class="number">0</span>] - cnt[<span class="number">2</span>], cnt[<span class="number">2</span>], cnt[<span class="number">1</span>]&#125;);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">solve</span>(&#123;s[<span class="number">0</span>] + s[<span class="number">2</span>], s[<span class="number">1</span>], s[<span class="number">2</span>]&#125;, &#123;cnt[<span class="number">0</span>], cnt[<span class="number">1</span>], cnt[<span class="number">2</span>] - cnt[<span class="number">0</span>]&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!cnt[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> (!cnt[<span class="number">1</span>]) <span class="keyword">return</span> s[<span class="number">2</span>] * cnt[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">solve</span>(&#123;s[<span class="number">1</span>], <span class="string">&quot;&quot;</span>, s[<span class="number">2</span>]&#125;, &#123;cnt[<span class="number">1</span>], <span class="number">0</span>, cnt[<span class="number">2</span>]&#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!cnt[<span class="number">1</span>]) <span class="keyword">return</span> s[<span class="number">0</span>] * cnt[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">solve</span>(&#123;s[<span class="number">0</span>], <span class="string">&quot;&quot;</span>, s[<span class="number">1</span>]&#125;, &#123;cnt[<span class="number">0</span>], <span class="number">0</span>, cnt[<span class="number">1</span>]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> A, B, C;</span><br><span class="line">std::cin &gt;&gt; A &gt;&gt; B &gt;&gt; C;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">solve</span>(&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;, &#123;A, B, C&#125;) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;神秘贪心 + 构造题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>AT Code Festival 2017 Qual B E Popping Balls</title>
    <link href="https://mydcwfy.github.io/2022/07/07/AT-Code-Festival-2017-Qual-B-E/"/>
    <id>https://mydcwfy.github.io/2022/07/07/AT-Code-Festival-2017-Qual-B-E/</id>
    <published>2022-07-07T08:45:24.000Z</published>
    <updated>2022-07-07T09:52:14.398Z</updated>
    
    <content type="html"><![CDATA[<p>组合数学真有趣。</p><span id="more"></span><p>题意：现在有 $A + B$ 个球组成的序列，前 $A$ 个是红色的，后 $B$ 个是蓝球，你可以在开始时选定两个数 $s, t$，你可以从 $1, s, t$ 三个位置取出球。问取出球的不同序列的个数，对 $10 ^ 9 + 7$ 取模。$A, B\leq 2000$。</p><p>其实注意到我们并不能直接枚举 $s, t$ 计算，因为不同的 $s, t$ 可能得到相同的结果。考虑另外的转换方式。</p><p>首先注意到在 $len \geq t$ 的时候，$s$ 是没有意义的，因为它如果拿走的是红球，可以被 1 所替代，如果拿的是蓝球，可以被 $t$ 所替代，所以我们可以只先考虑 $t$ 取的情况。</p><p>我们想要得到最多的序列，那么我们把 $t$ 放在第一个蓝球的位置（后面还有 $B$ 个），这样位置 1 和 位置 $t$ 一共可以取 $B$ 次，然后位置 $t$ 就没有用了。注意到除了我们钦定了第一次为蓝球外，每一次我们都可以在红球和蓝球之间任意选择，这时候的选择面是最广的，可以覆盖到其他情况。</p><p>假设我们前面取了 $i$ 个蓝球，那么等到 $s$ 取的时候，和 $t$ 的情况类似，但是只剩下 $B - i$ 个蓝球了，和刚才一样，我们从 $B - i$ 次机会中选择 $j$ 种，选完$B - i$ 次过后就只剩 1 位置可以选了。</p><p>我们现在相当于是只考虑了蓝球的情况，还需要考虑红球的情况。红球有 3  个去向：在 $t$ 拿到第一个蓝球之前，在 $s$ 和 $t$ 之间，在 $s$ 选完的后面。$t$ 选择的时候消耗了 $B - i$ 个红球，$s$ 选择的时候消耗了 $B - i - j$ 个红球（消耗是指混在蓝球当中的那些红球），那么剩下了 $A - 2\times B + 2\times i + j$ 个红球可以放在三个位置。利用插板法可以得到贡献。</p><p>最后由于 $s, t$ 可能取不到一个蓝球，注意到这时的蓝球一定是一段的，贡献为 $A + 1$。</p><p>于是最后的答案为：<br>$$<br>\sum_{i = 1} ^ B \sum_{j = 1} ^ {B - i} \binom Bi \binom{B - i} j \binom {A - 2\times B + 2\times i + j + 2}2 + A + 1<br>$$<br>直接计算即可，时间复杂度 $O(A + B ^ 2)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="type">int</span> A, B, res = <span class="number">0</span>;</span><br><span class="line">std::cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= B; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; i + j &lt;= B; ++ j)</span><br><span class="line">res = (res + (LL) <span class="built_in">C</span>(B - <span class="number">1</span>, i - <span class="number">1</span>) * <span class="built_in">C</span>(B - i - <span class="number">1</span>, j - <span class="number">1</span>) % Mod</span><br><span class="line">* <span class="built_in">C</span>(A - <span class="number">2</span> * B + <span class="number">2</span> * i + j + <span class="number">2</span>, <span class="number">2</span>)) % Mod;</span><br><span class="line">res = (res + A + <span class="number">1</span>) % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;组合数学真有趣。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>CF643F Bears and Juice</title>
    <link href="https://mydcwfy.github.io/2022/07/06/CF643F/"/>
    <id>https://mydcwfy.github.io/2022/07/06/CF643F/</id>
    <published>2022-07-06T13:55:08.000Z</published>
    <updated>2022-07-06T14:12:19.291Z</updated>
    
    <content type="html"><![CDATA[<p>有趣的信息量分析 + 组合数学题目。</p><span id="more"></span><p>题意：有一些个酒桶，有一个是酒，另外的都是果汁，有 $n$ 只熊玩游戏，每天可以选择一些酒桶集合（可以为空），倒出一杯喝掉，如果喝到了酒就会睡觉到游戏结束，并且不能超过 $p$ 只熊在睡觉，否则判为失败。如果至少有一只熊没有睡觉，并且他能判断哪一个是酒，就算游戏胜利。问给 $t$ 天时间，这些熊最多能辨别多少个酒桶。你需要给出 $t\in [1, q]$ 的答案，并将 $\oplus i\times ans_i$ 输出，对 $2 ^ {32}$ 取模。$n\leq 10 ^ 9$，$p\leq 130$，$q\leq 2\times 10 ^ 6$。</p><p>考虑最大的信息量，$n$ 只熊有 $i$ 只睡着了，有 $\binom ni$ 种情况；这 $i$ 只熊可以在 $[1, t]$ 的时间内任意一天开始睡觉，得到的信息量为 $t ^ i$。那么就可以得到：<br>$$<br>ans_t = \sum_{i = 0} ^ {\min\{n - 1, p\}} \binom ni t ^ i<br>$$<br>这个为什么是对的呢？首先容易发现这是上界，因为我们最多只能得到这么多的信息，能区分的也就只有这么多了。</p><p>下面我们需要干的事情就是构造一种方案使得正好能区分这么多的信息量。考虑对所有情况编一个号，它对应着选出了哪些熊睡觉，还有睡觉的那些熊多久开始睡觉。没有被选中的始终不会碰这一个酒桶；被选中的熊会在自己对应的天数选中这个酒桶。容易发现不同的酒桶其实是独立的，因为我可以选择任意多的酒桶。</p><p>那么我们就得到了构造，也就得到了答案。下面考虑如何计算。</p><p>其实 $t ^ i$ 这一部分是简单的，可以在 $O(pq)$ 的时间内做完，可以承受。计算 $\displaystyle \binom ni$ 可以拆成下降幂除以阶乘的形式，然后暴力枚举两个数并约分。注意到这个是整数，所以一定是合法的。求解单个的复杂度为 $O(p ^ 2\log n)$，可以接受。</p><p>总时间复杂度 $O(p ^ 3\log n + pq)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">C</span><span class="params">(uint n, uint m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::vector&lt;uint&gt; <span class="title">a</span><span class="params">(m)</span>, <span class="title">b</span><span class="params">(m)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; m; ++ i) a[i] = n - i;</span><br><span class="line"><span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; m; ++ j) b[j] = j + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (uint &amp;x : a)</span><br><span class="line"><span class="keyword">for</span> (uint &amp;y : b) &#123;</span><br><span class="line">uint G = <span class="built_in">Gcd</span>(x, y);</span><br><span class="line">x /= G, y /= G;</span><br><span class="line">&#125;</span><br><span class="line">uint res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (uint &amp;x : a) res *= x;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; p &gt;&gt; T;</span><br><span class="line">uint ed = std::<span class="built_in">min</span>(n - <span class="number">1</span>, p);</span><br><span class="line"><span class="function">std::vector&lt;uint&gt; <span class="title">bn</span><span class="params">(ed + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt;= ed; ++ i) bn[i] = <span class="built_in">C</span>(n, i);</span><br><span class="line">uint res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (uint t = <span class="number">1</span>; t &lt;= T; ++ t)</span><br><span class="line">&#123;</span><br><span class="line">uint ans = <span class="number">0</span>, cur = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt;= ed; ++ i, cur *= t) ans += cur * bn[i];</span><br><span class="line">res ^= ans * t;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有趣的信息量分析 + 组合数学题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>LOJ2143 [SHOI2017]组合数问题</title>
    <link href="https://mydcwfy.github.io/2022/07/06/LOJ2143/"/>
    <id>https://mydcwfy.github.io/2022/07/06/LOJ2143/</id>
    <published>2022-07-06T13:34:42.000Z</published>
    <updated>2022-07-06T13:54:06.290Z</updated>
    
    <content type="html"><![CDATA[<p>有意思的一道题目，做法比较多。</p><span id="more"></span><p>题意：求：<br>$$<br>\sum_{i = 0} ^ n [i\bmod k = r] \binom ni \bmod p<br>$$<br>$n\leq 10 ^ 9$，$k\leq 50$，$p &lt; 2 ^ {30}$。</p><h3 id="做法-1：单位根反演"><a href="#做法-1：单位根反演" class="headerlink" title="做法 1：单位根反演"></a>做法 1：单位根反演</h3><p>看到 $[i\bmod k = r]$，果断单位根反演。<br>$$<br>\begin{aligned}<br>&amp;\sum_{i = 0} ^ n [i\bmod k = r] \binom ni\\<br>=&amp; \sum_{i = 0} ^ n \binom ni \dfrac 1k \sum_{j = 0} ^ {k - 1} \omega_k ^ {ij - rj}\\<br>=&amp; \dfrac 1k \sum_{j = 0} ^ {k - 1} \omega_k ^ {-rj} \sum_{i = 0} ^ n \binom ni \omega_k ^ {ij}\\<br>=&amp; \dfrac 1k \sum_{j = 0} ^ {k - 1} \omega_k ^ {-rj} (\omega_k ^ {j} + 1) ^ n<br>\end{aligned}<br>$$<br>但是我们前面说到 $k|p - 1$ 才有单位根，那怎么办呢？其实可以直接能成一个多项式的形式，类似于 $\sum_{i = 0} ^ {k - 1} a_i \omega_k ^ {i}$ 来代替单个数，这样可以实现乘法加法运算，可以得到最终解、</p><p>有一个问题就是最后的数不一定是只有 $\omega_k ^ {0}$ 位置有数，但是我们前面有看到答案一定是整数。这里可以按照 $\sum_{i = 0 } ^ {k - 1}\omega_k ^ {i} = 0$，$\omega_k ^ {\frac k2} = -1$ 等式子化简，可以证明最后一定可以得到正确答案。另外一个问题就是 $\dfrac 1k$ 并不好处理、一个神秘的办法是按照 $p\times k$ 取模计算，由于答案是整数，直接 最后 $\times \dfrac 1k$ 即可。</p><p>时间复杂度 $O(k ^ 3\log n)$ 或者是 $O(k ^ 2\log k\log n)$，有没有更优的还没有细究。</p><p>代码写了但是没写对，有时间来重写（</p><h3 id="做法-2：矩阵乘法"><a href="#做法-2：矩阵乘法" class="headerlink" title="做法 2：矩阵乘法"></a>做法 2：矩阵乘法</h3><p>我们可以看到 $\displaystyle \binom ni$ 的组合意义，就是走 $n$ 步，每一次可以走到 $(i + 1, j)$ 或者是 $(i + 1, j + 1)$，最后走到了 $(n, i)$ 这个位置的方案数。而这个式子又是可以通过递推得到的。</p><p>然后怎么把 $\bmod k = r$ 加进去呢？我们就强制走到 $(x, k)$ 就是 $(x, 0)$，这样最后回到 $r$ 这个位置的方案数就是答案。</p><p>我们就可以很容易的写出矩阵的转移方程， 矩阵乘法即可，时间复杂度 $O(k ^ 3\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; a;</span><br><span class="line"><span class="built_in">Matrix</span>() : <span class="built_in">a</span>(k, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(k)) &#123;&#125;</span><br><span class="line"><span class="keyword">auto</span>&amp; <span class="keyword">operator</span> [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> a[x]; &#125;</span><br><span class="line">Matrix <span class="keyword">operator</span> *(Matrix b) <span class="type">const</span> &#123;</span><br><span class="line">Matrix res;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; k; ++ l)</span><br><span class="line">res[i][l] = (res[i][l] + (LL) a[i][j] * b[j][l]) % Mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">qpow</span><span class="params">(Matrix a, LL d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Matrix res;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++ i) res[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; d; d &gt;&gt;= <span class="number">1</span>, a = a * a)</span><br><span class="line"><span class="keyword">if</span> (d &amp; <span class="number">1</span>) res = res * a;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; Mod &gt;&gt; k &gt;&gt; r, n *= k;</span><br><span class="line">Matrix trs;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++ i) trs[i][(i + <span class="number">1</span>) % k] ++, trs[i][i] ++;</span><br><span class="line">trs = <span class="built_in">qpow</span>(trs, n);</span><br><span class="line">std::cout &lt;&lt; trs[<span class="number">0</span>][r] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="做法-3：生成函数"><a href="#做法-3：生成函数" class="headerlink" title="做法 3：生成函数"></a>做法 3：生成函数</h3><p>看到组合数，我们很自然的（？）就想到了二项式定理，那么不考虑模数的话，生成函数就是 $(1 + x) ^ n$，然后如果需要得到次数 $\bmod k$ 的结果，直接对长度为 $k$ 的多项式循环卷积即可。</p><p>暴力卷积 $O(k ^ 2\log n)$，使用 <a href="/2022/06/21/BlueStein-Algorithm/">BlueStein 算法</a> 循环卷积可以做到 $O(k\log k)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">poly <span class="keyword">operator</span> *(poly a, poly b) &#123;</span><br><span class="line">    <span class="function">poly <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++ j)</span><br><span class="line">            res[(i + j) % k] = (res[(i + j) % k] + (LL) a[i] * b[j]) % Mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; Mod &gt;&gt; k &gt;&gt; r, n *= k;</span><br><span class="line">    <span class="function">poly <span class="title">st</span><span class="params">(k)</span>, <span class="title">a</span><span class="params">(k)</span></span>;</span><br><span class="line">    a[<span class="number">0</span>] ++, a[<span class="number">1</span> % k] ++, st[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>, a = a * a)</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            st = st * a;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; st[r] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有意思的一道题目，做法比较多。&lt;/p&gt;</summary>
    
    
    
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="矩阵乘法" scheme="https://mydcwfy.github.io/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"/>
    
    <category term="生成函数" scheme="https://mydcwfy.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
    <category term="单位根反演" scheme="https://mydcwfy.github.io/tags/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
</feed>
