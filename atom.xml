<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mydcwfy&#39;s Blog</title>
  
  
  <link href="https://mydcwfy.github.io/atom.xml" rel="self"/>
  
  <link href="https://mydcwfy.github.io/"/>
  <updated>2022-01-20T11:58:39.381Z</updated>
  <id>https://mydcwfy.github.io/</id>
  
  <author>
    <name>mydcwfy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最小圆覆盖</title>
    <link href="https://mydcwfy.github.io/2022/01/20/mininum-circle/"/>
    <id>https://mydcwfy.github.io/2022/01/20/mininum-circle/</id>
    <published>2022-01-20T10:31:26.000Z</published>
    <updated>2022-01-20T11:58:39.381Z</updated>
    
    <content type="html"><![CDATA[<p>还是一个计算几何。</p><span id="more"></span><h2 id="1-性质"><a href="#1-性质" class="headerlink" title="1. 性质"></a>1. 性质</h2><h3 id="1）唯一性"><a href="#1）唯一性" class="headerlink" title="1）唯一性"></a>1）唯一性</h3><p>明显，如果我们能找到两个圆的话，他们的交也一定是可以的。我们可以尝试构造以相交的弦为直径构造一个圆，很明显会更小。</p><img src="/2022/01/20/mininum-circle/%E5%94%AF%E4%B8%80%E6%80%A7.png" class=""><h3 id="2）"><a href="#2）" class="headerlink" title="2）"></a>2）</h3><p><strong>如果 $P$ 不在集合 $S$ 的最小覆盖圆的内部，则 $P$ 在 ${P}\cup S$ 的最小覆盖圆的边上。</strong></p><p>首先，一个最小覆盖圆肯定会经过集合内的至少三个点。（在集合点数 $\geq 3$ 的时候）</p><p>反证：假设 $P$ 不在 ${P}\cup S$ 的最小覆盖圆的边上，那么 ${P}\cup S$ 的最小覆盖圆就是 $S$ 的最小覆盖圆。</p><p>但是 $S$ 的最小覆盖圆是无法覆盖到 $P$ 的，所以就会导致 ${P}\cup S$ 的最小圆覆盖无法覆盖到 $P$，矛盾，故原命题成立。</p><h2 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2. 算法流程"></a>2. 算法流程</h2><p>首先随机化，防止复杂度退化。</p><p>接着，我们将圆设置为 $(p(1), 0)$，表示圆心和半径。</p><p>然后，我们枚举每一个点，如果当前点 $p(i)$ 不在最小覆盖圆里的话，那么，我们由前面的性质得到，$p(i)$ 一定在 ${1, …, i}$ 的最小圆覆盖的边上。</p><p>现在，我们将圆设置为 $(p(i), 0)$，然后再暴力枚举前面的点。</p><p>如果如果 $p(j)$ 不在圆内的话，那么 $p(j)$ 在 ${1, …, j}\cup{i}$ 的最小圆覆盖的边上。同时，由于 $p(i)$ 不在 ${1, …, i - 1}$ 的最小圆覆盖里，那么一定导致 $p(i)$ 不在 ${1, …, j}$ 的最小覆盖圆上。</p><p>那么，我们就可以得到，$p(i), p(j)$ 都在 ${1, …, j}\cup {i}$ 的圆的边上。</p><p>因为找一个圆需要 $3$ 个点才能确定，所以我们再去寻找一个点。</p><p>我们将圆设置为 $p(i), p(j)$ 为直径的圆，再从前循环 $p(k)$，寻找到 $p(k)$ 不在 $p(i), p(j)$ 为直径的圆上。仿照前面的证明，我们就可以得到 $p(k), p(i), p(j)$ 都在圆上，我们就是求出了 ${1, …, k} \cup{i, j}$ 的最小圆覆盖。</p><p>最后我们一直循环，直到最后覆盖到了 ${1, …, i - 1}\cup{i}$ 也就是 ${1, …, i}$ 的圆覆盖。</p><h2 id="3-复杂度"><a href="#3-复杂度" class="headerlink" title="3. 复杂度"></a>3. 复杂度</h2><p>看似有 $O(n ^ 3)$，但是两步判断都是 $\dfrac{3}{n}$ 的概率，我们就可以得到时间复杂度为 $O(n)$。（感觉特别玄学</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">get_point</span><span class="params">(Point p1, Point k1, Point p2, Point k2)</span></span>&#123;</span><br><span class="line">Point u = p1 - p2;</span><br><span class="line"><span class="keyword">double</span> t = (k2 * u) / (k1 * k2);</span><br><span class="line"><span class="keyword">return</span> p1 + k1 * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Circle <span class="title">circle_by_point</span><span class="params">(Point a, Point b, Point c)</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> l1 = <span class="built_in">get_line</span>(a, b), l2 = <span class="built_in">get_line</span>(a, c);</span><br><span class="line">Point o = <span class="built_in">get_point</span>(l1.first, l1.second, l2.first, l2.second);</span><br><span class="line"><span class="keyword">return</span> &#123;o, <span class="built_in">dist2</span>(a, o)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Circle <span class="title">min_circle</span><span class="params">(Point *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">random_shuffle</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line">Circle ans = &#123;p[<span class="number">1</span>], <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">in_circle</span>(ans, p[i])) <span class="keyword">continue</span>;</span><br><span class="line">ans = &#123;p[i], <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++ j)&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">in_circle</span>(ans, p[j])) <span class="keyword">continue</span>;</span><br><span class="line">ans = &#123;(p[i] + p[j]) / <span class="number">2</span>, <span class="built_in">dist2</span>((p[i] + p[j]) / <span class="number">2</span>, p[i])&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; j; ++ k)</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">in_circle</span>(ans, p[k])) ans = <span class="built_in">circle_by_point</span>(p[i], p[j], p[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans.r = <span class="built_in">sqrt</span>(ans.r);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;还是一个计算几何。&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算几何" scheme="https://mydcwfy.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>凸包与旋转卡壳</title>
    <link href="https://mydcwfy.github.io/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/"/>
    <id>https://mydcwfy.github.io/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/</id>
    <published>2022-01-19T10:37:25.000Z</published>
    <updated>2022-01-20T14:00:53.234Z</updated>
    
    <content type="html"><![CDATA[<p>前置知识：计算几何。</p><span id="more"></span><h2 id="1-凸包"><a href="#1-凸包" class="headerlink" title="1. 凸包"></a>1. 凸包</h2><p>直接理解为我们用一条橡皮筋围住这些点。</p><p>我们就不再介绍 Javis 算法，直接介绍两个时间复杂度更优的 Graham 和 Andrew 算法。</p><h3 id="1）Graham-算法"><a href="#1）Graham-算法" class="headerlink" title="1）Graham 算法"></a>1）Graham 算法</h3><p>我们首先选择最左下方的点，注意到这个点一定是凸包上的点。假设这个点为 A。</p><p>接着，我们按照 A 点与这些点的连线与水平线的夹角排序。注意到如果夹角相同，将最远的点放在最前面。</p><p>接着，我们扫描整个数组，同时维护一个栈，记录当前的凸包里的点。</p><p>我们要加入一个点的时候，如果当前的栈里的点会和这个点形成一个顺时针的转角的话，我们就将栈顶弹出。</p><img src="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/%E5%87%B8%E5%8C%851.png" class=""><p>看到这个图，我们现在要将红线上面的点加入，容易发现红线下面这个点是一定不需要的，我们直接弹出即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Point &amp;t1, <span class="keyword">const</span> Point &amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t1 - p[<span class="number">1</span>]) * (t2 - p[<span class="number">1</span>]) &gt; eps || (<span class="built_in">fabs</span>((t1 - p[<span class="number">1</span>]) * (t2 - p[<span class="number">1</span>])) &lt; eps &amp;&amp; <span class="built_in">dist</span>(p[<span class="number">1</span>], t1) &gt; <span class="built_in">dist</span>(p[<span class="number">1</span>], t2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    <span class="keyword">if</span> (p[i].y &lt; p[t].y || (<span class="built_in">fabs</span>(p[i].y - p[t].y) &lt; eps &amp;&amp; p[i].x &lt; p[t].x)) t = i;</span><br><span class="line"><span class="built_in">swap</span>(p[<span class="number">1</span>], p[t]);</span><br><span class="line"><span class="built_in">sort</span>(p + <span class="number">2</span>, p + n + <span class="number">1</span>, cmp);</span><br><span class="line">stk[++ top] = p[<span class="number">1</span>], stk[++ top] = p[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; (stk[top] - stk[top - <span class="number">1</span>]) * (p[i] - stk[top]) &lt; -eps) top --;</span><br><span class="line">    stk[++ top] = p[i];</span><br><span class="line">&#125;</span><br><span class="line">stk[++ top] = p[<span class="number">1</span>];<span class="comment">//第一个点进入两次，便于计算周长面积</span></span><br></pre></td></tr></table></figure><h3 id="2）Andrew-算法"><a href="#2）Andrew-算法" class="headerlink" title="2）Andrew 算法"></a>2）Andrew 算法</h3><p>我们不再按照夹角排序，直接使用 x 坐标排序，结果又如何呢？</p><p>我们这么遍历，发现只会走到一半的凸壳。</p><p>于是，我们再会过来遍历一次，就可以把另一半的凸壳遍历到了！</p><p>这个算法避免的一些复杂的夹角的计算，常数略小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2)</span></span>&#123;<span class="keyword">return</span> (p1.x == p2.x) ? (p1.y &lt; p2.y) : p1.x &lt; p2.x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Andrew</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; (p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> ((p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt; <span class="number">0</span>) usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> top --;</span><br><span class="line">usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">usd[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (usd[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; (p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> ((p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt; <span class="number">0</span>) usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> top --;</span><br><span class="line">usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）例题"><a href="#3）例题" class="headerlink" title="3）例题"></a>3）例题</h3><h4 id="T1：信用卡凸包"><a href="#T1：信用卡凸包" class="headerlink" title="T1：信用卡凸包"></a>T1：信用卡凸包</h4><p><a href="https://www.luogu.com.cn/problem/P3829">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2938/">题目传送门 AcWing</a></p><p>我们可以发现，一个凸多边形的外角是 $360^{\circ}$。</p><p>那么，圆形一定贡献的是一个周角的大小。剩下的，我们发现可以向内平移到圆心的位置。按圆心凸包即可。</p><img src="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/%E5%87%B8%E5%8C%852.png" class=""><p>可以发现，黑直线的长度就是红线的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %lf %lf %lf&quot;</span>, &amp;n, &amp;a, &amp;b, &amp;R);</span><br><span class="line">a -= <span class="number">2</span> * R, b -= <span class="number">2</span> * R;</span><br><span class="line"><span class="keyword">double</span> x, y, th;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf&quot;</span>, &amp;x, &amp;y, &amp;th);</span><br><span class="line">x += eps, y += eps, th += eps;</span><br><span class="line">p[(i &lt;&lt; <span class="number">2</span>) - <span class="number">3</span>] = (Point)&#123;x, y&#125; + <span class="built_in">rotate</span>(&#123;b / <span class="number">2</span>, a / <span class="number">2</span>&#125;, th);</span><br><span class="line">p[(i &lt;&lt; <span class="number">2</span>) - <span class="number">2</span>] = (Point)&#123;x, y&#125; + <span class="built_in">rotate</span>(&#123;-b / <span class="number">2</span>, a / <span class="number">2</span>&#125;, th);</span><br><span class="line">p[(i &lt;&lt; <span class="number">2</span>) - <span class="number">1</span>] = (Point)&#123;x, y&#125; + <span class="built_in">rotate</span>(&#123;-b / <span class="number">2</span>, -a / <span class="number">2</span>&#125;, th);</span><br><span class="line">p[(i &lt;&lt; <span class="number">2</span>)] = (Point)&#123;x, y&#125; + <span class="built_in">rotate</span>(&#123;b / <span class="number">2</span>, -a / <span class="number">2</span>&#125;, th);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Andrew</span>(n &lt;&lt; <span class="number">2</span>);</span><br><span class="line"><span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; ++ i)</span><br><span class="line">res += <span class="built_in">dist</span>(p[stk[i]], p[stk[i + <span class="number">1</span>]]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>, res + <span class="number">2</span> * <span class="built_in">acos</span>(<span class="number">-1</span>) * R);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-半平面交"><a href="#2-半平面交" class="headerlink" title="2. 半平面交"></a>2. 半平面交</h2><p>我们介绍一种办法（我似乎并不知道是什么算法），能在 $O(n \log n)$ 的时间求出围住的凸多边形（注意好像不能判断无解的情况）。</p><p>为了方便，我们定义半平面存储为一条有向直线，在这条直线逆时针（可以理解为左边）的部分即为半平面。</p><h3 id="1）算法流程"><a href="#1）算法流程" class="headerlink" title="1）算法流程"></a>1）算法流程</h3><p>我们首先按照每条线与 $x$ 轴的夹角排序，如果相同，说明是平行的，我们按照从左至右的顺序。</p><p>然后，我们顺次插入每一个半平面。我们维护一个如此的双端队列来表示当前的半平面。</p><img src="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B31.png" class=""><p>接着，我们插入的时候，看一下有没有在当前半平面外面的交点，也就是判断有没有在直线顺时针的点，有的话就删除。</p><img src="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B32.png" class=""><p>比如蓝点在新加入的蓝线右边，所以肯定会导致最后加入的黑线被弹出队尾。</p><p>注意有可能线的方向不定导致会弹出队首，所以前后都要判断。</p><p>最后的时候，我们再用队首来尝试弹出队尾，队尾尝试弹出队首。</p><p>注意我们求夹角的时候，可以使用 <code>atan2(x, y)</code>，这样可以防止出现 <code>nan</code> 的情况，因为他会判断 $y$ 是否等于 0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">get_point_</span><span class="params">(Point p1, Point k1, Point p2, Point k2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point u = p1 - p2;</span><br><span class="line"><span class="keyword">double</span> t = (k2 * u) / (k1 * k2);</span><br><span class="line"><span class="keyword">return</span> &#123;t * k1.x + p1.x, t * k1.y + p1.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">get_point</span><span class="params">(<span class="keyword">const</span> Line &amp;l1, <span class="keyword">const</span> Line &amp;l2)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">get_point_</span>(l1.st, l1.ed - l1.st, l2.st, l2.ed - l2.st);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">on_right</span><span class="params">(<span class="keyword">const</span> Line &amp;a, <span class="keyword">const</span> Line &amp;b, <span class="keyword">const</span> Line &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point t = <span class="built_in">get_point</span>(b, c);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sgn</span>((a.ed - a.st) * (t - a.st)) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">half_plane</span><span class="params">(Line l[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(l + <span class="number">1</span>, l + n + <span class="number">1</span>, lcmp);</span><br><span class="line">hh = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; !<span class="built_in">cmp</span>(<span class="built_in">angle</span>(l[i]), <span class="built_in">angle</span>(l[i - <span class="number">1</span>]))) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[i], l[q[tt - <span class="number">1</span>]], l[q[tt]])) tt --;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[i], l[q[hh]], l[q[hh + <span class="number">1</span>]])) hh ++;</span><br><span class="line">q[++ tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[q[hh]], l[q[tt - <span class="number">1</span>]], l[q[tt]])) tt --;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[q[tt]], l[q[hh]], l[q[hh + <span class="number">1</span>]])) hh ++;</span><br><span class="line">q[++ tt] = q[hh];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）例题"><a href="#2）例题" class="headerlink" title="2）例题"></a>2）例题</h3><h4 id="T2：-JLOI-2013-赛车"><a href="#T2：-JLOI-2013-赛车" class="headerlink" title="T2：[JLOI 2013]赛车"></a>T2：[JLOI 2013]赛车</h4><p><a href="https://www.luogu.com.cn/problem/P3256">题目传送门 Luogu</a></p><p>半平面交的模板题，注意用 <code>long double</code>，并且把精度调高一点。</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> LD;</span><br><span class="line"><span class="keyword">const</span> LD eps = <span class="number">1e-18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">LD x, y;</span><br><span class="line">Point <span class="keyword">operator</span> +(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x + t.x, y + t.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Point <span class="keyword">operator</span> -(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">LD <span class="keyword">operator</span> *(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * t.y - y * t.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">Point st, ed;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; id;</span><br><span class="line">&#125;l[N];</span><br><span class="line"><span class="keyword">int</span> q[N], hh, tt;</span><br><span class="line"><span class="keyword">int</span> ki[N], vi[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> angle = [](<span class="keyword">const</span> Line &amp;l)&#123;<span class="keyword">return</span> <span class="built_in">atan2</span>(l.ed.y - l.st.y, l.ed.x - l.st.x);&#125;;</span><br><span class="line"><span class="keyword">auto</span> sgn = [](LD x)&#123;<span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">fabs</span>(x) &lt; eps) ? <span class="number">0</span> : (x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>);&#125;;</span><br><span class="line"><span class="keyword">auto</span> cmp = [](LD x, LD y)&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>(x - y);&#125;;</span><br><span class="line"><span class="keyword">auto</span> lcmp = [](<span class="keyword">const</span> Line &amp;l1, <span class="keyword">const</span> Line &amp;l2)&#123;</span><br><span class="line">LD A = <span class="built_in">angle</span>(l1), B = <span class="built_in">angle</span>(l2);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cmp</span>(A, B) == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">sgn</span>((l1.ed - l1.st) * (l2.ed - l1.st)) &lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> A &lt; B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">get_point_</span><span class="params">(Point p1, Point k1, Point p2, Point k2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point del = p1 - p2;</span><br><span class="line">LD t = (k2 * del) / (k1 * k2);</span><br><span class="line"><span class="keyword">return</span> &#123;t * k1.x + p1.x, t * k1.y + p1.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">get_point</span><span class="params">(<span class="keyword">const</span> Line &amp;l1, <span class="keyword">const</span> Line &amp;l2)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">get_point_</span>(l1.st, l1.ed - l1.st, l2.st, l2.ed - l2.st);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">on_right</span><span class="params">(<span class="keyword">const</span> Line &amp;a, <span class="keyword">const</span> Line &amp;b, <span class="keyword">const</span> Line &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point t = <span class="built_in">get_point</span>(b, c);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sgn</span>((t - a.st) * (a.ed - a.st)) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">half_plane</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(l + <span class="number">1</span>, l + n + <span class="number">1</span>, lcmp);</span><br><span class="line">hh = <span class="number">1</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; !<span class="built_in">cmp</span>(<span class="built_in">angle</span>(l[i]), <span class="built_in">angle</span>(l[i - <span class="number">1</span>]))) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[i], l[q[tt - <span class="number">1</span>]], l[q[tt]])) tt --;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[i], l[q[hh]], l[q[hh + <span class="number">1</span>]])) hh ++;</span><br><span class="line">q[++ tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[q[tt]], l[q[hh]], l[q[hh + <span class="number">1</span>]])) hh ++;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[q[hh]], l[q[tt - <span class="number">1</span>]], l[q[tt]])) tt --;</span><br><span class="line">q[++ tt] = q[hh];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = hh; i &lt; tt; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : l[q[i]].id) ans.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : ans) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;PII, vector&lt;<span class="keyword">int</span>&gt; &gt; ids;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">l[++ cnt] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">10000</span>, <span class="number">0</span>&#125;, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>)&#125;;</span><br><span class="line">l[++ cnt] = &#123;&#123;<span class="number">0</span>, <span class="number">10000</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>)&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; ki[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; vi[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">ids[&#123;ki[i], vi[i]&#125;].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : ids)</span><br><span class="line">l[++ cnt] = &#123;&#123;<span class="number">0</span>, c.first.first&#125;, &#123;<span class="number">1</span>, c.first.first + c.first.second&#125;, c.second&#125;;</span><br><span class="line"><span class="built_in">half_plane</span>(cnt);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="3-三维凸包"><a href="#3-三维凸包" class="headerlink" title="3. 三维凸包"></a>3. 三维凸包</h2><h3 id="1）三维空间向量"><a href="#1）三维空间向量" class="headerlink" title="1）三维空间向量"></a>1）三维空间向量</h3><h4 id="a-加减、数乘、模长"><a href="#a-加减、数乘、模长" class="headerlink" title="a. 加减、数乘、模长"></a>a. 加减、数乘、模长</h4><p>与二维向量相同，不再赘述。</p><h4 id="b-点乘"><a href="#b-点乘" class="headerlink" title="b. 点乘"></a>b. 点乘</h4><p>得到是一个数。</p><p>$(x1, y1, z1) \cdot (x2, y2, z2) = x1x2 + y1y2 + z1z2$。</p><p>注意满足 $|A||B|\cos&lt;A, B&gt; = A \cdot B$。</p><h4 id="c-叉乘"><a href="#c-叉乘" class="headerlink" title="c. 叉乘"></a>c. 叉乘</h4><p>得到不是数，是一个行列式的结果。<br>$$<br>det\left(<br>\begin{matrix}<br>i &amp; j &amp; k\<br>x1 &amp; y1 &amp; z1\<br>x2 &amp; y2 &amp; z2<br>\end{matrix}<br>\right)<br>$$<br>注意 $i, j, k$ 是空间单位向量，得到的明显也是一个三位向量。</p><p>展开行列式，可以得到：$(x1, y1, z1) \times (x2, y2, z2) = (y1z2 - y2z1, x2z1 - x1z2, x1y2 - x2y1)$。</p><h4 id="d-多面体欧拉定理"><a href="#d-多面体欧拉定理" class="headerlink" title="d. 多面体欧拉定理"></a>d. 多面体欧拉定理</h4><p>点数 - 棱数 + 面数 = 2。</p><h4 id="e-平面的法向量"><a href="#e-平面的法向量" class="headerlink" title="e. 平面的法向量"></a>e. 平面的法向量</h4><p>法向量是指垂直于</p><p>任意取两个向量</p><h3 id="2）三维凸包-增量法"><a href="#2）三维凸包-增量法" class="headerlink" title="2）三维凸包 - 增量法"></a>2）三维凸包 - 增量法</h3><p>其实是一个暴力算法，时间复杂度为 $O(n ^ 2)$。</p><p>我们首先找到任意不共面的 4 个点，使得可以形成一个凸包。</p><p>然后，我们尝试加入每一个点。</p><p>如果它在凸包里，则跳过；否则我们考虑加入。</p><p>假设这个点是一个太阳，那么一定会有一些面是“白天”，还有一些棱是“晨昏线”。</p><p>我们将”白天“全部删除，并且将”晨昏线“与新加的点相连，形成新的凸包。</p><p>具体看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Convex_3d</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> bitset&lt;N&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, ncnt = <span class="number">0</span>;</span><br><span class="line">pl[++ cnt] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, pl[++ cnt] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">ncnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++ j)&#123;</span><br><span class="line"><span class="keyword">bool</span> t = pl[j].<span class="built_in">above</span>(p[i]);</span><br><span class="line"><span class="keyword">if</span> (!t) np[++ ncnt] = pl[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++ k)</span><br><span class="line">g[pl[j].v[k]][pl[j].v[(k + <span class="number">1</span>) % <span class="number">3</span>]] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++ k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a = pl[j].v[k], b = pl[j].v[(k + <span class="number">1</span>) % <span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span> (g[a][b] &amp;&amp; !g[b][a]) np[++ ncnt] = &#123;a, b, i&#125;;</span><br><span class="line">&#125;</span><br><span class="line">cnt = ncnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++ j) pl[j] = np[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;前置知识：计算几何。&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算几何" scheme="https://mydcwfy.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
    <category term="凸包" scheme="https://mydcwfy.github.io/tags/%E5%87%B8%E5%8C%85/"/>
    
    <category term="旋转卡壳" scheme="https://mydcwfy.github.io/tags/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/"/>
    
  </entry>
  
  <entry>
    <title>计算几何基础</title>
    <link href="https://mydcwfy.github.io/2022/01/19/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://mydcwfy.github.io/2022/01/19/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/</id>
    <published>2022-01-19T06:28:54.000Z</published>
    <updated>2022-01-19T12:32:46.419Z</updated>
    
    <content type="html"><![CDATA[<p>需要的初高中几何知识是比较多的。</p><span id="more"></span><h2 id="1-数学基础"><a href="#1-数学基础" class="headerlink" title="1. 数学基础"></a>1. 数学基础</h2><p>$$<br>\begin{aligned}<br>\pi &amp;= \arccos(-1)\\<br>c^2 &amp;= a^2 + b^2 - 2ab\cos\theta<br>\end{aligned}<br>$$</p><p>第一个的原理来自于：$\cos \pi = -1$。</p><p>第二个是一个余弦定理。</p><h2 id="2-关于浮点数"><a href="#2-关于浮点数" class="headerlink" title="2. 关于浮点数"></a>2. 关于浮点数</h2><p>比如我们比较两个数的时候，他们可能因为计算的误差而不同。所以我们必须定义一个 $\epsilon$，表示两个的差别，如果在 $\epsilon$ 中的话，我们就认为这两个数相等。$\epsilon$ 可以定义为 $10^{-8}, 10^{-9}$ 等等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_equal</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(x - y) &lt; eps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，如果比较两个数的大小，我们同样也要使用 $\epsilon$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x - y) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-向量"><a href="#3-向量" class="headerlink" title="3. 向量"></a>3. 向量</h2><p>首先，简单的向量加减不再展开。</p><p>我们先介绍点乘：$a \cdot b = |a||b|\cos&lt;a, b&gt;$。</p><p>如果在二维点坐标下计算，就是 $(a, b) \cdot (c, d) = ac + bd$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dot</span><span class="params">(Point a, Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们计算一个向量的模的时候，可以直接计算就是了，也可以 $|a| = \sqrt{a \cdot a}$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">(Point a)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">dot</span>(a, a));&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用点乘来计算两个之间的夹角。</p><p>$\cos&lt;a, b&gt; = \dfrac{a\cdot b}{|a||b|}$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_angle</span><span class="params">(Point a, Point b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">acos</span>(<span class="built_in">dot</span>(a) / <span class="built_in">length</span>(a) / <span class="built_in">length</span>(b));&#125;</span><br></pre></td></tr></table></figure><p>还有一种乘法，是叉乘：$a\times b = |a||b|\sin&lt;a, b&gt;$。</p><p>如果是二维点坐标，就是 $(a, b)\times (c, d) = ad - bc$。</p><p>如果叉乘大于 0 的话，那么 $a$ 向量在 $b$ 向量的顺时针的方向。注意叉乘没有交换性。一般将叉乘重载为乘法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Point a, Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个，我们转一个角。</p><p>直接写出公式，证明可以使用和差角公式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">rotate</span><span class="params">(Point a, <span class="keyword">double</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;a.x * <span class="built_in">cos</span>(c) - a.y * <span class="built_in">sin</span>(c), a.x * <span class="built_in">sin</span>(c) + a.y * <span class="built_in">cos</span>(c)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-计算几何"><a href="#4-计算几何" class="headerlink" title="4. 计算几何"></a>4. 计算几何</h2><p>似乎能写的似乎不多……</p><p>我们简单的看几个比较常用的。</p><h3 id="1）直线相交"><a href="#1）直线相交" class="headerlink" title="1）直线相交"></a>1）直线相交</h3><p>首先，判断两个直线是否相交：$a\times b \not= 0$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_cross</span><span class="params">(Point a, Point b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">cross</span>(a, b) != <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="2）线段相交"><a href="#2）线段相交" class="headerlink" title="2）线段相交"></a>2）线段相交</h3><p>分为两步：快速排斥实验和跨立实验。</p><p>快速排斥实验是指如果两个线段所在的矩形如果不相交，那么两条线段一定不相交。</p><img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C.png" class=""><p>如果两个线段所在的矩形是相交的，也不说明两条线段是相交的。</p><img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C2.png" class=""><p>我们需要判断两个线段相交的话，需要判断一个线段的两个点是否在另外一个线段所在直线的两侧。</p><p>具体来说，就是判断 $(p3 - p1) \times (p2 - p1)$ 与 $(p4 - p1) \times (p2 - p1)$ 是否异号。</p><p>另外，我们可以直接对这两条线段都这么计算，可以省去第一步。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cross_seg</span><span class="params">(Point p1, Point p2, Point p3, Point p4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (((p1 - p3) * (p4 - p3)) * ((p2 - p3) * (p4 - p3)) &gt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (((p3 - p1) * (p2 - p1)) * ((p4 - p1) * (p2 - p1)) &gt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）判断一个点是否在多边形内"><a href="#3）判断一个点是否在多边形内" class="headerlink" title="3）判断一个点是否在多边形内"></a>3）判断一个点是否在多边形内</h3><p>注意不一定是凸多边形。</p><p>有一个结论：<strong>经过凸多边形的边奇数次，就在凸多边形内。</strong></p><p>很明显，没经过一次边，就会导致从外到内，或者从内到外。最后一定是在外部，所以奇数次的话该点就在里面。</p><p>注意这个结论在经过某一个顶点或者射线与边重合时并不适用，所以我们随机一个在凸多边形外部的点判断就可以了。</p><p>（不保证代码正确</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in_polygon</span><span class="params">(Point *p, Point a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p[n + <span class="number">1</span>] = p[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>((p[<span class="number">1</span>] - p[i]) * (p[i + <span class="number">1</span>] - p[i])) &lt; eps &amp;&amp;</span><br><span class="line"><span class="built_in">dot</span>(p[<span class="number">1</span>] - p[i], p[i + <span class="number">1</span>] - p[i]) &gt; eps &amp;&amp; <span class="built_in">dot</span>(p[i + <span class="number">1</span>] - p[<span class="number">1</span>], p[i + <span class="number">1</span>] - p[i]) &gt; eps)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Point c = &#123;(<span class="keyword">double</span>)<span class="built_in">rand</span>(), (<span class="keyword">double</span>)<span class="built_in">rand</span>()&#125;;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; !flag; ++ i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>((c - a) * (p[i] - a)) &lt; eps &amp;&amp; <span class="built_in">fabs</span>((c - a) * (p[i + <span class="number">1</span>] - a)) &lt; eps)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">flag ^= <span class="built_in">cross_seg</span>(a, c, p[i], p[i + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4）多边形面积"><a href="#4）多边形面积" class="headerlink" title="4）多边形面积"></a>4）多边形面积</h3><p>这是一个结论，我们就不证明了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sum_area</span><span class="params">(Point *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++ i)</span><br><span class="line">res += (p[i + <span class="number">1</span>] - p[<span class="number">1</span>]) * (p[i] - p[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-例题"><a href="#5-例题" class="headerlink" title="5. 例题"></a>5. 例题</h2><h3 id="T1：玩具"><a href="#T1：玩具" class="headerlink" title="T1：玩具"></a>T1：玩具</h3><p><a href="http://poj.org/problem?id=2318">题目传送门 POJ</a></p><p>我们二分，找到第一个在该点左边的隔板。判断这个点是否在线段的右边（这里是顺时针方向），直接用叉乘即可。</p><details><summary>完整代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">LL x, y;</span><br><span class="line">Point <span class="keyword">operator</span> +(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x + t.x, y + t.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Point <span class="keyword">operator</span> -(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">LL <span class="keyword">operator</span> *(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * t.y - y * t.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;L, R, now, up[N], dn[N];</span><br><span class="line"><span class="keyword">int</span> n, m, cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> is_fir = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %lld %lld %lld %lld&quot;</span>, &amp;m, &amp;L.x, &amp;R.y, &amp;R.x, &amp;L.y);</span><br><span class="line">up[<span class="number">0</span>] = &#123;L.x, L.y&#125;, dn[<span class="number">0</span>] = &#123;L.x, R.y&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;dn[i].x, &amp;up[i].x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) up[i].y = L.y, dn[i].y = R.y;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) cnt[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!is_fir) <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cse = <span class="number">1</span>; cse &lt;= m; ++ cse)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;now.x, &amp;now.y);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((now - up[mid]) * (dn[mid] - up[mid]) &gt; <span class="number">0</span>) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cnt[l] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>, i, cnt[i]);</span><br><span class="line">is_fir = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;需要的初高中几何知识是比较多的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算几何" scheme="https://mydcwfy.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>P3321</title>
    <link href="https://mydcwfy.github.io/2021/12/27/P3321/"/>
    <id>https://mydcwfy.github.io/2021/12/27/P3321/</id>
    <published>2021-12-27T13:58:09.000Z</published>
    <updated>2021-12-27T14:30:15.756Z</updated>
    
    <content type="html"><![CDATA[<p>比较难想，但其实是一个套路。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给定匹配串 $a$ 和原串 $b$，要求像 KMP 一样匹配，但是有通配符（指和每一个都可以匹配），给出所有的起点可以匹配。</p><p>$|a|,|b|\leq 10 ^ 5 $。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>（以下字符串默认从 0 开始）</p><p>首先，肯定不是暴力枚举每一个通配符的匹配字符。</p><p>其中，对于一个字符串 $s$，构造<br>$$<br>F(x) = \sum_{i = 0}^{|s| - 1} [s(i) == ‘*’]\times s(i) \ x ^ i<br>$$<br>表示如果是通配符的话，就是 0，否则就是原字符本身。</p><p>我们现在假设要求 $k$ 这个位置能否匹配。</p><p>我们考虑构造：<br>$$<br>H_k = \sum_{i = 0}^{m - 1} A(i) \times B(i + k - 1) \times (A(i) - B(i + k - 1)) ^ 2\ x ^ i<br>$$<br>那么，$[x^i]H(x)$ 为 0 的话，有 3 种情况：</p><ol><li>$A(i) = 0$</li><li>$B(i) = 0$</li><li>$A(i) = B(i + x - 1)$</li></ol><p>可以发现，这三种情况正好对应的有通配符的情况下的匹配。</p><p>由于每一项非负，所以只要有一项不是 0，所以整个就不是 0。</p><p>那么，我们展开一下：<br>$$<br>H_k = \sum_{i = 0}^{m - 1} (A(i)^3B(i + k - 1) - 2A(i)^2B(i + k - 1) ^ 2 + A(i)B(i + k - 1) ^ 3)<br>$$<br>那么，我们就只需要求出所有的 $H(x)$，每一位都是 $H_k$，只需要统计 0 的个数就可以了。<br>$$<br>H(x) = \sum_{k = 0}^{n - 1}\sum_{i = 0}^{m - 1} (A(i)^3B(i + k - 1) - 2A(i)^2B(i + k - 1) ^ 2 + A(i)B(i + k - 1) ^ 3)<br>$$<br>这个很明显是一个差相等的会放到一个 $H_k$ 中，根据套路，我们把它翻转一个。<br>$$<br>H(x) = \sum_{k = 0}^{n - 1}\sum_{i = 0}^{m - 1} (A(m - i - 1)^3B(i + k - 1) - 2A(m - i - 1)^2B(i + k - 1) ^ 2 + A(m - i - 1)B(i + k - 1) ^ 3)<br>$$<br>直接 NTT 就可以了。注意每一项都要 NTT，而不是一次 NTT 直接计算。</p><p>注意<a href="https://www.luogu.com.cn/discuss/303076">有人卡 998244353</a>，直接把原根换成 5 或者模数换为 167772161 就可以了。但是确实可以被卡。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">Match</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">char</span> *s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; mat;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">strlen</span>(s1), n = <span class="built_in">strlen</span>(s2);</span><br><span class="line">    <span class="built_in">reverse</span>(s1, s1 + m);</span><br><span class="line">    <span class="keyword">static</span> LL f[N], g[N], h[N], a[N], b[N];</span><br><span class="line">    <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (n + m + <span class="number">1</span>)) bit ++;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) h[i] = f[i] = g[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s1[i] == <span class="string">&#x27;*&#x27;</span>) f[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> f[i] = s1[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s2[i] == <span class="string">&#x27;*&#x27;</span>) g[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> g[i] = s2[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//H(i - j) += F(i) * G(j) * (F(i) - G(j)) ^ 2</span></span><br><span class="line">    <span class="comment">//H(i + j - m - 1) += F(i) * G1(m - j - 1) * (F(i) - G1(j)) ^ 2</span></span><br><span class="line">    <span class="comment">/*for (int i = 0; i &lt; tot; ++ i)</span></span><br><span class="line"><span class="comment">        f[i] = (qpow(f[i], 3) * g[i] % Mod - qpow(f[i] * g[i] % Mod, 2) * 2 % Mod + qpow(g[i], 3) * f[i] % Mod + Mod) % Mod;*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = f[i] * f[i] * f[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) b[i] = g[i];</span><br><span class="line">    <span class="built_in">NTT</span>(a, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) h[i] = (h[i] + a[i] * b[i]) % Mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = f[i] * f[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) b[i] = g[i] * g[i];</span><br><span class="line">    <span class="built_in">NTT</span>(a, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) h[i] = (h[i] + (Mod - <span class="number">2</span>) * a[i] % Mod * b[i]) % Mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = f[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) b[i] = g[i] * g[i] * g[i];</span><br><span class="line">    <span class="built_in">NTT</span>(a, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) h[i] = (h[i] + a[i] * b[i]) % Mod;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NTT</span>(h, bit, <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// for (int i = m - 1; i &lt; n; ++ i) cout &lt;&lt; h[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line">    <span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (h[i] == <span class="number">0</span>) mat.<span class="built_in">push_back</span>(i - m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;比较难想，但其实是一个套路。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="多项式" scheme="https://mydcwfy.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>二次剩余与 Cipolla 算法</title>
    <link href="https://mydcwfy.github.io/2021/12/26/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%E4%B8%8E-Cipolla-%E7%AE%97%E6%B3%95/"/>
    <id>https://mydcwfy.github.io/2021/12/26/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%E4%B8%8E-Cipolla-%E7%AE%97%E6%B3%95/</id>
    <published>2021-12-26T07:24:45.000Z</published>
    <updated>2021-12-30T12:11:50.248Z</updated>
    
    <content type="html"><![CDATA[<p>虽说比较困难，但是代码实现十分简单。</p><span id="more"></span><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>我们求解 $x ^ 2 \equiv n \pmod p$，其中 $n, p$ 给定，$p$ 是质数。就是二次剩余，可以记为 $x = \sqrt n$。</p><p>一般使用 Cipolla 算法，时间复杂度是玄学，期望是 $O(\log n)$，一般也比较稳定。</p><h2 id="2-推导过程"><a href="#2-推导过程" class="headerlink" title="2. 推导过程"></a>2. 推导过程</h2><p>首先，证明一下<strong>在 $\bmod p$ 意义下的有 $\sqrt n$ 的 $n$ 的个数有 $\dfrac{p - 1}{2}$ 个。</strong></p><p>首先，我们容易发现，$x$ 与 $p - x$ 在 $\bmod p$ 意义下是相等的。于是我们只需要判断 $x\in[1, \dfrac{p - 1}{2}]$ 的 $x ^ 2$ 是不相同的。这样的话，对于 $\dfrac{p - 1}{2}$ 个 $n$ 都有两个不同的二次剩余对应它。</p><p>使用反证法，我们假设 $x_1,x_2\in[1, \dfrac{p - 1}{2}]$ 的平方是一样的，那么可以得到 $(x_2 +x_1)(x_2 - x_1)\equiv 0\pmod p$。但是 $x_2 + x_1$ 和 $x_2 - x_1$ 都是不可能相等的，所以不可能存在这样的 $x_1$ 和 $x_2$。</p><p>第二个，我们有一个定理：<strong>如果 $n^{\frac{p - 1}{2}}\equiv 1\pmod p$，那么 $n$ 在 $\bmod p$ 下是有二次剩余的。</strong></p><p>这一个比较难证，这里就略过了。但是一个可以明确的地方是 $\forall n, n^{\frac{p - 1}2}\bmod p\in {1, p - 1}$。因为 $n^{p - 1}\bmod p = 1$。</p><p>第三个，我们找到一个 $a$，使得 $a^2 - n$ 是一个非二次剩余。找到 $a$ 的话，我们使用随机化算法，在 $[0, p - 1]$ 中随机，然后判断 $(a ^ 2 - n)^{\frac{p - 1}2}$ 是否等于 $-1\bmod p$。由于有 $\dfrac{p - 1}{2}$ 个数不是二次剩余，所以我们期望 2 次就可以找到一个 $a ^ 2 - n$。这一步的期望是 $O(\log n)$。</p><p>设 $w = a ^ 2 - n$。</p><p>最后一步，我们定义一个二维向量 $(a, b)$，表示 $a + b\sqrt w$。</p><p>我们可以得到第三个结论：<strong>将二维向量当作一个数来乘，$\sqrt n = (a, 1) ^{\frac{p - 1}{2}}$。</strong></p><p>其中，$(a, 1)$ 表示 $a + \sqrt w$ 这个数，我们将这个数 $\dfrac{p - 1}{2}$ 次方，实部就是 $\sqrt n$。</p><p>证明也太难了，我们就不讲了。</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p>首先，我们将向量直接看做复数封装好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    ll x, y;</span><br><span class="line">&#125;;</span><br><span class="line">ll w;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">mul</span><span class="params">(Complex t1, Complex t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(t1.x * t2.x % p + t1.y * t2.y % p * w % p) % p, (t1.x * t2.y % p + t1.y * t2.x % p) % p&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">qpow_com</span><span class="params">(Complex a, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Complex res = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = <span class="built_in">mul</span>(res, a);</span><br><span class="line">        a = <span class="built_in">mul</span>(a, a);</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>qpow_com</code> 表示复数快速幂，其实是比较简单的。</p><p>然后就可以直接实现了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="built_in">rand</span>() % p;</span><br><span class="line">        w = (a * a % p - n + p) % p;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">qpow</span>(w, (p - <span class="number">1</span>) / <span class="number">2</span>) == p - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow_com</span>(&#123;a, <span class="number">1</span>&#125;, (p + <span class="number">1</span>) / <span class="number">2</span>).x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完全版。</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cipolla</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    LL x, y;</span><br><span class="line">&#125;;</span><br><span class="line">LL w, Mod;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">mul</span><span class="params">(Complex a, Complex b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(a.x * b.x % Mod + a.y * b.y % Mod * w % Mod) % Mod, (a.x * b.y + a.y * b.x) % Mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">qpow_com</span><span class="params">(Complex a, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Complex res = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = <span class="built_in">mul</span>(res, a);</span><br><span class="line">        a = <span class="built_in">mul</span>(a, a);</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL a, LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * a % Mod;</span><br><span class="line">        a = a * a % Mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cipolla</span>(<span class="keyword">int</span> _Mod = <span class="number">998244353</span>) : <span class="built_in">Mod</span>(_Mod) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Mod_Sqrt</span><span class="params">(LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL a;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="built_in">rand</span>() % Mod;</span><br><span class="line">        w = (a * a - n + Mod) % Mod;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">qpow</span>(w, (Mod - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) == Mod - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow_com</span>(&#123;a, <span class="number">1</span>&#125;, (Mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>).x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽说比较困难，但是代码实现十分简单。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="二次剩余" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/"/>
    
  </entry>
  
  <entry>
    <title>P7590</title>
    <link href="https://mydcwfy.github.io/2021/12/26/P7590/"/>
    <id>https://mydcwfy.github.io/2021/12/26/P7590/</id>
    <published>2021-12-26T05:00:01.000Z</published>
    <updated>2021-12-26T05:01:58.637Z</updated>
    
    <content type="html"><![CDATA[<p>单调队列。</p><span id="more"></span><h2 id="0-前置知识-amp-废话"><a href="#0-前置知识-amp-废话" class="headerlink" title="0. 前置知识 &amp; 废话"></a>0. 前置知识 &amp; 废话</h2><p>说实话，出题人的办法我没太看懂，于是就想了另外一种方法。</p><p>本题解需要你掌握：单调队列</p><p><a href="https://www.luogu.com.cn/problem/P1886">本算法位置</a></p><p>时间复杂度仍为 $O(n)$，但常数较标程略大，故需要点 <del>玄学优化</del>。</p><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给你一个环，每一个点都可以加一定的权值 x，从一个点到下一个点都要减少一定的权值，要保证随时都要 $x\geq0$，可以在一个点时恰好为 0。</p><p>从每一个点开始时，权值都等于 0。</p><p>如果有一个点可以运动 1 周，输出最小编号，否则输出 “Failed!”。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>出题人的方法我确实没看懂。</p><h3 id="1）朴素"><a href="#1）朴素" class="headerlink" title="1）朴素"></a>1）朴素</h3><p>首先考虑朴素算法。</p><p>定义<br>$$<br>d[x]=a[x]-b[x],sum[x]=\sum_{i=1}^{x}d[i]<br>$$<br>所以如果从 i 可以到 i+1，需要满足：<br>$$<br>a[i]=sum[i+1]-sum[i]\geq 0<br>$$<br>我们可以考虑将环拆成 2 倍的链。</p><p>如果从 i 可以的话，需要满足：<br>$$<br>\forall j\in [i,i+n-1],sum[j]\geq sum[i-1]<br>$$<br>时间复杂度为 $O(n^2)$，期望得分 30 分。</p><p><a href="https://www.luogu.com.cn/paste/oewr50t0">代码放置处</a></p><p>实际打代码时，我们可以以它为对拍代码。</p><h3 id="2）堆优化"><a href="#2）堆优化" class="headerlink" title="2）堆优化"></a>2）堆优化</h3><p>其实，我们不难发现，对于该式，我们可以使用堆优化。</p><p>时间复杂度 $O(n\log n)$，期望得分 70 分。</p><p>不放代码了 <del>逃</del>。</p><h3 id="3）单调队列"><a href="#3）单调队列" class="headerlink" title="3）单调队列"></a>3）单调队列</h3><p>我们进一步挖掘性质，可以发现，我们需要的是 $[i,i+n-1]$ 的最小值，且 i 不断变大。</p><p>这难道不是和单调队列相似吗？</p><p>那么就可以了。</p><p>如果 $j&lt;k,sum[j]&gt;sum[k]$，那么 j 不可能成为某个点的最小值。</p><p>维护一个单调队列，使其保持递增的顺序。</p><p>队头是最小值。</p><p>那么就可以了 吗？ <del>雾</del>。</p><p>单调队列虽然是 $O(n)$,但常数相对于标程更大，而最大 $\sum n=2\times 10^7$，很可能超时。</p><h2 id="3-常数优化"><a href="#3-常数优化" class="headerlink" title="3. 常数优化"></a>3. 常数优化</h2><ol><li>我开始 scanf+O2 竟然超时了，所以快读是时候了。</li><li>听说 register 可以加快，用一用也不错。</li></ol><p>这样一阵 <del>玄学</del> 优化后，我们就不用 O2 最大点也可以只用 600ms 就过了。</p><h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll d[<span class="number">2</span>*N],sum[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">int</span> hh,tt,q[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (hh&lt;=tt&amp;&amp;sum[q[tt]]&gt;=sum[x]) tt--;</span><br><span class="line">q[++tt]=x;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((c=<span class="built_in">getchar</span>())&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) ;</span><br><span class="line">    x=c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c=<span class="built_in">getchar</span>())&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// freopen(&quot;randdata.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">// freopen(&quot;myans.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">re <span class="keyword">int</span> cas,n,x;</span><br><span class="line"><span class="built_in">get</span>(cas);</span><br><span class="line"><span class="keyword">while</span> (cas--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">get</span>(n);</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">get</span>(x),d[i]=x;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">get</span>(x);</span><br><span class="line">d[i]-=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) d[i+n]=d[i];</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;++i) sum[i]=sum[i<span class="number">-1</span>]+d[i];<span class="comment">//,cout&lt;&lt;sum[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">hh=<span class="number">1</span>;tt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">insert</span>(i);</span><br><span class="line">re <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (hh&lt;=tt&amp;&amp;q[hh]&lt;i) hh++;</span><br><span class="line"><span class="built_in">insert</span>(i+n<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// printf(&quot;%d %d\n&quot;,hh,tt);</span></span><br><span class="line"><span class="keyword">if</span> (sum[i<span class="number">-1</span>]&lt;=sum[q[hh]])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="built_in">puts</span>(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;单调队列。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="单调队列" scheme="https://mydcwfy.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>P7225</title>
    <link href="https://mydcwfy.github.io/2021/12/26/P7225/"/>
    <id>https://mydcwfy.github.io/2021/12/26/P7225/</id>
    <published>2021-12-26T04:58:34.000Z</published>
    <updated>2021-12-26T04:59:15.412Z</updated>
    
    <content type="html"><![CDATA[<p>极为简单的交互题目。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>你站在一个格子，你可以移动到相邻的格子（如果相邻的格子不是障碍物的话）。</p><p>现在你需要回答走能走到的格子有哪些。</p><h2 id="2-关于交互题"><a href="#2-关于交互题" class="headerlink" title="2. 关于交互题"></a>2. 关于交互题</h2><p>请确保你知道交互题的评测方式与做法。</p><p>其实，大概的意思就是你和另外一个程序同时运行，并交换数据。</p><p>本蒟蒻由于没做过几道交互题，只能讲到这个地步啦。</p><h2 id="3-本题"><a href="#3-本题" class="headerlink" title="3. 本题"></a>3. 本题</h2><p>主要有两种思路：bfs 和 dfs。</p><p>注意观察 bfs 的性质：他是走到一个位置后，一会在进行扩展。</p><p>但是，本题中，我们希望的是他走的时候，是连续的，并且有回溯过程。</p><p>看到原题，他只会给你当前格子的信息，不会给你其他格子的。</p><p>所以，我们采用 dfs 进行搜索，并时刻记录有没有被访问。</p><p>由于每一个格子访问次数是常数，所以复杂度为 $O(n^2)$。</p><h2 id="4-AC-代码"><a href="#4-AC-代码" class="headerlink" title="4.AC 代码"></a>4.AC 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(i,j) (i-1)*n+j-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> check(i,j) (i&gt;1&amp;&amp;j&gt;1&amp;&amp;i&lt;n&amp;&amp;j&lt;n&amp;&amp;m[i][j]==-1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">705</span>][<span class="number">705</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,n,m[<span class="number">705</span>][<span class="number">705</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">4</span>]=&#123;<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;W&#x27;</span>&#125;;</span><br><span class="line">string ans;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">bool</span> <span class="title">move_to</span><span class="params">(<span class="keyword">char</span> position)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(x+dx[i],y+dy[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">move_to</span>(op[i])) m[x+dx[i]][y+dy[i]]=<span class="number">0</span>,<span class="built_in">dfs</span>(x+dx[i],y+dy[i]),<span class="built_in">move_to</span>(op[<span class="number">3</span>-i]);</span><br><span class="line">            <span class="keyword">else</span> m[x+dx[i]][y+dy[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">string <span class="title">find_out_map</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    ans=<span class="string">&quot;&quot;</span>;n=N;</span><br><span class="line">    <span class="built_in">memset</span>(m,<span class="number">-1</span>,<span class="keyword">sizeof</span> m);</span><br><span class="line">    <span class="built_in">dfs</span>(x,y);</span><br><span class="line">    ans=<span class="string">&quot;&quot;</span>;m[x][y]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (m[i][j]==<span class="number">0</span>) ans+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> ans+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-半个交互库"><a href="#5-半个交互库" class="headerlink" title="5. 半个交互库"></a>5. 半个交互库</h2><p>我自己做的时候，由于没有交互库，无法得知自己是否正确。</p><p>自己手写的代码，算半个交互库，希望对你有所帮助。</p><p>（同时是本题的非交互写法）。</p><p>也增添了评测。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(i,j) (i-1)*n+j-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> check(i,j) (i&gt;1&amp;&amp;j&gt;1&amp;&amp;i&lt;n&amp;&amp;j&lt;n&amp;&amp;m[i][j]==-1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">705</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,n,m[N][N],nowx,nowy;</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">4</span>]=&#123;<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;W&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ansmap[N][N],tot;</span><br><span class="line">string ans,stdans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">move_to</span><span class="params">(<span class="keyword">char</span> position)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++tot&gt;=<span class="number">5e5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Too many operations!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position==<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ansmap[nowx+<span class="number">1</span>][nowy])</span><br><span class="line">        &#123;</span><br><span class="line">            nowx++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ansmap[nowx][nowy<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            nowy--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position==<span class="string">&#x27;W&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ansmap[nowx<span class="number">-1</span>][nowy])</span><br><span class="line">        &#123;</span><br><span class="line">            nowx--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ansmap[nowx][nowy+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            nowy++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(x+dx[i],y+dy[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">move_to</span>(op[i])) m[x+dx[i]][y+dy[i]]=<span class="number">0</span>,<span class="built_in">dfs</span>(x+dx[i],y+dy[i]),<span class="built_in">move_to</span>(op[<span class="number">3</span>-i]);</span><br><span class="line">            <span class="keyword">else</span> m[x+dx[i]][y+dy[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">find_out_map</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*put your code here</span></span><br><span class="line"><span class="comment">      this is mine*/</span></span><br><span class="line">    ans=<span class="string">&quot;&quot;</span>;n=N;</span><br><span class="line">    <span class="built_in">memset</span>(m,<span class="number">-1</span>,<span class="keyword">sizeof</span> m);</span><br><span class="line">    <span class="built_in">dfs</span>(x,y);</span><br><span class="line">    ans=<span class="string">&quot;&quot;</span>;m[x][y]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (m[i][j]==<span class="number">0</span>) ans+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> ans+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;nowx&gt;&gt;nowy&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;stdans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (stdans[<span class="built_in">get</span>(i,j)]!=<span class="string">&#x27;0&#x27;</span>) ansmap[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> ansmap[i][j]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//put in the stdmap</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find_out_map</span>(nowx,nowy,n)==stdans) <span class="built_in">puts</span>(<span class="string">&quot;Accepted.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Wrong Answer!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;极为简单的交互题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>P3329</title>
    <link href="https://mydcwfy.github.io/2021/12/26/P3329/"/>
    <id>https://mydcwfy.github.io/2021/12/26/P3329/</id>
    <published>2021-12-26T04:55:56.000Z</published>
    <updated>2021-12-26T04:57:58.171Z</updated>
    
    <content type="html"><![CDATA[<p>最小割树的模板题。</p><span id="more"></span><h2 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1. 前置知识"></a>1. 前置知识</h2><p><a href="https://www.luogu.com.cn/problem/P4897">最小割树（Gomory-Hu Tree）</a></p><p>如果你不知道，可以看 <a href="https://mydcwfy.github.io/2021/12/26/Network-flow/">网络流</a> 或 <a href="https://mydcwfy.github.io/2021/12/26/P4897/">最小割树</a> （ <del>都是我的博客</del> ）</p><p>当然，你也可以看一下下面的解释。</p><h2 id="2-最小割树（Gomory-Hu-Tree）"><a href="#2-最小割树（Gomory-Hu-Tree）" class="headerlink" title="2. 最小割树（Gomory-Hu Tree）"></a>2. 最小割树（Gomory-Hu Tree）</h2><p>（ <del>这也是来自我的博客</del> ）</p><p>很明显，不可能每次求最小割（复杂度为 $O(n^4m)$）。</p><p>我们将一个网络流的图转化为一棵树，其中原图 $u$ 到 $v$ 的最小割即为转化到树上。</p><p>树的一个性质是：删除一条边，树变得不连通。</p><p>那么，我们可以任意选 2 个点 $s$ 与 $t$，跑最小割（即最大流），然后再连一条从 $s$ 到 $t$ 的边。</p><p>又 Dinic 算法最后一次 bfs 相当于求一个最小割，原图就被分为了两部分。</p><p>最后分治就可以了，复杂度为 $O(n^3m)$（Dinic 跑不满的，所以不会超时）。</p><p>按这样建出的树，就是一棵无根树。</p><p>我们可以发现一个有趣的性质：$u$ 到 $v$ 的最小割就是树上从 $u$ 到 $v$ 的所有路径长的最小值。</p><p>可以感性地理解一下（ <del>主要是太菜不会证</del> ）：最小割即为最小的路径长，把 $u$ 到 $v$ 的任意一条路径切断，都是割。</p><h2 id="3-回归本题"><a href="#3-回归本题" class="headerlink" title="3. 回归本题"></a>3. 回归本题</h2><p>还是比较简单。</p><p>直接预处理，将所有的点对之间的最小割求出来。</p><p>有一下两种做法。</p><h3 id="1）-直接扫描"><a href="#1）-直接扫描" class="headerlink" title="1） 直接扫描"></a>1） 直接扫描</h3><p>由于出题人比较良心，这个题的 $Q$ 比较少，可以通过 $O(Qn^2)$，还是可以过的。</p><h3 id="2）-使用有序排列"><a href="#2）-使用有序排列" class="headerlink" title="2） 使用有序排列"></a>2） 使用有序排列</h3><p>我们也可以先将所有的最小割排序好，每次询问，直接查询在有序数列中的位置，减下标即可。</p><p><del>我太懒了</del>，使用了第一种。</p><h2 id="4-Code"><a href="#4-Code" class="headerlink" title="4. Code"></a>4. Code</h2><p>注意要建双向边，否则就不是两边都可以被割掉了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF=<span class="number">1e15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line">ll w[M],ans[N][N];</span><br><span class="line"><span class="keyword">int</span> cur[N],d[N],q[N],S,T,n,m;</span><br><span class="line"><span class="keyword">int</span> node[N],tmp1[N],tmp2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">e[idx]=a,ne[idx]=h[b],w[idx]=<span class="number">0</span>,h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">int</span> hh=<span class="number">1</span>,tt=<span class="number">1</span>;</span><br><span class="line">q[<span class="number">1</span>]=S;cur[S]=h[S];d[S]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (hh&lt;=tt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q[hh++];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (!d[e[i]]&amp;&amp;w[i])</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+<span class="number">1</span>;</span><br><span class="line">cur[e[i]]=h[e[i]];</span><br><span class="line"><span class="keyword">if</span> (e[i]==T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[++tt]=e[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findflow</span><span class="params">(<span class="keyword">int</span> x,ll limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x==T) <span class="keyword">return</span> limit;</span><br><span class="line">ll flow=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=cur[x];~i&amp;&amp;flow&lt;limit;i=ne[i])</span><br><span class="line">&#123;</span><br><span class="line">cur[x]=i;</span><br><span class="line"><span class="keyword">if</span> (d[e[i]]==d[x]+<span class="number">1</span>&amp;&amp;w[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">findflow</span>(e[i],<span class="built_in">min</span>(w[i],limit-flow));</span><br><span class="line"><span class="keyword">if</span> (!t) d[e[i]]=<span class="number">-1</span>;</span><br><span class="line">w[i]-=t,w[i^<span class="number">1</span>]+=t,flow+=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i+=<span class="number">2</span>)</span><br><span class="line">w[i]=(w[i]+w[i^<span class="number">1</span>]),w[i^<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">ll r=<span class="number">0</span>,flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">bfs</span>()) <span class="keyword">while</span> (flow=<span class="built_in">findflow</span>(S,INF)) r+=flow;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l==r) <span class="keyword">return</span> ;</span><br><span class="line">S=node[l],T=node[l+<span class="number">1</span>];</span><br><span class="line">ll t=<span class="built_in">dinic</span>();</span><br><span class="line">    <span class="keyword">int</span> s=node[l],tt=node[l+<span class="number">1</span>];</span><br><span class="line">ans[T][S]=ans[S][T]=t;</span><br><span class="line"><span class="comment">//printf(&quot;%d %d:%d\n&quot;,S,T,ans[S][T]);</span></span><br><span class="line"><span class="keyword">int</span> cnt1=<span class="number">0</span>,cnt2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=l;i&lt;=r;++i)</span><br><span class="line"><span class="keyword">if</span> (d[node[i]]) tmp1[++cnt1]=node[i];</span><br><span class="line"><span class="keyword">else</span> tmp2[++cnt2]=node[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt1;++i) node[i+l<span class="number">-1</span>]=tmp1[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt2;++i) node[cnt1+l+i<span class="number">-1</span>]=tmp2[i];</span><br><span class="line"><span class="built_in">work</span>(l,l+cnt1<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">work</span>(l+cnt1,r);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt1;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt2;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ii=node[i+l<span class="number">-1</span>],jj=node[j+cnt1+l<span class="number">-1</span>];</span><br><span class="line">ans[jj][ii]=ans[ii][jj]=<span class="built_in">min</span>(<span class="built_in">min</span>(ans[ii][s],ans[s][tt]),ans[tt][jj]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Case=<span class="number">0</span>;cin&gt;&gt;Case;</span><br><span class="line">    <span class="keyword">while</span> (Case--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">        idx=<span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j) ans[i][j]=INF;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        ll z;</span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lld&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            <span class="built_in">add</span>(x,y,z);<span class="built_in">add</span>(y,x,z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) node[i]=i;</span><br><span class="line">        <span class="built_in">work</span>(<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">int</span> que;cin&gt;&gt;que;</span><br><span class="line">        <span class="keyword">while</span> (que--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;z);</span><br><span class="line">            <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">                    <span class="keyword">if</span> (ans[i][j]&lt;=z) tot++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tot/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最小割树的模板题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流" scheme="https://mydcwfy.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>CF455B</title>
    <link href="https://mydcwfy.github.io/2021/12/26/CF455B/"/>
    <id>https://mydcwfy.github.io/2021/12/26/CF455B/</id>
    <published>2021-12-26T04:51:37.000Z</published>
    <updated>2021-12-26T04:52:11.738Z</updated>
    
    <content type="html"><![CDATA[<p>SG 函数的简单题目。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>两人交替在开始为空字符串的后面加入字符，要求必须随时为给定的字符串集的某一个串的前缀。将会进行 $k$ 次游戏，上一局输的人作为下一局的先手，最后一局胜利的人获得最终的胜利。在足够聪明的情况下，问第一局的先手是否会赢。</p><p>字符串的总个数 $\leq10^5$，字符串的总字符数 $\leq10^5$，$k\leq10^9$。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>首先，我们可以转化为一个在 Trie 上走，不能走者输的情况。</p><p>考虑 $k=1$ 的情况：这不就是一个 SG 函数的应用吗？</p><p>遍历一遍 Trie，叶节点为先手必败，如果一个节点的某个儿子是先手必败，那么该节点先手必胜，否则先手必败。</p><p>那么，我们可以简单的写出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_trie</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> has_son = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (son[u][i]) has_son = <span class="number">1</span>, <span class="built_in">get_trie</span>(son[u][i]);</span><br><span class="line"><span class="keyword">if</span> (!has_son)&#123;</span><br><span class="line">sg[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (son[u][i] &amp;&amp; !sg[son[u][i]])</span><br><span class="line">&#123;</span><br><span class="line">sg[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sg[u] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们考虑 $k=2$ 的情况。</p><p>如果先手 $k=1$ 是一定会胜而不可能输的（注意，这里指即使先手想输也不可能），那么，先手一定会在前一局的时候尽一切可能去输（感觉有点不合常理），这样他就会获得下一局的先手，而获得最后的胜利。</p><p>所以，我们在 $k&gt;1$ 的时候，不仅要考虑先手能否可以胜利，还要考虑先手能否失败。</p><p>怎样计算先手能否失败呢？我们将前面叶节点的时候设为必胜（是指一定可以输掉游戏，不是原来的游戏的必胜），那么如果最后根节点是必胜的话，那么他一定可以在走到叶节点为必胜状态，也就是可以输掉。</p><p>接着，我们发现先手有四种情况了：可胜可败，只能胜，只能败，不能胜也不能败（由后手控制力）。</p><ol><li><p>可胜可败：发现先手可以操控答案的走向，一定是可以赢的。</p></li><li><p>只能胜：最开始的先手和后手会交替先走，所以现在要看 $k$ 的奇偶，奇就是先手胜，偶就是后者胜。</p></li><li><p>只能败：先手每次都会败，也因为每次都败，每次都是先手，所以最后先手败。</p></li><li><p>不能胜也不能败：后手操控答案的走向，所以一定是输的。</p></li></ol><p>那么，我们就可以写出了最后的判断代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((able_win &amp;&amp; able_lose)) <span class="built_in">puts</span>(<span class="string">&quot;First&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (able_win) <span class="built_in">puts</span>(k &amp; <span class="number">1</span> ? <span class="string">&quot;First&quot;</span> : <span class="string">&quot;Second&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (able_lose) <span class="built_in">puts</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Second&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="3-Code"><a href="#3-Code" class="headerlink" title="3. Code"></a>3. Code</h2><p>前面基本已经展示了，这里给一个完整代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], rt = <span class="number">1</span>, tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> id[N], n, k, flag, sg[N], able_lose, able_win;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u = rt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; s[i]; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!son[u][s[i] - <span class="string">&#x27;a&#x27;</span>]) son[u][s[i] - <span class="string">&#x27;a&#x27;</span>] = ++ tot;</span><br><span class="line">u = son[u][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">id[i] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_trie</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> has_son = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (son[u][i]) has_son = <span class="number">1</span>, <span class="built_in">get_trie</span>(son[u][i]);</span><br><span class="line"><span class="keyword">if</span> (!has_son)&#123;</span><br><span class="line">sg[u] = flag;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (son[u][i] &amp;&amp; !sg[son[u][i]])</span><br><span class="line">&#123;</span><br><span class="line">sg[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sg[u] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">insert</span>(i, str);</span><br><span class="line">&#125;</span><br><span class="line">flag = <span class="number">1</span>, <span class="built_in">get_trie</span>(<span class="number">1</span>);<span class="comment">//flag 是指叶节点是胜还是败</span></span><br><span class="line">able_lose = sg[<span class="number">1</span>];</span><br><span class="line">flag = <span class="number">0</span>, <span class="built_in">get_trie</span>(<span class="number">1</span>);</span><br><span class="line">able_win = sg[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> ((able_win &amp;&amp; able_lose)) <span class="built_in">puts</span>(<span class="string">&quot;First&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (able_win) <span class="built_in">puts</span>(k &amp; <span class="number">1</span> ? <span class="string">&quot;First&quot;</span> : <span class="string">&quot;Second&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (able_lose) <span class="built_in">puts</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;SG 函数的简单题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="SG 函数" scheme="https://mydcwfy.github.io/tags/SG-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF919E</title>
    <link href="https://mydcwfy.github.io/2021/12/26/CF919E/"/>
    <id>https://mydcwfy.github.io/2021/12/26/CF919E/</id>
    <published>2021-12-26T04:49:27.000Z</published>
    <updated>2021-12-26T04:50:43.969Z</updated>
    
    <content type="html"><![CDATA[<p>模拟和逆元题目。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>求<br>$$<br>n\cdot a^n\equiv b\pmod p<br>$$<br>在 $[1,x]$ 的正整数解的个数，其中 $a,b,p,x$ 给定。</p><p>$p\leq10^6+3,x\leq10^{12},1\leq a,b&lt;p$。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>首先，看到 $p\leq10^6+3$，一定是要 $O(p)$ 枚举，然后再做。</p><h4 id="a）枚举-n"><a href="#a）枚举-n" class="headerlink" title="a）枚举 $n$"></a>a）枚举 $n$</h4><p>那么，原题转化为了 $t\cdot a^n\equiv b\pmod p$ 的解了。</p><p>很明显是一个 BSGS，时间复杂度为 $O(\sqrt p)$ 或 $O(\sqrt p\log \sqrt p)$，取决于 map 还是 Hash。</p><p>但是，总时间为 $O(p\sqrt p)$，很明显无法通过。</p><h4 id="b）枚举-a-n"><a href="#b）枚举-a-n" class="headerlink" title="b）枚举 $a^n$"></a>b）枚举 $a^n$</h4><p>首先，我们考虑 $a^n$ 的取值有多少种。</p><p>由于 $a^{p-1}\equiv 1\pmod p$，所以循环节一定是 $p-1$，那么我们就可以枚举 $n\bmod (p-1)$，得到所有的 $a^n$ 的取值。</p><p>那么，原题就是 $n\cdot t\equiv b\pmod p$ 的解。</p><p>咦，这不就是一个逆元了吗？</p><p>于是，我们可以 $O(\log p)$ 求出逆元（因为一定有），那么，我们就可以求出 $n\bmod p$ 的值。</p><h4 id="c）合并答案"><a href="#c）合并答案" class="headerlink" title="c）合并答案"></a>c）合并答案</h4><p>这道题在 CF 上有中国剩余定理的标签，大概就是这里用的吧。</p><p>我们已经得到了 $t1=n\bmod (p-1)$ 和 $t2=n\bmod p$ 的值，直接由中国剩余定理就可以了。</p><p>其实手玩也不是不可以，直接设 $n=kp+t2$，代入第一个就可以得到：<br>$$<br>\begin{aligned}<br>kp+t2&amp;\equiv t1 \pmod {p-1}\<br>k+t2&amp;\equiv t1\pmod {p-1}\<br>k&amp;\equiv t2-t1\pmod {p-1}<br>\end{aligned}<br>$$<br>就解出了 $n$ 的最小正整数取值了。</p><p>周期<del>很明显</del>是 $p\cdot(p-1)$，将答案加入即可。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><p>实际实现的时候可以预处理算出 $a$ 的逆元，每次枚举 ${a^t}$ 的逆元的时候可以通过 ${a^{t-1}}^{-1}$ 乘上 $a^{-1}$ 即可。</p><p>码风略丑，请见谅。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; Mod &gt;&gt; x;</span><br><span class="line">ll now = b, inv = <span class="built_in">qpow</span>(a, Mod - <span class="number">2</span>), lim = Mod * (Mod - <span class="number">1</span>), ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (ll modp1 = <span class="number">0</span>; modp1 &lt; Mod - <span class="number">1</span>; ++ modp1, now = now * inv % Mod)</span><br><span class="line">&#123;<span class="comment">//modp1 是枚举的 t，now 就是上面的 b 乘以（ a 的 t 次方的逆元），也就是 t1</span></span><br><span class="line">ll mx = (modp1 - now + (Mod - <span class="number">1</span>)) % (Mod - <span class="number">1</span>) * Mod + now;<span class="comment">//mx 是 n 的最小取值</span></span><br><span class="line">mx = (mx % lim + lim) % lim;<span class="comment">//lim 是 Mod * Mod - 1，是 n 的周期</span></span><br><span class="line"><span class="keyword">if</span> (mx &lt;= x) ans += (x - mx + lim) / lim;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;模拟和逆元题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>CF306C</title>
    <link href="https://mydcwfy.github.io/2021/12/26/CF306C/"/>
    <id>https://mydcwfy.github.io/2021/12/26/CF306C/</id>
    <published>2021-12-26T04:47:10.000Z</published>
    <updated>2021-12-26T04:47:37.220Z</updated>
    
    <content type="html"><![CDATA[<p>简单的组合数学。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给出 $n$ 天，以及<strong>互不相同</strong>的 $w$ 件好事、$b$ 件坏事，每天只能出现好事、坏事中的一种，要求发生的顺序为 好事 - 坏事 - 好事 的情况的方案数，答案对 $10^9+9$ 取模。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>首先，<strong>互不相同</strong>可以直接转化为<strong>相同</strong>，也就是我们可以现将答案算出来，然后乘上 $w!\cdot b!$ 即可。</p><p>我们再来想如果处理相同的。</p><p>我们发现，当好事的总天数一定的时候，前面有多少个、后面有多少个其实是不影响答案的，因为前面不管有多少个，其实都是一样的。</p><p>所以，我们可以统计 好事 - 坏事 的情况，然后对于每一个好事天数一定的，我们将一些好事的天放在坏事后面，就可以满足答案了。</p><p>答案将会乘上好事的天数减 1。</p><p>现在思路已经比较明显了：我们直接暴力枚举好事的天数 $x$，那么坏事的天数就是 $n-x$。</p><p>然后，我们发现，要将 $w$ 个好事放入 $x$ 天，每天至少一个，所以方案数就为 $\binom{w-1}{x-1}$。</p><p>坏事同理。</p><p>预处理组合数可以用 $O(n)$ 预处理阶乘及其逆元，不过没必要，直接 $O(n^2)$ 就可以了。</p><h2 id="3-Code"><a href="#3-Code" class="headerlink" title="3. Code"></a>3. Code</h2><p>注意要处理两倍的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; w &gt;&gt; b;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gday = <span class="number">1</span>; gday &lt; n; ++ gday)<span class="comment">//枚举好事的天数</span></span><br><span class="line">        ans = (ans + (gday - <span class="number">1ll</span>) * C[w - <span class="number">1</span>][gday - <span class="number">1</span>] % Mod * C[b - <span class="number">1</span>][n - gday - <span class="number">1</span>] % Mod) % Mod;</span><br><span class="line">    cout &lt;&lt; <span class="number">1ll</span> * ans * fact[w] % Mod * fact[b] % Mod &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单的组合数学。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="组合数学" scheme="https://mydcwfy.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>CF1335F</title>
    <link href="https://mydcwfy.github.io/2021/12/26/CF1335F/"/>
    <id>https://mydcwfy.github.io/2021/12/26/CF1335F/</id>
    <published>2021-12-26T04:43:02.000Z</published>
    <updated>2021-12-26T04:46:35.318Z</updated>
    
    <content type="html"><![CDATA[<p>基环树的简单题目。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><ul><li>给定一个 $n\times m$ 的黑白网格，每一个点都会有一个方向，如果放置的机器人走到这里的话，将会按照该方向走下去。现在要放置最多的机器人，使得机器人永远不会走到同一个点上（每一步中间相遇的不算）。在放置最多的基础上，要求最开始放在黑色上的机器人最多。</li><li>有 $t$ 组数据，$n\times m\leq10^6,\sum n\times m\leq10^6,t\leq5\times10^4$。</li></ul><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>其实如果想到图论的话，就比较简单了。</p><p>首先，我们考虑怎样才能 <strong>永远不相撞</strong>。</p><p>所有的机器人最后一定是在环上一直绕圈，又由于速度相同，所以永远不会相撞。</p><p>易得第一问答案不可能大于环上点的数量（因为如果有多的话，走到最后，一定会有两个机器人在同一个点，明显不符合条件）。</p><p>注意到每一个点有且只有一个出边，所以原图一共有 $n\times m$ 个点，同样也有 $n\times m$ 条边。</p><p>？这不就是基环树吗？</p><p>通过基环树的方法，我们可以简单的找出所有的环。不考虑第二问的话，我们直接将所有的机器人放在环上，这个就是一个最优解。</p><p>那么第一问就解决了，答案就是环的数量。</p><p>下面我们来看第二问：怎样让最多的机器人在黑色点上？</p><p>已经是黑色点的我们可以不管了，我们可以将一些白色的点替换为非环的黑点。</p><p>我们画一个图，来看一下需要满足什么样的条件才可以。</p><img src="/2021/12/26/CF1335F/CF1335F.png" class=""><p>当前，如果我们将一个机器人放在 b 点，经过两步之后，就会走到 c 点，如果最开始放在 a 点，也会走到 c 点。</p><p>所以其实 a 点和 b 点是等价的，换句话说，他们最后在环上的位置是等价的。</p><p>推广一下，对于任意一个点，假设他向上走走到环里需要的步数为 $x$，那么他就等价于环里距他最近的点往回走 $x$ 步得到的点。</p><p>转化为代码，就是：<code>cir[((dep - from) % sz + sz) % sz + 1]</code>，其中 $cir$ 存的是环的编号，从 1 开始，$sz$ 是指环的大小，$from$ 是指离他最近的点<strong>是环中的第几个。</strong></p><p>这几个都是可以在第二次遍历基环树的时候很简单的得到。具体可以看代码。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><p>注意由于有多组数据，不能使用 <code>memset</code> 之类的，而且读入的时候要直接转化为基环树上的编号。</p><p>码风略丑，请见谅。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> cir[N], tot, ed[N], cnt, fu[N];</span><br><span class="line"><span class="keyword">int</span> n, m, blk[N];</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">bool</span> ins[N], vis[N], onc[N], abl[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_c</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> from)</span><span class="comment">//找环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ins[x] = vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (i == (from ^ <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">fu[j] = x;</span><br><span class="line"><span class="keyword">if</span> (!vis[j]) <span class="built_in">dfs_c</span>(j, i);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ins[j])&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = x; k != j; k = fu[k]) cir[++ cnt] = k, onc[k] = <span class="literal">true</span>;</span><br><span class="line">cir[++ cnt] = j, onc[j] = <span class="literal">true</span>;</span><br><span class="line">ed[++ tot] = cnt;</span><br><span class="line"><span class="keyword">if</span> ((i &amp; <span class="number">1</span>)) <span class="built_in">reverse</span>(cir + ed[tot - <span class="number">1</span>] + <span class="number">1</span>, cir + ed[tot] + <span class="number">1</span>);</span><br><span class="line">&#125;<span class="comment">//注意此时如果 i &amp; 1 的话，找到的环和我们的环是相反的，我们要调换过来</span></span><br><span class="line">&#125;</span><br><span class="line">ins[x] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_d</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> cirst, <span class="keyword">int</span> dep, <span class="keyword">int</span> sz)</span><span class="comment">//cirst 表示环在 cir 数组里开始的位置，dep 是指当前的深度（我为了方便，加上了出发点的编号，方便直接计算，无需多余传参）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">abl[cirst + (dep % sz + sz) % sz] |= blk[x];</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[e[i]] || onc[e[i]]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs_d</span>(e[i], cirst, dep - <span class="number">1</span>, sz);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;<span class="keyword">return</span> (i - <span class="number">1</span>) * m + j;&#125;<span class="comment">//转换编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">idx = cnt = tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; ++ i) h[i] = <span class="number">-1</span>, blk[i] = onc[i] = abl[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) blk[<span class="built_in">get</span>(i, j)] = str[j] == <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (str[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span> : <span class="built_in">link</span>(<span class="built_in">get</span>(i, j), <span class="built_in">get</span>(i, j - <span class="number">1</span>));<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span> : <span class="built_in">link</span>(<span class="built_in">get</span>(i, j), <span class="built_in">get</span>(i, j + <span class="number">1</span>));<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span> : <span class="built_in">link</span>(<span class="built_in">get</span>(i, j), <span class="built_in">get</span>(i - <span class="number">1</span>, j));<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> : <span class="built_in">link</span>(<span class="built_in">get</span>(i, j), <span class="built_in">get</span>(i + <span class="number">1</span>, j));<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; ++ i) vis[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) <span class="built_in">dfs_c</span>(i, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; ++ i) vis[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = ed[i - <span class="number">1</span>] + <span class="number">1</span>; j &lt;= ed[i]; ++ j) <span class="built_in">dfs_d</span>(cir[j], ed[i - <span class="number">1</span>] + <span class="number">1</span>, j - ed[i - <span class="number">1</span>] - <span class="number">1</span>, ed[i] - ed[i - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> tblk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) tblk += abl[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, cnt, tblk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;基环树的简单题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="图论" scheme="https://mydcwfy.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="基环树" scheme="https://mydcwfy.github.io/tags/%E5%9F%BA%E7%8E%AF%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>CF1175B</title>
    <link href="https://mydcwfy.github.io/2021/12/26/CF1175B/"/>
    <id>https://mydcwfy.github.io/2021/12/26/CF1175B/</id>
    <published>2021-12-26T04:41:59.000Z</published>
    <updated>2021-12-26T04:45:30.646Z</updated>
    
    <content type="html"><![CDATA[<p>简单的模拟。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给定一串语句，并有变量 $x$，初始为 $0$，仅含有一下三种类型：</p><ol><li><code>for n</code>：表示循环 $n$ 次，直到与之匹配的 <code>end</code>。</li><li><code>end</code>：表示循环结束。</li><li><code>add</code>：将 $x$ 加一。</li></ol><p>执行完后，如果 $x\geq2^{32}$，输出 <code>OVERFLOW!!!</code>，否则输出 $x$ 的值。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>$x$ 的值就是 <code>add</code> 的执行次数。</p><p>我们可以在记录一个变量 $mul$，表示当前的语句将会被执行多少次。</p><p>所以碰到 <code>add</code> 的时候，将当前的 $x$ 加上 $mul$ 即可。</p><p>注意，这道题 $mul$ 最大会达到 $100^{5000}$，所以注意我们如果 $mul\geq 2^{32}$，就可以直接赋值为 $2^{32}$。</p><p>但是，这里又有一个问题：$mul=2^{32}$ 之后，碰上 <code>end</code>，我们将要 $mul$ 除以当前的循环次数，明显就错误了。</p><p>处理方法也很简单：用一个栈记录所有的 <code>for n</code>，然后使用前缀积 $pre$ 维护，于是退栈的时候，我们直接将当前的 $mul$ 赋值为 $pre[top-1]$ 即可。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = (<span class="number">1ll</span> &lt;&lt; <span class="number">32</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n, top;</span><br><span class="line">ll x, stk[N], tmp, pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;OVERFLOW!!!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;a&#x27;</span>) x += pre[top];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;tmp);</span><br><span class="line">            stk[++ top] = tmp;</span><br><span class="line">            pre[top] = pre[top - <span class="number">1</span>] * tmp;</span><br><span class="line">            <span class="keyword">if</span> (pre[top]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>) top --;</span><br><span class="line">        <span class="keyword">if</span> (pre[top] &gt; INF) pre[top] = INF + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; INF) <span class="built_in">overflow</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单的模拟。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>CF337C</title>
    <link href="https://mydcwfy.github.io/2021/12/26/CF337C/"/>
    <id>https://mydcwfy.github.io/2021/12/26/CF337C/</id>
    <published>2021-12-26T04:40:44.000Z</published>
    <updated>2021-12-26T04:41:12.714Z</updated>
    
    <content type="html"><![CDATA[<p>还是比较好想的，感觉难度应该在黄至绿之间。</p><span id="more"></span><p>话说这道题怎么没人做啊……</p><p>如果有没有考虑到的，请轻喷作者 qwq</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><ul><li>给出 $n$ 道题，答对了 $m$ 道题，按照规则安排 $m$ 道题的顺序，使得分数最小。输出对 $10^9+9$ 取模后的值。</li><li>从前向后扫描，答对一道分数加 $1$，计数器 $cnt$ 加一，如果 $cnt=k$，那么当前分数翻倍，$cnt$ 清零。如果答错 $cnt$ 清零。</li><li>$2\leq k\leq n\leq10^9,0\leq m\leq n$。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们首先考虑的肯定是尽量让 $m$ 道题目被翻倍的次数最少。</p><p>首先，一种情况是我们间隔开 $m$ 道题，使得每一道题都不会翻倍，那么答案就是 $m$。</p><p>具体就是 $k-1$ 道对，$1$ 道错，排列下去最后可以不需要 $1$ 道错误。</p><p>判断条件就是 $(n-m+1)\cdot(k-1)\geq m$。</p><p>第二种情况就是不得不要翻倍。</p><p>考虑第二个样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input:</span><br><span class="line">5 4 2</span><br><span class="line">output:</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>我们发现，不论怎么放错误的那个，一定都会有 $2$ 个会相连。（三个相连可以拆分为 $2+1$</p><p>那么，让相连的放在哪呢？</p><p>如果放在后面的话，一定会使答案变大，所以肯定放在最前面，让翻倍的尽量少。</p><p>所以，就可以构造成这样了：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ha2e8qfg.png"></p><p>注意到，前面会有 $n-(n-m)\cdot k$ 个连续的绿色。</p><p>按照这样计算即可.</p><p>假设前面有 $t$ 个连续的 $k$ 个绿色，前面的绿色的贡献就是 $k\cdot2^t+k\cdot2^{t-1}+…+k\cdot2$，注意最后未满 $k$ 个的由于没有特殊贡献，可以放到后面计算，为 $m-t\cdot k$。</p><p>前面的式子可以化简为 $k\cdot(2^{t+1}-2)$，快速幂即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"><span class="keyword">if</span> ((n - m + <span class="number">1</span>) * (k - <span class="number">1</span>) &gt;= m)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll t = (m - (n - m) * (k - <span class="number">1</span>)) / k;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (k * (<span class="built_in">qpow</span>(<span class="number">2</span>, t + <span class="number">1</span>) - <span class="number">2</span> + Mod) % Mod + m - k * t) % Mod);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;还是比较好想的，感觉难度应该在黄至绿之间。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>P5088</title>
    <link href="https://mydcwfy.github.io/2021/12/26/P5088/"/>
    <id>https://mydcwfy.github.io/2021/12/26/P5088/</id>
    <published>2021-12-26T04:38:15.000Z</published>
    <updated>2021-12-26T04:39:37.928Z</updated>
    
    <content type="html"><![CDATA[<p>杂题，没有什么说的。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p><a href="https://www.luogu.com.cn/problem/P5088">原题面</a></p><p>抽象一下题意：</p><p>求 $k1,k2$，使得：<br>$$<br>k1\times N:k2\times M=A:B<br>$$<br>（先使 $\gcd(A,B)=1$</p><p>然后，题目要求的就是 $k1+k2-2$ 的最小值。</p><p>对应到原题意是什么呢？</p><p>我们假设有无穷多个这样的 $N\times M$ 的矩形，然后我们不反射，直接穿过，直到碰到交界的点为止。</p><img src="/2021/12/26/P5088/P5088.png" class=""><p>蓝线是原来的反射路径，但是我们可以通过一系列的翻折，使得路径变为绿线。</p><p>变为绿线，其实已经简洁了许多。</p><p>我们假设横向的有 $k1$ 个 $N$，纵向的有 $k2$ 个 $M$，那么最后 $\zeta$ 的对边是 $k2\times M$，邻边是 $k1\times N$。</p><p>于是，我们可以得到：<br>$$<br>\cot\zeta=\dfrac{k1\times N}{k2\times M}=\dfrac{A}{B}<br>$$<br>也就是上面的式子了。</p><p>至于反射了多少次，其实就是穿过边界了多少次。</p><p><del>大眼观察法</del>易得 $ans=k1+k2-2$。</p><p>问题转化为怎样求 $k1,k2$。</p><p>首先，可以得到一个解：$k1=A\times M,k2=B\times N$。</p><p>然后，我们可以同时除以一个数 $x$。</p><p>那么需要满足：$x|A\times M,x|B\times N$。（不然的话，$k1,k2$ 无法整除 $x$，就不是整数了）。</p><p>综上，我们其实就可以总结出这道题的答案了：<br>$$<br>ans=\dfrac{A\times M+B\times N}{\gcd(A\times M,B\times N)}<br>$$</p><h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h2><p>数据水了一点，没有卡掉 <code>long long</code>。</p><p>唯一注意的是 $A=0$ 或 $B=0$ 的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">read</span>(n, m, a, b);</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">0</span> || b == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line">ll g = <span class="built_in">Gcd</span>(a, b);</span><br><span class="line">a /= g, b /= g;</span><br><span class="line">ll x = <span class="built_in">Gcd</span>(a * m, b * n);</span><br><span class="line"><span class="built_in">write</span>(a * m / x + b * n / x - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;杂题，没有什么说的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>P4539</title>
    <link href="https://mydcwfy.github.io/2021/12/26/P4539/"/>
    <id>https://mydcwfy.github.io/2021/12/26/P4539/</id>
    <published>2021-12-26T04:36:21.000Z</published>
    <updated>2021-12-26T04:37:02.133Z</updated>
    
    <content type="html"><![CDATA[<p>一个区间 DP 的较为简单的题目。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><ul><li>要求构造一个大小为 $n$ 的二叉树，按照中序遍历标号为 $1\sim n$，然后给定每个编号的频率 $f_i$，并且给定常数 $k,c$ 为实数，请最小化（设根节点深度为 1）：</li></ul><p>$$<br>\sum_{i=1}^nf_i\times(k\times dep_i+c)<br>$$</p><ul><li>$n\leq30,\sum f_i=1,0&lt;k,c\leq100$</li></ul><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>其实可能很多同学<del>（其实就是我）</del>都会想到 <code>Huffman Tree</code>，它是基于一个贪心的想法，但是我们可以比较一下两个的式子。<br>$$<br>\sum_{i=1}^nf_i\times dep_i<br>$$</p><p>$$<br>\sum_{i=1}f_i\times(k\times dep_i+c)<br>$$</p><p>这两个其实是有一定区别的。</p><p>本题中，不同节点是一定会出现祖先关系，并且只有 $n$ 个节点。但是 <code>Huffman Tree</code> 却要求给定的 $n$ 个节点不能出现祖先关系，构造出来后，也会超过 $n$ 个节点。</p><p>那本题怎么做呢？</p><p>首先，我们可以发现一个性质：假设当前子树覆盖的区间为 $[l,r]$，根节点为 $t$，那么左边的子树覆盖的区间为 $[l,t-1]$，右边的子树为 $[t+1,r]$。</p><p>这就是一个典型的区间 DP 了。</p><p>当我们要计算 $dp(l,r)$ 的时候，我们直接枚举根节点 $t$，然后递归计算 $dp(l,t-1)$ 和 $dp(t+1,r)$，然后我们将左右子树直接接在 $t$ 这个节点上。</p><p>怎么计算贡献呢？其实很简单，我们左右的子树的深度都要加一，对于整个的贡献就是 $k\times (s(r)-s(l-1)-f(t))$，其中 $s(i)=\sum_{j=1}^if(j)$。</p><p>再加上 $t$ 的贡献，那么，我们就可以得到式子：<br>$$<br>dp(l,r)=\min_{t\in[l,r]}{dp(l,t-1)+dp(t+1,r)+k\times(s(r)-s(l-1))+c\times f(t) }<br>$$</p><p>时间复杂度为 $O(n^3)$，轻松通过。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><p>采用的递归式写法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> (k + c) * fru[l];</span><br><span class="line"><span class="keyword">double</span> &amp;v = f[l][r];</span><br><span class="line"><span class="keyword">if</span> (v &gt;= <span class="number">0</span>) <span class="keyword">return</span> v;</span><br><span class="line">v = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = l; mid &lt;= r; ++ mid)</span><br><span class="line">v = <span class="built_in">min</span>(v, <span class="built_in">solve</span>(l, mid - <span class="number">1</span>) + k * (s[r] - s[l - <span class="number">1</span>]) + c * fru[mid] + <span class="built_in">solve</span>(mid + <span class="number">1</span>, r));</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个区间 DP 的较为简单的题目。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="区间 DP" scheme="https://mydcwfy.github.io/tags/%E5%8C%BA%E9%97%B4-DP/"/>
    
  </entry>
  
  <entry>
    <title>【CSP-S 2021 复习】DP 总结</title>
    <link href="https://mydcwfy.github.io/2021/12/26/csp-s-2021-review-dp-summary/"/>
    <id>https://mydcwfy.github.io/2021/12/26/csp-s-2021-review-dp-summary/</id>
    <published>2021-12-26T04:32:20.000Z</published>
    <updated>2021-12-26T04:35:17.571Z</updated>
    
    <content type="html"><![CDATA[<p>CSP-S 2021 前写的。</p><span id="more"></span><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>这个是为了复习前面的提高组的知识，所以可能不会复习提高组之外的知识。</p><p>没有具体的大纲，<del>大纲又没有写清楚</del>，所以只能看着办吧。</p><blockquote><p>【8】 动态规划的 <strong>常用优化</strong></p></blockquote><p>这个是 DP 专题。</p><h2 id="1-大概内容"><a href="#1-大概内容" class="headerlink" title="1. 大概内容"></a>1. 大概内容</h2><ol><li><a href="https://www.luogu.com.cn/blog/mydcwfy-342891/bei-bao-wen-ti">背包问题的基础以及变式</a></li><li>状态自动机模型</li><li><a href="https://mydcwfy.github.io/2021/12/13/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9-DP/">状态压缩 DP</a></li><li><a href="https://www.luogu.com.cn/blog/mydcwfy-342891/qu-jian-dp">区间 DP</a></li><li><a href="https://mydcwfy.github.io/2021/12/13/%E6%A0%91%E5%BD%A2-DP/">树形 DP</a></li><li><a href="https://mydcwfy.github.io/2021/12/13/%E6%95%B0%E4%BD%8D-DP/">数位 DP</a></li><li>单调队列优化 DP</li><li>数据结构优化 DP</li><li>倍增优化 DP</li></ol><h2 id="2-每一个的分类以及大体思路"><a href="#2-每一个的分类以及大体思路" class="headerlink" title="2. 每一个的分类以及大体思路"></a>2. 每一个的分类以及大体思路</h2><h3 id="1）背包问题"><a href="#1）背包问题" class="headerlink" title="1）背包问题"></a>1）背包问题</h3><p>这个其实是比较简单的。（</p><p>看一下这个题：<a href="https://www.luogu.com.cn/problem/P5662">CSP-J 2019 T3</a></p><p>这个题当时我在考场上想了很久， 1h 后才发现有想法。</p><p>一个完全背包的好题。</p><p>其他题我就不推荐了。</p><p>关于代码，其实没有什么好说的，大概就是需要我们发现背包模型的问题。</p><p>比如发现 $n$ 个物品，以及有一定的取用的限制而不能全部取得的时候，可以考虑使用背包。</p><h3 id="2）状态自动机模型"><a href="#2）状态自动机模型" class="headerlink" title="2）状态自动机模型"></a>2）状态自动机模型</h3><p>这个大家可能有一点陌生，其实就是 $f[i][j]$ 表示 $i$ 天并且状态为 $j$ 的某种值。</p><p>推荐这个题：<a href="https://www.acwing.com/problem/content/1059/">AcWIng 1057 股票买卖 IV</a></p><p>分别用 0 表示为已卖出，1 表示手头有股票。</p><p>就可以比较简单的转移了.</p><p>DP 问题其实比较简洁，所以代码没有什么可以多说的。</p><p>当遇到明显是 DP 的时候，但是如果没有状态的话很难转移，那么就可以考虑加上状态一维了。</p><h3 id="3）状态压缩-DP"><a href="#3）状态压缩-DP" class="headerlink" title="3）状态压缩 DP"></a>3）状态压缩 DP</h3><p>这类题目其实有一个比较明显的特征：个数一般不会超过 15 个。</p><p>有以下两题型：</p><ol><li>棋盘式（即存下每一行的状态，然后行之间直接转移）</li><li>集合式（用二进制压缩每一个元素是否在集合内，按照这个转移）</li></ol><p>棋盘式的推荐题：<a href="https://www.luogu.com.cn/problem/P2704">NOI2001</a></p><p>集合式的推荐题：<a href="https://www.luogu.com.cn/problem/P2831">NOIP2016</a></p><p>这两个都非常经典，相信大家都做过。</p><p>NOI2001 的题目要压缩两行，然后按照行的方式来转移。</p><p>同时，这一个题目需要进行一些优化，比如提前存下来一行内合法的状态。</p><p>空间上，需要使用滚动数组实现。</p><p>NOIP2016 的题目是一个重复覆盖问题，当然需要一点的计算几何。</p><p>这里介绍状态压缩的解法。</p><p>需要存下来猪被覆盖的集合，然后每一只小鸟分别转移。</p><p>DLX 的解法就不介绍了。</p><p>这类题首先注意范围，然后还要注意二进制运算的特殊性，可以优化代码难度及常数。</p><h3 id="4）区间-DP"><a href="#4）区间-DP" class="headerlink" title="4）区间 DP"></a>4）区间 DP</h3><p>区间 DP 的题目的数据范围一般还是比较小，但是比状态压缩大一些，一般在 30~100 之间，时间复杂度为 $O(n^3)\sim O(n^5)$，而且一般跑不满。</p><p>区间 DP 分为两种打法，分别是迭代法和递归法。</p><p>迭代法就是一堆 <code>for</code>，而递归法就是 <code>void dp(int x)&#123;...dp(i)...&#125;</code> 之类的。</p><p>这里大概有一维线性，一维环形，二维等几种情况。</p><p>这个就是注意边界问题，还有就是迭代式一定要第一维循环 <code>len</code>，第二维循环头结点，这样才能保证当前状态所用到的状态都是计算过的。</p><h3 id="5）树形-DP"><a href="#5）树形-DP" class="headerlink" title="5）树形 DP"></a>5）树形 DP</h3><p>这一类 DP 大多都是 $O(n)$ 的算法，可能有一些 $O(n\log n)$ 的东西（比如对子树得到的答案排序之类的）。</p><p>这类题目一般都比较麻烦，比如要进行数学推导，将求的东西转化为子树和父节点的信息可以分开维护，然后简单合并。</p><p>还有，这种题还需要换根技巧，就是将父亲的答案也合并进入儿子的答案，将儿子作为根。</p><p>题目不好找，就这样了吧。</p><p>大概有一个这个题：<a href="https://www.luogu.com.cn/problem/P5666">CSP-S2019 T6</a></p><p>（因为我还没做，所以后面在更新</p><h3 id="6）数位-DP"><a href="#6）数位-DP" class="headerlink" title="6）数位 DP"></a>6）数位 DP</h3><p>这种题目其实都有一定的套路，认真看了我的代码的同学应该都有印象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="comment">/*0 / 1*/</span>;</span><br><span class="line">    vector &lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">while</span> (n) nums.<span class="built_in">push_back</span>(n % <span class="number">10</span>), n /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; ~i; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> &amp;x = nums[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x; ++ j) <span class="comment">/*do with j*/</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这样一个套路，也没有多么难。</p><p>推荐一个题：<a href="https://loj.ac/p/10168">LOJ 10168 恨 7 不成妻</a></p><h3 id="7）各种优化"><a href="#7）各种优化" class="headerlink" title="7）各种优化"></a>7）各种优化</h3><p>核心思想就是 <strong>排除无用状态</strong>。</p><h4 id="a-单调队列"><a href="#a-单调队列" class="headerlink" title="a. 单调队列"></a>a. 单调队列</h4><p>这个就是一个简单的道理：如果 a 比 b 差，但是 a 会比 b 先弹出决策选择区（就是 a 可选的时候 b 都可以选），那么 a 就永远没有用。</p><p>比如说这个题：<a href="https://www.luogu.com.cn/problem/P5665">CSP-S2019 T5</a></p><p>这个题就是一个典型的单调队列优化 DP <del>（外带卡时空</del></p><p>这个的转移方程大概是这样：<br>$$<br>f_i=\max_{suf_j\leq s_i-s_j}(f_j+(s_i-s_j)^2)<br>$$</p><p>$$<br>suf_i=s_i-s_j<br>$$</p><p>其中，$suf_i$ 中用到的 $j$ 是 $f_i$ 转移用到的 $j$，表示最后一段的长度。</p><p>首先，很明显 $j$ 越靠后答案一定更优，因为最后一段越小，肯定限制就越小，分的段数就越多，答案就越小。</p><p>但是，转移的条件是 $suf_j+s_j\leq s_i$。</p><p>所以如果 $suf_j+s_j\geq suf_k+s_k$ 并且 $j&lt;k$，那么 $j$ 就没有用了。</p><p>代码大概就长这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt; tt &amp;&amp; a[q[hh + <span class="number">1</span>]] + suf[q[hh + <span class="number">1</span>]] &lt;= a[i])<span class="comment">//breakpoint</span></span><br><span class="line">        hh ++;</span><br><span class="line">    f[i] = f[q[hh]] + (B)(a[i] - a[q[hh]]) * (a[i] - a[q[hh]]);</span><br><span class="line">    suf[i] = a[i] - a[q[hh]];</span><br><span class="line">    <span class="keyword">while</span> (hh &lt; tt &amp;&amp; a[q[tt]] + suf[q[tt]] &gt; a[i] + suf[i]) tt --;</span><br><span class="line">    q[++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>breakpoint</code> 所代表的意思，就是要找到最后一个满足 $suf_j+s_j\leq s_i$ （往后越优）。</p><h4 id="b-数据结构优化"><a href="#b-数据结构优化" class="headerlink" title="b. 数据结构优化"></a>b. 数据结构优化</h4><p>这个最简单的应用就是这个：</p><blockquote><p>给出 $n$ 点的位置 $(x_i,y_i)$，每一个点只能向右上方（包含边界）连有向边，求最长的路径。</p></blockquote><p>这个首先离散化，不是重点，跳过了。</p><p>然后按照 $x$ 的位置倒序枚举，然后对于一个点 $(x_i,y_i)$，前面枚举到的点都 $x_j\geq x_i$，所以我们要在枚举过的点中找到 $y_j\leq y_i$ 中 $f_j$ 的最大值。</p><p>这个可以使用线段树维护，以 $y$ 坐标作为 <code>build(1, 1, n)</code> 的，维护 $f_i$ 的最大值，询问时直接 <code>query(1, y[j], n)</code> 就可以了。</p><h4 id="c-倍增优化"><a href="#c-倍增优化" class="headerlink" title="c. 倍增优化"></a>c. 倍增优化</h4><p>这个是一个经典的问题：<a href="https://www.luogu.com.cn/problem/P1081">NOIP2012 提高组</a></p><p>（虽然经典，可我还是没有过</p><p>所以略过了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;CSP-S 2021 前写的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="总结" scheme="https://mydcwfy.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>费用流</title>
    <link href="https://mydcwfy.github.io/2021/12/26/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    <id>https://mydcwfy.github.io/2021/12/26/%E8%B4%B9%E7%94%A8%E6%B5%81/</id>
    <published>2021-12-26T04:19:56.000Z</published>
    <updated>2021-12-26T04:22:10.293Z</updated>
    
    <content type="html"><![CDATA[<p>比较重要并且难想，需要多加练习。</p><span id="more"></span><h2 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>费用流是指所有最大可行流中，费用最小（最大）值。</p><p>前提是最大可行流。</p><p>给每条边幅赋一个费用，则总费用为：</p><p>$$w(f)= \sum f(u,v)\times p(u,v)$$</p><p>如果有最大可行流的话，一定有最小费用最大流。</p><p>因为可行流满足两个条件：</p><ol><li><p>满足容量限制；</p></li><li><p>满足容量守恒。</p></li></ol><p>但是有一些最小费用无法求出来。</p><p>如图，该费用流无法用后面的方法求出来。</p><img src="/2021/12/26/%E8%B4%B9%E7%94%A8%E6%B5%81/%E8%B4%B9%E7%94%A8%E6%B5%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%8D%E4%BE%8B.png" class="" title="如图"><h3 id="2-求法"><a href="#2-求法" class="headerlink" title="2.求法"></a>2.求法</h3><p>Edmonds-Karp 算法为基础。</p><p>将 bfs 换为 spfa，这样每一次都是最短路（即最小代价）。</p><h4 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h4><p>假设当前的 f1 是最小费用，经过一次 spfa 后，得到 f2，新的为 f</p><p>假设 f 不是最小费用，设 f’ 是最小费用，经过 f2‘ 得到。</p><p>那么 $|f’|=|f|$。</p><p>因为都由 f1 扩展而来，可得 $|f2’|=|f2|$</p><p>又$w(f)=|f|*s(f)$，可得 $s(f2’)&lt;s(f2)$，与最短路矛盾。</p><p>所以原命题成立。</p><p>如果原图有负权回路，那么 spfa 会陷入死循环。</p><p>要用到”消圈”的方法，这里不过多赘述。</p><p><a href="https://blog.sengxian.com/algorithms/clearcircle">消圈</a></p><p>建图时，将费用改为$p(u,v)=-p(v,u)$。</p><p>一般情况下，只要原图不存在负环，那么残留网络也不会。</p><p>（因为流量不会绕圈，所以反向边也不会成环）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,ll c,ll d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=d,f[idx]=c,h[a]=idx++;</span><br><span class="line">e[idx]=a,ne[idx]=h[b],w[idx]=-d,f[idx]=<span class="number">0</span>,h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) vis[i]=<span class="number">0</span>,d[i]=INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">q.<span class="built_in">push</span>(S);d[S]=<span class="number">0</span>;flow[S]=INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (f[i]&amp;&amp;(d[e[i]]&gt;d[x]+w[i]))</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+w[i];</span><br><span class="line">pre[e[i]]=i;</span><br><span class="line">flow[e[i]]=<span class="built_in">min</span>(flow[x],f[i]);</span><br><span class="line"><span class="keyword">if</span> (!vis[e[i]]) q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">vis[e[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[T]!=INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">spfa</span>())</span><br><span class="line">&#123;</span><br><span class="line">ll flowd=flow[T];</span><br><span class="line">maxflow+=flowd;mincost+=flowd*d[T];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">f[pre[i]]-=flowd;</span><br><span class="line">f[pre[i]^<span class="number">1</span>]+=flowd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-做题方式"><a href="#3-做题方式" class="headerlink" title="3.做题方式"></a>3.做题方式</h3><p>与最大流相似，都是先将原问题转化为一个网络流，然后证明解是一一对应的，最后证明原答案与新图的答案是相关的。</p><h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4.例题"></a>4.例题</h3><h4 id="T1"><a href="#T1" class="headerlink" title="T1:"></a>T1:</h4><p><a href="https://www.luogu.com.cn/problem/P4015">Luogu P4015 运输问题</a></p><p>先建立一个流网络，从源点到仓库建立 $a(i),0$ 的边，从零售店到汇点建立 $b(i),0$  的边，从仓库到零售店建立 $+\infty,c(i,j)$ 的边。</p><p>易得，最大流一定是满流（因为中间都是 $+\infty$）。</p><p>证明略，比较容易。</p><p>又因为，只有从仓库到零售店的流才会花费，所以最小费用就是原问题的费用。</p><p>注意最小最大费用流都要求。</p><p>我用传参的方式防止了代码过长。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,M=<span class="number">4e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],f[M],idx;</span><br><span class="line"><span class="keyword">int</span> pre[N],d[N],flow[N],c,maxflow;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=d,f[idx]=c,h[a]=idx++;</span><br><span class="line">e[idx]=a,ne[idx]=h[b],w[idx]=-d,f[idx]=<span class="number">0</span>,h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (op) <span class="keyword">return</span> a&lt;b;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+m+<span class="number">1</span>;++i) vis[i]=<span class="number">0</span>,d[i]=(op==<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>)*INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">q.<span class="built_in">push</span>(S);d[S]=<span class="number">0</span>;flow[S]=INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x]=<span class="number">0</span>;<span class="comment">//cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (f[i]&amp;&amp;<span class="built_in">cmp</span>(d[e[i]],d[x]+w[i],op))</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+w[i];</span><br><span class="line">pre[e[i]]=i;</span><br><span class="line">flow[e[i]]=<span class="built_in">min</span>(flow[x],f[i]);</span><br><span class="line"><span class="keyword">if</span> (!vis[e[i]]) q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">vis[e[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[T]!=(op==<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>)*INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initing</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i+=<span class="number">2</span>) f[i]+=f[i^<span class="number">1</span>],f[i^<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">(<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">c=maxflow=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">initing</span>();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">spfa</span>(op))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> flowd=flow[T];</span><br><span class="line">maxflow+=flowd;c+=flowd*d[T];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">f[pre[i]]-=flowd;</span><br><span class="line">f[pre[i]^<span class="number">1</span>]+=flowd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">int</span> x;S=<span class="number">0</span>,T=m+n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="built_in">add</span>(S,i,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="built_in">add</span>(i+n,T,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="built_in">add</span>(i,j+n,INF,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EK</span>(<span class="number">0</span>);cout&lt;&lt;c&lt;&lt;endl;</span><br><span class="line"><span class="built_in">EK</span>(<span class="number">1</span>);cout&lt;&lt;c&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2"><a href="#T2" class="headerlink" title="T2:"></a>T2:</h4><p><a href="https://www.luogu.com.cn/problem/P4016">Luogu P4016 负载平衡问题</a></p><p>可以发现，如果一个站比平均值多，他就要输出，否则就要输入。</p><p>可以将货物看为流量，将站分为2个部分，但是不是所有边都是连接两部的，也有一部之间的。</p><p>最小费用最大流即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>,M=<span class="number">1e4</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],f[M],idx;</span><br><span class="line"><span class="keyword">int</span> pre[N],d[N],flow[N];</span><br><span class="line"><span class="keyword">int</span> n,S,T,maxflow,mincost,a[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=d,f[idx]=c,h[a]=idx++;</span><br><span class="line">e[idx]=a,ne[idx]=h[b],w[idx]=-d,f[idx]=<span class="number">0</span>,h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i) vis[i]=<span class="number">0</span>,d[i]=INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">q.<span class="built_in">push</span>(S);d[S]=<span class="number">0</span>;flow[S]=INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (f[i]&amp;&amp;(d[e[i]]&gt;d[x]+w[i]))</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+w[i];</span><br><span class="line">pre[e[i]]=i;</span><br><span class="line">flow[e[i]]=<span class="built_in">min</span>(flow[x],f[i]);</span><br><span class="line"><span class="keyword">if</span> (!vis[e[i]]) q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">vis[e[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[T]!=INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">spfa</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> flowd=flow[T];</span><br><span class="line">maxflow+=flowd;mincost+=flowd*d[T];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">f[pre[i]]-=flowd;</span><br><span class="line">f[pre[i]^<span class="number">1</span>]+=flowd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;S=<span class="number">0</span>,T=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) sum+=a[i];</span><br><span class="line">sum/=n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">if</span> (sum&gt;a[i]) <span class="built_in">add</span>(i,T,sum-a[i],<span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">add</span>(S,i,a[i]-sum,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">add</span>(i,i+<span class="number">1</span>,INF,<span class="number">1</span>);<span class="built_in">add</span>(i+<span class="number">1</span>,i,INF,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>,n,INF,<span class="number">1</span>);<span class="built_in">add</span>(n,<span class="number">1</span>,INF,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">EK</span>();cout&lt;&lt;mincost&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3"><a href="#T3" class="headerlink" title="T3:"></a>T3:</h4><p><a href="https://www.luogu.com.cn/problem/P4014">Luogu P4014 分配问题</a></p><p>和第一题类似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>,M=<span class="number">4e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],f[M],idx;</span><br><span class="line"><span class="keyword">int</span> pre[N],d[N],flow[N],c,maxflow,S,T;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=d,f[idx]=c,h[a]=idx++;</span><br><span class="line">e[idx]=a,ne[idx]=h[b],w[idx]=-d,f[idx]=<span class="number">0</span>,h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (op) <span class="keyword">return</span> a&lt;b;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+n+<span class="number">1</span>;++i) vis[i]=<span class="number">0</span>,d[i]=(op==<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>)*INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">q.<span class="built_in">push</span>(S);d[S]=<span class="number">0</span>;flow[S]=INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x]=<span class="number">0</span>;<span class="comment">//cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (f[i]&amp;&amp;<span class="built_in">cmp</span>(d[e[i]],d[x]+w[i],op))</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+w[i];</span><br><span class="line">pre[e[i]]=i;</span><br><span class="line">flow[e[i]]=<span class="built_in">min</span>(flow[x],f[i]);</span><br><span class="line"><span class="keyword">if</span> (!vis[e[i]]) q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">vis[e[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[T]!=(op==<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>)*INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initing</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i+=<span class="number">2</span>) f[i]+=f[i^<span class="number">1</span>],f[i^<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">(<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">initing</span>();</span><br><span class="line">c=maxflow=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">initing</span>();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">spfa</span>(op))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> flowd=flow[T];</span><br><span class="line">maxflow+=flowd;c+=flowd*d[T];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">f[pre[i]]-=flowd;</span><br><span class="line">f[pre[i]^<span class="number">1</span>]+=flowd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> x;S=<span class="number">0</span>,T=<span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="built_in">add</span>(i,n+j,<span class="number">1</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">add</span>(S,i,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j) <span class="built_in">add</span>(j+n,T,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">EK</span>(<span class="number">0</span>);cout&lt;&lt;c&lt;&lt;endl;</span><br><span class="line"><span class="built_in">EK</span>(<span class="number">1</span>);cout&lt;&lt;c&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T4"><a href="#T4" class="headerlink" title="T4:"></a>T4:</h4><p><a href="https://www.luogu.com.cn/problem/P4013">P4013 数字梯形问题</a></p><p>只是要拆点。</p><p>同样的建图，只不过这道题比较麻烦，需要处理3个问。</p><p>主要讲一下 3 个问题的衔接。</p><p>第一个转到第二个时，我们将所有点内的边都设为 $+\infty$</p><p>第二个转到第三个时，我们将所有点间的点再都设为 $+\infty$</p><p>但是由于每个出发点只能有一次出发，所以不能更新。</p><p>看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(i,j) (m+m+i-2)*(i-1)/2+j</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>,M=<span class="number">5e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],f[M],idx;</span><br><span class="line"><span class="keyword">int</span> pre[N],d[N],flow[N];</span><br><span class="line"><span class="keyword">int</span> n,m,S,T,maxflow,maxcost,a[N][N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=d,f[idx]=c,h[a]=idx++;</span><br><span class="line">e[idx]=a,ne[idx]=h[b],w[idx]=-d,f[idx]=<span class="number">0</span>,h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i) vis[i]=<span class="number">0</span>,d[i]=-INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">q.<span class="built_in">push</span>(S);d[S]=<span class="number">0</span>;flow[S]=INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (f[i]&amp;&amp;(d[e[i]]&lt;d[x]+w[i]))</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+w[i];</span><br><span class="line">pre[e[i]]=i;</span><br><span class="line">flow[e[i]]=<span class="built_in">min</span>(flow[x],f[i]);</span><br><span class="line"><span class="keyword">if</span> (!vis[e[i]]) q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">vis[e[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[T]!=-INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">maxflow=maxcost=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">spfa</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> flowd=flow[T];</span><br><span class="line">maxflow+=flowd;maxcost+=flowd*d[T];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">f[pre[i]]-=flowd;</span><br><span class="line">f[pre[i]^<span class="number">1</span>]+=flowd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;m&gt;&gt;n;<span class="keyword">int</span> tot=(m+n<span class="number">-1</span>+m)*n/<span class="number">2</span>,idx1,idx2,idx0;</span><br><span class="line">S=<span class="number">0</span>,T=<span class="number">2</span>*tot+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) <span class="built_in">add</span>(S,<span class="built_in">get</span>(<span class="number">1</span>,j),<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">idx0=idx;<span class="comment">//开始的边 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m+n<span class="number">-1</span>;++j) <span class="built_in">add</span>(<span class="built_in">get</span>(n,j)+tot,T,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m+i;++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m+i;++j) <span class="built_in">add</span>(<span class="built_in">get</span>(i,j),<span class="built_in">get</span>(i,j)+tot,<span class="number">1</span>,a[i][j]);</span><br><span class="line">idx1=idx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m+i;++j)</span><br><span class="line"><span class="built_in">add</span>(<span class="built_in">get</span>(i,j)+tot,<span class="built_in">get</span>(i+<span class="number">1</span>,j),<span class="number">1</span>,<span class="number">0</span>),<span class="built_in">add</span>(<span class="built_in">get</span>(i,j)+tot,<span class="built_in">get</span>(i+<span class="number">1</span>,j+<span class="number">1</span>),<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">idx2=idx;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EK</span>();cout&lt;&lt;maxcost&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i+=<span class="number">2</span>) f[i]+=f[i^<span class="number">1</span>],f[i^<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//初始化 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=idx0;i&lt;idx1;i+=<span class="number">2</span>) f[i]=INF;<span class="comment">//点内的边设为INF </span></span><br><span class="line"><span class="built_in">EK</span>();cout&lt;&lt;maxcost&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i+=<span class="number">2</span>) f[i]+=f[i^<span class="number">1</span>],f[i^<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=idx1;i&lt;idx2;i+=<span class="number">2</span>) f[i]=INF;<span class="comment">//点间的边设为INF </span></span><br><span class="line"><span class="built_in">EK</span>();cout&lt;&lt;maxcost&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T5-餐巾计划问题"><a href="#T5-餐巾计划问题" class="headerlink" title="T5:餐巾计划问题"></a>T5:餐巾计划问题</h4><p><a href="https://www.luogu.com.cn/problem/P1251">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2186/">题目传送门 AcWing</a></p><p>对于每一天，干净毛巾的毛巾只可能来自 3 种情况：</p><ol><li><p>新买的</p></li><li><p>快洗部</p></li><li><p>慢洗部</p></li></ol><p>脏的毛巾也只可能来自3种情况：</p><ol><li><p>留到下一天</p></li><li><p>送到慢洗部</p></li><li><p>送到快洗部</p></li></ol><p>我们可以将每天用完的旧毛巾看做点，将每天要用的新毛巾看做另外的点</p><p>新毛巾就可以从 $s$ 到该点，费用为 $p$</p><p>每天都要从该点流 $r(i)$ 到汇点，相当于用了 $r(i)$</p><p>快洗与慢洗就相应连到相应相应早上的点。</p><p>从 $s$ 到晚上的点流量为 $r(i)$，相当于得到 $r(i)$ 条旧毛巾。</p><p>从早上的点到汇点一定是满流，否则就会使货不应求。</p><p>但源点开始的点可以不用满流（可以浪费）。</p><p>并且，前一天的脏毛巾可以留到下一天。</p><p>综上，建图如下（设早上点为$a(i)$，晚上点为 $b(i)$）：</p><ol><li><p>$add(s,b(i),r(i),0)$</p></li><li><p>$add(a(i),t,r(i),0)$</p></li><li><p>$add(b(i),b(i+1),+\infty,0)$</p></li><li><p>$add(s,a(i),+\infty,p)$</p></li><li><p>$add(b(i),a(i+n),+\infty,s)$</p></li><li><p>$add(b(i),a(i+m),+\infty,f)$</p></li></ol><p>注意，$s$ 与 $t$ 只是形式上的源汇点，没有什么实际意义，它象征着整个网络流的正常运作，而与本问题无关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>,INF=<span class="number">0x7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],f[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> pre[N],n,S,T,flow[N],d[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">ll mincost;</span><br><span class="line"></span><br><span class="line">queue &lt;<span class="keyword">int</span>&gt; q; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],f[idx]=c,w[idx]=d,h[a]=idx++;</span><br><span class="line">e[idx]=a,ne[idx]=h[b],f[idx]=<span class="number">0</span>,w[idx]=-d,h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>*n+<span class="number">1</span>;++i) d[i]=INF,vis[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">q.<span class="built_in">push</span>(S);d[S]=<span class="number">0</span>;flow[S]=INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (f[i]&amp;&amp;d[e[i]]&gt;d[x]+w[i])</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+w[i];</span><br><span class="line">pre[e[i]]=i;flow[e[i]]=<span class="built_in">min</span>(flow[x],f[i]);</span><br><span class="line"><span class="keyword">if</span> (!vis[e[i]]) q.<span class="built_in">push</span>(e[i]),vis[e[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[T]!=INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">spfa</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ff=flow[T];</span><br><span class="line">mincost+=(ll)ff*d[T];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">f[pre[i]]-=ff;</span><br><span class="line">f[pre[i]^<span class="number">1</span>]+=ff;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,e;</span><br><span class="line">S=<span class="number">0</span>,T=<span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"><span class="built_in">add</span>(i,T,a,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">add</span>(S,i+n,a,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">add</span>(S,i,INF,a);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i+<span class="number">1</span>&lt;=n) <span class="built_in">add</span>(i+n,i+n+<span class="number">1</span>,INF,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (i+b&lt;=n) <span class="built_in">add</span>(i+n,i+b,INF,c);</span><br><span class="line"><span class="keyword">if</span> (i+d&lt;=n) <span class="built_in">add</span>(i+n,i+d,INF,e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EK</span>();</span><br><span class="line">cout&lt;&lt;mincost&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;比较重要并且难想，需要多加练习。&lt;/p&gt;</summary>
    
    
    
    
    <category term="图论" scheme="https://mydcwfy.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="网络流" scheme="https://mydcwfy.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>差分约束</title>
    <link href="https://mydcwfy.github.io/2021/12/26/Difference-constraint/"/>
    <id>https://mydcwfy.github.io/2021/12/26/Difference-constraint/</id>
    <published>2021-12-26T04:17:14.000Z</published>
    <updated>2021-12-26T04:18:15.372Z</updated>
    
    <content type="html"><![CDATA[<p>比较重要的知识点。</p><span id="more"></span><p><strong>应用1：求不等式的可行解</strong></p><p><strong>应用2：求最大值或最小值</strong></p><h3 id="1-定义与应用场景"><a href="#1-定义与应用场景" class="headerlink" title="1. 定义与应用场景"></a>1. 定义与应用场景</h3><p>形如<br>$$<br>x(i)\leq x(j) +c(i,j)<br>$$<br>的形式的不等式组，即可用差分约束。</p><p>这类题目大概要求我们要 <strong>数形结合</strong>，可能是最好的解释了。</p><hr><h3 id="2-应用-1"><a href="#2-应用-1" class="headerlink" title="2. 应用 1"></a>2. 应用 1</h3><h3 id="建图方式"><a href="#建图方式" class="headerlink" title="建图方式"></a>建图方式</h3><p>由于最短路一定是最短路<del>（废话</del>，那么每一条边的转移一定是有效的，如果出现了 $dis(i)&gt;dis(j)+w(j,i)$，那么 $dis(i)$ 就不是最短路了。</p><p>所以我们可以得到最短路的三角形不等式：$dis(i)\le dis(j)+w(j,i)$</p><p>对于$x(i)\leq x(j) +c(j,i)$，我们可以从 $j$ 到 $i$ 连一条 $c(j,i)$ 的边。</p><p>但是这里没有源点，我们可以随意找一个点。</p><p><del>真的可以吗</del></p><p>其实是不完全可以的。</p><p>如果从源点到不了所有的边，那么这个点不可行。</p><p>注意，不是遍历到所有的点，因为可能有孤立的点，与主体无关。</p><p>好像一般是不会出现不联通的边吧……</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>先将每一个不等式 $x(i)\leq x(j) +c(j,i)$ 转换成从 $j$ 到 $i$ 连一条 $c(j,i)$ 的边。</p></li><li><p>找一个源点，使它能到每一条边。</p></li><li><p>从这个点找单源最短路。</p></li></ol><p> 有一个问题：有负环是什么情况？</p><p>易得，从一个环到自己且是负的话，就是 $x_i\leq x_j+c(j,i)\leq x_k+c(k,j)+c(j,i)\leq…\leq x_i+c(j,i)+c(k,j)+… $</p><p>又 $c(j,i)+c(k,j)+…&lt;0$，所以就是 $x_i\leq x_i+k$，其中 $k&lt;0$，显然是不可能的。 </p><p>同样，如果原不等式组无解，那么图有负环。（否则一定能构造出一组解）</p><p>如果有解，这一组解就是 $x(i)=dis(i)$。当然，可以加同样的值，原不等式依然成立。</p><p>另外，我们也可用最长路。</p><p>改为 $x(j)\geq x(i)-c(i,j)$ 的方式，并将从 $i$ 到 $j$ 连一条 $-c(i,j)$ 的边。</p><p>我们就反过来了，如果有正环，那么无解了。</p><hr><h3 id="3-应用2"><a href="#3-应用2" class="headerlink" title="3.应用2"></a>3.应用2</h3><p><strong>结论：如果是最小值，那么求最长路；如果是最大值，那么求最短路。</strong></p><p>首先，通过前面的转化，我们发现，对于同一个题，我们既可以构造最长路，也可以构造最短路。</p><p>虽然有些反直觉，为什么是正确的呢？</p><p>假设我们讨论最长路。</p><p>因为最长路，有一个式子 $x(i)\geq x(j)+w(j,i)$，那么一定会有一个 $j$，满足 $x(i)=x(j)+w(j,i)$（否则 $x(i)$ 从何处来？），那么就不会存在小于 $x(i)$ 的解，因为 $x(i)\geq x(j)+w(i,j)$，所以 $x(i)$ 就是所有解答最小值。</p><p>问题1：如何转化 $x(i)\leq c(i)$？</p><p>建立一个超级源点 $x(0)$，从 $0$ 到 $i$ 的建立$c(i)$ 的边。</p><p>以 $x(i)$ 的最大值为例，从 $x(i)$ 出发的不等式链，可以转化为一个只含变量 $x(0)$ 的值。</p><p>所有上界的最小值，即为 $x(i)$ 的最大值。</p><p>我们又可以发现一个有趣的性质：</p><p><strong>每一个不等式链，都是 $0$ 到 $i$ 的一条路径。</strong></p><p>然后，这些上界的最小值，其实就是最短路！</p><p>反过来，求最小值的话，应该求最长路。</p><p>这个就不再赘述。</p><hr><h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4.例题"></a>4.例题</h3><h4 id="T1"><a href="#T1" class="headerlink" title="T1:"></a>T1:</h4><p><a href="https://www.luogu.com.cn/problem/P3275">Luogu P3275 [SCOI2011]糖果</a></p><ol><li><p>$A=B \Leftrightarrow A\geq B,B\geq A$</p></li><li><p>$A&lt;B \Leftrightarrow B\geq A+1$</p></li><li><p>$A\leq B \Leftrightarrow B\geq A$</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>,M=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> d[N],h[N],e[M],ne[M],w[M],cnt[N],n,m,S,idx;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0xcf</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">stack &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(S);d[S]=<span class="number">0</span>;cnt[S]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (d[e[i]]&lt;d[x]+w[i])</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+w[i];</span><br><span class="line">cnt[e[i]]=cnt[x]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (cnt[e[i]]&gt;n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!vis[e[i]]) vis[e[i]]=<span class="number">1</span>,q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">int</span> a,b,op;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span>(op)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:<span class="built_in">add</span>(b,a,<span class="number">0</span>),<span class="built_in">add</span>(a,b,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:<span class="built_in">add</span>(a,b,<span class="number">1</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:<span class="built_in">add</span>(b,a,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:<span class="built_in">add</span>(b,a,<span class="number">1</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:<span class="built_in">add</span>(a,b,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">S=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">SPFA</span>()) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans+=(<span class="keyword">long</span> <span class="keyword">long</span>)d[i];</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2"><a href="#T2" class="headerlink" title="T2:"></a>T2:</h4><p><a href="https://www.acwing.com/problem/content/364/">AcWing 362.区间</a></p><p><strong>差分约束最难的地方就在于找不等关系。</strong></p><p>利用前缀和的思想：</p><ol><li><p>$S(0)=0$</p></li><li><p>$S(i)$ 表示$1$ 到 $i$ 中，选出数的个数。</p></li><li><p>$0\leq S(i)-S(i-1) \leq 1 \Leftrightarrow S(i)\geq S(i-1),S(i-1)\geq S(i)-1$ </p></li><li><p>$S(b)-S(a-1)\geq c$ </p></li></ol><p>可以发现，$0$ 可以遍历到所有点，也可以遍历到所有边。</p><p>那么这样就可以完成对每个点的遍历了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50010</span>,M=<span class="number">150050</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx,w[M];</span><br><span class="line"><span class="keyword">int</span> n,d[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0xcf</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">stack &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">0</span>);d[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (d[e[i]]&lt;d[x]+w[i])</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+w[i];</span><br><span class="line"><span class="keyword">if</span> (!vis[e[i]]) vis[e[i]]=<span class="number">1</span>,q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">int</span> a,b,c,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">a++;b++;ans=<span class="built_in">max</span>(ans,b);</span><br><span class="line"><span class="built_in">add</span>(a<span class="number">-1</span>,b,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;++i) <span class="built_in">add</span>(i<span class="number">-1</span>,i,<span class="number">0</span>),<span class="built_in">add</span>(i,i<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">SPFA</span>();</span><br><span class="line">cout&lt;&lt;d[ans]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3"><a href="#T3" class="headerlink" title="T3:"></a>T3:</h4><p><a href="https://www.acwing.com/problem/content/395/">AcWing 393. 雇佣收银员</a></p><p>特别拿出来讲的目的是其 实现较难。</p><ol><li>$0\leq x(i) \leq num(i)$</li><li>$x(i-7)+x(i-6)+…+x(i-1)+x(i)\geq r(i)$</li></ol><p>不满足形式，用前缀和优化：</p><ol><li><p>$0 \leq s(i)-s(i-1)\leq num(i)$</p></li><li><p>$i\geq 8 \Leftrightarrow s(i)-s(i-8)\geq r(i)$ </p></li><li><p>$0\leq i \leq 7\Leftrightarrow s(i)+s(24)-s(i+16)\geq r(i)$</p></li></ol><p>最后一项有 $3$ 个变量，所以要消元（<del>回到了数学课</del>）。</p><p>消哪个呢？</p><p>看到 $s(24)$ 比较好欺负，又看到时间是允许我们枚举的。</p><p>那么枚举 $s(24)$ 的取值，然后分别跑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">3e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N],cnt[N],num[<span class="number">26</span>],r[<span class="number">26</span>],n,st[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> s24)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);idx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">24</span>;++i) <span class="built_in">add</span>(i<span class="number">-1</span>,i,<span class="number">0</span>),<span class="built_in">add</span>(i,i<span class="number">-1</span>,-num[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;++i) <span class="built_in">add</span>(i+<span class="number">16</span>,i,-s24+r[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">8</span>;i&lt;=<span class="number">24</span>;++i) <span class="built_in">add</span>(i<span class="number">-8</span>,i,r[i]);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">0</span>,<span class="number">24</span>,s24);<span class="built_in">add</span>(<span class="number">24</span>,<span class="number">0</span>,-s24);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s24)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">build</span>(s24);</span><br><span class="line"><span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0xcf</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i) vis[i]=<span class="number">0</span>;</span><br><span class="line">d[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">queue &lt;<span class="keyword">int</span>&gt; q;q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (d[e[i]]&lt;d[x]+w[i])</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+w[i];</span><br><span class="line">cnt[e[i]]=cnt[x]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (cnt[e[i]]&gt;=<span class="number">25</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!vis[e[i]]) vis[e[i]]=<span class="number">1</span>,q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">24</span>;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,r+i);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,st+i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) num[st[i]+<span class="number">1</span>]++;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">SPFA</span>(i))</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;比较重要的知识点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="图论" scheme="https://mydcwfy.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="差分约束" scheme="https://mydcwfy.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
  </entry>
  
  <entry>
    <title>最小割</title>
    <link href="https://mydcwfy.github.io/2021/12/26/Min-cut/"/>
    <id>https://mydcwfy.github.io/2021/12/26/Min-cut/</id>
    <published>2021-12-26T04:15:20.000Z</published>
    <updated>2021-12-26T04:18:31.115Z</updated>
    
    <content type="html"><![CDATA[<p><strong>update：2021-04-13 21:49 根据<a href="https://www.luogu.com.cn/user/185726">RuSun</a>的建议，更改了解题步骤</strong></p><p><strong>请确保你知道网络流、最大流、最小割</strong></p><span id="more"></span><p><a href="https://mydcwfy.github.io/2021/12/26/Network-flow/">我的博客</a></p><p>鉴于最小割模型不宜想到，且变化多端，特出此笔记</p><h2 id="1-应用"><a href="#1-应用" class="headerlink" title="1.应用"></a>1.应用</h2><p>最小割常用来求最小代价，以及最大收益（满足一定条件才能获得）</p><p>最小割的复杂度与最大流相同，为$O(n^2m)$</p><p>由于模板没有可考察的，所以难点一般在建图上。</p><h2 id="2-模型"><a href="#2-模型" class="headerlink" title="2.模型"></a>2.模型</h2><h3 id="0）-前言"><a href="#0）-前言" class="headerlink" title="0） 前言"></a>0） 前言</h3><p>最小割求的是最小代价，即不选某条边的代价</p><p>满流表示的是割断该条边，并支付该代价</p><p>未满流的边，一般视为0</p><p>最小割求的是边的割，如果是点的代价，则使用拆点法</p><p>对于不能割断的边，将其流量设为 $+\infty$</p><h3 id="1）-最小代价型"><a href="#1）-最小代价型" class="headerlink" title="1） 最小代价型"></a>1） 最小代价型</h3><h4 id="T1："><a href="#T1：" class="headerlink" title="T1："></a>T1：</h4><p><a href="https://www.luogu.com.cn/problem/P1345">P1345 [USACO5.4]奶牛的电信Telecowmunication</a></p><p>这是一道典型的 01 最小代价问题，从入点到出点都是1的代价。</p><p>将每个点拆为入点和出点，之间的代价为1</p><p>每条边的代价为 $+\infty$，即不能割断。</p><p>不贴代码了，自己建图最大流就可以了。</p><h4 id="T2："><a href="#T2：" class="headerlink" title="T2："></a>T2：</h4><p><a href="https://www.luogu.com.cn/problem/P3866">P3866 [TJOI2009]战争游戏</a></p><p>这是一道多代价问题，不只是 1 的代价</p><p>同样要用到拆点法，入点与出点的连边为轰炸该点的炸药数，</p><p>注意，如果是本身是障碍物的话，相当于轰炸为0代价，在网络流中可以直接掠过。</p><p>从敌军位置向起点连边，从边界向汇点连边，就可以了。</p><h3 id="2）-最大收益类"><a href="#2）-最大收益类" class="headerlink" title="2） 最大收益类"></a>2） 最大收益类</h3><p>其实最大收益类都可以转化为最小代价类。</p><p>为什么单独拿出来说呢？因为很多时候，看不出来是最小割。</p><p>看几道题理解一下。</p><h4 id="T1：-1"><a href="#T1：-1" class="headerlink" title="T1："></a>T1：</h4><p><a href="https://www.luogu.com.cn/problem/P2774">P2774 方格取数问题</a></p><p>很多同学看到“最大和”，迫不及待地要用最大流。</p><p>但这道题，如果是最大流的话，会使图的规模增长一个数量级，并且杂乱无章。</p><p>（<del>所以讲一下还是有必要的</del>）</p><p>我们考虑应该不要哪些点。</p><p>回归割的定义，任意一条从 s 到 t 的路径，必有一条是割边。</p><p>我们将有关联的点全部连在一起，再将这些点分别接到源汇点上，会发现，任意一条边，要么左边满流（取其代价），要么右边满流</p><p>进一步观察题目，挖掘性质，我们可以发现，可将原图分为两部，相邻的点在不同部。</p><p>我们就可以发现，再将两部的点分别连到源汇点，就满足了上面的性质！</p><p>这样建图就可以了，用最大流跑。</p><h4 id="T2：-1"><a href="#T2：-1" class="headerlink" title="T2："></a>T2：</h4><p><a href="https://www.luogu.com.cn/problem/P2762">P2762 太空飞行计划问题</a></p><p>输出里直接说到“最大利润”，所以是最大收益的题目。</p><p>我们考虑哪些实验不要，以及需要支付的费用。</p><p>先将每个实验与源点连边，接着与需要的配置连边$+\infty$，然后把配置与汇点连边。</p><p>挖掘性质：任意一条从 s 到 t 的路径，都会经过一个实验和配置。</p><p>要么实验满流（既不选），要么配置满流（即支付该费用）。</p><p>满足原问题的性质。</p><h4 id="T3："><a href="#T3：" class="headerlink" title="T3："></a>T3：</h4><p><a href="https://www.luogu.com.cn/problem/P4177">P4177 [CEOI2008]order</a></p><p>这道题与上道题类似，只不过多了一个租的环节。</p><p>分析上一题，发现相当于是租的费用为 $+\infty$，这道题，改为对应代价即可。</p><p>每一部分，要么不选工作，要么对应边满流（即租），要么买。</p><h4 id="T4："><a href="#T4：" class="headerlink" title="T4："></a>T4：</h4><p><a href="https://www.luogu.com.cn/problem/P3872">P3872 [TJOI2010]电影迷</a></p><p>这道题提到，$-1000 \leq v(x) \leq 1000$，即可能为负。</p><p>我们可以把负点看做是代价，并将联系正负的分别与源汇点连边。</p><p>注意，负点不是收益，而是代价，该点没有满流代表不选该点</p><p>可以发现，要么正的满流（即不看），要么中间断开（即支付不看的代价），要么从负点断开（即支付看他的代价）。</p><p>详细证明参见 <a href="https://www.luogu.com.cn/blog/Feliks-GMYB/solution-p3872">这篇博客</a></p><h4 id="T5："><a href="#T5：" class="headerlink" title="T5："></a>T5：</h4><p><a href="https://www.luogu.com.cn/problem/P4313">P4313 文理分科</a></p><p>这是最能体现最小割通法的题目了。</p><p>按照先前的思路，就会发现牵扯过多，而不好建图。</p><p>这时我们采取的策略是：<br><strong>先将所有的利益加进来，在将不能共存的状态连边（或者一定的费用），将连边的端点分别以一定代价连边源汇点。</strong><br>按照这个思路，几乎可以秒杀该题。</p><p>将所有利益加起来，然后将 $same_art$ 与几个 $science$ 连边，$same_science$ 同理。</p><p>将带 $art$ 的与源点连边，其余的与汇点连边，用总收益减最小割即可。</p><h3 id="3）-总结"><a href="#3）-总结" class="headerlink" title="3） 总结"></a>3） 总结</h3><p>我们可以用最小割解决问题，都用上面的策略建图即可。</p><h2 id="3-解题步骤"><a href="#3-解题步骤" class="headerlink" title="3. 解题步骤"></a>3. 解题步骤</h2><ol><li><p>判断是不是最小割问题。</p></li><li><p>判断是不是最大收益类，如果是，先将收益加起来。</p></li><li><p>如果是最大收益类，就将不能共存的点连接起来。</p></li><li><p>如果是最小代价类，就将两点必须有至少其一的点连接起来。</p></li><li><p>跑最小割即可。</p></li></ol><h4 id="注意：这两类一般只能处理二分图的形式的题，除了一些明显的最小割问题"><a href="#注意：这两类一般只能处理二分图的形式的题，除了一些明显的最小割问题" class="headerlink" title="注意：这两类一般只能处理二分图的形式的题，除了一些明显的最小割问题"></a>注意：这两类一般只能处理二分图的形式的题，除了一些明显的最小割问题</h4><p>没有总结到的，请在评论区提出，我会按时回复。</p><p>希望对你有所帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;update：2021-04-13 21:49 根据&lt;a href=&quot;https://www.luogu.com.cn/user/185726&quot;&gt;RuSun&lt;/a&gt;的建议，更改了解题步骤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请确保你知道网络流、最大流、最小割&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="图论" scheme="https://mydcwfy.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="网络流" scheme="https://mydcwfy.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
</feed>
