<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mydcwfy&#39;s Blog</title>
  
  
  <link href="https://mydcwfy.github.io/atom.xml" rel="self"/>
  
  <link href="https://mydcwfy.github.io/"/>
  <updated>2023-02-06T13:49:21.403Z</updated>
  <id>https://mydcwfy.github.io/</id>
  
  <author>
    <name>mydcwfy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CF1103D Professional layer</title>
    <link href="https://mydcwfy.github.io/2023/02/06/CF1103D/"/>
    <id>https://mydcwfy.github.io/2023/02/06/CF1103D/</id>
    <published>2023-02-06T13:24:38.000Z</published>
    <updated>2023-02-06T13:49:21.403Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定 $n$ 个数 $a_i$，每个数有一个代价 $c_i$，你可以选择一次集合 $S$，让集合内部的每个数都可以被一个 $\leq k$ 的因数除掉，选择的代价为 $|S|\sum_{i\in S} c_i$。要求使得操作过后 $\gcd_i a_i = 1$ 的最小代价。$n\leq 10 ^ 6$，$a_i\leq 10 ^ {12}$，$c_i\leq 10 ^ 9$。</p><span id="more"></span><p>首先敲一下计算器容易发现 $\gcd_i a_i$ 最多只有 $k = 11$ 个质因数，那么我们对于每个数只需要考虑这些质因数的次数即可。写一个暴力容易发现只考虑 $m = 11$ 个质因数的话只有不超过 $M = 12000$ 个数需要考虑。对于缩减过后相同的数，我们发现只需要保留最小的 $m$ 个即可。这是因为每次选择一个数我们至少需要完全消掉一个质因子，那么只需要保留 $m$ 个即可。</p><p>对于一个缩减过后的数，我们枚举质因数集合 $S$，容易判断只选择一个数我们能否将集合 $S$ 全部消掉，这部分是 $O(Mm2 ^ m)$ 的。那么我们相当于对于一个集合 $S$，我们都保留一个最小的代价即可，然后最后直接 $O(m4 ^ m)$ DP 即可。</p><p>看似上面的做法没有问题，但是我们注意到对于一个数 $\{a_i, c_i\}$，我们只能选择一次，上面的做法并没有体现出这一点。于是我们考虑同样的对一个集合 $S$，我们只保留前 $m$ 个最小的代价。然后我们将这些可能有用的转移再分到不同的 $\{a_i, c_i\}$，DP 即可。注意最后的代价和 $|S|$ 有关，我们需要记录 $f(i, s)$ 表示选择了 $i$ 个数除，已经将 $s$ 集合的全部消去了的最小 $c$ 和。复杂度是 $O(m ^ 2 4 ^ m)$，可能不太能接受。</p><p>考虑我们原来的转移是 $s\to s\cup t$，但是容易发现对于所有的 $t$，他的所有子集的转移同样是被记录的（可能不在有用的转移中，但是肯定是被记录了的）。那么我们可以直接写为 $s\to s + t$，定义为 $s\cap t=\varnothing$。这样的话我们用 $t$ 转移的时候只需要枚举 $U \oplus t$ 的所有子集即可。这样做是 $O(m ^ 23 ^ m)$ 的，是可接受的。</p><p>总复杂度 $O(Mm2 ^ m + m ^ 23 ^ m)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; lim;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, c + i);</span><br><span class="line">G = a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) G = <span class="built_in">Gcd</span>(G, a[i]);</span><br><span class="line">LL tmp = G;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= tmp / i; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (tmp % i) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span> (tmp % i == <span class="number">0</span>) tmp /= i;</span><br><span class="line">fac.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmp ^ <span class="number">1</span>) fac.<span class="built_in">push_back</span>(tmp);</span><br><span class="line"><span class="type">int</span> tot = fac.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">LL x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (LL p : fac)</span><br><span class="line"><span class="keyword">while</span> (a[i] % p == <span class="number">0</span>) x *= p, a[i] /= p;</span><br><span class="line">mp[a[i] = x].<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> pr : mp) &#123;</span><br><span class="line">std::<span class="built_in">sort</span>(pr.second.<span class="built_in">begin</span>(), pr.second.<span class="built_in">end</span>(), cmp);</span><br><span class="line"><span class="keyword">if</span> (pr.second.<span class="built_in">size</span>() &gt; fac.<span class="built_in">size</span>()) pr.second.<span class="built_in">resize</span>(fac.<span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> id : pr.second) &#123;</span><br><span class="line">dv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">LL cur = a[id];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) &#123;</span><br><span class="line">dv[<span class="number">1</span> &lt;&lt; i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cur % fac[i] == <span class="number">0</span>) cur /= fac[i], dv[<span class="number">1</span> &lt;&lt; i] *= fac[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; tot); ++ s) &#123;</span><br><span class="line"><span class="keyword">if</span> ((dv[s] = dv[s &amp; (s - <span class="number">1</span>)] * dv[s &amp; -s]) &gt; lim) <span class="keyword">continue</span>;</span><br><span class="line">cov[s].<span class="built_in">push_back</span>(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; tot); ++ s) &#123;</span><br><span class="line">std::<span class="built_in">sort</span>(cov[s].<span class="built_in">begin</span>(), cov[s].<span class="built_in">end</span>(), cmp);</span><br><span class="line"><span class="keyword">if</span> (cov[s].<span class="built_in">size</span>() &gt; fac.<span class="built_in">size</span>()) cov[s].<span class="built_in">resize</span>(fac.<span class="built_in">size</span>());</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; s &lt;&lt; &quot; : &quot;;</span></span><br><span class="line"><span class="comment">// for (int id : cov[s]) std::cout &lt;&lt; id &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> id : cov[s]) trs[id].<span class="built_in">push_back</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; tot); ++ s)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= tot; ++ i) g[i][s] = f[i][s] = INF;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> id = <span class="number">1</span>; id &lt;= n; ++ id) &#123;</span><br><span class="line"><span class="keyword">if</span> (!trs[id].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s : trs[id]) &#123;</span><br><span class="line"><span class="type">int</span> t = ((<span class="number">1</span> &lt;&lt; tot) - <span class="number">1</span>) ^ s, all = t;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line"><span class="built_in">chkmin</span>(g[i + <span class="number">1</span>][s | t], f[i][t] + c[id]);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; id &lt;&lt; &#x27; &#x27; &lt;&lt; s &lt;&lt; &#x27; &#x27; &lt;&lt; t &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">t = (t - <span class="number">1</span>) &amp; all;</span><br><span class="line">&#125; <span class="keyword">while</span> (t != all);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s : trs[id]) &#123;</span><br><span class="line"><span class="type">int</span> t = ((<span class="number">1</span> &lt;&lt; tot) - <span class="number">1</span>) ^ s, all = t;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line"><span class="built_in">chkmin</span>(f[i][s | t], g[i][s | t]), g[i][s | t] = INF;</span><br><span class="line">t = (t - <span class="number">1</span>) &amp; all;</span><br><span class="line">&#125; <span class="keyword">while</span> (t != all);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">LL res = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (f[i][(<span class="number">1</span> &lt;&lt; tot) - <span class="number">1</span>] != INF) <span class="built_in">chkmin</span>(res, f[i][(<span class="number">1</span> &lt;&lt; tot) - <span class="number">1</span>] * i);</span><br><span class="line">std::cout &lt;&lt; (res == INF ? <span class="number">-1</span> : res) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定 $n$ 个数 $a_i$，每个数有一个代价 $c_i$，你可以选择一次集合 $S$，让集合内部的每个数都可以被一个 $\leq k$ 的因数除掉，选择的代价为 $|S|\sum_{i\in S} c_i$。要求使得操作过后 $\gcd_i a_i = 1$ 的最小代价。$n\leq 10 ^ 6$，$a_i\leq 10 ^ {12}$，$c_i\leq 10 ^ 9$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="复杂度分析" scheme="https://mydcwfy.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>LOJ2339 「WC2018」通道</title>
    <link href="https://mydcwfy.github.io/2023/02/06/LOJ2339/"/>
    <id>https://mydcwfy.github.io/2023/02/06/LOJ2339/</id>
    <published>2023-02-06T12:13:04.000Z</published>
    <updated>2023-02-06T13:15:37.919Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定三棵大小为 $n$ 的树，求 $\min_{i &lt; j} \{\text{dist}_1(i, j) + \text{dist}_2(i, j) + \text{dist}_3(i, j)\}$。$n\leq 10 ^ 5$，$w_i\leq 10 ^ {12}$。</p><span id="more"></span><p>首先考虑两棵树的做法：我们考虑对第一棵树边分治，然后分为 $S_L, S_R$ 过后，每个点带一个权值 $v(x)$，我们需要求 $\max_{x\in S_L, y\in S_R} \{ v(x) + v(y) + \text{dist}_2 (x, y) \}$。考虑直接对 $S_L\cup S_R$ 在第二棵树上建虚树，这样的话，我们只需要求 $x$ 子树内部 $\max_{u\in S_L} \text{dist}_2(u,x) + v(u)$ 和类似的对于 $S_R$ 的定义，就可以在 $O(sz)$ 内完成。于是总复杂度就是 $O(n\log n)$，如果使用神秘排序建虚树之类的话可以做到 $O(n\log n)$。</p><p>现在考虑我们多出来了一棵树怎么做。我们像上面那样建虚树过后合并 $S_1, S_2$ 两棵子树的答案的时候相当于是 $\max_{x\in S_1\cap S_L, y\in S_2\cap S_R} \{v(x) + v(y) + p_x + p_y - 2p_u + \text{dist}_3(x, y) \}$，当然 $x, y$ 反过来还可以贡献。注意到 $u$ 是当前点不需要管，我们只需要把剩余部分的最大值求好即可。这个本质相当于是我们在第三棵树的 $x$ 下面挂了一个长度为 $v(x) + p_x$ 的边，然后求集合内部的直径。容易发现计算集合的直径的时候可以直接从下方合并，于是就做完了。</p><p>时间复杂度 $O(n\log ^ 2 n)$ 或 $O(n\log n)$，可能带有较大的常数，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="built_in">Node</span>() : a&#123;&#125; &#123;&#125;</span><br><span class="line"><span class="keyword">auto</span>&amp; <span class="keyword">operator</span> [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> a[x]; &#125;</span><br><span class="line">Node <span class="keyword">operator</span> *(Node b) <span class="type">const</span> &#123;</span><br><span class="line">Node c;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : &#123;<span class="number">0</span>, <span class="number">1</span>&#125;) &#123;</span><br><span class="line">LL mx = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> tmp[<span class="number">4</span>]&#123;a[i][<span class="number">0</span>], a[i][<span class="number">1</span>], b[i][<span class="number">0</span>], b[i][<span class="number">1</span>]&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; <span class="number">4</span>; ++ k)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">chkmax</span>(mx, d1[tmp[j]] + d1[tmp[k]] + T2.pre[tmp[j]] + T2.pre[tmp[k]]</span><br><span class="line">+ T3.<span class="built_in">dist</span>(tmp[j], tmp[k])))</span><br><span class="line">c[i][<span class="number">0</span>] = tmp[j], c[i][<span class="number">1</span>] = tmp[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">edge_prepare</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ls = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h4[x], v; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> ((v = e[i]) == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (!ls) ls = x;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">link</span>(h1, ls, ++ cnt1, <span class="number">0</span>), ls = cnt1;</span><br><span class="line"><span class="built_in">link</span>(h1, ls, v, w[i]), <span class="built_in">edge_prepare</span>(v, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_size</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> sz = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h1[x], v; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (!vis[i &gt;&gt; <span class="number">1</span>] &amp;&amp; (v = e[i]) != fa) sz += <span class="built_in">get_size</span>(v, x);</span><br><span class="line"><span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_ec</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> frm, <span class="type">int</span> tot, <span class="type">int</span> &amp;mx, <span class="type">int</span> &amp;eid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> sz = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h1[x]; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (!vis[i &gt;&gt; <span class="number">1</span>] &amp;&amp; i != (frm ^ <span class="number">1</span>)) sz += <span class="built_in">get_ec</span>(e[i], i, tot, mx, eid);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">chkmin</span>(mx, std::<span class="built_in">max</span>(sz, tot - sz))) eid = frm;</span><br><span class="line"><span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_side</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa, LL dis, std::vector&lt;<span class="type">int</span>&gt; &amp;nds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= n) nds.<span class="built_in">push_back</span>(x), d1[x] = dis;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h1[x], v; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (!vis[i &gt;&gt; <span class="number">1</span>] &amp;&amp; (v = e[i]) != fa) <span class="built_in">get_side</span>(v, x, dis + w[i], nds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_vir</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (stk[top] == x) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> lca = T2.<span class="built_in">LCA</span>(x, stk[top]);</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; T2.dep[stk[top - <span class="number">1</span>]] &gt;= T2.dep[lca])</span><br><span class="line"><span class="built_in">link</span>(h5, stk[top], stk[top - <span class="number">1</span>], <span class="number">0</span>), top --;</span><br><span class="line"><span class="keyword">if</span> (T2.dep[stk[top]] &gt; T2.dep[lca]) <span class="built_in">link</span>(h5, stk[top], lca, <span class="number">0</span>), top --;</span><br><span class="line"><span class="keyword">if</span> (stk[top] != lca) stk[++ top] = lca;</span><br><span class="line">stk[++ top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">dfs_ans</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node ret&#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (sid[x] == <span class="number">2</span>) ret[<span class="number">1</span>][<span class="number">0</span>] = ret[<span class="number">1</span>][<span class="number">1</span>] = x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sid[x] == <span class="number">1</span>) ret[<span class="number">0</span>][<span class="number">0</span>] = ret[<span class="number">0</span>][<span class="number">1</span>] = x;</span><br><span class="line"><span class="keyword">auto</span> getval = [&amp;](<span class="type">int</span> u, <span class="type">int</span> v) &#123;</span><br><span class="line"><span class="keyword">if</span> (!u || !v) <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line"><span class="keyword">return</span> d1[u] + d1[v] + T2.pre[u] + T2.pre[v] - <span class="number">2</span> * T2.pre[x] + T3.<span class="built_in">dist</span>(u, v);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h5[x], v; ~i; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((v = e[i]) == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;Edge &quot; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; v &lt;&lt; &#x27; &#x27; &lt;&lt; i &lt;&lt; std::endl;</span></span><br><span class="line">Node to = <span class="built_in">dfs_ans</span>(v, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : &#123;<span class="number">0</span>, <span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j : &#123;<span class="number">0</span>, <span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k : &#123;<span class="number">0</span>, <span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">chkmax</span>(cans, <span class="built_in">getval</span>(ret[i][j], to[i ^ <span class="number">1</span>][k]));</span><br><span class="line">ret = ret * to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_clear</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h5[x], v; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> ((v = e[i]) != fa) <span class="built_in">dfs_clear</span>(v, x);</span><br><span class="line">h5[x] = <span class="number">-1</span>, sid[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> sz = <span class="built_in">get_size</span>(x), eid = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (sz == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">get_ec</span>(x, <span class="number">-1</span>, sz, sz, eid), vis[eid &gt;&gt; <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;Divide &quot; &lt;&lt; e[eid] &lt;&lt; &#x27; &#x27; &lt;&lt; e[eid ^ 1] &lt;&lt; std::endl;</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; nds, ndr;</span><br><span class="line"><span class="built_in">get_side</span>(e[eid], e[eid ^ <span class="number">1</span>], <span class="number">0</span>, nds), <span class="built_in">get_side</span>(e[eid ^ <span class="number">1</span>], e[eid], <span class="number">0</span>, ndr);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : nds) sid[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : ndr) sid[x] = <span class="number">2</span>, nds.<span class="built_in">push_back</span>(x);</span><br><span class="line">std::<span class="built_in">sort</span>(nds.<span class="built_in">begin</span>(), nds.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line"><span class="keyword">return</span> T2.fi[x] &lt; T2.fi[y];</span><br><span class="line">&#125;);</span><br><span class="line">stk[top = <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> bac = idx;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : nds) <span class="built_in">insert_vir</span>(x);</span><br><span class="line"><span class="keyword">while</span> (-- top)</span><br><span class="line"><span class="built_in">link</span>(h5, stk[top + <span class="number">1</span>], stk[top], <span class="number">0</span>);</span><br><span class="line">cans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">dfs_ans</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">chkmax</span>(res, cans + w[eid]), <span class="built_in">dfs_clear</span>(<span class="number">1</span>, <span class="number">0</span>), idx = bac;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; cans &lt;&lt; &#x27; &#x27; &lt;&lt; w[eid] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="built_in">divide</span>(e[eid]), <span class="built_in">divide</span>(e[eid ^ <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++ i) h1[i] = h2[i] = h3[i] = h4[i] = h5[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = N; i &lt; <span class="number">2</span> * N; ++ i) h1[i] = <span class="number">-1</span>;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> u, v;</span><br><span class="line">LL w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lld&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">link</span>(h4, u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lld&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">link</span>(h2, u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lld&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">link</span>(h3, u, v, w);</span><br><span class="line">&#125;</span><br><span class="line">cnt1 = n, <span class="built_in">edge_prepare</span>(<span class="number">1</span>), T2.<span class="built_in">prework</span>(h2), T3.<span class="built_in">prework</span>(h3), T4.<span class="built_in">prework</span>(h4);</span><br><span class="line"><span class="built_in">divide</span>(<span class="number">1</span>);</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定三棵大小为 $n$ 的树，求 $\min_{i &amp;lt; j} \{\text{dist}_1(i, j) + \text{dist}_2(i, j) + \text{dist}_3(i, j)\}$。$n\leq 10 ^ 5$，$w_i\leq 10 ^ {12}$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="树相关" scheme="https://mydcwfy.github.io/tags/%E6%A0%91%E7%9B%B8%E5%85%B3/"/>
    
    <category term="点分治和点分树" scheme="https://mydcwfy.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB%E5%92%8C%E7%82%B9%E5%88%86%E6%A0%91/"/>
    
    <category term="虚树" scheme="https://mydcwfy.github.io/tags/%E8%99%9A%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>CF1326F2 Wise Men</title>
    <link href="https://mydcwfy.github.io/2023/02/06/CF1326F2/"/>
    <id>https://mydcwfy.github.io/2023/02/06/CF1326F2/</id>
    <published>2023-02-06T11:49:20.000Z</published>
    <updated>2023-02-06T12:09:33.182Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定 $n$ 个人两两之间的认识关系，对于一个排列 $p$，设 $s_i$ 表示 $p_i$ 和 $p_{i + 1}$ 的认识关系。问对于每个 $s$ 有多少个 $p$ 能生成该 $s$。$n\leq 18$。</p><span id="more"></span><p>容易发现 $s$ 是长度为 $n - 1$ 的 01 序列。考虑容斥，我们强制钦定了某些位置为 1，剩下的位置随意，那么容易发现原序列被划分成了若干段，每一段内部相邻元素必须相连。容斥完了过后，我们用一个逆高维前缀和的做法就可以在 $O(n 2 ^ n)$ 内解决后半部分。</p><p>然后考虑如何计算。对于一段内部，我们使用预处理状压 DP 的做法，记录 $f(i, s)$ 表示已经选了 $s$ 集合，最后一个是 $i$ 的方案数，转移平凡，此部分预处理 DP 是 $O(2 ^ n n ^ 2)$。然后考虑已经枚举完分段过后怎么做。我们本质上是将不同段的状压值子集卷积起来，但是容易发现我们已经知道了每一段分别的 <code>popcount</code>，那么我们最后求 $[x ^ {2 ^ n - 1}]$ 相当于直接或卷积。我们还可以预处理每一段高维前缀和后的值，并且可以在 $O(2 ^ n)$ 时间内部得到一个数组逆高维前缀和过后某一项的值，所以只需要把所有不同段的 DP 并高位前置和后的值乘起来，所有逆高维前缀和得到一项的值即可。直接枚举所有拆分的话复杂度就是 $O(4 ^ n)$ 的。</p><p>上述复杂度仍然不能接受，我们发现这个 DP 值仅和所有段长度的 <code>std::multiset</code> 有关，所以这个本质是一个拆分数。于是我们枚举强制钦定的部分就是 $O(p(n))$ 的，而 $p(18) = 385$ 是可以接受的。</p><p>于是总复杂度是 $O((p(n) + n ^ 2)2 ^ n)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsta</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) s = (s &lt;&lt; len[i]) | ((<span class="number">1</span> &lt;&lt; (len[i] - <span class="number">1</span>)) - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> rem, <span class="type">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rem == <span class="number">0</span>) &#123;</span><br><span class="line">LL cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++ i)</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">popcount</span>(i) ^ n) &amp; <span class="number">1</span>) cur -= tmp[tot][i];</span><br><span class="line"><span class="keyword">else</span> cur += tmp[tot][i];</span><br><span class="line"><span class="comment">// for (int i = 1; i &lt;= tot; ++ i) std::cout &lt;&lt; len[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;: &quot; &lt;&lt; cur &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">do</span> ans[<span class="built_in">getsta</span>()] = cur; <span class="keyword">while</span> (std::<span class="built_in">next_permutation</span>(len + <span class="number">1</span>, len + tot + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rem &lt; st) <span class="keyword">return</span>;</span><br><span class="line">++ tot;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = st; i &lt;= rem; ++ i) &#123;</span><br><span class="line">len[tot] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line">tmp[tot][s] = tmp[tot - <span class="number">1</span>][s] * f[i][s];</span><br><span class="line"><span class="built_in">dfs</span>(rem - i, i);</span><br><span class="line">&#125;</span><br><span class="line">tot --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> s[N];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) a[i][j] = s[j] &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) dp[<span class="number">1</span> &lt;&lt; i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="keyword">if</span> (dp[s][i])</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> nxt = <span class="number">0</span>; nxt &lt; n; ++ nxt)</span><br><span class="line"><span class="keyword">if</span> (a[i][nxt] &amp;&amp; (~s &gt;&gt; nxt &amp; <span class="number">1</span>))</span><br><span class="line">dp[s | (<span class="number">1</span> &lt;&lt; nxt)][nxt] += dp[s][i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) f[<span class="built_in">popcount</span>(s)][s] += dp[s][i];</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] ++;</span><br><span class="line"><span class="comment">// for (int i = 0; i &lt;= n; ++ i, std::cout &lt;&lt; &#x27;\n&#x27;)</span></span><br><span class="line"><span class="comment">// for (int s = 0; s &lt; (1 &lt;&lt; n); ++ s) std::cout &lt;&lt; f[i][s] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> bit = <span class="number">0</span>; bit &lt; n; ++ bit)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); ++ j)</span><br><span class="line"><span class="keyword">if</span> (j &gt;&gt; bit &amp; <span class="number">1</span>) f[i][j] += f[i][j ^ (<span class="number">1</span> &lt;&lt; bit)];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s) tmp[<span class="number">0</span>][s] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> bit = <span class="number">0</span>; bit &lt; n - <span class="number">1</span>; ++ bit)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)); ++ j)</span><br><span class="line"><span class="keyword">if</span> (j &gt;&gt; bit &amp; <span class="number">1</span>) ans[j ^ (<span class="number">1</span> &lt;&lt; bit)] -= ans[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)); ++ s) std::cout &lt;&lt; ans[s] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定 $n$ 个人两两之间的认识关系，对于一个排列 $p$，设 $s_i$ 表示 $p_i$ 和 $p_{i + 1}$ 的认识关系。问对于每个 $s$ 有多少个 $p$ 能生成该 $s$。$n\leq 18$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="集合幂级数" scheme="https://mydcwfy.github.io/tags/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"/>
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="复杂度分析" scheme="https://mydcwfy.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
    <category term="状态压缩" scheme="https://mydcwfy.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="容斥" scheme="https://mydcwfy.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>LOJ3704 「联合省选 2022」序列变换</title>
    <link href="https://mydcwfy.github.io/2022/12/29/LOJ3704/"/>
    <id>https://mydcwfy.github.io/2022/12/29/LOJ3704/</id>
    <published>2022-12-29T00:45:28.000Z</published>
    <updated>2022-12-29T01:39:32.367Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一个长度为 $2n$ 的合法括号序列，每个左括号有一个权值，每次你可以把 $p(A)(B)q$ 改成 $p(A()B)q$ 的形式，代价为 $(A)$ 的第一个左括号乘 $x$ 加上 $(B)$ 的第一个左括号乘 $y$（$A, B$ 必须是合法括号序列，$p, q$ 无限制），或者任意交换相邻的合法括号序列，不需要代价。问最少需要多少代价才能使得括号序列不包含 $()()$ 的结构。$n\leq 4\times 10 ^ 5$，$0\leq x, y\leq 1$，$a_i\leq 10 ^ 7$。</p><span id="more"></span><p>考虑我们用括号树来刻画这个变换。首先将括号转成树的方法是一对括号代表一个节点，然后内部的都是在他子树内部的。那么我们可以用图表示这个变化过程：</p><img src="/2022/12/29/LOJ3704/%E8%BD%AC%E6%8D%A2.png" class=""><p>由图可以看出我们相当于用 A 把 B push 到了下一层，实际上其他的都没有变化。由于我们最后需要把整棵树变成一条链，所以其实中间的父子关系其实是没有关系的，我们只关心每个点所在的层数。</p><h3 id="x-0，y-0"><a href="#x-0，y-0" class="headerlink" title="x = 0，y = 0"></a>x = 0，y = 0</h3><p>答案显然为 0。</p><h3 id="x-0，y-1"><a href="#x-0，y-1" class="headerlink" title="x = 0，y = 1"></a>x = 0，y = 1</h3><p>这个相当于我们需要计算 B 的贡献，那么显然我们需要把最大的留在本层，这样代价尽量小。用一个 <code>std::multiset</code> 暴力维护即可做到 $O(n\log n)$。</p><h3 id="x-1，y-1"><a href="#x-1，y-1" class="headerlink" title="x = 1，y = 1"></a>x = 1，y = 1</h3><p>我们计算的单层答案就是 $mn\times (sz - 2) + sum$，容易发现还是把最大的保留在当前层即可。复杂度仍然是 $O(n\log n)$。</p><h3 id="x-1，y-0"><a href="#x-1，y-0" class="headerlink" title="x = 1，y = 0"></a>x = 1，y = 0</h3><p>现在我们计算的单层答案就是 $mn\times (sz - 2) + w$，$w$ 表示最后留下的权值。注意到除了最后一层的权值以外，其他的权值都被 $w$ 算了一遍。那么我们可以枚举最后一层的权值，这样的话剩下的就和前面的差不多，把最大的保留在当层即可，复杂度 $O(n ^ 2\log n)$。</p><p>注意到如果当前层个数 $\geq 3$ 的话，我们容易发现<strong>最大值和最小值都是有意义的</strong>，因为最小值可以让后面层贡献减少，而保留最大值到最后一层也是好的。难点在于我们对于个数 $=2$ 的情况 push 谁。</p><p>注意到一个性质就是 $sz$ 一定形如一个单峰的形式，而且下降一定是每次减 1。也就是说 $sz = 2$ 一定出现在前缀一段和倒数第二层。倒数第二层显然下放最大值，那么前面的应该怎么下放呢？</p><p>注意到我们前面说到只有最小值和最大值是有意义的，这一段 $sz = 2$ 最后只会下放一个值，那么这个值一定是最大值或者最小值。两个分别做就好了。复杂度 $O(n\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="type">int</span> st, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::multiset&lt;<span class="type">int</span>&gt; ms;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : allv[i]) ms.<span class="built_in">insert</span>(x);</span><br><span class="line">        ret += ((LL) ms.<span class="built_in">size</span>() - <span class="number">2</span>) * *ms.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span> (ms.<span class="built_in">size</span>() &gt;= <span class="number">3</span> || flag) &#123;</span><br><span class="line">        ret += *-- -- ms.<span class="built_in">end</span>();</span><br><span class="line">        ms.<span class="built_in">erase</span>(-- -- ms.<span class="built_in">end</span>());</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= st &amp;&amp; v == *ms.<span class="built_in">rbegin</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ms.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1e18</span>;</span><br><span class="line">            ret += *++ ms.<span class="built_in">rbegin</span>(), ms.<span class="built_in">erase</span>(-- -- ms.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ret += *ms.<span class="built_in">rbegin</span>(), ms.<span class="built_in">erase</span>(-- ms.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> Fly727</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;bracket.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;bracket.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%s&quot;</span>, &amp;n, &amp;x, &amp;y, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, c = <span class="number">0</span>, t = <span class="number">0</span>; i &lt;= <span class="number">2</span> * n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) allv[++ c].<span class="built_in">insert</span>(a[++ t]), deg[t] = c;</span><br><span class="line">        <span class="keyword">else</span> -- c;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (AllSame::<span class="built_in">issub</span>()) <span class="keyword">return</span> AllSame::<span class="built_in">solve</span>(), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">1</span>) &#123;</span><br><span class="line">        std::multiset&lt;<span class="type">int</span>, std::greater&lt;<span class="type">int</span>&gt;&gt; ms;</span><br><span class="line">        LL sum = <span class="number">0</span>, res = <span class="number">0</span>, cur;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x : allv[i]) ms.<span class="built_in">insert</span>(x), sum += x;</span><br><span class="line">            cur = *ms.<span class="built_in">begin</span>(), ms.<span class="built_in">erase</span>(ms.<span class="built_in">begin</span>()), sum -= cur;</span><br><span class="line">            res += sum;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> &amp;&amp; y == <span class="number">1</span>) &#123;</span><br><span class="line">        std::multiset&lt;<span class="type">int</span>, std::greater&lt;<span class="type">int</span>&gt;&gt; ms;</span><br><span class="line">        LL sum = <span class="number">0</span>, res = <span class="number">0</span>, cur;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x : allv[i]) ms.<span class="built_in">insert</span>(x), sum += x;</span><br><span class="line">            res += sum + *-- ms.<span class="built_in">end</span>() * ((<span class="type">int</span>) ms.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">            cur = *ms.<span class="built_in">begin</span>(), ms.<span class="built_in">erase</span>(ms.<span class="built_in">begin</span>()), sum -= cur;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="built_in">solve</span>(n, <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> flag1 = <span class="literal">true</span>, flag2 = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> edeg = <span class="number">0</span>, v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, t = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        t += allv[i].<span class="built_in">size</span>();</span><br><span class="line">        flag1 &amp;= t &lt;= <span class="number">2</span>, flag2 |= t &gt;= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag1 &amp;&amp; flag2 &amp;&amp; allv[i].<span class="built_in">size</span>() &amp;&amp; <span class="built_in">chkmax</span>(v, *allv[i].<span class="built_in">rbegin</span>())) edeg = i;</span><br><span class="line">        t --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">chkmin</span>(res, <span class="built_in">solve</span>(edeg, v));</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; edeg &lt;&lt; &#x27; &#x27; &lt;&lt; v &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    v = <span class="number">1e9</span>, flag1 = <span class="literal">true</span>, flag2 = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, t = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        t += allv[i].<span class="built_in">size</span>();</span><br><span class="line">        flag1 &amp;= t &lt;= <span class="number">2</span>, flag2 |= t &gt;= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag1 &amp;&amp; flag2 &amp;&amp; allv[i].<span class="built_in">size</span>() &amp;&amp; <span class="built_in">chkmin</span>(v, *allv[i].<span class="built_in">begin</span>())) edeg = i;</span><br><span class="line">        t --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">chkmin</span>(res, <span class="built_in">solve</span>(edeg, v));</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; edeg &lt;&lt; &#x27; &#x27; &lt;&lt; v &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一个长度为 $2n$ 的合法括号序列，每个左括号有一个权值，每次你可以把 $p(A)(B)q$ 改成 $p(A()B)q$ 的形式，代价为 $(A)$ 的第一个左括号乘 $x$ 加上 $(B)$ 的第一个左括号乘 $y$（$A, B$ 必须是合法括号序列，$p, q$ 无限制），或者任意交换相邻的合法括号序列，不需要代价。问最少需要多少代价才能使得括号序列不包含 $()()$ 的结构。$n\leq 4\times 10 ^ 5$，$0\leq x, y\leq 1$，$a_i\leq 10 ^ 7$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="贪心" scheme="https://mydcwfy.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>LOJ3702 「联合省选 2022」学术社区</title>
    <link href="https://mydcwfy.github.io/2022/12/28/LOJ3702/"/>
    <id>https://mydcwfy.github.io/2022/12/28/LOJ3702/</id>
    <published>2022-12-28T12:38:21.000Z</published>
    <updated>2022-12-28T23:36:16.103Z</updated>
    
    <content type="html"><![CDATA[<p>题意：有 $n$ 个人发了 $m$ 条消息，消息分为“xxx 楼下”“xxx 楼上”和学术消息。你需要合理安排这 $m$ 条消息的顺序，使得符合实际条件的楼上、楼下型消息尽量多，需要给出构造。保证每个人至少发了一条学术消息。$n\leq m\leq 77777$，$\sum m\leq 2.5\times 10 ^ 5$。</p><span id="more"></span><p>本题特殊性质有较强的提示性，我们根据特殊性质来解题。</p><ol><li>特殊性质 A：不会存在楼上型消息。</li><li>特殊性质 B：保证存在一种顺序使得每一条楼上、楼下型消息都符合实际。</li><li>特殊性质 C：保证不同时存在“A 说在 B 楼下”和“B 说在 A 楼上”。</li></ol><h3 id="特殊性质-ABC"><a href="#特殊性质-ABC" class="headerlink" title="特殊性质 ABC"></a>特殊性质 ABC</h3><p>考虑我们如果有一条 “A 在 B 楼下”的消息，我们 <strong>从 B 向 A</strong> 连一条边，那么现在一条完整的链就是从一条学术消息开始经过楼下型消息转移，最后在任意点停下。如果我们建立虚拟节点 T，任意一条学术消息我们都从 T 向这个点连边，这样的话就是从 T 开始到任意点结束的路径。</p><p>由于保证每条楼下型消息都符合实际，说明每个点的入度一定不小于出度，否则有些出边一定不能从 T 开始。对于多出来的，我们可以考虑链覆盖相关的算法欧拉回路，那么我们把一个点的（入度减去出度）条边从这个点引向 T，那么我们就从 T 开始求出欧拉回路即可。建的多出来的边不考虑就好了。</p><h3 id="特殊性质-AC"><a href="#特殊性质-AC" class="headerlink" title="特殊性质 AC"></a>特殊性质 AC</h3><p>现在去掉了保证符合实际的条件该怎么办？</p><p>现在相当于问题在于每个点的入度可能小于出度，这个时候我们将 T 向这个点连（出度减去入度）条边即可。注意每个点如果入度小于出度，那么答案应该减去（出度减去入度）。换言之，答案应该加上 $\min(\text{indeg} (x), \text{outdeg} (x))$。</p><h3 id="特殊性质-BC"><a href="#特殊性质-BC" class="headerlink" title="特殊性质 BC"></a>特殊性质 BC</h3><p>现在开始有楼上型消息了，我们怎么建图？</p><p>首先一个问题是楼上和楼下型消息其实不同点很多的，主要就在于其实两种的发出人并不相同。</p><p>我们可以考虑这样建图：建立 $G_1, G_2$，每个点在 $G_1, G_2$ 中都对应一个点，如果形如“A 在 B 楼上”就在 $G_1$ 中从 A 向 B 连边，形如“A 在 B 楼下”就在 $G_2$ 中从 B 向 A 连边，如果是学术消息就从 $G_1$ 对应点连向 $G_2$。</p><p>容易发现在特殊性质 C 范围下，一条完整链条形如任意楼上型消息链 - 学术消息 - 任意楼下型消息链。这个在建图中对应着一条从 $G_1$ 中点连到 $G_2$ 中点的一条链。那么既然每条都符合实际，那么说明 $G_1$ 中出度不小于入度，$G_2$ 中入度不小于出度。类似于上面的建图，我们从虚拟节点 $T$ 向 $G_1$ 中的点连边，从 $G_2$ 中的点向 T 连边，这样的话我们寻找欧拉回路，减去没有实际存在的边，就可以得到构造方案了。</p><h3 id="特殊性质-C"><a href="#特殊性质-C" class="headerlink" title="特殊性质 C"></a>特殊性质 C</h3><p>现在没有了 $G_1$ 出度不小于入度，$G_2$ 入度不小于出度，这个该怎么办呢？</p><p>注意到如果我们直接按照 特殊性质 AC 的计算的话，答案一定有一个下界 $\sum \min(\text{indeg}(x), \text{outdeg}(x))$。但是注意到我们有些并没有用到，我们可不可以合适的调整一下呢？</p><p>调整的方法显然是我们把一条原来是一条楼上或者楼下型消息改为学术消息。以一条楼上型消息为例，“A 在 B 楼上”的消息原来是 $G_1$ 中 A 向 B 连边，现在是 $G_1$ 中 A 向 $G_2$ 中 A 连边。原来 B 的出度过大，减少 1 不会影响答案，而 $G_2$ 中 A 的出度过小的话，增加 1 就会使得答案 +1。那么这样更改的话就是有效的。</p><p>我们可以通过一个网络流模型来刻画：如果 $G_1$ 中出度小于入度，就从 S 向该点连容量为 $\text{indeg}(x) - \text{outdeg}(x)$ 的边。向上面一样刻画两两之间的边，$G_2$ 中如果入度小于出度，就向 T 连容量为 $\text{outdeg}(x) - \text{indeg}(x)$。这样跑出来的网络流就是答案的增加量。</p><p>然后考虑怎么构造。其实是好构造的，我们对于每条边，找到其在网络流中对应的边，如果流过了，说明这条消息变成了学术消息，否则没有。向上面那样建图，存在出入度差异就用虚拟节点平衡，从虚拟节点开始欧拉回路就可以找到一个合法的构造了。</p><h3 id="无特殊性质"><a href="#无特殊性质" class="headerlink" title="无特殊性质"></a>无特殊性质</h3><p>这个相较于特殊性质 C 来说多了一个中间环节：可能直接是楼上型消息链 - 楼下型消息链。注意到这两条消息放在一起是好的，所以我们直接放在一起。比如是”A 在 B 楼上“和”B 在 A 楼下“两个消息，我们直接从 $G_1$ 中的 A 向 $G_2$ 中的 B 连边即可。同样参与出入度的统计，注意这样直接答案 +2，因为原来这个是一条学术消息，我们没有计算其答案，现在就需要直接 +2。这个等价于二分图匹配，使用 dinic 可以做到复杂度 $O(m\sqrt m)$，可以通过。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>写起来细节还行，主要是没有特殊性质的话，找到对应的楼上楼下型消息比较麻烦（没有保证任意两条消息不同），然后就是没有特殊性质的话，一条欧拉回路上的边可能实际代表两条边，所以需要压缩一下。然后对于 $\text{indeg}$ 和 $\text{outdeg}$ 的处理可能细节稍多，可以参考一下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;i = h[x], v, j; ~i;) &#123;</span><br><span class="line">v = e[i], j = i;</span><br><span class="line">i = ne[i];</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">seq[++ etot] = w[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; gid;</span><br><span class="line">std::map&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; alledg;</span><br><span class="line"><span class="built_in">clear</span>();</span><br><span class="line">std::string s1, s2, s3;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) std::cin &gt;&gt; s1, gid[s1] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">std::cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3;</span><br><span class="line"><span class="keyword">if</span> ((s3 == <span class="string">&quot;louxia&quot;</span> || s3 == <span class="string">&quot;loushang&quot;</span>) &amp;&amp; gid.<span class="built_in">count</span>(s2))</span><br><span class="line">mg[++ tot] = &#123;gid[s1], gid[s2], s3 == <span class="string">&quot;louxia&quot;</span>, i&#125;;</span><br><span class="line"><span class="keyword">else</span> xs[gid[s1]].<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!mg[i].typ) alledg[&#123;mg[i].i1, mg[i].i2&#125;] ++;</span><br><span class="line"><span class="type">int</span> tmptot = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = tot; i; -- i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mg[i].typ) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> &amp;x = alledg[&#123;mg[i].i2, mg[i].i1&#125;];</span><br><span class="line"><span class="keyword">if</span> (!x) nw[++ tmptot] = mg[i];</span><br><span class="line"><span class="keyword">else</span> x --, res += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::map&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt;<span class="type">int</span>&gt;&gt; predg;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (mg[i].typ) predg[&#123;mg[i].i2, mg[i].i1&#125;].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (mg[i].typ) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">auto</span> &amp;v = predg[&#123;mg[i].i1, mg[i].i2&#125;];</span><br><span class="line"><span class="keyword">if</span> (v.<span class="built_in">empty</span>()) nw[++ tmptot] = mg[i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">add</span>(mg[i].i1, mg[i].i2 + n, (LL) mg[i].id * m + mg[v.<span class="built_in">back</span>()].id);</span><br><span class="line">outdeg[mg[i].i1] ++, indeg[mg[i].i2 + n] ++, v.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tmptot; ++ i) mg[i] = nw[i];</span><br><span class="line">tot = tmptot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (mg[i].typ) outdeg[mg[i].i2 + n] ++, indeg[mg[i].i1 + n] ++;</span><br><span class="line"><span class="keyword">else</span> outdeg[mg[i].i1] ++, indeg[mg[i].i2] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">outdeg[i] += xs[i].<span class="built_in">size</span>(), indeg[i + n] += xs[i].<span class="built_in">size</span>();</span><br><span class="line">G.S = <span class="number">2</span> * n + <span class="number">1</span>, G.T = <span class="number">2</span> * n + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (indeg[i] &gt; outdeg[i]) G.<span class="built_in">add</span>(G.S, i, indeg[i] - outdeg[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (indeg[i] &lt; outdeg[i]) G.<span class="built_in">add</span>(i, G.T, outdeg[i] - indeg[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i) res += std::<span class="built_in">min</span>(indeg[i], outdeg[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (mg[i].typ) eid[i] = G.idx, G.<span class="built_in">add</span>(mg[i].i1, mg[i].i2 + n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> eid[i] = G.idx, G.<span class="built_in">add</span>(mg[i].i2, mg[i].i1 + n, <span class="number">1</span>);</span><br><span class="line">G.<span class="built_in">dinic</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i) indeg[i] = outdeg[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!G.w[eid[i]]) res ++, <span class="built_in">add</span>(mg[i].i1, mg[i].i1 + n, mg[i].id);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mg[i].typ) <span class="built_in">add</span>(mg[i].i2 + n, mg[i].i1 + n, mg[i].id);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">add</span>(mg[i].i1, mg[i].i2, mg[i].id);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> id : xs[i]) <span class="built_in">add</span>(i, i + n, id);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= <span class="number">2</span> * n; ++ x)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[x]; ~i; i = ne[i]) outdeg[x] ++, indeg[e[i]] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (indeg[i] &lt; outdeg[i]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= outdeg[i] - indeg[i]; ++ j) <span class="built_in">add</span>(<span class="number">2</span> * n + <span class="number">1</span>, i, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= indeg[i] - outdeg[i]; ++ j) <span class="built_in">add</span>(i, <span class="number">2</span> * n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = etot; i; -- i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!seq[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (seq[i] &lt;= m) std::cout &lt;&lt; seq[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> std::cout &lt;&lt; (seq[i] - <span class="number">1</span>) / m &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (seq[i] - <span class="number">1</span>) % m + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：有 $n$ 个人发了 $m$ 条消息，消息分为“xxx 楼下”“xxx 楼上”和学术消息。你需要合理安排这 $m$ 条消息的顺序，使得符合实际条件的楼上、楼下型消息尽量多，需要给出构造。保证每个人至少发了一条学术消息。$n\leq m\leq 77777$，$\sum m\leq 2.5\times 10 ^ 5$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="欧拉回路" scheme="https://mydcwfy.github.io/tags/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"/>
    
    <category term="网络流" scheme="https://mydcwfy.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="图论" scheme="https://mydcwfy.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>2022 联合省选 全题解</title>
    <link href="https://mydcwfy.github.io/2022/12/28/2022-provincal-selection-sol/"/>
    <id>https://mydcwfy.github.io/2022/12/28/2022-provincal-selection-sol/</id>
    <published>2022-12-28T12:03:57.000Z</published>
    <updated>2023-02-06T13:13:15.495Z</updated>
    
    <content type="html"><![CDATA[<p>省选完了直接回去 whk 了，后面逐渐忘了这场比赛，现在校内重做才来改题。</p><span id="more"></span><h3 id="D1T1"><a href="#D1T1" class="headerlink" title="D1T1"></a>D1T1</h3><p>题意：编写一个简化版的 C++ 预处理器，只需要等量全字替换即可，不能无限展开。</p><p>大模拟。注意读入的时候先读一整行再说，比较麻烦。</p><h3 id="D1T2"><a href="#D1T2" class="headerlink" title="D1T2"></a>D1T2</h3><p>题意：给定一棵大小为 $n$ 的树，每个点权值必须在给定区间 $[l_i, r_i]$ 中间。你需要找一条链，并对这条链每个点填上合适的权值使得这条链上最大值和最小值之差不超过 $K$。问有多少种填法，并求出所有填法的权值和。$n\leq 200$，$1\leq l_i \leq r_i\leq 10 ^ 9$，$1\leq K\leq 10 ^ 9$。</p><p>这里只讨论求填法的方法，权值和类似。</p><p>首先考虑一种 $O(na)$ 的做法。考虑简单的容斥，首先定义一段权值区间的 $v(l, r)$ 为任意找一条链并且填入的权值 $\in [l, r]$ 的方案数。那么我们可以把答案写作：$ans = \sum _{r - l = k} v(l, r) - \sum _{r - l = k - 1} v(l, r)$。这个转化为了我们只需要求 $O(a)$ 个区间的 $v(l, r)$。由于确定权值区间之后，每一个点填的方案数是确定的，于是我们可以考虑直接树形 DP，可以做到 $O(n)$ 求一段区间的 $v(l, r)$。于是总复杂度就是 $O(na)$ 的。</p><p>考虑如何甩掉这个 $a$。注意到由于 $r - l$ 不变（对 $k$ 和 $k - 1$ 分别求），我们平移的时候如果 $l, r$ 都没有碰到任何一个 $l_i / r_i$，那么每个点的贡献其实是一个常数或者一个一次函数。那么只要没有碰到，整个问题的答案就是一个 $n$ 次多项式，加上问前缀和，就是 $n + 1$ 次多项式。所以如果这个长度比较长，我们可以询问 $O(n)$ 个区间的答案，然后插值得到这段的答案。</p><p>总复杂度 $O(n ^ 3)$，常数比较大，可能需要卡常。代码见 <a href="https://uoj.ac/submission/596401。">https://uoj.ac/submission/596401。</a></p><h3 id="D1T3"><a href="#D1T3" class="headerlink" title="D1T3"></a>D1T3</h3><p><a href="/2022/12/28/LOJ3702/">到这里看</a>。</p><h3 id="D2T1"><a href="#D2T1" class="headerlink" title="D2T1"></a>D2T1</h3><p>题意：给定 $n$ 个数 $c_i$，$m$ 次询问，每次给出 $cnt_i$ 质数 $p_j$，问有多少种选择数的方案使得这些数的乘积能被所有给出的质数整除，对 998244353 取模。$c_i, p_j\leq 2000$，$n\leq 10 ^ 6$，$m\leq 1500$，$\sum cnt_i\leq 18000$。</p><p>令值域为 $a$。</p><p>首先考虑由于 $&gt;\sqrt a$ 的质数每个数只会有一个，所以我们可以按照大质数分类，每一类中间都至少选一个。</p><p>我们可以考虑 DP，记当前 $f(s)$ 表示小质数的状态为 $s$ 的方案数，然后不存在大质数的可以直接加入进去 DP，对于每个大质数，将他的倍数全部拿出来，容易发现这些数中间至少选一个，可以先不考虑至少选一个把所有加进去，最后在 $f’(s)$ 减去 $f(s)$。</p><p>记 $\pi(x)$ 表示 $x$ 以内的质数个数，这样的复杂度是 $O(2 ^ {\pi (\sqrt a)} am)$，如果我们预处理的话写起来比较麻烦，当然这样的复杂度也足以通过 85pts，如果要通过的话可能需要卡常，代码见 <a href="https://loj.ac/s/1446854。">https://loj.ac/s/1446854。</a></p><p>我们可以考虑容斥，现在相当于对于小质数集合的每一个子集，都需要计算不包含这些小质数（剩下的小质数随意）并且需要包含所有给出的大质数。假设容斥集合为 $t$，相当于是小质数状态需要在 $s = U\oplus t$ 里，我们可以预处理 $f_{p, s}$ 表示大质数是 $p$ 并且小质数状态是 $s$ 子集的个数，对于每一个大质数，$f_{p, s}$ 中间至少选一个，剩下没有大质数限制并且小质数状态在 $s$ 里面的随便选。对于每一个 $t$ 都只需要枚举每个大质数，$f_{p, s}$ 用高维前缀和预处理一下即可，总复杂度 $O(2 ^ {\pi (\sqrt a)} \sum cnt_i + \pi(a)\pi (\sqrt a) 2 ^ {\pi(\sqrt a)})$，可以通过。代码见 <a href="https://loj.ac/s/1659582。">https://loj.ac/s/1659582。</a></p><h3 id="D2T2"><a href="#D2T2" class="headerlink" title="D2T2"></a>D2T2</h3><p><a href="/2022/12/29/LOJ3704/">到这里看</a>。</p><h3 id="D2T3"><a href="#D2T3" class="headerlink" title="D2T3"></a>D2T3</h3><p>题意：有一棵 $n$ 个点的二叉树（每个点有不超过两个儿子），每个点有一个点权 $a_i$，每次可以切断一条边，切断的时候两边会交换点权，代价加上两边点权和。问将所有边切断的最小代价。$n\leq 5000$，$1\leq a_i\leq 10 ^ 9$。</p><p>容易发现对于一棵子树只有外部的一个点会进来参与交换，也只有一个点会被交换出去，那么我们就可以直接设计 DP 状态。记 $f(x, u, i)$ 表示在 $x$ 的子树内部，最后 $u$ 出去交换，交换进来的点会交换 $i$ 次的最小代价。注意我们只计算内部的点在子树内部的交换的代价。</p><p>转移的时候如果有两个儿子，就有 6 种转移方式，当然可以钦定左右的交换顺序，这样就只有 3 种了。记 $fl$ 表示左边的 DP 数组，$fr$ 表示右边的 DP 数组，$f$ 表示父亲的 DP 数组，用 $\to$ 表示 chkmin 操作，大力转移可以得到：</p><script type="math/tex; mode=display">\begin{aligned}fl(u, i) + fr(v, j) + (i + 1)a_x + a_v + (j + 2)a_u &\to  f(v, 0) & [l, r, f]\\fl(u, i) + fr(v, j) + (i + 1)a_x + a_u + a_v & \to f(u, j + 1) & [l, f, r]\\fl(u, i) + fr(v, j) + (j + 2)a_u + a_v &\to f(x, i + 1) & [f, l, r]\end{aligned}</script><p>直接转移可以根据树形背包的复杂度分析，得到 $O(n ^ 4)$，可以通过 28pts。</p><p>注意到上面的转移都可以拆分成独立的形式，这样的话我们实际只需要多枚举几次 2 维的转移即可。这样的话复杂度和状态数等同，都是 $O(n ^ 3)$，卡一下空间可以通过 64pts。代码见 <a href="https://loj.ac/s/1659587。">https://loj.ac/s/1659587。</a></p><p>现在我们关键是优化状态数，当前的状态数是 $O(\sum sz_x deg_x)$ 的。注意到假设 $u$ 是左儿子的节点，那么对应的 $i$ 一定不超过右儿子的深度，那么我们就可以认为这个状态数也是树上背包的复杂度，这样状态数就降为了 $O(n ^ 2)$，同时复杂度也降为了 $O(n ^ 2)$，可以通过。</p><p>实现的时候对于每一个 $f(x, u, *)$ 开一个 <code>std::vector</code> 就好了。写起来非常麻烦，由于 $u$ 是用 dfn 表示的，容易写错。代码见 <a href="https://loj.ac/s/1659692。">https://loj.ac/s/1659692。</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;省选完了直接回去 whk 了，后面逐渐忘了这场比赛，现在校内重做才来改题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LOJ3897 「NOIP2022」喵了个喵</title>
    <link href="https://mydcwfy.github.io/2022/12/28/LOJ3897/"/>
    <id>https://mydcwfy.github.io/2022/12/28/LOJ3897/</id>
    <published>2022-12-28T11:39:02.000Z</published>
    <updated>2022-12-28T12:39:32.137Z</updated>
    
    <content type="html"><![CDATA[<p>题意：有 $m$ 张卡牌分为 $k$ 种，每种都是偶数张，你需要顺次把 $m$ 张放进 $n$ 个栈，如果存在一个栈相邻两个种类相同，那么立刻消去。同时你可以选择两个栈，他们的底部卡牌种类需要相同，然后消去这两张卡牌。要求放完 $m$ 张卡牌过后 $n$ 个栈都是空的。请给出一个构造方案。$m\leq 2\times 10 ^ 6$，$n\leq 300$，$k = 2n - 2$ 或者 $k = 2n - 1$。</p><span id="more"></span><p>首先考虑 $k = 2n - 2$ 的做法。容易发现我们只需要空出一个栈，剩下的每个栈都放不同种类的卡牌，新来一张如果是对应卡牌是在底部的话就放在空栈，在顶部的话就直接可以消去。容易发现这样是一定能消完的。</p><p>现在考虑多一种怎么做。首先一个关键点是我们还是得留出一个空栈，否则底部的 $n - 1$ 种都没法消。那么现在问题在于这 $n - 1$ 个栈已经放了 $2n - 2$ 种类，并且又来了一种新的。</p><p>首先如果他的下一张卡牌是在底部的话，我们直接在这个栈上面放上一个新来的，然后把底部消去即可。同时如果下一张卡牌也是新来的种类的话，我们直接把这两张都放在空栈即可消去。</p><p>上面两种特殊情况提示我们考虑后面卡牌中第一次出现底部种类或者是新来种类的卡牌，注意到中间一定全部是顶部种类。</p><p>如果后面第一次出现是新来种类的话，由于中间全是顶部种类，没必要留空栈，于是我们把新来的种类放在空栈等待消去，其他的顶部种类直接消 / 放即可。</p><p>如果后面第一次出现是底部种类的话，我们直接把新来的种类放在这个栈上面是不好的，因为后面可能出现这个栈的顶部种类无法消去。</p><ol><li>如果这个顶部种类在这段区间中出现了偶数次，我们就把它全部扔在空栈，其他的种类正常消 / 放没有影响。</li><li>如果这个顶部种类在这段区间中出现了奇数次，我们必须把这个栈让开，否则消不掉。注意到这个栈最后会变成空栈，这恰好符合我们的构造。于是我们把新来的种类放在空栈，然后其他的正常消 / 放，最后来的底部种类就会把这个栈变成空栈（因为这个栈的顶部种类已经被消了）。这样我们重新把这个栈看作空栈即可。</li></ol><p>实现的时候会出现一些问题，主要是因为 $O(nm)$ 的时间比较卡，我们用一个队列维护（没有填满并且没有被钦定为是空栈）的栈，由于这些填入造成的修改都是 $O(1)$ 的，所以我们动态维护每个点是否出现，是底部还是顶部种类是可以做到的。实现起来比较繁琐，膜拜场上想出来并写对的神仙。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">read</span>(n, m, k);</span><br><span class="line"><span class="type">int</span> em = n; <span class="comment">// empty stack</span></span><br><span class="line">opt.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">while</span> (!add.<span class="built_in">empty</span>()) add.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i) id[i] = <span class="number">0</span>, ins[i] = dn[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i].<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) add.<span class="built_in">push</span>(i), add.<span class="built_in">push</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="built_in">read</span>(c[i]);</span><br><span class="line"><span class="keyword">auto</span> insert = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line"><span class="keyword">if</span> (ins[x]) &#123;</span><br><span class="line"><span class="keyword">if</span> (dn[x]) &#123;</span><br><span class="line">opt.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, em&#125;);</span><br><span class="line">opt.<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, id[x], em&#125;);</span><br><span class="line">a[id[x]].<span class="built_in">pop_front</span>();</span><br><span class="line">ins[x] = dn[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (a[id[x]].<span class="built_in">size</span>()) dn[a[id[x]].<span class="built_in">front</span>()] = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> opt.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, id[x]&#125;), a[id[x]].<span class="built_in">pop_back</span>(), ins[x] = dn[x] = <span class="literal">false</span>;</span><br><span class="line">add.<span class="built_in">push</span>(id[x]), id[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (add.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="type">int</span> t = add.<span class="built_in">front</span>();</span><br><span class="line">add.<span class="built_in">pop</span>();</span><br><span class="line">dn[x] = !a[id[x] = t].<span class="built_in">size</span>(), ins[x] = <span class="literal">true</span>, a[t].<span class="built_in">push_back</span>(x);</span><br><span class="line">opt.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, t&#125;);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; c[i] &lt;&lt; &quot; Deque\n&quot;;</span></span><br><span class="line"><span class="comment">for (int j = 1; j &lt;= n; ++ j, puts(&quot;&quot;))</span></span><br><span class="line"><span class="comment">for (int x : a[j]) printf(&quot;%d &quot;, x);</span></span><br><span class="line"><span class="comment">fflush(stdout);*/</span></span><br><span class="line"><span class="keyword">if</span> (ins[x = c[i]] || add.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="built_in">insert</span>(x);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> j = i + <span class="number">1</span>, flag = <span class="number">0</span>, t, uc;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= m &amp;&amp; !dn[c[j]] &amp;&amp; c[j] != x) ++ j;</span><br><span class="line"><span class="keyword">if</span> (c[j] == x) &#123;</span><br><span class="line">opt.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, em&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; ++ k) <span class="built_in">insert</span>(c[k]);</span><br><span class="line">opt.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, em&#125;);</span><br><span class="line">i = j;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">t = id[c[j]], uc = a[t].<span class="built_in">back</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; ++ k) flag ^= (c[k] == uc);</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;Flag1 &quot; &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; j &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">opt.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, em&#125;);</span><br><span class="line"><span class="type">int</span> ls = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; ++ k)</span><br><span class="line"><span class="keyword">if</span> (c[k] == uc) ls = k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; ++ k)</span><br><span class="line"><span class="keyword">if</span> (c[k] == uc) &#123;</span><br><span class="line"><span class="keyword">if</span> (k == ls) opt.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, t&#125;);</span><br><span class="line"><span class="keyword">else</span> opt.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, em&#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="built_in">insert</span>(c[k]);</span><br><span class="line">opt.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, t&#125;);</span><br><span class="line">ins[x] = dn[x] = <span class="literal">true</span>, id[x] = em;</span><br><span class="line">ins[c[j]] = ins[uc] = dn[c[j]] = dn[uc] = <span class="literal">false</span>, id[c[j]] = id[uc] = <span class="number">0</span>;</span><br><span class="line">add.<span class="built_in">push</span>(em), a[t].<span class="built_in">clear</span>(), a[em].<span class="built_in">push_back</span>(x);</span><br><span class="line">em = t;</span><br><span class="line">i = j;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;Flag0 &quot; &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; j &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">opt.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, t&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; ++ k)</span><br><span class="line"><span class="keyword">if</span> (c[k] == uc) opt.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, em&#125;);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">insert</span>(c[k]);</span><br><span class="line">opt.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, em&#125;), opt.<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, t, em&#125;);</span><br><span class="line">dn[x] = <span class="literal">false</span>, ins[x] = <span class="literal">true</span>, dn[uc] = <span class="literal">true</span>, id[uc] = id[x] = t;</span><br><span class="line">a[t].<span class="built_in">pop_front</span>(), a[t].<span class="built_in">push_back</span>(x);</span><br><span class="line">ins[c[j]] = <span class="literal">false</span>, id[c[j]] = <span class="number">0</span>;</span><br><span class="line">i = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">write</span>(opt.<span class="built_in">size</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : opt)</span><br><span class="line">        <span class="keyword">if</span> (p.op == <span class="number">1</span>) <span class="built_in">write</span>(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27; &#x27;</span>, p.u, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">write</span>(<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27; &#x27;</span>, p.u, <span class="string">&#x27; &#x27;</span>, p.v, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：有 $m$ 张卡牌分为 $k$ 种，每种都是偶数张，你需要顺次把 $m$ 张放进 $n$ 个栈，如果存在一个栈相邻两个种类相同，那么立刻消去。同时你可以选择两个栈，他们的底部卡牌种类需要相同，然后消去这两张卡牌。要求放完 $m$ 张卡牌过后 $n$ 个栈都是空的。请给出一个构造方案。$m\leq 2\times 10 ^ 6$，$n\leq 300$，$k = 2n - 2$ 或者 $k = 2n - 1$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>NOIp 2022 全题解</title>
    <link href="https://mydcwfy.github.io/2022/12/28/NOIp-2022-sol/"/>
    <id>https://mydcwfy.github.io/2022/12/28/NOIp-2022-sol/</id>
    <published>2022-12-28T10:34:38.000Z</published>
    <updated>2022-12-28T11:59:54.960Z</updated>
    
    <content type="html"><![CDATA[<p>总算有时间来补 NOIp 了。</p><span id="more"></span><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>题意：给定一个 $n\times m$ 的 01 矩阵，问有多少个 1 组成的 <code>C</code> 和 <code>F</code> 图案，对 998244353 取模。$n, m\leq 1000$，$T(T\leq 5)$ 组数据。</p><p><code>C</code> 和 <code>F</code> 是类似的，这里我们只讨论 <code>F</code> 的做法。</p><p>注意到考虑枚举极长的竖段，加上两段向右的 1 连续段。可以先求出每个点向右最长的 1 连续段长度，然后在极长连续段上枚举下面横线的位置，动态维护上面所有向右 1 连续段长度和即可 $O(1)$ 计算。</p><p>枚举极长竖段的总复杂度相当于枚举每一个点，总复杂度就是 $O(nm)$ 的，可以通过。</p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p><a href="/2022/12/28/LOJ3897/">到这里看</a>。</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>题意：给出一个 $n$ 个点 $m$ 条边的无向联通图，选择一些点和一些边，问有多少种选法使得割掉任意一条未选中的边后选择了的点仍然联通，对 $10 ^ 9 + 7$ 取模。$n\leq 5\times 10 ^ 5$，$m\leq 10 ^ 6$。</p><p>只割一条边，那么说明在一个强连通分量里面的是不会不连通的，那么缩点就一定是必要的。</p><p>无向图缩点过后会变成一棵树，现在每个点会有一个点权，如果选择他会乘上 $2 ^ {sz} - 1$，要求选择点和边使得点联通（点不连通的话显然会被割掉）。强连通分量里面的边选不选都没有影响，可以最后乘。</p><p>剩下就是一个树形 DP 的过程了，方法比较多，就说一下我的 DP 办法。记 $f1_x$ 表示在 $x$ 子树内部选择一些点和边（不能不选点），他们的 $\text{lca}$ 在 $x$ 并且联通的方案数，$f2_x$ 表示 $x$ 子树内部选择一些点和边（不能不选点），他们和 $x$ 联通的方案数。注意定义的区别。</p><p>我们计算的时候假设 $f2$ 是可以内部不选点的，新来了一棵子树 $v$，$f2$ 是好更新的，如果内部有点，那么就乘 $f2_v$，否则就是 $v$ 子树内部和 $(x, v)$ 共 $sz_v$ 条边都可以选择，是 $2 ^ {sz_v}$。$f1$ 有两种更新方式，一种是从 $f1_x$ 来，另一种是从 $f2_x$ 和 $f2_v$ 来。注意这个时候不能算重了，$f2_x$ 需要去掉什么点都没选的情况和 $\text{lca}$ 已经在 $x$ 的情况。最后更新完所有子树过后，$f2_x$ 再减去内部不选点的情况。更新答案的时候直接使用 $f1_x$ 然后外部的边任意选即可。</p><p>具体实现可以到 <a href="https://loj.ac/s/1659416">https://loj.ac/s/1659416</a> 看。</p><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>题意：给定两个长度为 $n$ 的序列 $a$ 和 $b$，定义一个区间 $[l, r]$ 的权值为 $\left(\max_{i = l} ^ r a_i\right) \times \left( \max_{i = l} ^ r b_i \right)$。$q$ 次给定一段区间，问这段区间的所有子区间的权值和，对 $2 ^ {64}$ 取模。$n, q\leq 2.5\times 10 ^ 5$。</p><p>最值分治之类的可以过掉大部分随机的数据点，但显然正解不是这个。</p><p>考虑直接扫描线 + 线段树大力做。现在我们对左端点扫描线，对右端点记录历史和，这样的话查询的时候只要在对应左端点的时间查询区间内部的历史和即可。</p><p>单调栈可以动态维护每个节点的 $a$ 和 $b$ 的 $\max$，那么现在扔给线段树的问题就是：</p><ol><li>区间 $a$ 加一个数</li><li>区间 $b$ 加一个数</li><li>区间内部每个位置 $c$ 加上当前位置的 $a\times b$</li></ol><p>改题的时候比较偷懒，就使用的是矩阵维护，具体来说，需要维护区间长度，区间 $a$ 和，区间 $b$ 和，当前区间 $a\times b$ 和，历史区间 $a\times b$ 和 5 个变量。3 种操作都是好用矩阵维护的，不过比较卡常，可能需要一定技巧才能通过，具体可以看 <a href="https://loj.ac/s/1659366。">https://loj.ac/s/1659366。</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;总算有时间来补 NOIp 了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="题解" scheme="https://mydcwfy.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>NOIp 2022 游记</title>
    <link href="https://mydcwfy.github.io/2022/12/27/NOIp-2022/"/>
    <id>https://mydcwfy.github.io/2022/12/27/NOIp-2022/</id>
    <published>2022-12-27T13:44:51.000Z</published>
    <updated>2022-12-28T11:10:49.998Z</updated>
    
    <content type="html"><![CDATA[<p>挂分场，差点送退役……</p><span id="more"></span><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day  0"></a>Day  0</h3><p>NOIp 前的模拟赛分数倒还看的过去，可是 CF / AT 的比赛实在是拉跨，连原来的低分 rating 都保不住，简直离谱。感觉 NOIp 药丸。</p><p>教练也说了前一赛季有 Ag 其实压力还不是很大，心态放平就好了。但总还是有点慌。</p><p>在本校考试，前一天去看了一下机子，没啥问题。本身有场模拟赛（还不是信心赛！），但是直接鸽了，到现在我也不会那场的 T3 T4。</p><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>8：00 就进了考场，结果我们到的时候外校的基本都坐齐了，看样子确实是距离最近的最后到（</p><p>8：10 就下发了压缩包密码，还以为很良心，结果 pdf 还有一层密码，于是接着发呆。</p><p>8：27 左右总算发了 pdf 密码，但是有感觉不差这 3min，就没怎么看题。</p><p>开考后光速浏览题，T1 应该就是一个枚举 1 的极长段计算之类的做法，T2 感觉和 NOIp2020 T3 一类的构造，T3 看样子是一个简单的缩点 + 树形 DP，T4 有点板，没怎么想。</p><p>T2 这个位置放一个神秘构造实属有点离谱，怀疑可能是一个诈骗，虽然 $k = 2n - 2$ 很简单，但是 $k = 2n - 1$ 多出来的一种颜色怎么放感觉都不合适。想过动态调整 $k = 2n - 2$ 种颜色，但是没有保持“每列只有两种颜色”的性质导致怎么都做不出来。</p><p>一下就 10：00 了，可是我一分都还没有。开始有点慌了，于是回去写 T1 T3。T1 虽然没有大样例，但是感觉不容易写挂，于是没拍就跑路了。</p><p>T3 缩点过后的 DP 好像比较难写，改了很久才过掉题面上的两个小样例。但是过掉小样例一下就通过了两个下发样例，一看还是满数据，觉得自己 T3 稳了（伏笔）。</p><p>差不多 10：50 又开始想 T2，因为觉得 T4 可能要很久，然后接下来的半个多小时就在两个题中间来回跳转，期间写了一个 T4 的 $O(nq\log n)$ 的做法，还胡了一个最值分治的做法，可以过所有的 $a$ 随机的部分分。但是怕写不完，于是先写 T2 的随机化。</p><p>由于并不知道随机化的分数，于是随便写了一个单次 $O(nm)$，期望不知道多少次能得出答案的一个做法，由于 T4 还没开写，只好甩了。T4 比较难写，但是由于赛前一天做了一个巨大恶心的猫树分治，写起来比较轻松（这也是为什么没想到线段树 + 单调栈的做法！）。中间一个返回值 <code>unsigned long long</code> 写的 <code>int</code>，差不多 12：50 的时候才调出来。检查了一下文件位置和文件读写就结束了。</p><p>我斜对后是 wjx，赛时没怎么关注他，结果赛后大家纷纷起身的时候还看到监考员围着他的电脑，不知道发生了什么。出来后问他才知道他不清楚 T3 交没交上去，惨惨。他说 300pts 没问题，把我吓一跳，但是这么算来，T2 能有个 20 pts 似乎也能上 300（？</p><p>又和本校同学交流了一会，大家感觉都还行（？），但是下午就得回常规教室了，我因为 CTT 暂时还可以在机房 /jy。</p><p>中午吃完外卖，看到 Inf 有 T3 数据了，光速去测，结果发现只有 40pts！当时觉得是数据有问题，因为我满数据的大样例都过了。结果看到很多人都过了，虽然也有挂成 40pts 并且小范围和我答案一样，但是人不算很多。过了一会水群知道 T3 的大样例是缩点后以 1 开始的链，而我是 <code>dfs(1)</code>，这说明我的代码只能过链！</p><p>当时感觉比较崩溃，因为第一个测的就挂了，但后面开了 T4 过后，发现 84pts 没挂，然后开了 T1 过后也没挂，这样的话在 Inf 就是 $100 + ? + 40 + 84$，虽然离预期目标差一个没挂的 T3，但似乎在全省的排名还算能看过去（？），当 T2 20pts 的话似乎也是 rk10 左右。</p><p>机房几乎全员挂 T1，感觉很离谱，分数视清空情况而定，但也有写假成 $O(n ^ 3)$ 被卡的。我们年级一半的人被 T1 送退役了，惨惨 /ll</p><p>我侥幸没挂 T1，但是 T3 挂成暴力分的事实仍然无法接受，看样子排名和 T2 的分数很有关系。写的比较假，在 Inf 上是 20pts，但是在 Luogu 上竟然有 70 pts？</p><p>晚上就准备 CTT 了，第二天就得去，对 NOIp 不太关心了，至少 T1 没挂，应该不会退役 /cy</p><h3 id="Day"><a href="#Day" class="headerlink" title="Day ?"></a>Day ?</h3><p>官网出成绩了，$100 + 35 + 30 + 84 = 249$，全省 rk12，要是不挂 T3 就 rk1 了 /cy</p><p>尘埃已经落定，这是一些人的退役之战，也是一些人的高光时刻，也是一些人的警醒钟，不管怎样，又过了一年。虽然年年皆是如此，但是物是人非，对于退役的印象更深了 /kel</p><p>CTT 回来遇到疫情，然后补了两周常规，所以现在才有时间写游记，也才有时间来 <a href="/2022/12/28/NOIp-2022-sol/">补题</a>。又是一年省选季，加油！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;挂分场，差点送退役……&lt;/p&gt;</summary>
    
    
    
    
    <category term="游记" scheme="https://mydcwfy.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P8861 线段</title>
    <link href="https://mydcwfy.github.io/2022/11/22/Luogu-P8861/"/>
    <id>https://mydcwfy.github.io/2022/11/22/Luogu-P8861/</id>
    <published>2022-11-22T08:16:29.000Z</published>
    <updated>2022-11-22T11:02:03.365Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一些区间的集合，最开始为空。给出 $q$ 次操作，会给出 $op, l, r$：</p><ol><li>$op = 1$：向集合插入一个新的元素 $[l, r]$。</li><li>$op = 2$：对于集合的每一个元素，如果其与 $[l, r]$ 有交，就改为其与 $[l, r]$ 的交。</li><li>$op = 3$：查询集合中每一个元素与 $[l, r]$ 交的长度的和。</li></ol><p>$[l, r]$ 的长度定义为 $r - l$。部分测试点强制在线。假设 $op = 1, 2, 3$ 的操作次数分别为 $k_1, k_2, k_3$，则有 $k_1, k_2\leq 10 ^ 5, k_3\leq 3\times 10 ^ 5$，$1\leq l\leq r\leq 2\times 10 ^ 5$。</p><span id="more"></span><p>记权值范围为 $m = 2\times 10 ^ 5$。</p><h3 id="Tests-13-17"><a href="#Tests-13-17" class="headerlink" title="Tests 13 - 17"></a>Tests 13 - 17</h3><p>首先注意到中间的一些测试点（$13\sim 17$）是 $1\leq l\leq 10 ^ 5\leq r\leq 2\times 10 ^ 5$，这个启示我们在 $10 ^ 5$ 处给出一个分界线，然后左右分别 <code>chkmin/chkmax</code>，维护信息。</p><p>具体来说，我们维护两个数据结构，插入平凡，修改相当于是对于全局左端点 <code>chkmax</code>，右端点 <code>chkmin</code>。</p><p>直接使用 jls 线段树即可（当然全局 <code>chkmin/chkmax</code> 有其他做法）。现在问题是我们怎么维护区间交的长度和。</p><p>首先考虑我们直接使用 $\min(r_1, r_2) - \max(l_1, l_2)$ 计算所有答案，这个是好计算的，我们使用权值线段树 / 树状数组维护值域区间内个数以及值域区间内和就可以 $O(\log n)$ 查询。</p><p>然后考虑如果 $l_1 &gt; r_2$，本身应该是 0，但是我们会得到 $r_2 - l_1$，所以我们加回来的话需要计算 $&gt; r_2$ 的所有 $l$ 的个数和和。另一边同理。</p><p>据上我们可以得到一个 $O(\log m)$ 修改查询的做法。注意到这个做法只和 $l$ 集合，$r$ 集合相关，和他们如何配对的无关。这个对我们下面的推导是有一定作用的。</p><h3 id="AC-做法"><a href="#AC-做法" class="headerlink" title="AC 做法"></a>AC 做法</h3><p>上面的启示性很强，我们马上可以得到一个做法：使用类似猫树的二区间分治结构，对每个区间都使用这个做法。但是和上面不同的是我们还需要考虑另外一些情况。</p><p>假设插入的是 $[l’, r’]$，我们在一个满足 $l\leq l’\leq mid &lt; r’\leq r$ 的分治区间 $[l, r]$ 插入这个区间。容易发现这个分治区间是确定并且唯一的。插入由于需要动态维护权值树状数组，是 $O(\log m)$ 的。</p><p>考虑如何修改。直接在分治区间上修改，如果 $r’ &gt; mid$，我们需要向右区间递归，当前分治区间所有满足 $r\geq l’$ 的都会被修改成 $[l’, \min(r, r’)]$。得到这个区间我们直接向右区间插入这个区间，注意到这个暴力的均摊复杂度是正确的（每个区间最多向下 $O(\log m)$ 次），所以我们直接在线段树上找出所有右端点 $\geq l’$ 的区间，一个一个修改即可。</p><p>如果当前分治区间满足 $l \leq l’\leq mid &lt; r’\leq r$，那么可以发现和上面的情况类似，我们直接 jls 线段树即可。注意到此时我们不能直接返回，因为他对 $[l, mid]$ 和 $[mid + 1, r]$ 等分治区间还有贡献。由于完全覆盖是不存在贡献的，所以类似线段树的复杂度分析，最多只会访问 $O(\log m)$ 个节点。单次修改均摊是 $O(\log m)$ 的，因为我们需要更新树状数组。</p><p>分析以上复杂度：我们一共有 $O(k_1\log m)$ 次修改，单次修改是 $O(\log m)$ 的，jls 线段树上共有 $O(k_2 \log m)$ 次操作，均摊单次是 $O(\log n + \log m)$ 的。单次查询是 $O(\log m)$ 的。</p><p>于是总复杂度是 $O(k_1 \log ^ 2 m + k_2 \log m(\log n + \log m) + k_3\log m)$ 的，可以通过。</p><p>注意几个细节：</p><ol><li>其实没人写 jls 线段树的罢，因为这个是好用 dsu / 堆 维护的，只是我 vp 的时候只想到了这里 /kk。但是由于线段树的强大，这个题有没有可能扩展到编号过后区间修改呢？</li><li>线段树大小是不固定的，这里我是用的类似 <code>std::vector</code> 的扩容办法，满了就增加一倍的空间。</li><li>注意插入时 $l’ = r’$ 需要特判一下，不然可能 RE/WA。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree1</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="type">int</span> mn, sec, cnt, lt;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;Node&gt; tr;</span><br><span class="line">    <span class="type">int</span> mid, L;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;nl = tr[x &lt;&lt; <span class="number">1</span>], &amp;nr = tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], &amp;rt = tr[x];</span><br><span class="line">        <span class="keyword">if</span> (nl.mn &lt; nr.mn)</span><br><span class="line">            rt.mn = nl.mn, rt.cnt = nl.cnt, rt.sec = std::<span class="built_in">min</span>(nl.sec, nr.mn);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nl.mn &gt; nr.mn)</span><br><span class="line">            rt.mn = nr.mn, rt.cnt = nr.cnt, rt.sec = std::<span class="built_in">min</span>(nr.sec, nl.mn);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rt.mn = nl.mn, rt.cnt = nl.cnt + nr.cnt, rt.sec = std::<span class="built_in">min</span>(nl.sec, nr.sec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tr[x] = &#123;l, r&#125;;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tr[x].mn = a[l], tr[x].sec = INF, tr[x].cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid, a), <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, a);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span> </span>&#123; tr[x].mn += c, tr[x].lt += c; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tr[x].lt) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mnl = tr[x &lt;&lt; <span class="number">1</span>].mn, mnr = tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mn;</span><br><span class="line">        <span class="keyword">if</span> (mnl &lt;= mnr) <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span>, tr[x].lt);</span><br><span class="line">        <span class="keyword">if</span> (mnl &gt;= mnr) <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tr[x].lt);</span><br><span class="line">        tr[x].lt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> pos, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[x].l == tr[x].r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c &lt;= mid) T1[<span class="number">0</span>].<span class="built_in">add</span>(c, <span class="number">1</span>), T1[<span class="number">1</span>].<span class="built_in">add</span>(c, c);</span><br><span class="line">            <span class="keyword">return</span> tr[x].mn = c, <span class="built_in">void</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="built_in">change</span>(x &lt;&lt; <span class="number">1</span> | (pos * <span class="number">2</span> &gt; tr[x].l + tr[x].r), pos, c);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[x].l &gt; r || tr[x].r &lt; l || tr[x].mn &gt;= c) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r &amp;&amp; tr[x].sec &gt; c) &#123;</span><br><span class="line">            T1[<span class="number">0</span>].<span class="built_in">add</span>(tr[x].mn, -tr[x].cnt), T1[<span class="number">1</span>].<span class="built_in">add</span>(tr[x].mn, (LL) -tr[x].cnt * tr[x].mn);</span><br><span class="line">            T1[<span class="number">0</span>].<span class="built_in">add</span>(c, tr[x].cnt), T1[<span class="number">1</span>].<span class="built_in">add</span>(c, (LL) tr[x].cnt * c);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">update</span>(x, c - tr[x].mn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span>, l, r, c), <span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, c);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, std::vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">int</span> lim)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[x].mn &gt; lim) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (tr[x].l == tr[x].r) <span class="keyword">return</span> vec.<span class="built_in">push_back</span>(tr[x].l);</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="built_in">dfs</span>(x &lt;&lt; <span class="number">1</span>, vec, lim), <span class="built_in">dfs</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, vec, lim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[x].l == tr[x].r) <span class="keyword">return</span> tr[x].mn;</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ask</span>(x &lt;&lt; <span class="number">1</span> | (pos * <span class="number">2</span> &gt; tr[x].l + tr[x].r), pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> _l, <span class="type">int</span> _m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mid = _m, L = _l;</span><br><span class="line">        tr.<span class="built_in">resize</span>(a.<span class="built_in">size</span>() * <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, a.<span class="built_in">size</span>() - <span class="number">1</span>, a.<span class="built_in">data</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SegTree1</span>() : <span class="built_in">tr</span>(<span class="number">2</span>, &#123;<span class="number">0</span>, <span class="number">0</span>, INF&#125;), <span class="built_in">mid</span>(<span class="number">0</span>), <span class="built_in">L</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree2</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="type">int</span> mx, sec, cnt, lt;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;Node&gt; tr;</span><br><span class="line">    <span class="type">int</span> mid, R;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;nl = tr[x &lt;&lt; <span class="number">1</span>], &amp;nr = tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], &amp;rt = tr[x];</span><br><span class="line">        <span class="keyword">if</span> (nl.mx &gt; nr.mx)</span><br><span class="line">            rt.mx = nl.mx, rt.cnt = nl.cnt, rt.sec = std::<span class="built_in">max</span>(nl.sec, nr.mx);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nl.mx &lt; nr.mx)</span><br><span class="line">            rt.mx = nr.mx, rt.cnt = nr.cnt, rt.sec = std::<span class="built_in">max</span>(nr.sec, nl.mx);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rt.mx = nl.mx, rt.cnt = nl.cnt + nr.cnt, rt.sec = std::<span class="built_in">max</span>(nl.sec, nr.sec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tr[x] = &#123;l, r&#125;;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tr[x].mx = a[l], tr[x].sec = -INF, tr[x].cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid, a), <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, a);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span> </span>&#123; tr[x].mx += c, tr[x].lt += c; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tr[x].lt) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mxl = tr[x &lt;&lt; <span class="number">1</span>].mx, mxr = tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx;</span><br><span class="line">        <span class="keyword">if</span> (mxl &gt;= mxr) <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span>, tr[x].lt);</span><br><span class="line">        <span class="keyword">if</span> (mxl &lt;= mxr) <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tr[x].lt);</span><br><span class="line">        tr[x].lt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> pos, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[x].l == tr[x].r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c &gt; mid) T2[<span class="number">0</span>].<span class="built_in">add</span>(c, <span class="number">1</span>), T2[<span class="number">1</span>].<span class="built_in">add</span>(c, c);</span><br><span class="line">            <span class="keyword">return</span> tr[x].mx = c, <span class="built_in">void</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="built_in">change</span>(x &lt;&lt; <span class="number">1</span> | (pos * <span class="number">2</span> &gt; tr[x].l + tr[x].r), pos, c);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[x].l &gt; r || tr[x].r &lt; l || tr[x].mx &lt;= c) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r &amp;&amp; tr[x].sec &lt; c) &#123;</span><br><span class="line">            T2[<span class="number">0</span>].<span class="built_in">add</span>(tr[x].mx, -tr[x].cnt), T2[<span class="number">1</span>].<span class="built_in">add</span>(tr[x].mx, (LL) -tr[x].cnt * tr[x].mx);</span><br><span class="line">            T2[<span class="number">0</span>].<span class="built_in">add</span>(c, tr[x].cnt), T2[<span class="number">1</span>].<span class="built_in">add</span>(c, (LL) tr[x].cnt * c);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">update</span>(x, c - tr[x].mx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span>, l, r, c), <span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, c);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, std::vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">int</span> lim)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[x].mx &lt; lim) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (tr[x].l == tr[x].r) <span class="keyword">return</span> vec.<span class="built_in">push_back</span>(tr[x].l);</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="built_in">dfs</span>(x &lt;&lt; <span class="number">1</span>, vec, lim), <span class="built_in">dfs</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, vec, lim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[x].l == tr[x].r) <span class="keyword">return</span> tr[x].mx;</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ask</span>(x &lt;&lt; <span class="number">1</span> | (pos * <span class="number">2</span> &gt; tr[x].l + tr[x].r), pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> _m, <span class="type">int</span> _r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mid = _m, R = _r;</span><br><span class="line">        tr.<span class="built_in">resize</span>(a.<span class="built_in">size</span>() * <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, a.<span class="built_in">size</span>() - <span class="number">1</span>, a.<span class="built_in">data</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SegTree2</span>() : <span class="built_in">tr</span>(<span class="number">2</span>, &#123;<span class="number">0</span>, <span class="number">0</span>, -INF&#125;), <span class="built_in">mid</span>(<span class="number">0</span>), <span class="built_in">R</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, sz;</span><br><span class="line">    SegTree1 T1;</span><br><span class="line">    SegTree2 T2;</span><br><span class="line">&#125; tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x] = &#123;l, r, <span class="number">0</span>, <span class="built_in">SegTree1</span>(), <span class="built_in">SegTree2</span>()&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[x].l == tr[x].r) &#123;</span><br><span class="line">        T1[<span class="number">0</span>].<span class="built_in">add</span>(l, <span class="number">1</span>), T1[<span class="number">1</span>].<span class="built_in">add</span>(l, l), T2[<span class="number">0</span>].<span class="built_in">add</span>(l, <span class="number">1</span>), T2[<span class="number">1</span>].<span class="built_in">add</span>(l, l);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if (l == r) std::cout &lt;&lt; &quot;Insert &quot; &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; &#x27;\n&#x27;, exit(0);</span></span><br><span class="line">    <span class="type">int</span> mid = (tr[x].l + tr[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Insert &quot; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; &#x27; &#x27; &lt;&lt; tr[x].l &lt;&lt; &#x27; &#x27; &lt;&lt; tr[x].r &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> <span class="built_in">insert</span>(x &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> <span class="built_in">insert</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (tr[x].sz &amp; (tr[x].sz - <span class="number">1</span>)) &#123;</span><br><span class="line">        tr[x].T1.<span class="built_in">change</span>(<span class="number">1</span>, tr[x].sz, l), tr[x].T2.<span class="built_in">change</span>(<span class="number">1</span>, tr[x].sz, r);</span><br><span class="line">        tr[x].sz ++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vl</span><span class="params">(tr[x].sz)</span>, <span class="title">vr</span><span class="params">(tr[x].sz)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tr[x].sz; ++ i)</span><br><span class="line">        vl[i] = tr[x].T1.<span class="built_in">ask</span>(<span class="number">1</span>, i), vr[i] = tr[x].T2.<span class="built_in">ask</span>(<span class="number">1</span>, i);</span><br><span class="line">    vl.<span class="built_in">push_back</span>(l), vr.<span class="built_in">push_back</span>(r);</span><br><span class="line">    <span class="type">int</span> bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt;= tr[x].sz) bit ++;</span><br><span class="line">    vl.<span class="built_in">resize</span>(<span class="number">1</span> &lt;&lt; bit, INF), vr.<span class="built_in">resize</span>(<span class="number">1</span> &lt;&lt; bit, -INF);</span><br><span class="line">    tr[x].T1.<span class="built_in">rebuild</span>(vl, tr[x].l, mid), tr[x].T2.<span class="built_in">rebuild</span>(vr, mid, tr[x].r);</span><br><span class="line">    tr[x].sz ++, T1[<span class="number">0</span>].<span class="built_in">add</span>(l, <span class="number">1</span>), T1[<span class="number">1</span>].<span class="built_in">add</span>(l, l), T2[<span class="number">0</span>].<span class="built_in">add</span>(r, <span class="number">1</span>), T2[<span class="number">1</span>].<span class="built_in">add</span>(r, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Modify &quot; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; &#x27; &#x27; &lt;&lt; tr[x].l &lt;&lt; &#x27; &#x27; &lt;&lt; tr[x].r &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="type">int</span> mid = (tr[x].l + tr[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid) &#123;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        tr[x].T1.<span class="built_in">dfs</span>(<span class="number">1</span>, vec, r);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> id : vec) &#123;</span><br><span class="line">            <span class="type">int</span> cl = tr[x].T1.<span class="built_in">ask</span>(<span class="number">1</span>, id), cr = tr[x].T2.<span class="built_in">ask</span>(<span class="number">1</span>, id);</span><br><span class="line">            tr[x].T1.<span class="built_in">change</span>(<span class="number">1</span>, id, INF), tr[x].T2.<span class="built_in">change</span>(<span class="number">1</span>, id, -INF);</span><br><span class="line">            <span class="built_in">insert</span>(x &lt;&lt; <span class="number">1</span>, std::<span class="built_in">max</span>(l, cl), r);</span><br><span class="line">            T1[<span class="number">0</span>].<span class="built_in">add</span>(cl, <span class="number">-1</span>), T1[<span class="number">1</span>].<span class="built_in">add</span>(cl, -cl), T2[<span class="number">0</span>].<span class="built_in">add</span>(cr, <span class="number">-1</span>), T2[<span class="number">1</span>].<span class="built_in">add</span>(cr, -cr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; mid) &#123;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        tr[x].T2.<span class="built_in">dfs</span>(<span class="number">1</span>, vec, l);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> id : vec) &#123;</span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; &quot;Check &quot; &lt;&lt; id &lt;&lt; std::endl;</span></span><br><span class="line">            <span class="type">int</span> cl = tr[x].T1.<span class="built_in">ask</span>(<span class="number">1</span>, id), cr = tr[x].T2.<span class="built_in">ask</span>(<span class="number">1</span>, id);</span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; cl &lt;&lt; &#x27; &#x27; &lt;&lt; cr &lt;&lt; std::endl;</span></span><br><span class="line">            tr[x].T1.<span class="built_in">change</span>(<span class="number">1</span>, id, INF), tr[x].T2.<span class="built_in">change</span>(<span class="number">1</span>, id, -INF);</span><br><span class="line">            <span class="built_in">insert</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, std::<span class="built_in">min</span>(r, cr));</span><br><span class="line">            T1[<span class="number">0</span>].<span class="built_in">add</span>(cl, <span class="number">-1</span>), T1[<span class="number">1</span>].<span class="built_in">add</span>(cl, -cl), T2[<span class="number">0</span>].<span class="built_in">add</span>(cr, <span class="number">-1</span>), T2[<span class="number">1</span>].<span class="built_in">add</span>(cr, -cr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    tr[x].T1.<span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">0</span>, tr[x].sz - <span class="number">1</span>, l), tr[x].T2.<span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">0</span>, tr[x].sz - <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span>, l, r), <span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = T1[<span class="number">0</span>].<span class="built_in">ask</span>(l) * l + T1[<span class="number">1</span>].<span class="built_in">ask</span>(M) - T1[<span class="number">1</span>].<span class="built_in">ask</span>(l);</span><br><span class="line">    res = res * <span class="number">-1</span> + (T2[<span class="number">0</span>].<span class="built_in">ask</span>(M) - T2[<span class="number">0</span>].<span class="built_in">ask</span>(r)) * r + T2[<span class="number">1</span>].<span class="built_in">ask</span>(r);</span><br><span class="line">    res += l * T2[<span class="number">0</span>].<span class="built_in">ask</span>(l) - T2[<span class="number">1</span>].<span class="built_in">ask</span>(l);</span><br><span class="line">    res += T1[<span class="number">1</span>].<span class="built_in">ask</span>(M) - T1[<span class="number">1</span>].<span class="built_in">ask</span>(r) - r * (T1[<span class="number">0</span>].<span class="built_in">ask</span>(M) - T1[<span class="number">0</span>].<span class="built_in">ask</span>(r));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, op, l, r, typ;</span><br><span class="line">    LL ls = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(m, typ);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, M);</span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(op, l, r);</span><br><span class="line">        l = (l + ls * typ) % (M + <span class="number">1</span>), r = (r + ls * typ) % (M + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">insert</span>(<span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) <span class="built_in">modify</span>(<span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ls = <span class="built_in">query</span>(l, r));</span><br><span class="line">        <span class="comment">// printf(&quot;%lld\n&quot;, query(1, M));</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一些区间的集合，最开始为空。给出 $q$ 次操作，会给出 $op, l, r$：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$op = 1$：向集合插入一个新的元素 $[l, r]$。&lt;/li&gt;
&lt;li&gt;$op = 2$：对于集合的每一个元素，如果其与 $[l, r]$ 有交，就改为其与 $[l, r]$ 的交。&lt;/li&gt;
&lt;li&gt;$op = 3$：查询集合中每一个元素与 $[l, r]$ 交的长度的和。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$[l, r]$ 的长度定义为 $r - l$。部分测试点强制在线。假设 $op = 1, 2, 3$ 的操作次数分别为 $k_1, k_2, k_3$，则有 $k_1, k_2\leq 10 ^ 5, k_3\leq 3\times 10 ^ 5$，$1\leq l\leq r\leq 2\times 10 ^ 5$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="线段树" scheme="https://mydcwfy.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="分治" scheme="https://mydcwfy.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>ABC238G Cubic?</title>
    <link href="https://mydcwfy.github.io/2022/11/06/ABC238G/"/>
    <id>https://mydcwfy.github.io/2022/11/06/ABC238G/</id>
    <published>2022-11-06T12:58:45.000Z</published>
    <updated>2022-11-06T13:34:06.973Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定 $n$ 个数的序列，每次询问一段区间的乘积是不是立方数。$n, q\leq 2\times 10 ^ 5$，$A_i\leq 10 ^ 6$，3s。</p><span id="more"></span><p>注意到我们显然需要对每一个质因数都判断一次，看这段区间有多少个该质因子，观察次幂是否是 3 的倍数即可。但是怎么都不好做，大概都是带根号的平衡做法了。</p><p>瓶颈仍然在于我们如何对每个质因子都需要判一边，很浪费时间。于是<strong>考虑 Hash</strong>，我们令一个质因子是 $[0, 2]$ 的任意一个数，然后让和 $\bmod 3$ 的余数看是不是 0。如果不是 0 的话显然答案是 NO。</p><p>注意到一个 NO 在单次判断中被判成 YES 的概率大概是 $\dfrac 13$，于是我们可以考虑判断 $10\sim 15$ 次，这样准确的概率已经极高了。这样就可以通过了，但是可能需要卡常。</p><p>但其实有更好的办法，就是把多位压成一个数，这样就是三进制不进位加法，假设有 $w$ 位的话，容易发现准确率是 $1 - \dfrac 1{3 ^ w}$ 的。这个对应到判断平方就是 xor 操作，同样也是这样。</p><p>于是直接按照这个写，大概分解一下质因数就好了。时间复杂度 $O(n\sqrt n + TQ)$，$T$ 表示判断次数，可以通过。</p><p>场上想的降智办法是找到一个数满足 $x ^ 3\equiv 1\pmod p$，然后对于每一个质因数，任取 $x$ 的几次方作为随机权值，这样的话区间乘积如果不是 1 的话，这个询问是 NO。容易发现其实是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="type">static</span> std::mt19937 <span class="title">rnd</span><span class="params">(std::random_device&#123;&#125;())</span></span>;</span><br><span class="line"><span class="type">int</span> mul = ((<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">8</span>) / <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t; i &lt; cnt; ++ i) &#123;</span><br><span class="line"><span class="keyword">while</span> (std::__gcd(t = <span class="built_in">rnd</span>() % (Mod - <span class="number">1</span>), Mod - <span class="number">1</span>) != <span class="number">1</span>);</span><br><span class="line">rv[i] = <span class="built_in">qpow</span>(<span class="number">13</span>, (LL) mul * t % (Mod - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x, p, id; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">x = a[i], pre[i] = pre[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (x ^ <span class="number">1</span>) &#123;</span><br><span class="line">p = mxp[x];</span><br><span class="line">id = std::<span class="built_in">lower_bound</span>(prime, prime + cnt, p) - prime;</span><br><span class="line"><span class="keyword">while</span> (x % p == <span class="number">0</span>) pre[i] = (LL) pre[i] * rv[id] % Mod, x /= p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; ++ i)</span><br><span class="line">res[i] &amp;= (LL) pre[q[i].r] * <span class="built_in">qpow</span>(pre[q[i].l - <span class="number">1</span>]) % Mod == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sieve</span>();</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; ++ i) res[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;q[i].l, &amp;q[i].r);</span><br><span class="line"><span class="type">int</span> T = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">while</span> (T --) <span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; ++ i) <span class="built_in">puts</span>(res[i] ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定 $n$ 个数的序列，每次询问一段区间的乘积是不是立方数。$n, q\leq 2\times 10 ^ 5$，$A_i\leq 10 ^ 6$，3s。&lt;/p&gt;</summary>
    
    
    
    
    <category term="随机化" scheme="https://mydcwfy.github.io/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"/>
    
    <category term="数论" scheme="https://mydcwfy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="Hash" scheme="https://mydcwfy.github.io/tags/Hash/"/>
    
    <category term="离散对数" scheme="https://mydcwfy.github.io/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF1606F Tree Queries</title>
    <link href="https://mydcwfy.github.io/2022/11/06/CF1606F/"/>
    <id>https://mydcwfy.github.io/2022/11/06/CF1606F/</id>
    <published>2022-11-06T11:42:38.000Z</published>
    <updated>2023-02-06T13:14:46.085Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一棵 $n$ 的点的根为 1 的树，定义一次操作为把 $x$ 的所有儿子接到 $x$ 父亲处，并删除 $x$。$q$ 次询问给定 $u, k$，输出任意操作之后 $son(u) - mk$ 的最大值，$m$ 表示操作次数。$n, q\leq 2 \times 10 ^ 5$，6s。</p><span id="more"></span><p>比较经典，但是没做过，于是 vp 时没有思路……</p><p>首先考虑暴力 DP 的过程，记 $f(u)$ 表示把 $u$ 删除，在删除前的儿子个数（定义比较奇怪？），容易得到转移式：</p><script type="math/tex; mode=display">f(u) = -k + \sum_{v \in son(u)} \max\{1, f(v)\}</script><p>考虑对其进行化简，记 $s_u$ 表示 $u$ 在<strong>原树</strong>上的儿子，然后可以得到：</p><script type="math/tex; mode=display">f(u) = -k + s_u + \sum_{v \in son(u)} \max\{0, f(v) - 1\}</script><p>注意到如果 $f(v) - k - 1 &lt; 0$ 的话，我们可以<strong>认为 $(u, v)$ 不连通</strong>，从而达到对 $0$ 取 $\max$ 的效果。</p><p>现在忽视掉 $\max$ 的话，我们可以写出比较好的形式：</p><script type="math/tex; mode=display">\begin{aligned}f(u) =& -k +  s_u + \sum_{v\in son(u)} (f(v) - 1)\\=& sum_u - (k + 1) sz_u + 1\end{aligned}</script><p>$sum_u$ 表示在<strong>联通树</strong>上在 $u$ 子树内部的<strong>原树</strong>度数和，所以 $sum_u$ 不是 $sz_u - 1$，需要注意。</p><p>根据这个式子，由于 $f(u)$ 要 $\geq 1$ 才会被认为是向父亲连边了，于是我们可以得到 $k\leq \dfrac {sum_u}{sz_u} - 1$ 时 $f(u)$ 相当于是向父亲连边。</p><p>改变联通性过后，$fa(u)\to top(u)$ 的 $sum$ 和 $sz$ 都会发生变化，同理他们的 $k$ 的阈值也会发生变化。但是注意到只有 $top(u)$ 的阈值时受关注的，因为其他点都已经向父亲联通了。修改这个可以使用差分转化为单点加子树查，于是树状数组可以做到 $O(n\log n)$。</p><p>维护所有的阈值只需要用一个 <code>std::priority_queue</code> 维护，计算时将询问按 $k$ 从大到小处理即可。注意 $top(u)$ 联通性改变过后，他的阈值一定是变大，所以没必要删除原来的。复杂度 $O(n\log n)$，轻松通过。</p><p>总结：<strong>树上取 $\max / \min$ 时可以转化为和 0 比较，使用连通性去掉 $\max / \min$。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick</span> &#123;</span><br><span class="line"><span class="type">int</span> tr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Failed&quot;</span>), <span class="built_in">void</span>();</span><br><span class="line"><span class="keyword">for</span> (; x &lt; N; x += (x &amp; -x)) tr[x] += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; x; x ^= (x &amp; -x)) res += tr[x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125; T1, T2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">find</span>(f[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">nw[dfn[x] = ++ *dfn] = x, ::fa[x] = fa, sz[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (v ^ fa) <span class="built_in">dfs</span>(v, x), sz[x] += sz[v];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(Fenwick &amp;T, <span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> T.<span class="built_in">ask</span>(dfn[x] + sz[x] - <span class="number">1</span>) - T.<span class="built_in">ask</span>(dfn[x] - <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[x] || x == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">assert</span>(f[x] == x);</span><br><span class="line"><span class="type">int</span> sz = <span class="built_in">ask</span>(T1, x), sum = <span class="built_in">ask</span>(T2, x), anc;</span><br><span class="line">f[x] = <span class="built_in">find</span>(fa[x]), anc = <span class="built_in">find</span>(x);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;Update &quot; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; sz &lt;&lt; &#x27; &#x27; &lt;&lt; fa[x] &lt;&lt; &#x27; &#x27; &lt;&lt; find(fa[x]) &lt;&lt; std::endl;</span></span><br><span class="line">T2.<span class="built_in">add</span>(dfn[fa[x]], sum), T1.<span class="built_in">add</span>(dfn[fa[x]], sz);</span><br><span class="line"><span class="keyword">if</span> (fa[anc]) T1.<span class="built_in">add</span>(dfn[fa[anc]], -sz), T2.<span class="built_in">add</span>(dfn[fa[anc]], -sum);</span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">ask</span>(T1, anc) &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">ask</span>(T2, anc) &gt;= <span class="number">0</span>);</span><br><span class="line">pq.<span class="built_in">push</span>(&#123;<span class="built_in">ask</span>(T2, anc) / <span class="built_in">ask</span>(T1, anc) - <span class="number">1</span>, anc&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) f[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">g[u].<span class="built_in">push_back</span>(v), g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line">std::cin &gt;&gt; Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;q[i].u, &amp;q[i].k), q[i].id = i;</span><br><span class="line">std::<span class="built_in">sort</span>(q + <span class="number">1</span>, q + Q + <span class="number">1</span>, [&amp;](Query &amp;q1, Query &amp;q2) &#123;</span><br><span class="line"><span class="keyword">return</span> q1.k &gt; q2.k;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">T1.<span class="built_in">add</span>(dfn[i], <span class="number">1</span>), son[i] = g[i].<span class="built_in">size</span>() - (i &gt; <span class="number">1</span>);</span><br><span class="line">T2.<span class="built_in">add</span>(dfn[i], son[i]);</span><br><span class="line"><span class="keyword">if</span> (i ^ <span class="number">1</span>)</span><br><span class="line">T1.<span class="built_in">add</span>(dfn[fa[i]], <span class="number">-1</span>), T2.<span class="built_in">add</span>(dfn[fa[i]], -son[i]), pq.<span class="built_in">push</span>(&#123;son[i] - <span class="number">1</span>, i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= Q; ++ i) &#123;</span><br><span class="line"><span class="keyword">while</span> (!pq.<span class="built_in">empty</span>() &amp;&amp; pq.<span class="built_in">top</span>().first &gt;= q[i].k)</span><br><span class="line">x = pq.<span class="built_in">top</span>().second, pq.<span class="built_in">pop</span>(), <span class="built_in">update</span>(x);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;Query &quot; &lt;&lt; q[i].u &lt;&lt; &#x27; &#x27; &lt;&lt; q[i].k &lt;&lt; &#x27; &#x27; &lt;&lt; ask(T1, q[i].u) &lt;&lt; &#x27; &#x27; &lt;&lt; ask(T2, q[i].u) &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">res[q[i].id] = <span class="built_in">ask</span>(T2, q[i].u) - (q[i].k + <span class="number">1</span>) * <span class="built_in">ask</span>(T1, q[i].u) + <span class="number">1</span> + q[i].k;</span><br><span class="line"><span class="comment">// res[q[i].id] = std::max(res[q[i].id], (int) g[q[i].u].size() - 1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定一棵 $n$ 的点的根为 1 的树，定义一次操作为把 $x$ 的所有儿子接到 $x$ 父亲处，并删除 $x$。$q$ 次询问给定 $u, k$，输出任意操作之后 $son(u) - mk$ 的最大值，$m$ 表示操作次数。$n, q\leq 2 \times 10 ^ 5$，6s。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DP 及其优化" scheme="https://mydcwfy.github.io/tags/DP-%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="树相关" scheme="https://mydcwfy.github.io/tags/%E6%A0%91%E7%9B%B8%E5%85%B3/"/>
    
    <category term="并查集" scheme="https://mydcwfy.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>CSP-S 2022 游记</title>
    <link href="https://mydcwfy.github.io/2022/10/30/CSP-S-2022/"/>
    <id>https://mydcwfy.github.io/2022/10/30/CSP-S-2022/</id>
    <published>2022-10-30T14:13:36.000Z</published>
    <updated>2022-10-31T05:38:12.048Z</updated>
    
    <content type="html"><![CDATA[<p>中规中矩的一场……</p><span id="more"></span><h3 id="Day-inf"><a href="#Day-inf" class="headerlink" title="Day -inf"></a>Day -inf</h3><p>初赛 92，过了。为啥错的全是排序的题啊，看来排序得重修了！</p><p>报上名了，结果缴费就遇上服务器更新，还以为钱被吞了……</p><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>回顾整个 CSP 的备战过程，感觉很多事情都没有做到位，比如认真改题，总结并复习之类的，一天陷入了 做题 - 摆烂 - 讲题或听讲 的死循环了。特别是考前的几天又加入了同学互相展示讲课的过程，直接将整个一天填的满满当当，这直接导致我 AT 和 CF 在 10.21 过后除了 CF 10.23 的比赛外再没有提交，感觉降智严重，于是有预感 CSP 要寄。另外打 CF 连 *2000 都无法下手了，要是我拿这小于 2000 的水准考 CSP，显然会寄 /ll</p><p>但是不知怎么的，又没有感到紧张，反而一天颓得严重。这是怎么回事呢？我也不清楚，有一种说不出来的感觉。</p><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>2：30 在本校考试为啥要 1：30 就到啊！</p><p>发呆了一会看到 dottle 来了，又闲聊了一会。他们也是人渐稀疏啊，高二的似乎只有 2 个，去年 NOIp 可是我们考场 1-7 的座位都是他们学校的呢。</p><p>进去了就也是什么都做不了，连聊天的时间都没有了，所以为啥这么多人 2 点就进考场啊！</p><p>看到下发文件和密码 <code>belief2022</code>，但想起我省选的经历，这次坚决不先动键盘，坐等 2：30，应该不差这几分钟吧（flag）。</p><p>一开题，发现 T1 上来很神秘，T2 取最大最小直接秒了，T3 神秘基环树，发现只需要判断每个点出度是不是 1，T4 感觉很可做，但暂时不会。</p><p>想了一会 T3 一点不会，发现自己 T2 做法假了，又想想，发现取 $\geq 0$ 的最小值和 $\leq 0$ 的最大值，随便分讨即可。预估要 6 个 ST 表，等会再写。</p><p>回过头来想 T1，发现 5 元环 $1\to A\to B\to C\to D\to 1$ 枚举 $B\to C$ 即可把 5 元环枚举分到 $O(n ^ 2)$。又想了一会 T3，还是不会，于是 3：40 开始写 T1 和 T2，结果 ST 表写错了（，大概 4：20 写完。</p><p>先看了会 T4，发现随机是好做的，因为 $k\leq 2$ 只有链上的点有用，$k = 3$ 也只有链上和旁边最小点是有意义的。再一想就是一个显然的 $(\min, +)$ 矩阵，但是没想到倍增，以为动态 DP 只能使用树剖。</p><p>于是本场最大的决定来了：我决定猛冲 T3，不做 T4，因为虽然 T3 60pts 是显然的，但同样 T4 76pts 也是显然的，T3 想出来了可能很简洁，T4 即使我会也要写很久，还会因为写挂、卡常等问题挂分。于是我先做 T3。</p><p>然后直到 5：30 我一直在想，结果一点都不会 T3，意识到 T4 也时间不够了，于是光速写完 T3 60pts，反过来写 T4。</p><p>先把 $k = 3$ 的随机数据写了，一直过不了样例，发现 DP 写假的地方比较多，6：00 左右才调对。感觉不能倍增，于是 $k = 3$ 还 2log 不是很可过，开始写 $k = 2$ 的树剖。当我做下这个决定时已经 6：10 了，可想而知什么都写不出来，检查了一会，竟然发现了一个 <code>freopen</code> 打错了！！</p><p>但是在 6：28 的时候我猛然发现 $k = 2$ 至少是可以倍增维护的，虽然我已经写完了矩阵乘法，但是没有用了。要是我早点开题又是怎样的结局呢？</p><p>出来过后讨论了一下，发现大家都不怎么会 T3，T4 知道怎么做也写不完。看样子就是拼挂分的情况了！</p><p>回去冷静了一下发现 $k = 3$ 也是可以倍增维护的，那么 $O(k ^ 3 n\log n)$ 的复杂度就很可过了。不过已是后话了。</p><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>T3 怎么是随机权值判断啊！！没怎么做过这种题呢。</p><p>看游记知道 dottle AK 了，非常厉害。一问一车人 AK 了，感觉寄了。</p><p>Luogu 和 InfOJ 都没挂，$100 + 100 + 60 + 76 = 336$。</p><p>看到了 InfOJ 的榜，感觉很恐怖，336 连 BJ 的前 20 都进不去，属于是输麻了。</p><p>确实又感觉最近的状态比较差，打 CF Div1 直接垫底，平常 sb 题都做不出来了。究其原因还是太摆了，希望 NOIp 不再是这样了吧。</p><p>祝自己加油！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;中规中矩的一场……&lt;/p&gt;</summary>
    
    
    
    
    <category term="游记" scheme="https://mydcwfy.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF Educational Round#137</title>
    <link href="https://mydcwfy.github.io/2022/10/24/CF-Round-Edu137/"/>
    <id>https://mydcwfy.github.io/2022/10/24/CF-Round-Edu137/</id>
    <published>2022-10-24T00:20:23.000Z</published>
    <updated>2022-10-30T14:10:44.705Z</updated>
    
    <content type="html"><![CDATA[<p>没去打，赛后就做了 EFG 三个题。</p><span id="more"></span><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：有两把激光枪，冷却时长分别为 $t_1, t_2$，攻击力为 $p_1, p_2$，你需要攻击一个护盾为 $s$，血量为 $h$ 的怪兽，每次可以任意选择一些已冷却的激光枪射击，注意护盾可以抵挡 $s$ 的伤害。求至少需要的时间。$2\leq p_1, p_2\leq 5000$，$h\leq 5000$，$s&lt; \min(p_1, p_2)$，$t_1, t_2\leq 10 ^ {12}$。</p><p>显然比 F 难……</p><p>注意到一个特殊的地方在于 $t$ 很大，但是 $h, p_1, p_2$ 都很小。考虑按此 DP。</p><p>首先我们考虑用两把枪可能有哪些组合。假设我们最后需要把两把枪一起射，我们可以以此为分界点（因为这个点后面相当于冷却时间又从头开始）。一个暴力的想法是我们枚举下一次同时发射的时间，但显然是不好的。注意到贡献伤害的分界线只有 $t_1$ 的倍数和 $t_2$ 的倍数。于是考虑枚举这两个的倍数的时间，那么此时假设我们可以射 $c_1$ 次第一把，$c_2$ 次第二把，那么既然射击的次数已经确定了，我们可以直接计算总伤害了。</p><p>于是我们现在就考虑 DP：记 $f(i)$ 表示达到伤害 $i$ 至少需要多少时间。按照刚才我们确定伤害的方式，我们枚举 $t_1$ 的倍数和 $t_2$ 的倍数，在这些时间下我们考虑转移。</p><p>单次转移是 $O(h)$ 的，状态数也是 $O(h)$，于是总复杂度为 $O(h ^ 2)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= h; ++ i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j1 = <span class="number">1</span>; ; ++ j1) &#123;</span><br><span class="line">LL nxt = i + j1 * (p1 - s) + t1 * j1 / t2 * (p2 - s);</span><br><span class="line"><span class="keyword">if</span> (j1 * t1 &gt;= t2) nxt += s;</span><br><span class="line"><span class="built_in">chkmin</span>(nxt, h);</span><br><span class="line"><span class="built_in">chkmin</span>(dp[nxt], dp[i] + j1 * t1);</span><br><span class="line"><span class="keyword">if</span> (nxt == h) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j2 = <span class="number">1</span>; ; ++ j2) &#123;</span><br><span class="line">LL nxt = i + j2 * (p2 - s) + t2 * j2 / t1 * (p1 - s) + s;</span><br><span class="line"><span class="built_in">chkmin</span>(nxt, h);</span><br><span class="line"><span class="built_in">chkmin</span>(dp[nxt], dp[i] + j2 * t2);</span><br><span class="line"><span class="keyword">if</span> (nxt == h) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：有 $n$ 条线段 $[l_i, r_i]$，定义 $S_i$ 表示之间的所有整数。有 $\cup, \cap, \oplus$ 分别表示集合并，集合交，集合对称差。计算将 $\texttt{op}_i$ 任意替换后下列式子的和。</p><script type="math/tex; mode=display">\mid(((S_1 \texttt{op} _1 S_2) \texttt{op} _2 S_3)... \texttt {op} _{n - 1} S_n)\mid</script><p>注意计算得到集合的大小之和。$0\leq n, l_i, r_i\leq 3\times 10 ^ 5$，$n\geq 2$。</p><p>容易发现这是一个扫描线模型，显然我们关键的问题是给定一个 01 序列，问有多少种填入运算符的方式满足得到的答案为 1。</p><p>注意到一个点的贡献方法和他左半部分计算得到的东西有关，于是我们考虑 DP，用 $f(i, c)$ 表示前 $i$ 个计算后得到结果为 $c$ 的方案数，转移直接看 3 中运算符后能得到什么即可。这个 DP 可以考虑用矩阵来描述，于是动态修改一个位置是 0 还是 1 的时候直接将对应的矩阵填入线段树即可。</p><p>注意第一个位置可能需要特殊处理，不能用矩阵描述。时间复杂度 $O(n\log n)$，可以通过，怕常数大的话用 ZKW 就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; <span class="keyword">operator</span> [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> a[x]; &#125;</span><br><span class="line"><span class="built_in">Matrix</span>() : a&#123;&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">I</span><span class="params">()</span> </span>&#123; a[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">Matrix <span class="keyword">operator</span> *(Matrix b) <span class="type">const</span> &#123;</span><br><span class="line">Matrix c;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : &#123;<span class="number">0</span>, <span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j : &#123;<span class="number">0</span>, <span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k : &#123;<span class="number">0</span>, <span class="number">1</span>&#125;)</span><br><span class="line">c[i][k] = (c[i][k] + (LL) a[i][j] * b[j][k]) % Mod;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">&#125; m0, m1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ZKW_Sgt</span> &#123;</span><br><span class="line">Matrix a[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; a[x] = a[x &lt;&lt; <span class="number">1</span>] * a[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">len = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (len &lt;= n) len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">2</span> &amp;&amp; i &lt;= n) a[i + len] = m0;</span><br><span class="line"><span class="keyword">else</span> a[i + len].<span class="built_in">I</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i; -- i) <span class="built_in">pushup</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, Matrix c)</span> </span>&#123;</span><br><span class="line">a[x += len] = c;</span><br><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">1</span>) <span class="built_in">pushup</span>(x &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; seg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line">m0[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">3</span>, m0[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>, m0[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">m1[<span class="number">0</span>][<span class="number">0</span>] = m1[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>, m1[<span class="number">0</span>][<span class="number">1</span>] = m1[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">seg.<span class="built_in">build</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, l + i, r + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">stl[l[i]].<span class="built_in">push_back</span>(i), edr[r[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> id : stl[i]) seg.<span class="built_in">update</span>(id, m1);</span><br><span class="line"><span class="built_in">upd</span>(res, seg.a[<span class="number">1</span>][i &gt;= l[<span class="number">1</span>] &amp;&amp; i &lt;= r[<span class="number">1</span>]][<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; seg.a[1][i &gt;= l[1] &amp;&amp; i &lt;= r[1]][1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> id : edr[i]) seg.<span class="built_in">update</span>(id, m0);</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p>题意：定义斐波那契串为 $f_0 = \texttt 0, f_1 = \texttt 1, f_i = f_{i - 1} + f_{i - 2}$，$+$ 表示拼接。定义 $g(s)$ 表示合法的划分方式使得每一个串都不是斐波那契串。先给定 $n$ 个字符串 $s_i$，求 $g(s_1)$，$g(s_1 + s_2)$，……。答案对 998244353 取模。$n\leq 3\times 10 ^ 3$，$|s_i|\leq 10 ^ 3$，12s，4MB。</p><p>假设我们不考虑神秘的空间限制怎么做。直接考虑容斥，记 $f(i)$ 表示前缀 $i$ 的答案。直接考虑容斥是 $\tilde O((\sum s_i) ^ 2)$ 的，不好。注意到除了 $f_0$ 以外，$f_{i - 1}$ 都是 $f_i$ 的前缀。于是我们可以考虑维护一个当前仍然是斐波那契串的前缀的一些转移位置。在数据范围内，我们可以用爆搜或者是之类的可以得到这样的转移位置是不超过 $O(\log \sum s_i)$ 的。</p><p>于是我们可以考虑直接维护所有满足是斐波那契串前缀的转移位置并判断当前是不是斐波那契串，这样直接做是 $O(\sum s_i \log ^ 2 \sum s_i)$，精细实现也可以做到 1log。</p><p>现在再来考虑卡空间。我们只能维护斐波那契串的前 $3\times 10 ^ 6$ 个字符，然后转移的时候需要我们只需要维护当前前缀的 dp 值，其他的都没必要。这样我们就不需要其他的空间来维护了。</p><p>这样大概能卡过空间了，注意不能使用 <code>std::string</code>，直接 MLE。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fib[<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>, fib[<span class="number">2</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="type">int</span> sz = <span class="number">2</span>, ls = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (sz &lt; (<span class="type">int</span>) <span class="number">3e6</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ls &amp;&amp; i + sz &lt;= (<span class="type">int</span>) <span class="number">3e6</span>; ++ i) fib[i + sz] = fib[i];</span><br><span class="line"><span class="type">int</span> tmp = sz + ls;</span><br><span class="line">ls = sz, sz = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isfib</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (c &lt; x) &#123;</span><br><span class="line">a = b, b = c, c = a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">append</span><span class="params">(<span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (fib[val[i].first + <span class="number">1</span>] == ch) nxt[++ tmp] = &#123;val[i].first + <span class="number">1</span>, val[i].second&#125;;</span><br><span class="line">std::<span class="built_in">swap</span>(tot, tmp), std::<span class="built_in">swap</span>(nxt, val);</span><br><span class="line"><span class="type">int</span> cur = sum;</span><br><span class="line"><span class="built_in">adj</span>(cur -= ls);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isfib</span>(val[i].first)) <span class="built_in">adj</span>(cur -= val[i].second);</span><br><span class="line"><span class="built_in">adj</span>(sum += cur - Mod);</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;1&#x27;</span>) val[++ tot] = &#123;<span class="number">1</span>, ls&#125;;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; ch &lt;&lt; &#x27; &#x27; &lt;&lt; tot &lt;&lt; &#x27; &#x27; &lt;&lt; cur &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">return</span> ls = cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;没去打，赛后就做了 EFG 三个题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CF" scheme="https://mydcwfy.github.io/tags/CF/"/>
    
    <category term="做题记录" scheme="https://mydcwfy.github.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>ARC125E Snack</title>
    <link href="https://mydcwfy.github.io/2022/10/22/ARC125E/"/>
    <id>https://mydcwfy.github.io/2022/10/22/ARC125E/</id>
    <published>2022-10-22T06:12:03.000Z</published>
    <updated>2022-10-22T06:41:07.228Z</updated>
    
    <content type="html"><![CDATA[<p>题意：有 $n$ 种零食，每种零食有 $a_i$ 片，有 $m$ 个小孩，每种小孩每种零食最多拿 $b_i$ 片（$b_i$ 只和小孩相关），一共不能超过 $c_i$ 片。问最多能拿走的零食片。$n, m\leq 2\times 10 ^ 5$，$a_i, c_i\leq 10 ^ {12}$，$b_i\leq 10 ^ 7$。</p><span id="more"></span><p>首先容易得到一个网络流的做法：$S$ 向每一个零食连边，流量为 $a_i$；零食 $i$ 想小孩 $j$ 连边，流量为 $b_j$；小孩 $j$ 向 $T$ 连边，流量为 $c_j$。</p><p>但是这这种办法的空间过于庞大，无法建出网络流。考虑我们<strong>模拟网络流的过程</strong>，尝试找到最大流。</p><p>首先一个性质就是<strong>将最大流转化为最小割</strong>。我们考虑左部点中有 $x$ 个与 $S$ 联通，按照割的定义，右边的 $m$ 个点要么和 $T$ 割开，要么和左边的 $x$ 个点都割开。前面一种方案的代价是 $c_j$，后面一种方案的代价是 $x\times b_j$。这两个需要取 $\min$，那么我们考虑一个分段的一次函数，分别维护斜率和截距即可。</p><p>容易发现后面的贡献只和 $x$ 的大小有关，和左边到底哪些和 $S$ 联通无关。于是我们直接对整个 $a$ 数组排序，选取前 $n - x$ 个与 $S$ 断开即可。</p><p>除开排序，我们很容易用前缀和在 $O(n + m)$ 的时间内解决原问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, b + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, c + i);</span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">k[<span class="number">1</span>] += b[i];</span><br><span class="line"><span class="keyword">if</span> ((t = (c[i] + b[i] - <span class="number">1</span>) / b[i]) &lt;= n)</span><br><span class="line">k[t] -= b[i], st[t] += c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) k[i] += k[i - <span class="number">1</span>], st[i] += st[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">auto</span> get = [&amp;](<span class="type">int</span> s) &#123; <span class="keyword">return</span> k[s] * s + st[s]; &#125;;</span><br><span class="line">LL res = <span class="number">5e18</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">res = std::<span class="built_in">min</span>(res, <span class="built_in">get</span>(n - i) + (sum += a[i]));</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：有 $n$ 种零食，每种零食有 $a_i$ 片，有 $m$ 个小孩，每种小孩每种零食最多拿 $b_i$ 片（$b_i$ 只和小孩相关），一共不能超过 $c_i$ 片。问最多能拿走的零食片。$n, m\leq 2\times 10 ^ 5$，$a_i, c_i\leq 10 ^ {12}$，$b_i\leq 10 ^ 7$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络流" scheme="https://mydcwfy.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="贪心" scheme="https://mydcwfy.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="堆" scheme="https://mydcwfy.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>ABC273Ex Inv(0,1)ving Insert(1,0)n</title>
    <link href="https://mydcwfy.github.io/2022/10/18/ABC273H/"/>
    <id>https://mydcwfy.github.io/2022/10/18/ABC273H/</id>
    <published>2022-10-18T13:10:05.000Z</published>
    <updated>2023-02-06T13:14:46.217Z</updated>
    
    <content type="html"><![CDATA[<p>题意：定义对序列 $A$（$A$ 包含整数二元组）操作一次为如下操作：选定任意两个相邻的二元组 $(a, b)$ 和 $(c, d)$，在他们中间插入 $(a + c, b + d)$。定义一个二元组序列的价值为从 $A = \{(0, 1), (1, 0)\}$ 开始至少要操作多少次才能包含序列中的所有二元组。如果无法的话价值就是 0。现给定一个长度为 $n$ 的二元组序列 $T$，问所有连续子序列的价值和，对 998244353 取模。$n\leq 10 ^ 5$，$a, b\leq 10 ^ 9$。</p><span id="more"></span><p>首先注意到这个的操作方式和 <a href="https://oi-wiki.org/math/number-theory/stern-brocot/#stern-brocot-%E6%A0%91">Stern-Brocot 树</a> 的构造方式是一样的，那么直接在这棵树上做似乎是一个不错的选择。</p><p>那么根据该树的性质，我们容易得到一个二元组有两种情况是无法得到的：</p><ol><li>$\gcd(a, b) \neq 1$</li><li>$a = 0\lor b = 0$</li></ol><p>那么我们相当于现在是划分为一段一段的分别做，每一段内都是合法的状态，然后不同段之间的显然贡献都为 0。现在就处理掉了没有贡献的区间。</p><p>现在我们考虑按照该树的构造办法，我们于是可以这么拆贡献：对于该树上的每一个节点 $[\dfrac ab, \dfrac cd]$（可能 $d$ 为 0，不太严谨，就是 $+\infty$ 的意思），我们考虑要生成 $\dfrac {a + c}{b + d}$ 需要被多少个子串所需要。</p><p>一个充要条件是如果一个子串中存在一个 $\dfrac pq$ 满足 $\dfrac ab &lt; \dfrac pq &lt; \dfrac cd$，那么就需要 $\dfrac {a + c}{b + d}$。那么，我们需要统计所有满足分数在 $(\dfrac ab, \dfrac cd)$ 之间的位置。这样的话就是容易容斥计算的。</p><p>这样直接做复杂度是不对的，应为单次统计至少需要 $O(len)$，$len$ 为在这个区间之间的分数个数。首先我们直接考虑分治下去，将 $[\dfrac ab, \dfrac {a + c}{b + d}]$ 和 $[\dfrac {a + c}{b + d}, \dfrac cd]$ 的答案分别算出来，然后可以启发式合并一下，将少的合并到多的上，用 <code>std::set</code> 维护并动态统计答案，假设每次都有分支的话，复杂度就是 $O(n\log ^ 2 n)$ 的。</p><p>然后我们再来处理假设区间内部的所有数都在 $\dfrac {a + c}{b + d}$ 的一边怎么办。一个极端的情况就是 $(10 ^ 9, 1)$，我们不得不递归 $10 ^ 9$ 层才能找到他。这样显然是不好的，于是我们可以考虑二分一个 $k$ 满足不是所有数都在 $\dfrac {a + kc}{b + kd}$（或者是 $\dfrac {ka + c}{kb + d}$，看在哪一边）的一边。注意到我们相当于在树上是一次跳了 $k$ 层，于是最后的答案要 $\times k$。</p><p>于是总复杂度就是 $O(n\log ^ 2 n + n\log a)$，可以通过。实际实现的时候二分的 $k$ 差一两个是没有问题的，效率如何没测试过（<del>因为我的 $k$ 好像就少 1</del>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Frac</span> &#123;</span><br><span class="line">LL x, y;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">Frac <span class="keyword">operator</span> +(Frac t) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;x + t.x, y + t.y&#125;; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(Frac t) <span class="type">const</span> &#123; <span class="keyword">return</span> (s128) x * t.y &lt; (s128) y * t.x; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &gt;(Frac t) <span class="type">const</span> &#123; <span class="keyword">return</span> (s128) x * t.y &gt; (s128) y * t.x; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> ==(Frac t) <span class="type">const</span> &#123; <span class="keyword">return</span> x == t.x &amp;&amp; y == t.y; &#125;</span><br><span class="line">Frac <span class="keyword">operator</span> *(LL t) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;x * t, y * t&#125;; &#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> iter = s[id].<span class="built_in">insert</span>(x).first;</span><br><span class="line"><span class="type">int</span> y = *std::<span class="built_in">prev</span>(iter), z = *std::<span class="built_in">next</span>(iter);</span><br><span class="line">ans[id] = (ans[id] + (LL) (z - x) * (x - y)) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, Frac lf, Frac rf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= n &amp;&amp; a[l] == lf) l ++;</span><br><span class="line"><span class="keyword">while</span> (r &amp;&amp; a[r] == rf) r --;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[r] &lt; lf + rf) &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>, y = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt; y) &#123;</span><br><span class="line"><span class="type">int</span> mid = (x + y + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (lf * mid + rf &gt; a[r]) x = mid;</span><br><span class="line"><span class="keyword">else</span> y = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">rf = rf + lf * (x - <span class="number">1</span>), cnt = x;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[l] &gt; lf + rf) &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>, y = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt; y) &#123;</span><br><span class="line"><span class="type">int</span> mid = (x + y + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (lf + rf * mid &lt; a[l]) x = mid;</span><br><span class="line"><span class="keyword">else</span> y = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">lf = lf + rf * (x - <span class="number">1</span>), cnt = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x = l, y = r + <span class="number">1</span>, mL, mR;</span><br><span class="line"><span class="keyword">while</span> (x &lt; y) &#123;</span><br><span class="line"><span class="type">int</span> mid = (x + y) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid] &lt; lf + rf) x = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> y = mid;</span><br><span class="line">&#125;</span><br><span class="line">mL = x, x = l - <span class="number">1</span>, y = r;</span><br><span class="line"><span class="keyword">while</span> (x &lt; y) &#123;</span><br><span class="line"><span class="type">int</span> mid = (x + y + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid] &gt; lf + rf) y = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> x = mid;</span><br><span class="line">&#125;</span><br><span class="line">mR = x;</span><br><span class="line"><span class="comment">// Equal (a + c) / (b + d) range</span></span><br><span class="line"><span class="type">int</span> lc = <span class="built_in">solve</span>(l, mL - <span class="number">1</span>, lf, lf + rf), rc = <span class="built_in">solve</span>(mR + <span class="number">1</span>, r, lf + rf, rf);</span><br><span class="line"><span class="keyword">if</span> (s[lc].<span class="built_in">size</span>() &gt; s[rc].<span class="built_in">size</span>()) std::<span class="built_in">swap</span>(lc, rc);</span><br><span class="line"><span class="keyword">if</span> (rc == <span class="number">1</span>) s[rc = ++ tot] = &#123;<span class="number">0</span>, n + <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> t : s[lc])</span><br><span class="line"><span class="keyword">if</span> (t &gt;= <span class="number">1</span> &amp;&amp; t &lt;= n) <span class="built_in">insert</span>(rc, t);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> t = mL; t &lt;= mR; ++ t) <span class="built_in">insert</span>(rc, a[t].id);</span><br><span class="line">res = (res + (LL) ans[rc] * cnt) % Mod;</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">(std::vector&lt;Frac&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">res = <span class="number">0</span>;</span><br><span class="line">n = vec.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) a[i + <span class="number">1</span>] = vec[i], a[i + <span class="number">1</span>].id = i + <span class="number">1</span>;</span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">s[<span class="number">1</span>] = &#123;<span class="number">0</span>, n + <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">solve</span>(<span class="number">1</span>, n, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;), res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：定义对序列 $A$（$A$ 包含整数二元组）操作一次为如下操作：选定任意两个相邻的二元组 $(a, b)$ 和 $(c, d)$，在他们中间插入 $(a + c, b + d)$。定义一个二元组序列的价值为从 $A = \{(0, 1), (1, 0)\}$ 开始至少要操作多少次才能包含序列中的所有二元组。如果无法的话价值就是 0。现给定一个长度为 $n$ 的二元组序列 $T$，问所有连续子序列的价值和，对 998244353 取模。$n\leq 10 ^ 5$，$a, b\leq 10 ^ 9$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="复杂度分析" scheme="https://mydcwfy.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
    <category term="启发式合并" scheme="https://mydcwfy.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
    <category term="分治" scheme="https://mydcwfy.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="二分" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>CF1515H Phoenix and Bits</title>
    <link href="https://mydcwfy.github.io/2022/10/15/CF1515H/"/>
    <id>https://mydcwfy.github.io/2022/10/15/CF1515H/</id>
    <published>2022-10-14T23:34:21.000Z</published>
    <updated>2022-10-15T00:58:04.113Z</updated>
    
    <content type="html"><![CDATA[<p>题意：维护一个集合 $a$，最开始有 $n$ 个元素，有 $m$ 次操作或者询问：</p><ol><li>将 $a_i\in [l, r]$ 的值全部与 $x$。</li><li>将 $a_i\in [l, r]$ 的值全部或 $x$。</li><li>将 $a_i\in [l, r]$ 的值全部异或 $x$。</li><li>询问在 $[l, r]$ 中有多少个不同的 $a_i$。</li></ol><p>$n\leq 2\times 10 ^ 5$，$m\leq 10 ^ 5$，$0\leq a_i &lt; 2 ^ {20}$。</p><span id="more"></span><p>进阶 01 Trie 的模板题。</p><h3 id="寻找一段区间"><a href="#寻找一段区间" class="headerlink" title="寻找一段区间"></a>寻找一段区间</h3><p>类似于 FHQ Treap 的 split 一样，我们考虑在 $[l, r]$ 之间分离出一段 $[x, y]$。此时考虑 $mid$ 在 $[x, y]$ 的位置，向左右递归即可。节点 split 直接新建即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!u || !tr[u].sz) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (bit &lt; <span class="number">0</span> || (l == <span class="number">0</span> &amp;&amp; r == <span class="number">2</span> * (<span class="number">1</span> &lt;&lt; bit) - <span class="number">1</span>)) &#123;</span><br><span class="line">x = u;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; u &lt;&lt; &#x27; &#x27; &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; &#x27; &#x27; &lt;&lt; bit &lt;&lt; &#x27; &#x27; &lt;&lt; tr[u].sz &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="built_in">pushdown</span>(u, bit);</span><br><span class="line"><span class="keyword">if</span> (l &gt;= mid)</span><br><span class="line">y = u, <span class="built_in">split</span>(tr[u].s[<span class="number">1</span>], tr[x = ++ tot].s[<span class="number">1</span>], tr[u].s[<span class="number">1</span>], l ^ mid, r ^ mid, bit - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r &lt; mid)</span><br><span class="line">y = u, <span class="built_in">split</span>(tr[u].s[<span class="number">0</span>], tr[x = ++ tot].s[<span class="number">0</span>], tr[u].s[<span class="number">0</span>], l, r, bit - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// if (l == 0 &amp;&amp; r == mid * 2 - 1) return x = u, void();</span></span><br><span class="line">x = u, y = ++ tot;</span><br><span class="line"><span class="built_in">split</span>(tr[u].s[<span class="number">0</span>], tr[u].s[<span class="number">0</span>], tr[y].s[<span class="number">0</span>], l, mid - <span class="number">1</span>, bit - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">split</span>(tr[u].s[<span class="number">1</span>], tr[u].s[<span class="number">1</span>], tr[y].s[<span class="number">1</span>], <span class="number">0</span>, r ^ mid, bit - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushup</span>(x), <span class="built_in">pushup</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并两棵子树"><a href="#合并两棵子树" class="headerlink" title="合并两棵子树"></a>合并两棵子树</h3><p>没什么好讲的，注意到了叶子节点只能保留一个信息即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;MERGE &quot; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; &#x27; &#x27; &lt;&lt; bit &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">if</span> (!x || !tr[x].sz) <span class="keyword">return</span> y;</span><br><span class="line"><span class="keyword">if</span> (!y || !tr[y].sz) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">if</span> (bit &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; tr[x].val &lt;&lt; &#x27; &#x27; &lt;&lt; tr[y].val &lt;&lt; std::endl;</span></span><br><span class="line"><span class="built_in">assert</span>(!tr[x].sz || !tr[y].sz || tr[x].val == tr[y].val);</span><br><span class="line"><span class="keyword">return</span> tr[x].sz ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(x, bit), <span class="built_in">pushdown</span>(y, bit);</span><br><span class="line">tr[x].s[<span class="number">0</span>] = <span class="built_in">merge</span>(tr[x].s[<span class="number">0</span>], tr[y].s[<span class="number">0</span>], bit - <span class="number">1</span>);</span><br><span class="line">tr[x].s[<span class="number">1</span>] = <span class="built_in">merge</span>(tr[x].s[<span class="number">1</span>], tr[y].s[<span class="number">1</span>], bit - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pushup</span>(x), x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对全局-xor"><a href="#对全局-xor" class="headerlink" title="对全局 xor"></a>对全局 xor</h3><p>我们考虑对于一棵子树全部 xor 怎么做。因为我们已经有 <code>split</code> 了，所以这个操作可以支持区间做。</p><p>这个可以使用懒标记实现。因为子树的节点个数并没有发生改变，而只是对于一些节点的左右儿子交换即可。这个节点的所有信息都可以在不递归子树的情况下 $O(1)$ 维护。</p><p>具体有哪些信息呢？我们目前只需要维护左右儿子、懒标记和不同的数的个数，都很简单，就不讲了。</p><h3 id="对全局-or"><a href="#对全局-or" class="headerlink" title="对全局 or"></a>对全局 or</h3><p>全局 or 是不好做的，因为我们可能合并节点之类的。虽然总结点个数是 $O((n + m)\log a)$ 的，但是我们并不好判断一棵子树内部有没有需要合并的节点。</p><p>首先如果全局 or 在一定情况下可以变成全局 xor，这样不会减少节点，所以我们为了保证复杂度，不能递归。容易发现这个的成立条件是在给定 or 的每一位上全局要么全是 1，要么全是 0。我们考虑记录全局的 or $v_1$ 和全局补集的 or $v_2$（将所有数取反的 or），那么判断条件可以写作 $[(v_2\odot x)\odot v_1 = 0]$（$\odot$ 表示与运算）。另外，此时我们相当于要对全局 xor 上 $v_2\odot x$。</p><p>否则的话，我们至少会出现一个节点的合并，这个时候我们再考虑递归。如果当前节点左右儿子都存在，并且我们这一位会 or 上 1，那么我们可以先将左儿子的所有值 xor 上 $2 ^ {bit}$，然后直接将左右儿子都合并到右儿子即可。</p><p>这个时候再反过去在 xor 的时候维护一下 or 和补集的 or，注意到如果 or 和补集的 or 都包含某一位的话，怎么 xor 这一位都是 1。拆位做一下就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">allxor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> bit, <span class="type">int</span> lt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> v = tr[x].val, lv = tr[x].lval;</span><br><span class="line"><span class="keyword">if</span> (lt &gt;&gt; bit &amp; <span class="number">1</span>) std::<span class="built_in">swap</span>(tr[x].s[<span class="number">0</span>], tr[x].s[<span class="number">1</span>]);</span><br><span class="line">tr[x].val = (v ^ lt) | (v &amp; lv &amp; lt);</span><br><span class="line">tr[x].lval = (lv ^ lt) | (v &amp; lv &amp; lt);</span><br><span class="line">tr[x].lt ^= lt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x || !tr[x].lt || !tr[x].sz) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">allxor</span>(tr[x].s[<span class="number">0</span>], bit - <span class="number">1</span>, tr[x].lt), <span class="built_in">allxor</span>(tr[x].s[<span class="number">1</span>], bit - <span class="number">1</span>, tr[x].lt);</span><br><span class="line">tr[x].lt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allor</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> bit, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!u || !tr[u].sz) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> add = val &amp; tr[u].lval;</span><br><span class="line"><span class="keyword">if</span> (!(add &amp; tr[u].val)) <span class="keyword">return</span> <span class="built_in">allxor</span>(u, bit, add);</span><br><span class="line"><span class="built_in">pushdown</span>(u, bit);</span><br><span class="line"><span class="type">int</span> mid = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">if</span> (val &amp; mid)</span><br><span class="line"><span class="built_in">allxor</span>(tr[u].s[<span class="number">0</span>], bit - <span class="number">1</span>, mid),</span><br><span class="line">tr[u].s[<span class="number">1</span>] = <span class="built_in">merge</span>(tr[u].s[<span class="number">0</span>], tr[u].s[<span class="number">1</span>], bit - <span class="number">1</span>), tr[u].s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">allor</span>(tr[u].s[<span class="number">0</span>], bit - <span class="number">1</span>, val), <span class="built_in">allor</span>(tr[u].s[<span class="number">1</span>], bit - <span class="number">1</span>, val);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对全局-and"><a href="#对全局-and" class="headerlink" title="对全局 and"></a>对全局 and</h3><p>容易发现 $v\odot x = \neg(\neg v |x)$，那么就可以拆分成 or 和 xor 操作。这个就好做了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于一共只有 $O((n + m)\log a)$ 个节点，我们花费 $O(\log a)$ 的时间可以永久删除一个点，所以复杂度时 $O((n + m)\log ^ 2a)$ 的，可以通过。</p><p>由于笔者也是第一次也这种代码，出了很多神秘错误，大概列几点可能常见的：</p><ol><li>计算低位的时候，不管 xor 还是 or 都不能只把 $x$ 的低位传下去，因为需要维护子树的值相关的信息。</li><li>由于 <code>split</code> 时可能出现里面一个数都没有的节点，操作时需要特判一下，比如把所有判断空节点都写成 <code>!tr[u].sz</code>。</li><li>注意 or 判断改为 xor 时的判断条件要准确，因为小样例测不出来。</li></ol><p>只放主函数了，调用的函数上面基本出现了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), <span class="built_in">insert</span>(x);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, typ, l, r, v, x, y; i &lt;= m; ++ i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;typ, &amp;l, &amp;r);</span><br><span class="line"><span class="built_in">split</span>(rt, x, y, l, r, <span class="number">19</span>);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;RANGE &quot; &lt;&lt; tr[x].sz &lt;&lt; &#x27; &#x27; &lt;&lt; tr[x].val &lt;&lt; &#x27; &#x27; &lt;&lt; tr[x].lval &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="keyword">if</span> (typ == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tr[x].sz);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (typ == <span class="number">3</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v), <span class="built_in">allxor</span>(x, <span class="number">19</span>, v);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (typ == <span class="number">2</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v), <span class="built_in">allor</span>(x, <span class="number">19</span>, v);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v), <span class="built_in">allxor</span>(x, <span class="number">19</span>, U), <span class="built_in">allor</span>(x, <span class="number">19</span>, U ^ v), <span class="built_in">allxor</span>(x, <span class="number">19</span>, U);</span><br><span class="line">rt = <span class="built_in">merge</span>(y, x, <span class="number">19</span>);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;ALL &quot; &lt;&lt; tr[rt].sz &lt;&lt; &#x27; &#x27; &lt;&lt; tr[rt].val &lt;&lt; &#x27; &#x27; &lt;&lt; tr[x].lval &lt;&lt; &quot;\n\n&quot;;</span></span><br><span class="line"><span class="comment">// exit(0);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：维护一个集合 $a$，最开始有 $n$ 个元素，有 $m$ 次操作或者询问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将 $a_i\in [l, r]$ 的值全部与 $x$。&lt;/li&gt;
&lt;li&gt;将 $a_i\in [l, r]$ 的值全部或 $x$。&lt;/li&gt;
&lt;li&gt;将 $a_i\in [l, r]$ 的值全部异或 $x$。&lt;/li&gt;
&lt;li&gt;询问在 $[l, r]$ 中有多少个不同的 $a_i$。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$n\leq 2\times 10 ^ 5$，$m\leq 10 ^ 5$，$0\leq a_i &amp;lt; 2 ^ {20}$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Trie" scheme="https://mydcwfy.github.io/tags/Trie/"/>
    
    <category term="位运算" scheme="https://mydcwfy.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="复杂度分析" scheme="https://mydcwfy.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>LOJ6736 「2020 集训队论文」最小连通块</title>
    <link href="https://mydcwfy.github.io/2022/10/13/LOJ6736/"/>
    <id>https://mydcwfy.github.io/2022/10/13/LOJ6736/</id>
    <published>2022-10-13T11:56:00.000Z</published>
    <updated>2022-10-13T12:23:44.347Z</updated>
    
    <content type="html"><![CDATA[<p>题意：<strong>交互题</strong>。给出一棵树的点数 $n$，你每次询问可以给出一个点集 $S$ 和一个点 $x$，可以得到 $x$ 是否在点集 $S$ 的最小连通块中，需要还原出树。$n = 1000$，你最多可以询问 22000 次。求构造方案。</p><span id="more"></span><p>这个题的做法有很多，我们切入一个比较简单并且易懂的角度。</p><p>首先我们考虑如果我们已经知道了这棵树的拓扑序后怎么做。注意此时我们需要定义一个根，然后每条边从儿子指向父亲。简单来说就是父亲的拓扑序在儿子的后面。</p><p>注意到我们在拓扑序上枚举到了 $x$，我们求它的所有后代。容易发现它的所有后代都是在它前面的，并且除了 $x$ 的儿子以外，其他的点都已经被这种方式覆盖过了。这给我们一个区分儿子和后代的办法：拿到所有的后代后，直接在拓扑序中把这些点删除，这样后面就不会再遍历到这些点了。那么我们就可以保证，现在拿到的所有的点都满足是 $x$ 的儿子。这样做下去，容易发现询问复杂度是 $O(n\log n)$ 的，因为遍历到一个点就会把他删除，遍历到点的过程可以二分查找前半段是否存在 $x$ 的后代，所以就是 $O(n\log n)$ 的。</p><p>那么现在问题就转化成了求树的拓扑序。假设我们当前 $S$ 集合里面的点都没有放进拓扑序，我们要把 $x$ 子树内全部放进去。做法比较神秘，我们考虑找到一个 $S$ 内部并且在 $x$ 子树内部的点 $y$，然后先将 $y$ 子树内部的点放进拓扑序（注意到 $y$ 子树内部的点一定在 $x$ 前面），$S$ 集合对应更新。我们这样做的话，显然是一定会把 $x$ 子树内部的所有点全部都放进拓扑序。最后放 $x$，这样的话就可以完成构造拓扑序。</p><p>考虑分析一下上述算法的复杂度。注意到每一个 $x$ 都只会被遍历一次（不挂其子树内是什么），找到一个 $x$ 的后代的过程同样可以二分，于是询问复杂度也是 $O(n\log n)$ 的。</p><p>综上，我们可以在询问复杂度 $O(n\log n)$ 的时间内完成，时间复杂度可以较容易地做到 $O(n ^ 2)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) s.<span class="built_in">size</span>(); ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s[i] == x) <span class="keyword">return</span> s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i), <span class="built_in">void</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; s, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask</span>(s, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">del</span>(x);</span><br><span class="line">    <span class="keyword">while</span> (s.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">query</span>(s, x))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">query</span>(&#123;s.<span class="built_in">data</span>(), s.<span class="built_in">data</span>() + mid&#125;, x)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> y = s[l - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">solve</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    ord.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">work</span>(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) s.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = ord[i];</span><br><span class="line">        <span class="keyword">while</span> (vec.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">query</span>(vec, x)) &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">1</span>, r = vec.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">query</span>(&#123;vec.<span class="built_in">data</span>(), vec.<span class="built_in">data</span>() + mid&#125;, x)) r = mid;</span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; &quot;Find &quot; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; vec[l - 1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;x, vec[l - <span class="number">1</span>]&#125;), vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + l - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; res.size() &lt;&lt; &#x27; &#x27; &lt;&lt; ord.size() &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：&lt;strong&gt;交互题&lt;/strong&gt;。给出一棵树的点数 $n$，你每次询问可以给出一个点集 $S$ 和一个点 $x$，可以得到 $x$ 是否在点集 $S$ 的最小连通块中，需要还原出树。$n = 1000$，你最多可以询问 22000 次。求构造方案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="复杂度分析" scheme="https://mydcwfy.github.io/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
    <category term="交互" scheme="https://mydcwfy.github.io/tags/%E4%BA%A4%E4%BA%92/"/>
    
    <category term="二分" scheme="https://mydcwfy.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>ARC150D Removing Gacha</title>
    <link href="https://mydcwfy.github.io/2022/10/12/ARC150D/"/>
    <id>https://mydcwfy.github.io/2022/10/12/ARC150D/</id>
    <published>2022-10-12T00:04:45.000Z</published>
    <updated>2022-10-12T00:25:31.944Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定 $n$ 个点的树，定义一个点是好的当且仅当它和它的所有祖先都是黑色的，从所有点都是白点开始，任选一个不好的点染成黑色，问期望染多少次使得所有都是黑色。$n\leq 2\times 10 ^ 5$，对 998244353 取模。</p><span id="more"></span><p>非常 nb 的期望题，做了一整场 /cy</p><p>和题解角度不同，我们考虑每个点的时候，需要考虑它没被祖先覆盖的概率，然后再在它的子树内部任意选，直到选到这个点为止。容易发现我们如果没选在子树内部的话，根据期望的线性性，我们可以把不同子树之间的答案直接加就好了。</p><p>首先考虑在它的子树内部任意选的期望。因为子树的根是没有被选中的，所以所有点都是不好的点，那么期望就是 $sz(x)$ 能选中子树的根。</p><p>然后考虑它没被祖先覆盖的概率。我们不管其他节点，我们现在只关心我们选到了 $x$ 以及所有祖先的情况。这个相当于是我们把所有祖先都染成黑色了，但是 $x$ 没被碰到。</p><p>有一个好点的限制比较烦，但是注意到我们选择好点对概率是没有影响的。所以我们相当于是不管好不好，所有点都是随机一个选择。这样的话，所有点是等价的，那么 $x$ 没被碰到相当于是 $x$ 被最后选到，概率就是 $\dfrac 1{dep(x)}$。</p><p>于是我们可以得到答案为 $\displaystyle \sum_{i = 1} ^ n \dfrac {sz(x)}{dep(x)}$。直接计算即可，时间复杂度 $O(n)$ 或者 $O(n\log a)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x ^ <span class="number">1</span>) dep[x] = dep[fa[x]] + <span class="number">1</span>;</span><br><span class="line">sz[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : g[x]) <span class="built_in">dfs</span>(v), sz[x] += sz[v];</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; dep[x] &lt;&lt; &#x27; &#x27; &lt;&lt; sz[x] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">res = (res + (LL) <span class="built_in">qpow</span>(dep[x] + <span class="number">1</span>) * sz[x]) % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定 $n$ 个点的树，定义一个点是好的当且仅当它和它的所有祖先都是黑色的，从所有点都是白点开始，任选一个不好的点染成黑色，问期望染多少次使得所有都是黑色。$n\leq 2\times 10 ^ 5$，对 998244353 取模。&lt;/p&gt;</summary>
    
    
    
    
    <category term="树相关" scheme="https://mydcwfy.github.io/tags/%E6%A0%91%E7%9B%B8%E5%85%B3/"/>
    
    <category term="期望" scheme="https://mydcwfy.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>ABC272F Two Strings</title>
    <link href="https://mydcwfy.github.io/2022/10/12/ABC272F/"/>
    <id>https://mydcwfy.github.io/2022/10/12/ABC272F/</id>
    <published>2022-10-11T23:44:34.000Z</published>
    <updated>2022-10-12T00:03:25.867Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定两个长度为 $n$ 的字符串 $S, T$，定义 $f(S, i)$ 表示将前 $i$ 个字符放在最后得到的字符串，问有多少个 $(i, j)(0\leq i, j &lt;n)$ 满足 $f(S, i)\leq f(T, j)$。$n\leq 2\times 10 ^ 5$，$S, T$ 仅由小写英文字符构成。</p><span id="more"></span><p>场上没做出来，靠 G 的随机化才上了分……</p><p>我们尝试把 $S, T$ 拼在一起，然后把 $f(S, i)\leq f(T, j)$ 设置为整个字符串内部的某些后缀的大小关系。经过构造可以这样：</p><script type="math/tex; mode=display">S + S + \texttt a ^ n + T + T + \texttt z ^ n</script><p>首先两倍是很显然的，因为我们需要把前 $i$ 个拼到最后面，复制一遍显然是比较好的选择。如果 $f(S, i) &lt; f(T, j)$，那么在新字符串中，他们对应的后缀一定满足小于关系。如果 $f(S, i) = f(T, j)$ 的话，容易发现他们一定会跳过本身的 $S, T$，而变成 $\tt a, z$ 的比较了。那么也就是说新的字符串，我们只需要比较新的字符串中 $S, T$ 区间的大小关系。</p><p>这个怎么做呢？其实我场上想到这了，但是没想到这是一个 SA 板子 /kk。直接做就好了，复杂度 $O(n\log n)$ 或者 $O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> m = <span class="number">2</span> * n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[i] = s[i + n] = a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[++ m] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[i + m] = s[i + n + m] = b[i];</span><br><span class="line">m += <span class="number">2</span> * n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[++ m] = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"><span class="built_in">get_sa</span>(s);</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, cnt = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line"><span class="keyword">if</span> (sa[i] &lt;= n) cnt ++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sa[i] &gt; <span class="number">3</span> * n &amp;&amp; sa[i] &lt;= <span class="number">4</span> * n) res += cnt;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题意：给定两个长度为 $n$ 的字符串 $S, T$，定义 $f(S, i)$ 表示将前 $i$ 个字符放在最后得到的字符串，问有多少个 $(i, j)(0\leq i, j &amp;lt;n)$ 满足 $f(S, i)\leq f(T, j)$。$n\leq 2\times 10 ^ 5$，$S, T$ 仅由小写英文字符构成。&lt;/p&gt;</summary>
    
    
    
    
    <category term="构造" scheme="https://mydcwfy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="字符串" scheme="https://mydcwfy.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="后缀数据结构" scheme="https://mydcwfy.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
