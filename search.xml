<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>万能欧几里得简介</title>
      <link href="/2022/05/19/Universal-Euclidean/"/>
      <url>/2022/05/19/Universal-Euclidean/</url>
      
        <content type="html"><![CDATA[<p>经典的下取整求和，一般不能使用数论分块等（因为被除数不固定）。</p><span id="more"></span><p>使用类欧几里得的模板题吧（为什么不讲类欧呢？因为感觉没什么用……）。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>题意：求<br>$$<br>\sum_{i = 0} ^ n \left\lfloor\dfrac{ai + b}c \right\rfloor<br>$$<br>$T \leq 10 ^ 5, a, b, c, n\leq 10 ^ 9, c\not= 0$。</p><p>看到如此庞大的数据范围，大概率是对数做法了。</p><p>将其放在坐标系下，我们可以看作 $y = \dfrac{ax + b}c$，定义这个直线生成的字符串为：越过一个 $x$ 整点，则加一个 <code>R</code>，越过一个 $y$ 整点，则加一个 <code>U</code>，遇到同时的整点先 <code>U</code> 后 <code>R</code>。容易发现这样下去答案一定只和这个字符串有关。</p><p>比如对于这个，我们计算答案，即为：遇到 <code>U</code> 则 <code>cnt ++</code>，遇到 <code>R</code> 就 <code>res += cnt</code>。</p><p>考虑合并两个已经计算好的答案，我们尝试使用一个结构体维护，容易发现答案需要和前面的 <code>U</code> $cntu$，后面 <code>R</code> 的个数 $cntr$，前后的答案，那么我们可以合并这两个的答案。具体可以写作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="keyword">operator</span> *(Node a, Node b)</span><br><span class="line">&#123;</span><br><span class="line">Node res;</span><br><span class="line"><span class="built_in">adj</span>(res.u = a.u + b.u - Mod), <span class="built_in">adj</span>(res.r = a.r + b.r - Mod);</span><br><span class="line">res.ans = (a.ans + b.ans + <span class="built_in">LL</span>(a.u) * b.r) % Mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们现在需要做的事情就是将整个序列拆开，最后合并答案。首先我们定义最开始单次向右 <code>R</code> 的结构体 <code>fr</code> 和单次向上 <code>U</code> 的结构体 <code>fu</code>，这样就可以最后合并得到答案。</p><p>令最开始的答案为 <code>f(a, b, c, n, fu, fr)</code>，其中 <code>fu</code> 表示向上走一步所乘的结构体，<code>fr</code> 表示向右走一步要成的结构体。注意这里可能不再是开始递归进入的 <code>fu, fr</code></p><p>首先我们考虑第一种情况 $a\geq c$，于是可以将 $a\geq c$ 的变为 $a &lt; c$，具体的，每次 <code>R</code> 前面相当于多加入了 $\left\lfloor\dfrac ac \right\rfloor$ 个 <code>U</code>，那么我们可以直接写作 <code>f(a % c, b, c, n, fu, qpow(fu, a / c) * fr)</code>，<code>qpow</code> 表示快速幂。</p><p>那么现在我们需要考虑的就是 $a &lt; c$ 的情况。一个初步的想法是我们现在 $y = \dfrac{ax + b}c$ 的斜率是小于 1 的，我们可以将 $x, y$ 交换一下，将 <code>fu, fr</code> 交换一下，这样就可以将斜率变为大于 1 的情况，从而可以继续递归。</p><p>我们显然可以变形为 $x = \dfrac{cy - b}{a}$（为了清楚，这里只是对式子进行了变形，没有把 $x, y$ 交换）。但是我们需要注意有 <code>U</code> 和 <code>R</code> 的优先级的问题。比如下图：</p><img src="/2022/05/19/Universal-Euclidean/%E7%BF%BB%E8%BD%AC%E5%9B%BE1.png" class=""><p>原来的线经过了 $(1, 1)$，是先 <code>U</code> 后 <code>R</code>，但是翻转之后，变成了先 <code>R</code> 后 <code>U</code>，所以我们需要将这条线向右平移 $\dfrac 1a$ 个单位，这样就是先 <code>U</code> 后 <code>R</code>，对应上了原来的字符串。</p><p>于是我们现在需要计算的就是 $x = \dfrac{cy - b - 1}a$ 的答案。注意我们现在这个的定义域是 $(0, n]$，即我们需要计算最开始的 <code>fu</code> 贡献，但不计算最开始 <code>fr</code> 的贡献。所以可以得到 $b$ 是属于 $[0, c - 1]$ 的。</p><p>回到上面那张图，我们发现 $(0, 1]$ 的部分的答案是不完整的，我们不能直接扔给下一个算，那么前面所经过的 $\left\lfloor\dfrac{c - b - 1} a \right\rfloor$ 个 <code>fu</code> 是需要提前乘入的，另外还有一个 <code>fr</code>。</p><p>然后我们考虑 $(1, \left\lfloor\dfrac{an + b}c \right\rfloor]$ 这段区间如何计算。容易发现这就是我们需要递归的部分，但是注意，我们计算的定义域是 $(0, n]$，所以需要我们向左平移一个单位得到 $x = \dfrac{cy + c - b - 1}{a}$，所以应该递归到 <code>f(c, c - b - 1, a, m - 1, fr, fu)</code>（$m = \left\lfloor\dfrac{an + b}c \right\rfloor$）。</p><p>最后我们需要考虑 $y &gt; m, x\leq n$，这样我们转化一下就是 $x\in (\left\lfloor\dfrac{cm - b - 1}a \right\rfloor, n]$，容易发现我们需要乘上 <code>qpow(fu, n - (c * m - b - 1) / a)</code>。</p><p>那么我们就可以得到最后的 <code>AsGcd</code> 代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">AsGcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> n, Node fu, Node fr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b %= c;</span><br><span class="line"><span class="keyword">if</span> (a &gt;= c) <span class="keyword">return</span> <span class="built_in">AsGcd</span>(a % c, b, c, n, fu, <span class="built_in">qpow</span>(fu, a / c) * fr);</span><br><span class="line">LL m = (<span class="built_in">LL</span>(a) * n + b) / c;<span class="comment">// y = (cx - b - 1) / a</span></span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">qpow</span>(fr, n);<span class="comment">// all is fr</span></span><br><span class="line">std::<span class="built_in">swap</span>(fu, fr);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">qpow</span>(fu, (c - b - <span class="number">1</span>) / a) * fr <span class="comment">// solving x in [0, 1]</span></span><br><span class="line">* <span class="built_in">AsGcd</span>(c, c - b - <span class="number">1</span>, a, m - <span class="number">1</span>, fu, fr) <span class="comment">// solving x in (1, m]</span></span><br><span class="line">* <span class="built_in">qpow</span>(fu, n - (c * m - b - <span class="number">1</span>) / a) <span class="comment">// solving x in [m, m + 1), notice that y_max = n</span></span><br><span class="line">;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似欧几里得算法，得到时间复杂度 $O(\log(a + c))$，不过常数比较大。</p><p>最后递归的时候，注意到 0 是被包含进入答案的，所以递归前，我们要先乘上 <code>qpow(fu, b / c) * fr</code>。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>给定 $a, b, c, l$ 和 $n\times n$ 的矩阵 $A, B$，求：<br>$$<br>\sum_{i = 1} ^ l A ^ {i} B ^ {\lfloor\frac{ai + b}{c} \rfloor}<br>$$<br>$a, b, c, \lfloor\dfrac{al + b}{c}\rfloor\leq 10 ^ {18}$。</p><p>通过这个题，我们就可以看出万能欧几里得的优势：只需要将上面的模板记住（或手推），然后处理一下信息的合并即可。这相对于类欧几里得优化了许多，思维量减小了不少。</p><p>看这个题，如果我们需要合并两个已经计算好的信息，我们需要维护 $A ^ x$，这就是后面的答案需要乘在前面的；然后还需要维护 $B ^ {\lfloor\frac {ax + b}c \rfloor}$，这个需要乘在答案的中间，这和乘在最后没有区别。</p><p>于是我们需要维护三个信息，而这三个信息是可以用 $O(n ^ 3)$ 时间合并的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">Matrix cntx, cnty, ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node <span class="keyword">operator</span> *(Node a, Node b)</span><br><span class="line">&#123;</span><br><span class="line">a.ans += a.cntx * b.ans * a.cnty;</span><br><span class="line">a.cnty = a.cnty * b.cnty, a.cntx = a.cntx * b.cntx;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们套用前面的计算方法<del>直接复制</del>，得到这份代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">AsGcd</span><span class="params">(LL a, LL b, LL c, LL n, Node fu, Node fr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b %= c;</span><br><span class="line"><span class="keyword">if</span> (a &gt;= c) <span class="keyword">return</span> <span class="built_in">AsGcd</span>(a % c, b, c, n, fu, <span class="built_in">qpow</span>(fu, a / c) * fr);</span><br><span class="line">LL m = ((s128) a * n + b) / c;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">qpow</span>(fr, n);</span><br><span class="line">std::<span class="built_in">swap</span>(fu, fr);</span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">qpow</span>(fu, (c - b - <span class="number">1</span>) / a) * fr * <span class="built_in">AsGcd</span>(c, c - b - <span class="number">1</span>, a, m - <span class="number">1</span>, fu, fr)</span><br><span class="line">* <span class="built_in">qpow</span>(fu, n - ((s128) c * m - b - <span class="number">1</span>) / a);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们需要考虑的就是一个 <code>U</code> 和一个 <code>R</code> 分别产生什么影响。</p><p>一个 <code>U</code> 会使得 <code>cnty ++</code>，而 $cntx$ 不变；一个 <code>R</code> 会使得 <code>cntx ++</code>，<code>ans += cntx</code>，$cnty$ 不变。而一个单位元就是 <code>cntx = cnty = 0</code>（注意我这里是使用 $A, B$ 的多少次方表示的，所以 <code>cntx = 0</code> 表示的是单位矩阵，以此类推）。</p><p>那么 <code>fu = &#123;I, B, 0&#125;, fr = &#123;A, I, A&#125;</code> 表示 <code>U</code> 和 <code>R</code> 分别带来的影响。</p><p>前面照例乘上一个 <code>qpow(fu, b / c)</code>，注意从 1 开始，不需要乘 <code>fr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">Matrix cntx, cnty, ans;</span><br><span class="line">&#125; f0;</span><br><span class="line"></span><br><span class="line">Node <span class="keyword">operator</span> *(Node a, Node b)</span><br><span class="line">&#123;</span><br><span class="line">a.ans += a.cntx * b.ans * a.cnty;</span><br><span class="line">a.cnty = a.cnty * b.cnty, a.cntx = a.cntx * b.cntx;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">qpow</span><span class="params">(Node a, LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(k &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="function">Node <span class="title">res</span><span class="params">(f0)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = a * a)</span><br><span class="line"><span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * a;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">AsGcd</span><span class="params">(LL a, LL b, LL c, LL n, Node fu, Node fr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b %= c;</span><br><span class="line"><span class="keyword">if</span> (a &gt;= c) <span class="keyword">return</span> <span class="built_in">AsGcd</span>(a % c, b, c, n, fu, <span class="built_in">qpow</span>(fu, a / c) * fr);</span><br><span class="line">LL m = ((s128) a * n + b) / c;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">qpow</span>(fr, n);</span><br><span class="line">std::<span class="built_in">swap</span>(fu, fr);</span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">qpow</span>(fu, (c - b - <span class="number">1</span>) / a) * fr * <span class="built_in">AsGcd</span>(c, c - b - <span class="number">1</span>, a, m - <span class="number">1</span>, fu, fr)</span><br><span class="line">* <span class="built_in">qpow</span>(fu, n - ((s128) c * m - b - <span class="number">1</span>) / a);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL a, b, c, l;</span><br><span class="line">std::cin &gt;&gt; a &gt;&gt; c &gt;&gt; b &gt;&gt; l &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) I[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i][j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;B[i][j]);</span><br><span class="line">Node fu&#123;I, B, &#123;&#125;&#125;, fr&#123;A, I, A&#125;;</span><br><span class="line">f0 = &#123;I, I, &#123;&#125;&#125;;</span><br><span class="line"><span class="keyword">auto</span> res = (<span class="built_in">qpow</span>(fu, b / c) * <span class="built_in">AsGcd</span>(a, b, c, l, fu, fr)).ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i, <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, res[i][j]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 万能欧几里得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC132F</title>
      <link href="/2022/05/19/ARC132F/"/>
      <url>/2022/05/19/ARC132F/</url>
      
        <content type="html"><![CDATA[<p>扩展了集合幂级数的定义，比较有借鉴性。</p><span id="more"></span><p>题意：三个人玩 $k$ 次石头剪刀布，两个人会分别从自己的策略集合中随机选取一个然后按照选的策略出 $k$ 次（每个策略都是长度为 $k$ 的字符串，代表每次出的是什么）。第一个人策略集合大小为 $n$，第二个人策略集合大小为 $m$。第三个人想知道，对于 $3 ^ k$ 种他出的策略，计算他 $k$ 次中至少有一次成为唯一赢家的概率。$k\leq 12, n, m\leq 3 ^ k$，5s。</p><p>容易发现我们当且仅当第一个人和第二个人出的一样，第三个人出的可以赢他们的情况才可能计入答案。</p><p>我们考虑<strong>构造另外一种状态</strong>，记作 0，表示这个人可以随意出。容易发现这个状态是包含 1、2、3 的状态的（分别对应石头剪刀布），那么如果我们使用类似集合幂级数的思想前缀和的话，我们就要将对应 1、2、3 的数贡献到对应位为 0 的数。</p><p><strong>类似集合幂级数定义卷积</strong>，定义一个运算，使得如果两个数不同，这一位就是 0，否则就是相同的那个数。容易发现无需暴力卷积，我们按照上面的方法先前缀和，乘起来，再做逆变换。</p><blockquote><p>做法的正确性：拆位打开看，如果这两个数对应位相同，假设为 $x$，那么这个的贡献不仅会在该位为 0 的地方出现，还会在该位为 $x$ 的地方出现，乘起来后做逆变换，这样 0 位置的贡献就变为了 0。而如果不一样的话，这两个数对应位不同，这样一个出现的位置是 $0, x$，另一个出现的位置是 $0, y$，这样乘起来后，只出现在 0 的位置，于是贡献到了 0。这个可以看作是一个广义的与卷积。</p></blockquote><p>这样，我们可以用 $O(k4 ^ k)$ 的时间得到每个状态的各处。然后考虑如何得到答案。</p><p>经典<strong>至少一个容斥为都不是</strong>，考虑计算这个状态下不能胜的情况。对于这一位为 1 来说，不能胜的情况就是 0、2、3。特别的，这一位为 0 不能胜的情况是 0、1、2、3，即所有。</p><p><strong>还是类似集合幂级数拆位的思想</strong>，拆开每一位分别贡献，仍然可以做到 $O(k4 ^ k)$。</p><p>最后直接判断这一个状态是不是切实存在的（即所有位都不是 0），输出即可。</p><p>注意编号的问题，我们可以先将编号设为 1-石头，2-剪刀，3-布（原来是 1-布，2-石头，3-剪刀），这样就是计算三个人相同的问题了，直接按序输出即可。时间复杂度 $O(k4 ^ k)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trs</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; <span class="keyword">return</span> c == <span class="string">&#x27;P&#x27;</span> ? <span class="number">3</span> : (c == <span class="string">&#x27;R&#x27;</span> ? <span class="number">1</span> : <span class="number">2</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FMT</span><span class="params">(T *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k + k; j += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; (k + k)); ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">3</span>) a[i &amp; ~(<span class="number">3</span> &lt;&lt; j)] += a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IFMT</span><span class="params">(T *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k + k; j += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; (k + k)); ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">3</span>) a[i &amp; ~(<span class="number">3</span> &lt;&lt; j)] -= a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; k &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tmp + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i)</span><br><span class="line">s = (s &lt;&lt; <span class="number">2</span>) | <span class="built_in">trs</span>(tmp[i]);</span><br><span class="line">A[s] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tmp + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i)</span><br><span class="line">s = (s &lt;&lt; <span class="number">2</span>) | <span class="built_in">trs</span>(tmp[i]);</span><br><span class="line">B[s] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">FMT</span>(A), <span class="built_in">FMT</span>(B);</span><br><span class="line"><span class="comment">// for (int i = 0; i &lt; (1 &lt;&lt; (k + k)); ++ i) printf(&quot;%d %d\n&quot;, A[i], B[i]);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; (k + k)); ++ i) C[i] = (LL) A[i] * B[i];</span><br><span class="line"><span class="built_in">IFMT</span>(C);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (k + k); j += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; (k + k)); ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">LL sum = C[i] + C[i | (<span class="number">1</span> &lt;&lt; j)] + C[i | (<span class="number">2</span> &lt;&lt; j)] + C[i | (<span class="number">3</span> &lt;&lt; j)];</span><br><span class="line">C[i] = sum;</span><br><span class="line">C[i | (<span class="number">1</span> &lt;&lt; j)] = sum - C[i | (<span class="number">1</span> &lt;&lt; j)];</span><br><span class="line">C[i | (<span class="number">2</span> &lt;&lt; j)] = sum - C[i | (<span class="number">2</span> &lt;&lt; j)];</span><br><span class="line">C[i | (<span class="number">3</span> &lt;&lt; j)] = sum - C[i | (<span class="number">3</span> &lt;&lt; j)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; (k + k)); ++ s) &#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (k + k) &amp;&amp; flag; i += <span class="number">2</span>)</span><br><span class="line">flag &amp;= !!(s &gt;&gt; i &amp; <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (LL) n * m - C[s]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 集合幂级数 </tag>
            
            <tag> AtCoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC Round#132</title>
      <link href="/2022/05/19/ARC-Round-132/"/>
      <url>/2022/05/19/ARC-Round-132/</url>
      
        <content type="html"><![CDATA[<p>vp 的时候降智了，简单的 D 题没做出来，被吊锤了。</p><p>赛时进度：ABC Accepted，Score：1400，Penalty：83：02。</p><p>改题进度：ABCDF Accepted。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定 $n\times n$ 的矩阵，已知每行有 $r_i$ 个 1，每列有 $c_i$ 个 1，且 $r, c$ 均为排列。$q$ 次询问某个点是否是 1。$n, m\leq 10 ^ 5$。</p><p>如果我们需要构造的话，那么 $r_i = n, c_j = n$ 的行列是可以全部赋值为 1 的，然后 $r_i = 1, c_j = 1$ 的行列除了已赋值的全部赋值为 0，然后 $r_i = n - 1, c_j = n - 1$……</p><p>这样行列相当于是一个要将他赋值为 1，一个需要将他赋值为 0，就看谁的优先级高。假设询问 $(x, y), r_x &gt; c_y$，容易发现行的优先级可以用 $n - r_x$，列的优先级可以用 $c_y$，这样行的优先级小于等于列的优先级那么就是 1，否则是 0。</p><p>整理一下，就是 $n - r_x\leq c_y$，即 $r_x + c_y\geq n$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Q --) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">int</span> mn = std::<span class="built_in">min</span>(a[x], b[y]), mx = std::<span class="built_in">max</span>(a[x], b[y]);</span><br><span class="line"><span class="keyword">if</span> (mn - <span class="number">1</span> &lt; n - mx) <span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定一个排列 $p_{1, \dots, n}$，每次可以将第一个数移到最后，或是反转整个数列，问至少多少次才能变为 $1, 2, \dots, n$。给出的排列保证可以变为 $1, 2, \dots, n$。$n\leq 10 ^ 5$。</p><p>如果将原序列看作是一个环的话，那么环的本质没有变，这样序列一定就是 $x, x - 1, \dots, 1, n, n - 1, \dots, x + 1$ 或者是 $x, x + 1, \dots, n, 1, 2, \dots, x - 1$。</p><p>下面用 $pos$ 表示 1 的位置。</p><p>对于第一种情况，我们必须翻转，如果最开始就翻转的话，那么答案就是 $n - pos + 1$，如果是最后翻转的话，答案就是 $(n - pos) + 1$，二者取 $\min$ 即可。</p><p>对于第二种情况，我们可以不翻转，答案就是 $pos - 1$，也可以翻转两次（一次最先，一次最后），答案就是先到 $(n - pos + 1) + 2$，二者取 $\min$ 即可。可以自己手玩一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, p + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) nw[p[i]] = i;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (p[(i + n - <span class="number">2</span>) % n + <span class="number">1</span>] != <span class="number">1</span> &amp;&amp; p[i] != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!~flag) flag = p[i] &gt; p[(i + n - <span class="number">2</span>) % n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">assert</span>(flag == (p[i] &gt; p[(i + n - <span class="number">2</span>) % n + <span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; flag &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, std::<span class="built_in">min</span>(nw[<span class="number">1</span>] - <span class="number">1</span>, <span class="number">3</span> + n - nw[<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, std::<span class="built_in">min</span>(n - nw[<span class="number">1</span>] + <span class="number">1</span>, nw[<span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定 $n, d$，求满足 $|p_i - i|\leq d$ 的排列的数量，某些 $p_i$ 确定，未确定用 -1 表示。$n\leq 500, d\leq 5$。</p><p><strong>排列的 DP 一般有两种：第一种是按顺序填入，哪个位置填 $n$，哪个位置填 $n - 1$，类推。还有一种是先将前 $i$个构成排列，然后枚举 $i + 1$ 的数 $x$，将前面原来 $\geq x$ 的数加 1</strong>。</p><p>如果方向选的是第二种的话，这道题就不好做，因为你需要维护前 5 个的数分别是什么，这样才能判断 +1 后是否合法。</p><p>而用第一种就体现出优势了：我们只需要维护和这个数距离不超过 5 的位置是否已经有数即可。这样就很好做了，时间复杂度 $O(nd2 ^ {2d})$，可以通过。</p><p>代码有些繁琐，有一点难写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (~a[i]) nw[a[i]] = i;</span><br><span class="line"><span class="keyword">int</span> sta = <span class="number">0</span>, lim = d &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; ++ j)</span><br><span class="line"><span class="keyword">if</span> (j &gt; d || ~a[n + j - d]) sta |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">f[n + <span class="number">1</span>][sta] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &gt; <span class="number">1</span>; -- i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; lim); ++ s) &#123;</span><br><span class="line"><span class="keyword">if</span> (!f[i][s]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> cur = f[i][s];</span><br><span class="line"><span class="comment">// printf(&quot;%d %d %d\n&quot;, i, s, cur);</span></span><br><span class="line"><span class="keyword">if</span> (nw[i - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> to = nw[i - <span class="number">1</span>] - i + <span class="number">2</span> + d;</span><br><span class="line"><span class="keyword">int</span> &amp;trs = f[i - <span class="number">1</span>][((s &lt;&lt; <span class="number">1</span>) | (<span class="number">1</span> &lt;&lt; to) | (i &lt;= d + <span class="number">2</span> || ~a[i - d - <span class="number">2</span>])) &amp; ((<span class="number">1</span> &lt;&lt; lim) - <span class="number">1</span>)];</span><br><span class="line"><span class="built_in">adj</span>(trs += cur - Mod);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nxt = <span class="number">0</span>; nxt &lt; lim; ++ nxt) &#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;&gt; nxt &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// printf(&quot;Trs %d\n&quot;, nxt);</span></span><br><span class="line"><span class="keyword">int</span> &amp;trs = f[i - <span class="number">1</span>][((s &lt;&lt; <span class="number">1</span>) | (<span class="number">1</span> &lt;&lt; (nxt + <span class="number">1</span>)) | (i &lt;= d + <span class="number">2</span> || ~a[i - d - <span class="number">2</span>])) &amp; ((<span class="number">1</span> &lt;&lt; lim) - <span class="number">1</span>)];</span><br><span class="line"><span class="built_in">adj</span>(trs += cur - Mod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; f[<span class="number">1</span>][(<span class="number">1</span> &lt;&lt; lim) - <span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定两个长度相同、1 个数相同的串 $s, t$，定义 $d(s, t)$ 为最少邻项交换的次数。定义一个字符串的权值为相邻字符相同的个数。求所有满足 $d(s, t) = d(s,u) + d(u, t)$ 中 $u$ 的最大权值。$|s|\leq 3\times 10 ^ 5$。</p><p>sb 贪心题。</p><p>容易发现 $u$ 的第 $i$ 个 1 一定在 $s$ 的第 $i$ 个 1 和 $t$ 的第 $i$ 个 1 之间。那么我们如果前面已经填好了，新加入一个字符我们就可以判断新的是否合法。注意还需要判断 0 是否合法，即 $u$ 的 0 在 $s$ 对应的 0 和 $t$ 对应的 0 之间。</p><p>剩下的直接贪心，考虑如果能和前一个相同就填相同的，否则就填不同的。注意第一个位置无法填入，随便枚举一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> valid = [&amp;](<span class="keyword">int</span> pos, <span class="keyword">int</span> x) &#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; std::<span class="built_in">min</span>(cnta[pos], cntb[pos]) || x &gt; std::<span class="built_in">max</span>(cnta[pos], cntb[pos]))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> x + (n + m - pos) &gt;= cnta[n + m] &amp;&amp; x &lt;= cnta[n + m];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] != st + <span class="string">&#x27;0&#x27;</span> &amp;&amp; b[<span class="number">1</span>] != st + <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = st, ls = st, res = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// printf(&quot;Solve %d\n&quot;, st);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n + m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// printf(&quot;%d %d %d\n&quot;, cnt, cnta[i - 1], cntb[i - 1]);</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">valid</span>(i, cnt + ls)) cnt += ls, res ++;</span><br><span class="line"><span class="keyword">else</span> cnt += !ls, ls = !ls;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// printf(&quot;%d %d %d\n&quot;, cnt, cnta[n + m], cntb[n + m]);</span></span><br><span class="line"><span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; (a + <span class="number">1</span>) &gt;&gt; (b + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; ++ i) cnta[i] = cnta[i - <span class="number">1</span>] + (a[i] ^ <span class="number">48</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; ++ i) cntb[i] = cntb[i - <span class="number">1</span>] + (b[i] ^ <span class="number">48</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, std::<span class="built_in">max</span>(<span class="built_in">solve</span>(<span class="number">0</span>), <span class="built_in">solve</span>(<span class="number">1</span>)));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>见 <a href="/2022/05/19/ARC132F">ARC132F</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> AtCoder </tag>
            
            <tag> 做题记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC Round#140</title>
      <link href="/2022/05/17/ARC-Round-140/"/>
      <url>/2022/05/17/ARC-Round-140/</url>
      
        <content type="html"><![CDATA[<p>赛时没做出来 D，结果似乎比较简单……</p><p>赛时进度：ABC Accepted，Penalty：59：56，Rank：291，Rating：1995 -&gt; 2006。</p><p>改题进度：ABCDE Accepted。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定字符串 $S$，可以修改其中的 $k$ 个字符，问可以得到的最小循环节。$|S|\leq 2000$。</p><p>直接暴力枚举循环节是否合法，这样每一个对应的位置需要变成一个字符，统计众数出现次数即可。计算众数的时候可以做到线性。</p><p>由于循环节最多只有 $O(\sqrt n)$ 种，所以得到时间复杂度 $O(n\sqrt n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = st; i &lt;= n; i += d) <span class="built_in">chkmax</span>(res, ++ cnt[s[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = st; i &lt;= n; i += d) -- cnt[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="comment">// printf(&quot;%d %d %d\n&quot;, st, d, res);</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (n % i) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> res = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++ j) res -= <span class="built_in">solve</span>(j, i);</span><br><span class="line"><span class="keyword">if</span> (res &lt;= k) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定只有 A、R、C 的字符串，奇数次操作可以 <code>ARC -&gt; R</code>，偶数次操作可以 <code>ARC -&gt; AC</code>，问最多可以进行的操作次数。$|S|\leq 2\times 10 ^ 5$。</p><p>容易发现我们每一段是独立的，因为 <code>ARC -&gt; AC</code> 后两边都不能再合并，只有 <code>AA...ARC...CC</code> 可以通过只有奇数次变换可以得到 <code>ARC</code>，最后一次任选。</p><p>这样我们可以将原串的有用部分压缩为 <code>AA...ARC...CC</code> 中 $\min\{len_A, len_C\}$，容易发现这一定是可以的，多出来的部分是无法操作的。</p><p>这样奇数操作就是对数列中的一个非零数 -1，偶数操作就是将一个非零数变为 0。问最多多少次操作。</p><p>这其实是可以贪心的：我每次将尽量靠近 1 又不是 1 的一个数用奇数操作，直到他变成 1，这样偶数操作删除这个数的时候代价是最小的。我赛时的代码就是这个。</p><p>考虑两个上界：</p><ol><li>偶数次操作最多只有 <code>ARC</code>出现的次数，因为一个偶数次一定会消耗一个 <code>ARC</code> 而不会再次出现。</li><li>总操作最多只有压缩后数列的和，因为操作一次，至少会减 1。</li></ol><p>从偶数操作容易推出所有操作的一个上界：$2\times cnt$（不可能最后一次是一个奇数操作，因为这样的话，我们预估的 $cnt$ 就可以 +1</p><p>直接取 $\min$ 即可。代码是贪心，时间复杂度 $O(n\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] ^ <span class="string">&#x27;R&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &gt; len &amp;&amp; i + len &lt;= n &amp;&amp; s[i - len] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i + len] == <span class="string">&#x27;C&#x27;</span>) len ++;</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">2</span>) al.<span class="built_in">push_back</span>(len - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> cnt += len == <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(al.<span class="built_in">begin</span>(), al.<span class="built_in">end</span>());</span><br><span class="line">sz = al.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">++ ans;</span><br><span class="line"><span class="keyword">if</span> (ans &amp; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; sz &amp;&amp; al[i] &lt;= <span class="number">1</span>) ++ i;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= sz) <span class="keyword">break</span>;</span><br><span class="line">al[i] --;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (cnt) &#123;</span><br><span class="line">-- cnt;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= sz) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">al[j ++] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">-- ans;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : al) <span class="built_in">assert</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= <span class="number">1</span>), cur += x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans + cur + cnt);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定 $n, x$，要求构造长度为 $n$ 的排列 $p$ 使得 $p_1 = x$ 且 $a_i = |p_i - p_{i + 1}|$ 序列的最长严格上升子序列最大。</p><p>首先，如果不管 $p_1$ 的话，我们有一个最长上升字符列为 $n - 2$ 的答案。如果 $n$ 是偶数，我们构造即为 $\{\dfrac n2, \dfrac n2 + 1, \dfrac n2 - 1, \dfrac n2 + 2\dots\}$ 或 $\{\dfrac n2 + 1, \dfrac n2, \dfrac n2 + 2, \dfrac n2 - 1\dots\}$，相邻两个差是 $\{1, 2, \dots\}$，这达到了上界。如果是奇数，构造即为 $\{\dfrac{n + 1}2, \dfrac{n + 1}2 + 1, \dfrac{n + 1}2 - 1, \dfrac{n + 1}2 + 2\dots \}$ ，容易证明这个也是达到了上界的。</p><p>现在考虑加入 $p_1 = x$。第一种方案是我们不管 $p_1$，后面原来 $\geq x$ 的加 1 即可。第二种方案是我们先将 $p_1$ 按照上面的构造尽可能摆放，剩下的随便摆。容易发现如果 $x$ 不是上面最优情况的开头，第二个一定不优。</p><p>剩下的随便分类讨论即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span> &amp;&amp; x == (n + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = (n + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>, k = (n + <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &amp; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, k ++);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, j --);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(n &amp; <span class="number">1</span>) &amp;&amp; x == n / <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = n / <span class="number">2</span> + <span class="number">1</span>, k = n / <span class="number">2</span> - <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, j ++);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, k --);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(n &amp; <span class="number">1</span>) &amp;&amp; x == n / <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = n / <span class="number">2</span> + <span class="number">2</span>, k = n / <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &amp; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, j ++);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, k --);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = n / <span class="number">2</span> + <span class="number">1</span>, k = n / <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &amp; <span class="number">1</span>) p[i] = j ++;</span><br><span class="line"><span class="keyword">else</span> p[i] = k --;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = n / <span class="number">2</span> + <span class="number">1</span>, k = n / <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) p[i] = k --;</span><br><span class="line"><span class="keyword">else</span> p[i] = j ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i] + (p[i] &gt;= x));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定一个无向图，$i$ 会和 $x_i$ 连边，有些 $x_i$ 未定，问所有可能的 $x_i$ 无向图连通块个数之和。$n\leq 2000$。</p><p>观察 1：容易发现确定 $x_i$ 后的图一定是基环树森林，连通块的个数就是环的个数（包括自环）</p><p>观察 2：还没有形成基环树的连通块一定是树，每棵树中 $x_i$ 不确定的点有且只有 1 个。</p><p>观察 3：一旦形成了环，这个连通块的贡献就固定了，和其他的有没有联通过来没有关系（因为统计的是环的数量）</p><p>有了上面的发现，其实就比较好做了。</p><p>首先如果我们确定了 $k$ 棵树，总共有 $cnt$ 个点 $x_i$ 未确定，每棵的大小为 $a_i$，互相连接，并形成了环，那么对应的贡献应该是<br>$$<br>(k - 1)!n ^ {cnt - k} \prod_{i = 1} ^ k a_i<br>$$<br>发现答案和 $k$ 和 $\prod$ 有关，那么直接考虑 DP，即目前个数为 $k$ 的所有树的组合的乘积和。直接 $O(n ^ 2)$ 转移即可。</p><p>对于原来就是基环树的，我们已经形成了环，不参加 DP，直接贡献为 $n ^ {cnt}$。加和即可，时间复杂度 $O(n ^ 2)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[x] = <span class="number">1</span>, sz ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (v ^ fa) &#123;</span><br><span class="line"><span class="keyword">if</span> (vis[v]) &#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(v, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line">fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) fact[i] = (LL) fact[i - <span class="number">1</span>] * i % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!~a[i]) <span class="keyword">continue</span>;</span><br><span class="line">g[a[i]].<span class="built_in">pb</span>(i), g[i].<span class="built_in">pb</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> excnt = <span class="number">0</span>, res = <span class="number">0</span>, mul;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) excnt += !~a[i];</span><br><span class="line">mul = <span class="built_in">qpow</span>(n, excnt);</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vad;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">sz = <span class="number">0</span>, flag = <span class="number">0</span>, <span class="built_in">dfs</span>(i);</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="built_in">adj</span>(res += mul - Mod);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">vad.<span class="built_in">pb</span>(sz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt = vad.<span class="built_in">size</span>();</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : vad)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = cnt - <span class="number">1</span>; ~j; -- j)</span><br><span class="line"><span class="keyword">if</span> (f[j]) f[j + <span class="number">1</span>] = (f[j + <span class="number">1</span>] + (LL) f[j] * x) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line"><span class="keyword">if</span> (f[i]) res = (res + (LL) f[i] * <span class="built_in">qpow</span>(n, cnt - i) % Mod * fact[i - <span class="number">1</span>]) % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：构造 $n\times m$ 的网格，每个数在 $[1, 25]$，要求 $\forall x_1, x_2\in [1, n], y_1, y_2\in [1, m]$，$a_{x_1, y_1}, a_{x_1, y_2}, a_{x_2, y_1}, a_{x_2, y_2}$ 不全相等。$n, m\leq 500$。</p><p>不是很好构造，虽然代码不超过 20 行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i, <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ((i / B) * (j / B) + i + j) % B + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到 $25$ 和 $\sqrt n$ 同级，果断分块。</p><p>暂定为 $\sqrt n\times \sqrt n$ 的分块，那么需要考虑块内和块间的不同情况。</p><p>块内的话，需要我们每两个相同的数字得不在一行一列，否则同行 / 列的块内可能会出现对应的情况导致不合法。</p><p>既然不在一行一列，这要求我们需要每行每列都是排列，这样的话，我们按照如下构造即可：<br>$$<br>\begin{bmatrix}<br>1&amp; 2&amp; 3&amp; \dots&amp; 22&amp; 23\\<br>2&amp; 3&amp; 4&amp; \dots&amp; 23&amp; 1\\<br>3&amp; 4&amp; 5&amp; \dots&amp; 1&amp; 2\\<br>\dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots\\<br>23&amp; 1&amp; 2&amp; \dots&amp; 21&amp; 22<br>\end{bmatrix}<br>$$<br>那么块间像块内一样是否合法呢？、</p><p>首先看 $B = 3, n = m = 9$ 的示范样例输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3 1 2 1 2 3 2 3 1 </span><br><span class="line">1 2 3 2 3 1 3 1 2 </span><br><span class="line">2 3 1 3 1 2 1 2 3 </span><br><span class="line">1 2 3 2 3 1 3 1 2 </span><br><span class="line">2 3 1 3 1 2 1 2 3 </span><br><span class="line">3 1 2 1 2 3 2 3 1 </span><br><span class="line">2 3 1 3 1 2 1 2 3 </span><br><span class="line">3 1 2 1 2 3 2 3 1 </span><br><span class="line">1 2 3 2 3 1 3 1 2 </span><br></pre></td></tr></table></figure><p>容易发现第 4 行和第 2 行是一样的，是怎么回事呢？</p><p>我们发现，当第 1 行变为第 4 行的时候，我们将 <code>1 2 3</code> 的排列变成了 <code>2 3 1</code>，变为第 2 行的时候也是这样，导致第 2 行的输出和第 4 行完全相同。</p><p>这启示我们需要找到另外的方式，使得不会产生不合法情况。</p><p>给出结论：使用块行编号和纵编号的乘积。</p><p>手玩一下发现是不会冲突的。于是就是上面的那个代码（别问我是怎么<del>看题解</del>想到的</p>]]></content>
      
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> 构造 </tag>
            
            <tag> AtCoder </tag>
            
            <tag> 做题记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF Round#791</title>
      <link href="/2022/05/15/CF-Round-791/"/>
      <url>/2022/05/15/CF-Round-791/</url>
      
        <content type="html"><![CDATA[<p>A 吃了发罚时……</p><p>赛时进度：ABCDE Accepted，Score：6025，Rank：7，Rating：1987 -&gt; 2189。</p><p>改题进度：All Accepted。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定 $n$，拆分成 4 和 6，问最多有多少个 4、最多有多少个 6，或报告无解。</p><p>容易发现 $n$ 是奇数或 $n = 2$ 的时候显然无解。剩下的按余数那么随便分讨一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">if</span> ((n &amp; <span class="number">1</span>) || n &lt; <span class="number">4</span>) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">6</span> == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, n / <span class="number">6</span> + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, (n + <span class="number">2</span>) / <span class="number">6</span>);</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">4</span> == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, n / <span class="number">4</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, n / <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定一个序列 $n$ 和 $q$ 次操作，单点修改或是整体赋值。问操作后的和。$n\leq 2\times 10 ^ 5, q\leq 2\times 10 ^ 5$。</p><p>给出线性做法。</p><p>考虑每个数最后被覆盖 / 单点修改的时间，如果单点修改的时间晚于整体赋值的时间，那么就是 $a_i$，否则值就是最后的 $cov$。用增量法维护和即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) sum += a[i];</span><br><span class="line"><span class="keyword">int</span> pos, x, op;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cs = <span class="number">1</span>; cs &lt;= Q; ++ cs) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;pos, &amp;x);</span><br><span class="line"><span class="keyword">if</span> (t[pos] &lt; ct) sum += x - cov;</span><br><span class="line"><span class="keyword">else</span> sum += x - a[pos];</span><br><span class="line">t[pos] = cs, a[pos] = x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">sum = (LL) n * x;</span><br><span class="line">cov = x, ct = cs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>给出 $n\times n$ 的方格，有些位置有关键点，$q$ 次操作，设立关键点，删除关键点，询问一个子矩阵所有的格子都被关键点所覆盖。覆盖是将一行 / 一列的点覆盖。$n, q\leq 2\times 10 ^ 5$。</p><p>考虑结论：想要覆盖一个子矩阵，当且仅当所有行 / 所有列都被覆盖。</p><p>于是我们可以将 行 / 列 分开，分别判断 行 / 列 是否分别合法，一个合法就都可以了。</p><p>于是随便使用树状数组判断区间是否合法即可。具体的，如果覆盖的时候这个位置覆盖次数为 0，就在这个位置 +1；如果删除后这个位置覆盖次数为 0，就在这个位置 -1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, Q, t, x, y, sx, sy;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; Q;</span><br><span class="line"><span class="keyword">while</span> (Q --) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;t, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">if</span> (t == <span class="number">1</span>) row.<span class="built_in">add</span>(x, !r[x] ++), col.<span class="built_in">add</span>(y, !c[y] ++);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">2</span>) row.<span class="built_in">add</span>(x, -(!-- r[x])), col.<span class="built_in">add</span>(y, -(!-- c[y]));</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;sx, &amp;sy);</span><br><span class="line"><span class="built_in">puts</span>((row.<span class="built_in">ask</span>(sx) - row.<span class="built_in">ask</span>(x - <span class="number">1</span>)) == sx - x + <span class="number">1</span> || (col.<span class="built_in">ask</span>(sy) - col.<span class="built_in">ask</span>(y - <span class="number">1</span>)) == sy - y + <span class="number">1</span> ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>给出 $n$ 个点 $m$ 条边的有向图，点带权，任选点数为 $k$ 的路径使得最大点权最小。$n, m\leq 2\times 10 ^ 5, k\leq 10 ^ {18}$。</p><p>最大最小，果断二分。</p><p>二分后，有一些点不再能走，那么转化为了在现有图上走出 $k$ 个点。</p><p>首先容易发现如果有环的话，那么任意 $k$ 都是可以的。对于剩下的情况，直接拓扑排序做一下最长路径即可。拓扑排序的时候可以同时判断有没有环。判断时间复杂度线性。</p><p>总复杂度 $O((n + m)\log a)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) deg[i] = d[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[x] &gt; mid) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (a[v] &lt;= mid) deg[v] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!deg[i] &amp;&amp; a[i] &lt;= mid) q.<span class="built_in">push</span>(i), d[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (a[v] &lt;= mid) &#123;</span><br><span class="line"><span class="built_in">chkmax</span>(d[v], d[x] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!-- deg[v]) q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (deg[i] || d[i] &gt;= k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++ i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">g[u].<span class="built_in">pb</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">check</span>(<span class="number">1e9</span> + <span class="number">10</span>)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; l &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：给定长度为 $n$ 的字符串，满足每一个都属于 $\{a, b, c\dots, p, q\}$ 17 个字符，有一些待填，用 <code>?</code> 表示，$q$ 次给定可以将 <code>?</code> 变成的字符的集合，问所有填法回文串个数的和。$n\leq 1000, q\leq 2\times 10 ^ 5$。</p><p>容易发现 $n\leq 1000$，我们可以考虑枚举出所有可能的回文串，然后判断是否可能变为回文串。注意我们需要增量枚举，否则是 $O(n ^ 3)$ 的。</p><p>考虑现在新加入的两边字符：</p><ol><li>两边都是 <code>?</code>，这样答案就乘上 $|\sum|$。这样我们还需要枚举 $\sum$ 的大小贡献答案。</li><li>有一边是 <code>?</code>，这样字符集中需要有另一边的字符。</li><li>两边都不是 <code>?</code>，这样需要两边字符一样，否则直接停止。</li></ol><p>此外，其他的 <code>?</code> 可以随便选，那么我们需要给出随意选的个数。容易发现贡献和 $|\sum|$ 有关，所以再枚举 $|\sum|$，这样我们需要在包含当前需要的字符集的字符集位置加上 $cnt ^ {|\sum|}$。这个可以使用 FMT 简单的实现。于是总时间复杂度 $O(|\sum| ^ 22 ^ {|\sum|} + n ^ 2|\sum|)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">17</span>; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pw[j][<span class="number">0</span>] = <span class="number">1</span>; i &lt;= n; ++ i) pw[j][i] = (LL) pw[j][i - <span class="number">1</span>] * j % Mod;</span><br><span class="line"><span class="keyword">int</span> totcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) totcnt += str[i] == <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt;= n; ++ mid) &#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>, sta = <span class="number">0</span>, cnt = <span class="number">0</span>, excnt = totcnt;</span><br><span class="line"><span class="keyword">while</span> (mid &gt; len &amp;&amp; mid + len &lt;= n) &#123;</span><br><span class="line"><span class="keyword">int</span> i = mid - len, j = mid + len;</span><br><span class="line"><span class="keyword">if</span> (str[i] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; str[j] != <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] != str[j]) <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;?&#x27;</span> &amp;&amp; str[j] == <span class="string">&#x27;?&#x27;</span>) cnt ++;</span><br><span class="line"><span class="keyword">else</span> sta |= <span class="number">1</span> &lt;&lt; ((str[i] == <span class="string">&#x27;?&#x27;</span> ? str[j] : str[i]) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">excnt -= (str[i] == <span class="string">&#x27;?&#x27;</span>) + (str[j] == <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (i == j &amp;&amp; str[i] == <span class="string">&#x27;?&#x27;</span>) excnt ++;</span><br><span class="line"><span class="comment">// printf(&quot;1 : %d %d %d %d\n&quot;, mid, len, cnt, sta);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">17</span>; ++ j) <span class="built_in">adj</span>(ans[j][sta] += pw[j][cnt + excnt] - Mod);</span><br><span class="line">len ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt;= n; ++ mid) &#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">1</span>, sta = <span class="number">0</span>, cnt = <span class="number">0</span>, excnt = totcnt;</span><br><span class="line"><span class="keyword">while</span> (mid &gt;= len &amp;&amp; mid + len &lt;= n) &#123;</span><br><span class="line"><span class="keyword">int</span> i = mid - len + <span class="number">1</span>, j = mid + len;</span><br><span class="line"><span class="keyword">if</span> (str[i] != <span class="string">&#x27;?&#x27;</span> &amp;&amp; str[j] != <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] != str[j]) <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;?&#x27;</span> &amp;&amp; str[j] == <span class="string">&#x27;?&#x27;</span>) cnt ++;</span><br><span class="line"><span class="keyword">else</span> sta |= <span class="number">1</span> &lt;&lt; ((str[i] == <span class="string">&#x27;?&#x27;</span> ? str[j] : str[i]) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">// printf(&quot;2 : %d %d %d %d\n&quot;, mid, len, cnt, sta);</span></span><br><span class="line">excnt -= (str[i] == <span class="string">&#x27;?&#x27;</span>) + (str[j] == <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">17</span>; ++ j) <span class="built_in">adj</span>(ans[j][sta] += pw[j][cnt + excnt] - Mod);</span><br><span class="line">len ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">17</span>; ++ j) <span class="built_in">FMT</span>(ans[j]);</span><br><span class="line">std::cin &gt;&gt; Q;</span><br><span class="line"><span class="keyword">while</span> (Q --) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tmp + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> sta = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; tmp[j]; ++ j) sta |= <span class="number">1</span> &lt;&lt; (tmp[j] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[<span class="built_in">popcount</span>(sta)][sta]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：给定长度为 $n$ 仅包含 $0\sim 9$ 的字符串相同，给定 $m$ 个交换，相邻两个出现在里面时可以交换。如果两个字符串可以互相交换得到，则称两个字符串相同。问本质不同的字符串有多少个。$n\leq 50000$。</p><p>首先我们定义代表元为本质相同的字符串中字典序最小的。这样，如果我们存在满足中间某些位是 $(d_1, d_2, d_3\dots, d_k)$ 并且 $(d_i, d_{i + 1})$ 中间可以交换，$d_1 &gt; d_k$，那么这个字符串就不是最小的。记录前面可以互相交换的 $d_1,\dots,  d_k$，如果存在一个 $d$ 满足 $d &gt; nxt$ 并且 $nxt$ 中可以有转移 $(d, nxt)$，那么加入 $nxt$ 之后就不是最小的了。（注意前面的都可以放到 $d_k$ 这个位置来和 $nxt$ 交换，如果存在 $d &gt; nxt$，可以将 $nxt$ 交换到 $d_k$ 的位置，$d$ 交换到 $nxt$ 的位置，就不是最小的</p><p>注意到我们只需要哪些元素出现没有，并不需要出现的次数及顺序。于是直接状压，将 $sta$ 记作前面 $d_1\dots, d_k$ 的并集。转移的时候观察存在 $(nxt, d)$ 且 $nxt &lt; d$ 的 $nxt$ 无法转移，其余均可。转移到的就是 $sta$ 中能和 $nxt$ 交换的数和 $nxt$ 本身。判断大于的有没有记录一下大于 $nxt$ 的所有转移，压一下状态即可。</p><p>时间复杂度 $O(n|\sum|2 ^ {|\sum|})$，可以通过。</p><p><strong>注意寻找代表元的做法统计本质不同个数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">std::cin &gt;&gt; u &gt;&gt; v;<span class="comment">// assert(u &lt; v);</span></span><br><span class="line">A[u] |= <span class="number">1</span> &lt;&lt; v, B[u] |= <span class="number">1</span> &lt;&lt; v, A[v] |= <span class="number">1</span> &lt;&lt; u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i) f[<span class="number">1</span>][<span class="number">1</span> &lt;&lt; i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; S; ++ s) f[i &amp; <span class="number">1</span>][s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>, cur; s &lt; S; ++ s) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(cur = f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][s])) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nxt = <span class="number">0</span>; nxt &lt; <span class="number">10</span>; ++ nxt)</span><br><span class="line"><span class="keyword">if</span> (!(B[nxt] &amp; s)) <span class="built_in">adj</span>(f[i &amp; <span class="number">1</span>][(A[nxt] &amp; s) | (<span class="number">1</span> &lt;&lt; nxt)] += cur - Mod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; ++ i) <span class="built_in">adj</span>(res += f[n &amp; <span class="number">1</span>][i] - Mod);</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 状态压缩 </tag>
            
            <tag> 集合幂级数 </tag>
            
            <tag> 做题记录 </tag>
            
            <tag> CF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF Round#Edu128</title>
      <link href="/2022/05/14/CF-Round-Edu128/"/>
      <url>/2022/05/14/CF-Round-Edu128/</url>
      
        <content type="html"><![CDATA[<p>贪心做多了，E 题 DP 也认为是贪心（自然挂了却死活找不出错</p><p>个人感觉 D 比 E 简单，怎么 D 比 E 少那么多人？</p><p>赛时进度：ABCDE Accepted，Penalty：214，Rank：86。</p><p>改题进度：All Accepted。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：求一个数组长度最小，且满足有 $[l_1, r_1]$ 个最小值，$[l_2, r_2]$ 个最大值。</p><p>判一下区间有没有交即可。否则就是 $l_1 + l_2$。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定 $n\times m$ 的网格，有些格子有机器人，每次操作会让所有机器人移动同样的方向，问能否在所有机器人都不出格子的情况下有一个机器人走到最左上 $(1, 1)$。</p><p>容易发现下图情况一定不行：</p><img src="/2022/05/14/CF-Round-Edu128/B%E4%B8%8D%E5%90%88%E6%B3%95%E5%9B%BE.png" class=""><p>你无法将其中的任意一个移到左上方。</p><p>所以这样你只需要找到最靠左上的，判一下剩下的点是否在他的右下方，这样就可以看出是否合法了。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定一个 01 字符串，可以从前后删除一些数，使得剩下的 0 的个数和删除 1 的个数最大值最小。$n\leq 10 ^ 5$。</p><p>容易发现最大值最小，果断二分。</p><p>然后首先 0 的个数满足条件需要我们双指针到最远的位置，在判是否删除 1 的个数大于限制。时间复杂度 $O(n\log n)$。</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定一个序列，为 0 表示不知道，你需要将每一个 0 替换为 $[-k, k]$ 的一个数，使得和为 0，且前缀最大值 - 前缀最小值最大。输出前缀最大值 - 前缀最小值。$n\leq 3000$。</p><p>不知道做法是不是对的，反正过了（</p><p>假设前缀最大值出现在 $a$，前缀最小值出现在 $b$，设 $a &gt; b$，容易发现答案就是 $sum_a - sum_{b - 1}$。时间反正允许，我们直接枚举 $a, b$，这样我们就需要 $O(1)$ 或 $O(\log n)$ 计算答案。</p><p>容易发现我们将 $+k$ 全部放在中间，让两边去平衡，这样显然是最优的。于是就有两个限制：中间的最多只有 $sum + k\times z$，$z$ 表示 0 的个数，两边的限制为 $-sum + k\times z$，因为需要平衡为 0。直接取 $\min$ 即可，时间复杂度 $O(n ^ 2)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">chkmax</span>(res, std::<span class="built_in">min</span>(-(sum[n] - sum[r] + sum[l - <span class="number">1</span>]) + (LL) (cnt[n] - cnt[r] + cnt[l - <span class="number">1</span>]) * k, sum[r] - sum[l - <span class="number">1</span>] + (LL) (cnt[r] - cnt[l - <span class="number">1</span>]) * k));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">cnt[i] = cnt[i - <span class="number">1</span>] + !a[i], sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; ++ j)</span><br><span class="line"><span class="built_in">solve</span>(i, j);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) std::cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">LL sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cnt += !a[i], sum += a[i];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Abs</span>(sum) &gt; (LL) k * cnt) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line"><span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = -a[i];</span><br><span class="line"><span class="built_in">work</span>();</span><br><span class="line">std::cout &lt;&lt; res + <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：在 $2\times n$ 的网格上，有一些点上有权值 1，每次任选一个 1 向四周移动，注意两个 1 合并后还是一个 1，问最后剩 1 个 1 至少需要多少步。</p><p>想了许久，错了很久才发现贪心似乎有问题，写了个 DP 一下就过了。</p><p>容易发现我们合并的时候，如果前 $i$ 个有 1 的话，那么消完后一定是只有第一行有 / 只有第二行有一个 1，直接按照这个转移。</p><p>具体的，计算第一行的答案，那么答案可以来自 $f(2, i - 1) + 2$，或者是 $f(1, i - 1) + 1+a(2, i)$，因为第二行 $i$ 的位置有 1 的话，那么就需要多一个代价合并到 $f(1, i)$。第二行计算类似，不再赘述。</p><blockquote><p> 给出我的错误贪心思路，希望有好心人指出错误 / 给出反例：如果只有 1 行的话，答案显然是最后一个出现的位置减第一个出现的位置 $mx - mn$。这样枚举是最后合并到了第一行还是第二行，然后第二行如果在 $[mn, mx]$ 之间的 1 显然需要 1 个代价合并。旁边多出来的显然需要一次扫描，最后堆在 $mn / mx$ 的位置。这样 $mn, mx$ 如果原来有的话就不再需要多一次操作的，否则需要。<a href="https://codeforces.com/contest/1680/submission/157103464">错误代码链接</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%s%s&quot;</span>, &amp;n, s1 + <span class="number">1</span>, s2 + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> st = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (s1[st] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; s2[st] == <span class="string">&#x27;.&#x27;</span>) st ++;</span><br><span class="line">f1[st] = s2[st] == <span class="string">&#x27;*&#x27;</span>, f2[st] = s1[st] == <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = st + <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">f1[i] = std::<span class="built_in">min</span>(f1[i - <span class="number">1</span>] + (s2[i] == <span class="string">&#x27;*&#x27;</span>) + <span class="number">1</span>, f2[i - <span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">f2[i] = std::<span class="built_in">min</span>(f2[i - <span class="number">1</span>] + (s1[i] == <span class="string">&#x27;*&#x27;</span>) + <span class="number">1</span>, f1[i - <span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ed = n;</span><br><span class="line"><span class="keyword">while</span> (s1[ed] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; s2[ed] == <span class="string">&#x27;.&#x27;</span>) ed --;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, std::<span class="built_in">min</span>(f1[ed], f2[ed]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：给出一个无向图，要求选出一些关键点，使得每一条边至少有一个端点是关键点，且不超过一条边两个端点是关键点。给出构造，或报告无解。</p><p>赛时想到了一些，没写，赛后看到了这个做法，和自己做法有点像，就写<del>贺</del>了一遍。</p><p>抽出 dfs 树，如果不考虑可以有一条边两个关键点，那么必须保证所有边两边的深度奇偶性不同，这样按照深度选关键点即可。</p><p>现在我们有边可能不满足深度奇偶性不同，那么我们需要调整。具体地就是将一棵子树的选 / 不选状态反转，这样只有连边跨越这棵子树的状态会反转。</p><p>首先如果只有一条边不满足条件，直接输出原方案即可（可能不满足条件的边两边都是 0，注意整个翻转）。</p><p>注意到一条非树边只有可能是 儿子 - 祖先 的边，设其为 $(v, u)$，那么 $[v, u)$ 的所有点（指 $u, v$ 路径上的所有点，不包括 $u$）之中，需要一个点和他的子树进行翻转。我们将所有的深度奇偶性相同的非树边两边做一次差分，这样再次 dfs，就知道哪些点是可以反转的了。注意两边可能都是 0，所有点需要反转。</p><p>具体看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], v; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (!vis[v = e[i]])</span><br><span class="line">f[v] = x, dep[v] = dep[x] + <span class="number">1</span>, evis[i &gt;&gt; <span class="number">1</span>] = <span class="number">1</span>, <span class="built_in">dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], v; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (evis[i &gt;&gt; <span class="number">1</span>] &amp;&amp; dep[x] &lt; dep[v = e[i]])</span><br><span class="line"><span class="built_in">rdfs</span>(v), b[x] += b[v], c[x] += c[v];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsans</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dep[x] ^= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x], v; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (evis[i &gt;&gt; <span class="number">1</span>] &amp;&amp; (v = e[i]) != f[x]) <span class="built_in">dfsans</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) vis[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) evis[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) h[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) b[i] = c[i] = <span class="number">0</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++ i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line"><span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, st, ed;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (evis[i &gt;&gt; <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> u = x, v = e[i];</span><br><span class="line"><span class="keyword">if</span> (dep[u] &gt; dep[v]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// printf(&quot;Extra Edge %d %d\n&quot;, u, v);</span></span><br><span class="line"><span class="keyword">if</span> ((dep[u] - dep[v]) &amp; <span class="number">1</span>) c[u] --, c[v] ++;</span><br><span class="line"><span class="keyword">else</span> st = u, ed = v, b[u] --, b[v] ++, cnt ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">rdfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(dep[ed] &amp; <span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) dep[i] ^= <span class="number">1</span>;</span><br><span class="line">dep[st] = dep[ed] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dep[i] &amp; <span class="number">1</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> to = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line"><span class="keyword">if</span> (b[x] == cnt &amp;&amp; c[x] == <span class="number">0</span>) &#123;</span><br><span class="line">to = x;</span><br><span class="line"><span class="keyword">if</span> (dep[x] &amp; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) dep[i] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!~to) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>));</span><br><span class="line"><span class="built_in">dfsans</span>(to);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dep[x] &amp; <span class="number">1</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 做题记录 </tag>
            
            <tag> CF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC020F</title>
      <link href="/2022/05/14/AGC020F/"/>
      <url>/2022/05/14/AGC020F/</url>
      
        <content type="html"><![CDATA[<p>有趣的无限转有限（<code>double</code> 转 <code>int</code>），似乎扩展了状态压缩的定义。</p><span id="more"></span><p>题意：给定一个长度为 $C$ 的圆周和 $n$ 个长度为 $l_i$ 的圆弧，随机将圆弧放在圆周的任意位置（不一定是整数），求圆周上的每一个点都被覆盖的概率。$n\leq 6, C\leq 50$，$C, l_i$ 均为整数。</p><p>数据范围这么小，几乎能想出怎么求就可以了。</p><p>首先固定一个位置，比如固定最大 $l_i$ 开始的位置为 0。这样其他的位置就比较好描述了。</p><p>首先，题目中有一个关键信息：$C, l_i$ 均为整数，虽然放的位置可能不是。如果我们将小数部分拆开看的话，其实他们到底是多少我们是无法枚举的，但是我们并不需要他们的准确值，也就是说，我们只需要他们的相对关系。这样，我们将 $n - 1$ 个 $[0, 1)$ 的小数映射到了 $[1, n - 1]$，这个离散化的过程就是第一次状态压缩。</p><p>容易发现两个小数相同的概率是 0，所以我们可以使用一个排列的方式表示这 $n - 1$ 个小数的大小关系。然后考虑在确定小数状态下，如何计算完全覆盖。</p><p>$n$ 如此之小，直接考虑状态压缩，记录 $f(s, len)$ 表示已经放入了 $s$ 状态的圆弧，最远达到了 $len$ 位置。注意 $len$ 包含了小数部分，为了方便，我们将整数部分 $\times n$，这样 $\bmod n$ 的就是小数部分。</p><p>枚举下一个数放在了哪个位置，直接考虑转移，这里不再详细展开，时间复杂度 $O((n - 1)! 2^{n - 1} (nC) ^ 2)$，可以通过。</p><p>注意实现的时候有两个坑点：</p><ol><li>代码中我直接对 $l_i$ 枚举全排列，注意可能出现 $l_i$ 相同的情况，这样 <code>std::next_permutation</code> 的次数不会达到 $(n - 1)!$，需要记录有多少。</li><li>代码中转移的时候必须先枚举下一个数放在了哪个位置（枚举了位置自然知道是哪个圆弧），顺序转移，否则会出现由于下一个数枚举的混乱导致算重情况。</li></ol><p>给出参考代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line"><span class="keyword">int</span> m = n - <span class="number">1</span>;</span><br><span class="line">f[<span class="number">0</span>][a[<span class="number">0</span>] * n] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nxt = <span class="number">0</span>; nxt &lt;= C * n; ++ nxt)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ls = nxt; ls &lt;= C * n; ++ ls)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; m); ++ s)</span><br><span class="line"><span class="keyword">if</span> (nxt % n &amp;&amp; !(s &gt;&gt; (nxt % n - <span class="number">1</span>) &amp; <span class="number">1</span>))</span><br><span class="line">f[s | (<span class="number">1</span> &lt;&lt; (nxt % n - <span class="number">1</span>))][std::<span class="built_in">min</span>(n * C, std::<span class="built_in">max</span>(ls, nxt + a[nxt % n] * n))]</span><br><span class="line">+= f[s][ls];</span><br><span class="line"><span class="comment">// for (int i = 0; i &lt; n; ++ i) printf(&quot;%d &quot;, a[i]);</span></span><br><span class="line"><span class="comment">// printf(&quot;: %.10lf\n&quot;, f[(1 &lt;&lt; m) - 1][n * C]);</span></span><br><span class="line"><span class="keyword">return</span> f[(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>][n * C];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; C;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) std::cin &gt;&gt; a[i];</span><br><span class="line">std::<span class="built_in">swap</span>(*std::<span class="built_in">max_element</span>(a, a + n), a[<span class="number">0</span>]);</span><br><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n);</span><br><span class="line"><span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> res += <span class="built_in">solve</span>(), cnt ++; <span class="keyword">while</span> (std::<span class="built_in">next_permutation</span>(a + <span class="number">1</span>, a + n));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) res /= C;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.14lf\n&quot;</span>, res / cnt);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 状态压缩 </tag>
            
            <tag> DP 及其优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF Round#785</title>
      <link href="/2022/05/12/CF-Round-785/"/>
      <url>/2022/05/12/CF-Round-785/</url>
      
        <content type="html"><![CDATA[<p>E 想出来了，不过只有最后 5 min 了，以后还是得更快给出做法。</p><p>vp 赛时：ABCDF Accepted，Score：6734，Rank：38。</p><p>改题进度：All Accepted。</p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定字符串，字符权值为 $a\to z, 1\to 26$，每次轮流选，先手只能选长度为偶的子串拿走，后手只能选长度为奇的子串拿走，问最后谁得分高，高多少。</p><p>首先长度为偶数一定直接拿走。</p><p>长度为奇数直接选择少的一个不选即可。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：判断一个字符串是否满足以下条件：</p><blockquote><p>设该字符串字符集为 $\sum$，那么任意子串均满足 $\forall c_1, c_2\in \sum, |\text{occ}(c_1) - \text{occ}(c_2)| \leq 1$，$\text{occ}(c)$ 表示 $c$ 在子串中出现的次数。</p></blockquote><p>爆搜或者观察样例，容易发现一定是一个周期为 $\sum$ 的循环出现，否则一定不合法。</p><p>如果有打破规律的，那么一定是 $c_1c_2\dots c_1$ 而没有包括 $c_{\sum}$，这样出现次数差一定大于 1。</p><p>这个串合法是显然的。所以证明了这个是充分必要的。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：$T$ 组询问，给出一个数 $n$ 求使其由“回文数”加和的方案数。注意没有顺序，可以选择相同的数。$T\leq 10 ^ 4, n\leq 4\times 10 ^ 4$。</p><p>暴力 DP $O(n ^ 2)$ 似乎过不去，但是容易发现回文数的个数一定不多，打个表<del>看题解</del>发现只有不超过 500 个，随便完全背包即可。时间复杂度 $O(nm)$，$m$ 表示回文数的个数。</p><p>另外的问题：如果是有序的怎么做？没想到什么好的做法，只有记录有多少个 binom 一下，似乎是 $O(n^2 m)$。</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：给定两个有限递增等差数列 $B, C$，求有多少个有限递增等差数列 $A$ 满足 $A\cap B = C$。有无穷多个输出 -1。$T(T\leq 100)$ 组询问，</p><p>首先考虑无解情况：如果 $d_B$ 不整除 $d_C$，显然无解。如果 $d_B$ 不整除 $st_C - st_B$，无解。如果 $C$ 的首尾项超出了 $B$ 的范围，无解。</p><p>接下来考虑无穷的情况。如果 $C$ 的尾项后面一项超出了 $B$ 的范围，那么 $A$ 的尾项就可以无限延伸，就是无穷。首项前面同理。</p><p>如果 $\text{lcm}(d_A, d_B)\not= d_C$，显然是不可能的，所以我们可以暴力判断 $d_C$ 的所有因子是否合法。时间是允许的。</p><p>如果是合法的，那么 $A$ 的首项应该在 $C$ 的首项和 $C$ 首项前一项之间，尾项同理。贡献就是 $(\dfrac {d_C}{d_A}) ^ 2$。</p><p>直接暴力计算即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> ad)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Lcm</span>(ad, bd) != cd) <span class="keyword">return</span>;</span><br><span class="line">res = (res + (LL) (cd / ad) * (cd / ad)) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; bst &gt;&gt; bd &gt;&gt; bn &gt;&gt; cst &gt;&gt; cd &gt;&gt; cn;</span><br><span class="line">res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (cd % bd || (cst - bst) % bd) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (cst + (LL) cd * (cn - <span class="number">1</span>) &gt; bst + (LL) bd * (bn - <span class="number">1</span>) || cst &lt; bst)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (cst + (LL) cd * cn &gt; bst + (LL) bd * (bn - <span class="number">1</span>) || cst - cd &lt; bst)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cd / i; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (cd % i) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">solve</span>(i);</span><br><span class="line"><span class="keyword">if</span> (i != cd / i) <span class="built_in">solve</span>(cd / i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：给定 $n$ 的序列 $a_i = 2 ^ {b_i}$，可以在中间加入 $\oplus$ 或者是 $\texttt{Power}$，然后按照优先级计算，至少加入 $k$ 个 $\oplus$，问所有插入方式的计算答案的 $\oplus$，对 $2 ^ {2 ^ {20}}$ 取模，2 进制输出。$n\leq 2 ^ {20}, 1\leq b_i &lt; 2 ^ {20}$。</p><p>可能与 tutorial 做法不一样。</p><p>考虑，然后按照一段区间算贡献。容易发现一段不包含 $\oplus$ 区间的答案只有可能是 $2 ^ x$ 的形式，于是看贡献次数是否是 2 的倍数。</p><p>考虑如果我们已经确定了一段区间，怎样计算贡献次数。如果两边都没有到头，那么相当于我们已经选择了两个端点，又强制一些不能选，那么就是 $\binom {len - 1}{k - 2}$，$len$ 表示没有被选择的区间。至少有 $k$ 个，就是 $\displaystyle \sum_{i = k - 2} ^ {len - 2} \binom{len - 2}{i}$（自己手玩一下。如果覆盖了一端，那么就是 $\displaystyle \sum_{i = k - 1} ^ {len - 1}\binom{len - 1}{i}$。覆盖了两端当且仅当 $k = 0$ 合法。</p><p>怎样快速计算这个呢？根据 Lucas 定理，那么相当于 $i\odot (len - 1) = i$ 贡献才为 1，那么我们可以使用 FMT 前缀和一下，就可以得到了。</p><p>直接暴力枚举区间是 $O(n ^ 2)$，但是容易发现不超过 20 次就会超出模数范围，也就是说，区间长度最多只有 20。于是暴力枚举即可，注意分讨。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = std::<span class="built_in">max</span>(<span class="number">0</span>, k - <span class="number">2</span>); i &lt; n; ++ i) ans[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = std::<span class="built_in">max</span>(<span class="number">0</span>, k - <span class="number">1</span>); i &lt; n; ++ i) ans2[i] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">FMT</span>(ans, <span class="number">20</span>), <span class="built_in">FMT</span>(ans2, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, b + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> st = <span class="number">2</span>; st &lt;= n; ++ st)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cur = st;</span><br><span class="line">LL mul = b[st];</span><br><span class="line"><span class="keyword">while</span> (cur &lt;= n &amp;&amp; !(mul &gt;&gt; <span class="number">20</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur ^ n) &#123;</span><br><span class="line"><span class="keyword">if</span> (ans[n - <span class="number">2</span> - (cur - st + <span class="number">1</span>)]) res[mul] ^= <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (ans2[n - <span class="number">1</span> - (cur - st + <span class="number">1</span>)]) res[mul] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">++ cur;</span><br><span class="line"><span class="keyword">if</span> (b[cur] &gt;= <span class="number">20</span>) <span class="keyword">break</span>;</span><br><span class="line">mul &lt;&lt;= b[cur];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">LL mul = b[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (cur &lt;= n &amp;&amp; !(mul &gt;&gt; <span class="number">20</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur ^ n) &#123;</span><br><span class="line"><span class="keyword">if</span> (ans2[n - <span class="number">1</span> - cur]) res[mul] ^= <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">0</span>) res[mul] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">++ cur;</span><br><span class="line"><span class="keyword">if</span> (b[cur] &gt;= <span class="number">20</span>) <span class="keyword">break</span>;</span><br><span class="line">mul &lt;&lt;= b[cur];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>, flag = <span class="number">0</span>; ~i; -- i) &#123;</span><br><span class="line">flag |= res[i] || !i;</span><br><span class="line"><span class="keyword">if</span> (flag) <span class="built_in">putchar</span>(res[i] | <span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：$n\times n$ 的网格，合理设计四联通相邻的网格边权，使得从任意已知起点走到任意点都能通过边权异或值得到终点位置。$n\leq 32$，边权和不得超过 $48000$。</p><p>比较有意思的位运算题目。一下默认 0 开始标号。</p><p>首先考虑 1D 情况，我们需要把大的 $bit$ 出现次数尽量小，那么比如 $n = 32$，我们就在 $15\to 16$ 的边上放上 16，此外都不放 16，这样我就能判断是在 $[0, 15]$ 还是 $[16, 31]$。向下同理，可以发现需要的边权和就是 $16 + 8\times 2 + 4\times 4 + 2\times 8 + 1\times 16 = 64$。</p><p>放到 2D 上，一个显然的想法是我们将两维分开，两维互不干扰，于是 $x$ 维上使用 $0, 1, 2, 3, 4$ 位，$y$ 维上使用 $5, 6, 7, 8, 9$ 位，这样整个的代价就是 $32\times 64 + 32\times 2048 = 67584$，不能通过。</p><p>$y$ 维上全是高位，贡献组合较大，我们可以考虑交叉使用，$x$ 维使用 $0, 2, 4, 6, 8$，$y$ 维使用 $1, 3, 5, 7, 9$，这样跑一下程序发现是 $47616$，于是可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> tr1 = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (x &gt;&gt; i &amp; <span class="number">1</span>) res |= <span class="number">1</span> &lt;&lt; (i * <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> tr2 = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (x &gt;&gt; i &amp; <span class="number">1</span>) res |= <span class="number">1</span> &lt;&lt; (i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n, T, res = <span class="number">0</span>;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; T;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i, std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++ j) std::cout &lt;&lt; <span class="built_in">tr1</span>(j &amp; -j) &lt;&lt; <span class="string">&#x27; &#x27;</span>, res += <span class="built_in">tr1</span>(j &amp; -j);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i, std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) std::cout &lt;&lt; <span class="built_in">tr2</span>(i &amp; -i) &lt;&lt; <span class="string">&#x27; &#x27;</span>, res += <span class="built_in">tr2</span>(i &amp; -i);</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; res &lt;&lt; std::endl;</span></span><br><span class="line">std::cout.<span class="built_in">flush</span>();</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>, lx = <span class="number">0</span>, ly = <span class="number">0</span>; <span class="comment">// x, y is exchanged</span></span><br><span class="line"><span class="keyword">while</span> (T --) &#123;</span><br><span class="line">std::cin &gt;&gt; cur;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">8</span>, ls = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i -= <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> ((cur &gt;&gt; i &amp; <span class="number">1</span>) ^ ls) lx ^= <span class="number">1</span> &lt;&lt; (i / <span class="number">2</span>), ls = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ls = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>, ls = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i -= <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> ((cur &gt;&gt; i &amp; <span class="number">1</span>) ^ ls) ly ^= <span class="number">1</span> &lt;&lt; (i / <span class="number">2</span>), ls = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ls = <span class="number">0</span>;</span><br><span class="line">std::cout &lt;&lt; ly + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; lx + <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 构造 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 集合幂级数 </tag>
            
            <tag> 做题记录 </tag>
            
            <tag> CF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF Round#788</title>
      <link href="/2022/05/11/CF-Round-788/"/>
      <url>/2022/05/11/CF-Round-788/</url>
      
        <content type="html"><![CDATA[<p>vp Div2 差点把构造题想出来了，结果以为自己是错的（</p><p>赛时进度：ABCD Accpeted，Score：4091，Rank：923，Rating 无变化。</p><p>改题进度：All Accepted。</p><span id="more"></span><p><a href="https://codeforces.com/contest/1670/">比赛传送门</a></p><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：给定一个序列，问能否通过交换符号的方式使序列有序。没有 0。</p><p>容易发现负号一定在前面，随便判一下即可。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给定一个字符串和一些关键字符，一次删除是将关键字符前面的字符删去，问有用的删除有多少次。</p><p>卡了比较久，写出来了，结果还被卡常了（（（</p><p>首先相当于是一个序列，每次所有数减 1，小于 0 的数删去，能减多少次。开头的可能不同，特判一下。证明即考虑每一段关键字符之间的段即可。</p><p>答案显然是 $\max a$ 再加 1，注意 +1 是前面的关键字符被删了，所以如果是开头就不能加 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%s%d&quot;</span>, &amp;n, str + <span class="number">1</span>, &amp;cnt);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i) sp[<span class="string">&#x27;a&#x27;</span> + i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tmp);</span><br><span class="line">sp[tmp[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, ls = <span class="number">0</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!sp[str[i]]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">chkmax</span>(mx, i - ls - <span class="number">1</span> + !!ls), ls = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给定两个排列 $a, b$，构造序列 $c$ 使得 $c_i\in\{a_i, b_i\}$ 且 $c$ 是排列的方案数有多少。部分 $c_i$ 给定，保证有解。</p><p>容易发现如果某一个没有选 $a_i$，那么 $b_j = a_i$ 的位置就得选 $b$，这样 $a_j$ 有没有选，这样就会轮下去，形成一个置换环。容易发现一个置换环只有两种选法。</p><p>题目保证有解，那么 $c_i$ 覆盖了的置换环有且仅有一种情况。计算有多少置换环没有被覆盖即可。注意长度为 1 的置换环贡献一定为 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, b + i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) nw[a[i]] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) bel[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (bel[i] || a[i] == b[i]) <span class="keyword">continue</span>;</span><br><span class="line">++ cnt;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (!bel[j]) bel[j] = cnt, j = nw[b[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) usd[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="keyword">if</span> (x) usd[bel[i]] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> und = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) und += !usd[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pw2[und]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意不好描述，看原题面吧。</p><p>主要是题意转化比较麻烦。</p><p>如果我们将一个正六边形看作是一个点的话，那么相当于是三个方向的直线交点的个数（三线相交算 3 个交点），那么假设三个方向的直线分别是 $a, b, c$，那么答案就是 $ab + bc + ac$。</p><p>如果总条数已经确定，那么答案就是将 $a, b, c$ 尽量平均即可。随便二分即可。</p><p>代码和题解略有不同，代码中是二分的 $\min\{a, b, c\}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">std::cin &gt;&gt; n, n = (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">calc</span>(mid, mid, mid) &lt;= n) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">calc</span>(l, l, l) == n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">3</span> * l);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">calc</span>(l, l, l + <span class="number">1</span>) &gt;= n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">3</span> * l + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">calc</span>(l, l + <span class="number">1</span>, l + <span class="number">1</span>) &gt;= n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">3</span> * l + <span class="number">2</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">3</span> * l + <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：给定 $n = 2 ^ p$ 的树，要求给每个点 / 边设置权值，恰好覆盖 $0\sim 2 ^ {p + 1} - 1$ 的数，并选定根，使得每个点 / 边的前缀异或最大值最小。</p><p>本身想到了，结果以为菊花图将其卡掉，没认真想。</p><p>首先，观察样例可得答案应该为 $2 ^ p$，想一想为什么。</p><p>首先证明 $ans\geq 2 ^ {p}$，因为有一个 $\geq 2 ^ p$ 的数，如果答案都 $&lt; 2 ^ p$，那么 $\oplus 2 ^ p$ 一定就 $\geq 2 ^ p$，与假设矛盾。</p><p>答案应该就是 $2 ^ {p}$，考虑构造。首先选择根是假的，任选都可以。</p><p>先将根设为 $2 ^ p$，然后每个节点假设父亲前缀异或是 $2 ^ p$，那么边就是 $x + 2 ^ p$，点的权值就是 $x$，这样该点的前缀异或也是 $2 ^ p$，可以递归下去。</p><p>所以这样答案就是 $2 ^ p$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> ex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (e[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">++ tot;</span><br><span class="line">w[i] = w[i ^ <span class="number">1</span>] = tot ^ (ex * n), val[e[i]] = tot ^ (!ex * n);</span><br><span class="line"><span class="built_in">dfs</span>(e[i], x, !ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n, n = <span class="number">1</span> &lt;&lt; n, tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) h[i] = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++ i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line"><span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">&#125;</span><br><span class="line">val[<span class="number">1</span>] = n, <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, val[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idx; i += <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, w[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：给定 $n, l, r, z$，求满足条件的 $a$ 序列使得 $\sum_{i = 1} ^ na_i\in [l, r], \oplus_{i = 1} ^ n a_i = z$。对 $10 ^ 9 + 7$ 取模。$n\leq 1000, l, r, z\leq 10 ^ {18}$。</p><p>一看显然的数位 DP，不过做法复杂了，赛时没写出来。</p><p>显然差分一下，只有上界。</p><p>记录 $f(bit, x)$ 表示处理到 $bit$ 位，最多可以放 $x$ 个 1。最后从 $f(61, 0)$ 开始最后到 $f(-1, *)$ 的方案数（因为 0 位考虑后答案放在 -1 了）。限制可以从上一位传下来，也可以通过这一位 $lim$ 为 1 得到。</p><p>直接转移即可，注意 <code>chkmin(x, n)</code>，因为 $x = n$ 后面相当于不限制了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(LL lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">f[<span class="number">62</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">61</span>; ~i; -- i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= n; ++ s)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> trs = z &gt;&gt; i &amp; <span class="number">1</span>, ed = std::<span class="built_in">min</span>((LL) n, (s &lt;&lt; <span class="number">1</span>) + (lim &gt;&gt; i &amp; <span class="number">1</span>)); trs &lt;= ed; trs += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> &amp;nxt = f[i][std::<span class="built_in">min</span>((LL) n, (s &lt;&lt; <span class="number">1</span>) + (lim &gt;&gt; i &amp; <span class="number">1</span>) - trs)];</span><br><span class="line">nxt = (nxt + (LL) f[i + <span class="number">1</span>][s] * C[n][trs]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1023</span>; ++ i) <span class="built_in">adj</span>(res += f[<span class="number">0</span>][i] - Mod);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 做题记录 </tag>
            
            <tag> CF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC248G</title>
      <link href="/2022/05/11/ABC248G/"/>
      <url>/2022/05/11/ABC248G/</url>
      
        <content type="html"><![CDATA[<p>有趣的反演（？）题目，欧拉函数基础变化。</p><span id="more"></span><p>题意：给定一棵带点权树，定义一条路径的权值为覆盖点的数目乘以所有数的 $\gcd$，求所有路径（不含单点路径）的和。$n\leq 10 ^ 5, 1\leq a_i\leq n$。</p><h3 id="做法-1（赛时做法）"><a href="#做法-1（赛时做法）" class="headerlink" title="做法 1（赛时做法）"></a>做法 1（赛时做法）</h3><p>考虑枚举 $d$，使得所有数都是 $d$ 的倍数，对所有连通块进行遍历，可以得到所有路径覆盖点的个数和。$\gcd$ 为 $d$ 的答案即为 $d | \gcd$ 的答案减去所有 $\gcd = 2d, 3d, \dots$ 的答案，倒序扫即可。时间复杂度 $O(nD + n\ln n)$，$D$ 表示 $n$ 以内最大因数个数。统计连通块的个数可以树形 DP 一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a[x] % d) <span class="keyword">return</span>;</span><br><span class="line">sz[x] = dis[x] = <span class="number">1</span>, vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v : g[x])</span><br><span class="line"><span class="keyword">if</span> (!(a[v] % d) &amp;&amp; !vis[v]) &#123;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">ans[d] = (ans[d] + (LL) dis[v] * sz[x] + (LL) dis[x] * sz[v]) % Mod;</span><br><span class="line"><span class="built_in">adj</span>(dis[x] += dis[v] - Mod), <span class="built_in">adj</span>(dis[x] += sz[v] - Mod), sz[x] += sz[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, x = a[i]; j &lt;= x / j; ++ j) &#123;</span><br><span class="line"><span class="keyword">if</span> (x % j) <span class="keyword">continue</span>;</span><br><span class="line">bs[j].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">if</span> (j * j != x) bs[x / j].<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (d = <span class="number">1</span>; d &lt; N; ++ d)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : bs[d])</span><br><span class="line"><span class="keyword">if</span> (!vis[x]) <span class="built_in">dfs</span>(x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : bs[d]) vis[x] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i; -- i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j * i &lt; N; ++ j) <span class="built_in">adj</span>(ans[i] -= ans[i * j]);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) res = (res + (LL) i * ans[i]) % Mod;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="做法-2（欧拉函数）"><a href="#做法-2（欧拉函数）" class="headerlink" title="做法 2（欧拉函数）"></a>做法 2（欧拉函数）</h3><p>考虑一件事情：$\sum_{d | n} \varphi(d) = n$，具体证明可以拆质数算。那么当贡献为 $n$ 时，我们只需要计算 $\sum_{d | n} \varphi(d)$ 即可。</p><p>向上面一样，我们直接计算 $d | \gcd$ 的路径点数之和，最后乘上 $\varphi(d)$ 即可。时间复杂度 $O(nD)$。</p><p>代码和上面差不多，不给了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 数论 </tag>
            
            <tag> AtCoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC242Ex</title>
      <link href="/2022/05/11/ABC242H/"/>
      <url>/2022/05/11/ABC242H/</url>
      
        <content type="html"><![CDATA[<p>虽然是 ABC，质量、难度还是不错的（考场上没想到）。</p><span id="more"></span><p>题意：给定 $m$ 个区间，每次随机选择一个区间，问期望多少次将 $[1, n]$ 全部覆盖。$n, m\leq 400$。</p><p>拆开每一位，相当于是 $E(\max t_i)$，$\max$ 的期望似乎很不好求，我们考虑 min-max 容斥。<br>$$<br>E(\max_{i\in T} a_i) = \sum_{S\subseteq T} (-1) ^ {|S| + 1}E(\min_{i\in S} a_i)<br>$$<br>一个集合的 $\min$ 是好求的，我们先求出与之有交的区间个数 $x$，那么选到 $x$ 中的任意一个都是合法的，那么期望显然是 $\dfrac mx$。</p><p>直接暴力枚举所有集合显然是不行的，我们考虑前面集合中都 $\subseteq \{1, 2, \dots, i - 1\}$在所有集合中加入 $i$，看需要维护什么。首先我们需要维护新加入 $i$ 后区间的个数，容斥系数直接每次加入元素时乘 -1 即可。维护区间个数需要我们维护出上一个选的数 $ls$，这样 $l\in [ls + 1, i], r\in [i, n]$ 的区间就是新加入的。容易发现这是对的。</p><p>于是我们需要维护的就是 $ls$ 表示上一个选的数，$cnt$ 表示有交的区间。状态数为 $O(nm)$，转移为 $O(n)$，总复杂度 $O(n ^ 2m)$。</p><p><strong>期望 max/min 可以互相转化</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = Mod - <span class="number">1</span>; <span class="comment">// last position i, j intervals</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line"><span class="keyword">if</span> (!f[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">res = (res + (LL) m * <span class="built_in">qpow</span>(j) % Mod * f[i][j]) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> to = i + <span class="number">1</span>; to &lt;= n; ++ to)</span><br><span class="line"><span class="built_in">adj</span>(f[to][j + cnt[i][to]] -= f[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> min-max 容斥 </tag>
            
            <tag> AtCoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AHOI2022 钥匙</title>
      <link href="/2022/05/11/AHOI2022-T2/"/>
      <url>/2022/05/11/AHOI2022-T2/</url>
      
        <content type="html"><![CDATA[<p>码量题，vp 时差点写吐了（当然也和我选的方法不够简洁有关），没调出来。</p><span id="more"></span><p>题意：给定一棵树，每个节点有钥匙或宝箱，钥匙和宝箱都有一个颜色，相同颜色 的才能匹配。同一种颜色的钥匙最多只有 5 把。进行 $q$ 次旅行，问每次旅行能打开多少宝箱。$n\leq 5\times 10 ^ 5, q\leq 10 ^ 6$。</p><p>容易发现我们要对每一种颜色建一棵虚树。</p><p>建虚树过后，由于钥匙最多只有 5 把，暴力以为一个钥匙为起点枚举是可行的。考虑计算到每一个节点时还剩几把钥匙，如果没有了说明起点的钥匙会和这个点匹配，当他们两同时出现在路径上时，贡献会多 1。</p><p>最后就是一个路径覆盖问题，注意 $(a, b)$ 需要分类 $a$ 是 $b$ 的祖先，$b$ 是 $a$ 的祖先，其余情况。拍到 dfn 序上，扫描线 + 树状数组即可解决。</p><p>代码是在考场代码上改的，很冗长，仅供参考。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line">    <span class="keyword">int</span> st[N &lt;&lt; <span class="number">1</span>][<span class="number">22</span>], lg[N &lt;&lt; <span class="number">1</span>], fi[N], cnt;</span><br><span class="line">    <span class="keyword">int</span> dep[N], d1[N], d2[N], typ[N], f[N], up[N], frm, rem[N];</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) h[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) typ[i] = <span class="number">0</span>;</span><br><span class="line">        idx = cnt = frm = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        st[++ cnt][<span class="number">0</span>] = x, fi[x] = cnt, dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">        d1[x] = d1[fa], d2[x] = d2[fa], f[x] = fa, up[x] = frm;</span><br><span class="line">        <span class="keyword">if</span> (typ[x] == <span class="number">1</span>) d1[x] ++, frm = x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (typ[x] == <span class="number">2</span>) d2[x] ++;</span><br><span class="line">        <span class="keyword">int</span> tmp = frm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">            <span class="keyword">if</span> (e[i] ^ fa) <span class="built_in">dfs</span>(e[i], x), st[++ cnt][<span class="number">0</span>] = x, frm = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dmin</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> dep[x] &lt; dep[y] ? x : y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++ i) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lg[cnt]; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= cnt; ++ i)</span><br><span class="line">                st[i][j] = <span class="built_in">dmin</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fi[x] &gt; fi[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">int</span> k = lg[fi[y] - fi[x] + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dmin</span>(st[fi[x]][k], st[fi[y] - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dist1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">LCA</span>(x, y);</span><br><span class="line">        <span class="keyword">return</span> d1[x] + d1[y] - d1[t] - d1[f[t]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dist2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">LCA</span>(x, y);</span><br><span class="line">        <span class="keyword">return</span> d2[x] + d2[y] - d2[t] - d2[f[t]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        rem[x] = rem[fa];</span><br><span class="line">        <span class="keyword">if</span> (typ[x] == <span class="number">1</span>) rem[x] ++;</span><br><span class="line">        <span class="keyword">if</span> (typ[x] == <span class="number">2</span>) rem[x] --;</span><br><span class="line">        <span class="keyword">if</span> (rem[x] == <span class="number">0</span>) <span class="keyword">return</span> ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">            <span class="keyword">if</span> (e[i] ^ fa) <span class="built_in">dfs2</span>(e[i], x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">getmatch</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ans.<span class="built_in">clear</span>(), <span class="built_in">dfs2</span>(x);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr, oc;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tr[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; N; i += (i &amp; -i)) tr[i] += c; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i ^= (i &amp; -i)) res += tr[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!top) <span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(stk[top = <span class="number">1</span>] = x);</span><br><span class="line">    <span class="keyword">int</span> lca = tr.<span class="built_in">LCA</span>(x, stk[top]);</span><br><span class="line">    allnodes.<span class="built_in">push_back</span>(lca);</span><br><span class="line">    <span class="keyword">if</span> (!pos[lca]) pos[lca] = ++ curcnt;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; tr.dep[stk[top - <span class="number">1</span>]] &gt;= tr.dep[lca])</span><br><span class="line">        oc.<span class="built_in">link</span>(pos[stk[top - <span class="number">1</span>]], pos[stk[top]]), top --;</span><br><span class="line">    <span class="keyword">if</span> (stk[top] != lca) oc.<span class="built_in">link</span>(pos[lca], pos[stk[top]]), stk[top] = lca;</span><br><span class="line">    <span class="keyword">if</span> (lca != x) stk[++ top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = ++ *dfn, sz[x] = <span class="number">1</span>, nw[*dfn] = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[x])</span><br><span class="line">        <span class="keyword">if</span> (v ^ fa) <span class="built_in">dfs</span>(v, x), sz[x] += sz[v];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MyRun</span></span><br><span class="line">    <span class="comment">// freopen(&quot;keys.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;keys.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">read</span>(n, Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(typ[i], col[i]);</span><br><span class="line">    tr.<span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++ i)</span><br><span class="line">        <span class="built_in">read</span>(u, v), g[u].<span class="built_in">push_back</span>(v), g[v].<span class="built_in">push_back</span>(u), tr.<span class="built_in">add</span>(u, v), tr.<span class="built_in">add</span>(v, u);</span><br><span class="line">    tr.<span class="built_in">prework</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        all[col[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (typ[i] == <span class="number">1</span>) ky[col[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">else</span> bx[col[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> cmp = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> dfn[x] &lt; dfn[y]; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        std::<span class="built_in">sort</span>(all[i].<span class="built_in">begin</span>(), all[i].<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ky[i].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// std::cerr &lt;&lt; &quot;Col &quot; &lt;&lt; i &lt;&lt; std::endl;</span></span><br><span class="line">        oc.<span class="built_in">init</span>(std::<span class="built_in">min</span>((<span class="keyword">int</span>) all[i].<span class="built_in">size</span>() * <span class="number">2</span> + <span class="number">1</span>, n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>) all[i].<span class="built_in">size</span>(); ++ j)</span><br><span class="line">            pos[all[i][j]] = j + <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// for (int i = 1; i &lt;= n; ++ i) printf(&quot;%d &quot;, pos[i]);</span></span><br><span class="line">        <span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line">        allnodes = all[i], allnodes.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        pos[<span class="number">1</span>] = <span class="number">1</span>, <span class="built_in">insert</span>(<span class="number">1</span>), curcnt = all[i].<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// printf(&quot;%d %d %d %d\n&quot;, i, (int) all[i].size(), (int) ky[i].size(), (int) allnodes.size());</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : all[i])</span><br><span class="line">            <span class="keyword">if</span> (x ^ <span class="number">1</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (-- top) oc.<span class="built_in">link</span>(pos[stk[top]], pos[stk[top + <span class="number">1</span>]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : ky[i]) oc.typ[pos[x]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : bx[i]) oc.typ[pos[x]] = <span class="number">2</span>;</span><br><span class="line">        oc.<span class="built_in">prework</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p1 : ky[i]) &#123;</span><br><span class="line">            <span class="keyword">auto</span> mat = oc.<span class="built_in">getmatch</span>(pos[p1]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p2 : mat) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p2 &gt; (<span class="keyword">int</span>) all[i].<span class="built_in">size</span>() + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (p2 == <span class="number">1</span> &amp;&amp; bx[i].<span class="built_in">front</span>() != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (p2 == <span class="number">1</span>) p2 ++;</span><br><span class="line">                p2 = all[i][p2 - <span class="number">2</span>];</span><br><span class="line">                <span class="comment">// printf(&quot;%d %d Pair\n&quot;, p1, p2);</span></span><br><span class="line">                <span class="keyword">if</span> (dfn[p1] &lt;= dfn[p2] &amp;&amp; dfn[p2] &lt; dfn[p1] + sz[p1]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> son = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[p1])</span><br><span class="line">                        <span class="keyword">if</span> (dfn[v] &gt; dfn[p1] &amp;&amp; dfn[v] &lt;= dfn[p2] &amp;&amp; dfn[p2] &lt; dfn[v] + sz[v])</span><br><span class="line">                            <span class="built_in">assert</span>(!~son), son = v;</span><br><span class="line">                    <span class="built_in">assert</span>(~son);</span><br><span class="line">                    opt[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;dfn[p2], dfn[p2] + sz[p2] - <span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">                    opt[dfn[son]].<span class="built_in">push_back</span>(&#123;dfn[p2], dfn[p2] + sz[p2] - <span class="number">1</span>, <span class="number">-1</span>&#125;);</span><br><span class="line">                    opt[dfn[son] + sz[son]].<span class="built_in">push_back</span>(&#123;dfn[p2], dfn[p2] + sz[p2] - <span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dfn[p2] &lt;= dfn[p1] &amp;&amp; dfn[p1] &lt; dfn[p2] + sz[p2]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> son = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> v : g[p2])</span><br><span class="line">                        <span class="keyword">if</span> (dfn[v] &gt; dfn[p2] &amp;&amp; dfn[v] &lt;= dfn[p1] &amp;&amp; dfn[p1] &lt; dfn[v] + sz[v])</span><br><span class="line">                            <span class="built_in">assert</span>(!~son), son = v;</span><br><span class="line">                    <span class="built_in">assert</span>(~son);</span><br><span class="line">                    opt[dfn[p1]].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, dfn[son] - <span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">                    opt[dfn[p1]].<span class="built_in">push_back</span>(&#123;dfn[son] + sz[son], n, <span class="number">1</span>&#125;);</span><br><span class="line">                    opt[dfn[p1] + sz[p1]].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, dfn[son] - <span class="number">1</span>, <span class="number">-1</span>&#125;);</span><br><span class="line">                    opt[dfn[p1] + sz[p1]].<span class="built_in">push_back</span>(&#123;dfn[son] + sz[son], n, <span class="number">-1</span>&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    opt[dfn[p1]].<span class="built_in">push_back</span>(&#123;dfn[p2], dfn[p2] + sz[p2] - <span class="number">1</span>, <span class="number">1</span>&#125;),</span><br><span class="line">                    opt[dfn[p1] + sz[p1]].<span class="built_in">push_back</span>(&#123;dfn[p2], dfn[p2] + sz[p2] - <span class="number">1</span>, <span class="number">-1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : allnodes) pos[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::cerr &lt;&lt; &quot;Success&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, st, ed; i &lt;= Q; ++ i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(st, ed);</span><br><span class="line">        <span class="built_in">assert</span>(dfn[st] &gt;= <span class="number">1</span> &amp;&amp; dfn[st] &lt;= n);</span><br><span class="line">        q[dfn[st]].<span class="built_in">push_back</span>(&#123;dfn[ed], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : opt[i])</span><br><span class="line">            bt.<span class="built_in">add</span>(p.l, p.c), bt.<span class="built_in">add</span>(p.r + <span class="number">1</span>, -p.c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : q[i])</span><br><span class="line">            res[p.second] = bt.<span class="built_in">ask</span>(p.first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 扫描线 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 虚树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AHOI2022 排列</title>
      <link href="/2022/05/11/AHOI2022-T1/"/>
      <url>/2022/05/11/AHOI2022-T1/</url>
      
        <content type="html"><![CDATA[<p>有趣的数论题目，似乎说不上用了什么高级知识。</p><span id="more"></span><p>题意：一个排列的权值定义为最少置换次数使得出现循环。给出排列，求将任意两个不在一个置换环的数交换后排列的权值和。$n\leq 5\times 10 ^ 5$。</p><p>首先，容易发现一个排列的取值就是虽有置换环长度的 $\text{lcm}$。</p><p>$\text{lcm}$ 可能会炸，所以需要考虑枚举所有的质数，求质数幂次的最大值，最后合并答案。</p><p>考虑暴力枚举两个不同的置换环，我们需要将这两个环对于 $\text{lcm}$ 的贡献去掉，然后将两个置换环长度和加入整个 $\text{lcm}$ 的贡献。去掉两个数可能会产生删除最大值两次，于是我们需要维护质数幂的前三大值以便维护。回滚的时候记录下所有改变的值即可。</p><p>暴力枚举置换环最坏是 $O(n ^ 2)$ 的，还没有算计算 $\text{lcm}$ 的复杂度，但是容易发现只有 $O(\sqrt n)$ 个不同的置换环长度，而贡献又只与长度相关。这样枚举复杂度降为 $O(n)$，后面直接暴力枚举涉及到的质数即可通过。不太会算复杂度，据说是 $O(n\log n)$？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    all.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) vis[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cnt[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) mx1[i] = mx2[i] = mx3[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> j = i, cir = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!vis[j]) cir ++, vis[j] = <span class="literal">true</span>, j = a[j];</span><br><span class="line">        <span class="keyword">if</span> (!cnt[cir] ++) all.<span class="built_in">push_back</span>(cir);</span><br><span class="line">        <span class="comment">// printf(&quot;Cir %d\n&quot;, cir);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c : all) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = c, t = <span class="number">0</span>, p;</span><br><span class="line">        <span class="keyword">while</span> (cur ^ <span class="number">1</span>) &#123;</span><br><span class="line">            p = fac[cur].<span class="built_in">front</span>(), t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur % p == <span class="number">0</span>) t ++, cur /= p;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> cs = <span class="number">1</span>; cs &lt;= cnt[c]; ++ cs)</span><br><span class="line">                <span class="keyword">if</span> (t &gt; mx1[p]) mx3[p] = mx2[p], mx2[p] = mx1[p], mx1[p] = t;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; mx2[p]) mx3[p] = mx2[p], mx2[p] = t;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">chkmax</span>(mx3[p], t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lcm = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (mx1[i]) lcm = (LL) lcm * pw[i][mx1[i]] % Mod;</span><br><span class="line">    <span class="comment">// printf(&quot;Lcm = %d\n&quot;, lcm);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c1 : all)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c2 : all) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c1 == c2 &amp;&amp; cnt[c1] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = lcm;</span><br><span class="line">            <span class="keyword">auto</span> del = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">                <span class="keyword">int</span> p, t;</span><br><span class="line">                <span class="keyword">while</span> (x ^ <span class="number">1</span>) &#123;</span><br><span class="line">                    p = fac[x].<span class="built_in">front</span>(), t = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!havbac[p])</span><br><span class="line">                        havbac[p] = <span class="literal">true</span>, bac1[p] = mx1[p], bac2[p] = mx2[p], bac3[p] = mx3[p];</span><br><span class="line">                    <span class="keyword">while</span> (x % p == <span class="number">0</span>) t ++, x /= p;</span><br><span class="line">                    <span class="keyword">if</span> (t == mx1[p])</span><br><span class="line">                        cur = (LL) cur * inv[p][mx1[p] - mx2[p]] % Mod, mx1[p] = mx2[p], mx2[p] = mx3[p];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (t == mx2[p]) mx2[p] = mx3[p];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">auto</span> ins = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">                <span class="keyword">int</span> p, t;</span><br><span class="line">                <span class="keyword">while</span> (x ^ <span class="number">1</span>) &#123;</span><br><span class="line">                    p = fac[x].<span class="built_in">front</span>(), t = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!havbac[p])</span><br><span class="line">                        havbac[p] = <span class="literal">true</span>, bac1[p] = mx1[p], bac2[p] = mx2[p], bac3[p] = mx3[p];</span><br><span class="line">                    <span class="keyword">while</span> (x % p == <span class="number">0</span>) t ++, x /= p;</span><br><span class="line">                    <span class="keyword">if</span> (t &gt; mx1[p])</span><br><span class="line">                        cur = (LL) cur * pw[p][t - mx1[p]] % Mod, mx3[p] = mx2[p], mx2[p] = mx1[p], mx1[p] = t;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; mx2[p]) mx3[p] = mx2[p], mx2[p] = t;</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">chkmax</span>(mx3[p], t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">auto</span> bac = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">                <span class="keyword">int</span> p, t;</span><br><span class="line">                <span class="keyword">while</span> (x ^ <span class="number">1</span>) &#123;</span><br><span class="line">                    p = fac[x].<span class="built_in">front</span>(), t = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> (x % p == <span class="number">0</span>) t ++, x /= p;</span><br><span class="line">                    <span class="keyword">if</span> (havbac[p])</span><br><span class="line">                        havbac[p] = <span class="literal">false</span>, mx1[p] = bac1[p], mx2[p] = bac2[p], mx3[p] = bac3[p];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">del</span>(c1), <span class="built_in">del</span>(c2), <span class="built_in">ins</span>(c1 + c2);</span><br><span class="line">            <span class="built_in">bac</span>(c1), <span class="built_in">bac</span>(c2), <span class="built_in">bac</span>(c1 + c2);</span><br><span class="line">            <span class="comment">// printf(&quot;%d %d %d&quot;, c1, c2, cur);</span></span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) res = (res + (LL) cur * cnt[c1] % Mod * (cnt[c1] - <span class="number">1</span>) % Mod * c1 % Mod * c1) % Mod;</span><br><span class="line">            <span class="keyword">else</span> res = (res + (LL) cur * cnt[c1] % Mod * cnt[c2] % Mod * c1 % Mod * c2) % Mod;</span><br><span class="line">            <span class="comment">// printf(&quot; : %d\n&quot;, res);</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZJOI2022 树</title>
      <link href="/2022/05/10/ZJOI2022-D1T1/"/>
      <url>/2022/05/10/ZJOI2022-D1T1/</url>
      
        <content type="html"><![CDATA[<p>经典的数数题，实在是做不来。</p><span id="more"></span><p><a href="https://loj.ac/p/3706">题目传送门 LOJ</a></p><p>题意：构造两棵有根树，第一棵树 $i$ 的父亲在 $[1, i - 1]$，第二棵树 $i$ 的父亲在 $[i + 1, n]$。问有多少种方案使得 $\forall i\in [1, n]$，第一棵树和第二棵树有且只有一个满足 $i$ 是叶子。$n\leq 500$，需要输出所有 $n\in [2, lim]$ 的答案对 $P$ 取模的结果，$lim, P$ 输入给定。</p><p><strong>有且只有明显在提示容斥</strong>。</p><p>容易发现我们限制一个节点是叶子是容易的，直接记录前面都有多少非叶子即可转移，于是可以得到状态 $f(i, x, y)$ 表示处理到 $i$，$[1, i]$ 第一棵树有 $x$ 个非叶子，$[i, n]$ 有 $y$ 个非叶子。主要是限制非叶子比较麻烦。</p><p>考虑容斥，假设我们选定的 $i$ 在第一棵树中是叶子，那么他在第二棵树中出现必须是非叶子。但是注意，我们不好限制非叶子。于是考虑容斥，虽然他是非叶子，我们考虑强制选择一个集合，使得集合内部的变为叶子，剩余的就不再需要考虑非叶子的问题了。这样容斥只需要是叶子容斥时系数乘 -1 即可，并且两边的容斥可以一起写。</p><p>边界状态就是开始的时候 $f(1, 1, i) = i$，统计答案就是 $\sum f(i, x, 1) \times x$。理解了写起来很简单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x) ans = (ans + (LL) f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][x][<span class="number">1</span>] * x) % Mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; ++ y) f[i &amp; <span class="number">1</span>][x][y] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; ++ y) &#123;</span><br><span class="line"><span class="keyword">if</span> (!f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][x][y]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">adj</span>(f[i &amp; <span class="number">1</span>][x][y] -= (LL) f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][x][y] * x % Mod * y % Mod * <span class="number">2</span> % Mod),</span><br><span class="line">f[i &amp; <span class="number">1</span>][x][y - <span class="number">1</span>] = (f[i &amp; <span class="number">1</span>][x][y - <span class="number">1</span>] + (LL) f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][x][y] * x % Mod * (y - <span class="number">1</span>)) % Mod;</span><br><span class="line">f[i &amp; <span class="number">1</span>][x + <span class="number">1</span>][y] = (f[i &amp; <span class="number">1</span>][x + <span class="number">1</span>][y] + (LL) f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][x][y] * x % Mod * y) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 容斥 </tag>
            
            <tag> 组合计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZJOI2022 众数</title>
      <link href="/2022/05/10/ZJOI2022-D1T2/"/>
      <url>/2022/05/10/ZJOI2022-D1T2/</url>
      
        <content type="html"><![CDATA[<p>非常厉害的 分块 / 平衡规划 题目，不卡常，码量小，比较有趣。</p><span id="more"></span><p><a href="https://loj.ac/p/3707">题目传送门 LOJ</a></p><p>题意：给定序列 $a$，可以任选一个区间加一个数，问最后众数个数的最大值和可能的众数。$n\leq 2\times 10 ^ 5, \sum n\leq 5\times 10 ^ 5$，3s。</p><p>首先相当于是选一个区间使得内外众数个数和最大。</p><p>设 $\text{occ}(i)$ 表示 $i$ 出现的次数，我们就是要利用好 $\sum \text{occ}(i) = n$ 的性质。</p><p>首先，如果我们确定的内部或者是外部的颜色，我们可以在线性时间内求出最大答案。具体的，比如我们已经确定的外部的颜色，我们再枚举内部颜色。容易发现我们一定两边都是这个颜色时最优，否则我们可以缩短使得刚好两边都是这个颜色。容易发现可以转化成前缀和，我们用前缀最大值更新当前右端点的答案，可以做到 $\text{occ}(i)$，所以确定了一个颜色后，可以在 $O(n)$ 时间得到。</p><p>但是不能每个颜色都扫一边，我们可以考虑平衡规划，将 $\text{occ}(i) &gt; B$ 的颜色用这个方法做，前面的复杂度为 $O(\dfrac {n ^ 2}B)$。剩下的都是 $\text{occ}(i)\leq B$ 的颜色了。</p><p>我们还是得枚举外部颜色，容易发现现在内部的众数答案一定 $\leq B$，我们可以考虑确定左端点时，暴力将 $ans\in [1, B]$ 时满足条件的最小的右端点全部统计一遍，这样就可以做到 $O(\text{occ}(i)B)$ 的复杂度。</p><p>将所有的全部扫一遍，于是总复杂度 $O(nB)$，与上一个平衡规划一下，复杂度就是 $O(n\sqrt n)$，不算卡常。</p><p>注意有一些实现细节，比如可能外部颜色只出现在左边，右边没有可能导致统计漏。可以自己手搓一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solvebig</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        cnt[i] = cnt[i - <span class="number">1</span>] + (a[i] == col);</span><br><span class="line">    <span class="keyword">int</span> tres = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> ed = app[i].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ed; ++ j)</span><br><span class="line">            pre[j] = cnt[app[i][j] - <span class="number">1</span>] - j + <span class="number">1</span>, suf[j] = cnt[n] - cnt[app[i][j]] + j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; ed; ++ j) <span class="built_in">chkmax</span>(pre[j], pre[j - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = ed - <span class="number">2</span>; ~j; -- j) <span class="built_in">chkmax</span>(suf[j], suf[j + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ed; ++ j) <span class="built_in">chkmax</span>(tres, pre[j] + suf[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;Big Col %d %d\n&quot;, col, tres);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">chkmax</span>(res, tres)) ans.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span> (res == tres) ans.<span class="built_in">push_back</span>(col);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> ed = app[i].<span class="built_in">size</span>(), tres = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ed; ++ j)</span><br><span class="line">            pre[j] = j - cnt[app[i][j]] + <span class="number">1</span>, suf[j] = cnt[app[i][j] - <span class="number">1</span>] + ed - j;</span><br><span class="line">        <span class="built_in">chkmax</span>(pre[<span class="number">0</span>], <span class="number">0</span>), <span class="built_in">chkmax</span>(suf[ed - <span class="number">1</span>], cnt[n]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; ed; ++ j) <span class="built_in">chkmax</span>(pre[j], pre[j - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = ed - <span class="number">2</span>; ~j; -- j) <span class="built_in">chkmax</span>(suf[j], suf[j + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ed - <span class="number">1</span>; ++ j) <span class="built_in">chkmax</span>(tres, pre[j] + suf[j + <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// printf(&quot;Col2 %d %d %d\n&quot;, i, col, tres);</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">chkmax</span>(res, tres)) ans.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span> (res == tres) ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solvesmall</span><span class="params">(<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;ap = app[col];</span><br><span class="line">    app[col].<span class="built_in">insert</span>(app[col].<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ed = ap.<span class="built_in">size</span>(), tres = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, cur; j &lt; ed; ++ j) &#123;</span><br><span class="line">        cur = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> del = <span class="number">1</span>; del &lt;= lim; ++ del) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mx[ap[j] + <span class="number">1</span>][del] &gt; n + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur &lt; ed &amp;&amp; ap[cur] &lt;= mx[ap[j] + <span class="number">1</span>][del]) cur ++;</span><br><span class="line">            <span class="built_in">chkmax</span>(tres, ed - cur + j + del);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    app[col].<span class="built_in">erase</span>(app[col].<span class="built_in">begin</span>());</span><br><span class="line">    <span class="comment">// printf(&quot;Res : %d %d\n&quot;, col, tres);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">chkmax</span>(res, tres)) ans.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span> (res == tres) ans.<span class="built_in">push_back</span>(col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    lim = std::<span class="built_in">max</span>(std::<span class="built_in">sqrt</span>(n) + <span class="number">1</span>, <span class="number">1.</span>), res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) app[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">ws</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) ws[i] = a[i + <span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">sort</span>(ws.<span class="built_in">begin</span>(), ws.<span class="built_in">end</span>());</span><br><span class="line">    ws.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(ws.<span class="built_in">begin</span>(), ws.<span class="built_in">end</span>()), ws.<span class="built_in">end</span>());</span><br><span class="line">    sz = ws.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        a[i] = std::<span class="built_in">lower_bound</span>(ws.<span class="built_in">begin</span>(), ws.<span class="built_in">end</span>(), a[i]) - ws.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">    std::cerr &lt;&lt; a[n - <span class="number">6</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) app[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lim; ++ j) mx[i][j] = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int</span>) app[i].<span class="built_in">size</span>() &gt; lim) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> ed = app[i].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ed; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> del = <span class="number">1</span>; del &lt;= lim &amp;&amp; j + del &lt;= ed; ++ del)</span><br><span class="line">                <span class="built_in">chkmin</span>(mx[app[i][j]][del], app[i][j + del - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i; -- i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lim; ++ j) <span class="built_in">chkmin</span>(mx[i][j], mx[i + <span class="number">1</span>][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; ++ i)</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int</span>) app[i].<span class="built_in">size</span>() &gt; lim) <span class="built_in">solvebig</span>(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">solvesmall</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    std::<span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    ans.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>()), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : ans) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ws[x - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 分块 </tag>
            
            <tag> 平衡规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022 联合省选半退役记</title>
      <link href="/2022/04/22/2022-provincal-team-select-competition/"/>
      <url>/2022/04/22/2022-provincal-team-select-competition/</url>
      
        <content type="html"><![CDATA[<p>打的很臭，暂且是以一种轻松的心态写这篇游记吧。</p><span id="more"></span><h2 id="Day"><a href="#Day" class="headerlink" title="Day -?"></a>Day -?</h2><p>感觉状态总是不好，感觉赛后觉得比较套路 / 简单的题目赛时因为各种原因没有做出来，感觉要寄。</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>复习了比较多的模板，还在结束前绝杀了一道题，心态不错。但结局是一个都没有考到。不过和一些外校高我们一级的学生聊了一会。</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>8：00 左右就进了考场，本身想码一些模板的，结果被监考员警告了（</p><p>8：30 才能看到题目，14 页的题目，厉害。</p><p>T1 读懂题后发现是一个模拟（省选也有这题？），T2 是一个神仙的树形 DP，T3 神秘图论，题面过长，没怎么读懂。</p><p>先写 T1，本着好写的原则（？）用 <code>std::map&lt;std::string, std::pair&lt;std::string, bool&gt;&gt;</code> 没管复杂度直接写了。而且没注意空格之类的问题（flag）。</p><p>T2 一看肯定和容斥和树形 DP 相关，猜两个没有关键点之间是一个 1 次多项式，写了很久，发现没对。但是如果把所有的权值加进去就是对的，想了想，显然不是 1 次多项式，但是没想到是 $n$ / $n + 1$ 次多项式。想到了 $O(nK)$ 但是没写（？）。</p><p>T3 不可做题，一眼看 8 pts 状压，20 pts 白送，28 pts 到手。</p><p>检查了一下所有的代码问题，慢悠悠的结束了。估计 $100 + 20 + 28 = 148$，看样子是大众分。</p><p>出来感觉大家考得都不怎么好，不太多的人做出来了 T2。似乎 D1 没什么差距。</p><p>下午、晚上懒得复习，看了一部电影、足球比赛、篮球比赛（？）。听说 T1 有空串问题，我直接是先读入第一个字符串 <code>std::cin &gt;&gt; cur</code>，显然有锅。Luogu 上直接 0 pts，不过管他的，Day 2 才是拉差距的关键。</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>学懂了，8：30 才开始看题。</p><p>T1 一眼是一个 NOI 哪年的题（赛后发现是寿司晚宴），T2 神秘 <code>bracket</code> 直接跳过（谁叫我没认真听 WC 讲课？），T3 一眼 CSP2019 D1T3。决定顺序开题。</p><p>T1 结果想了好久没想到根号，一直想怎么容斥，结果都是 $2 ^ c$ 有关（$c$ 是质数个数），9：20 才发现是根号，大力胡了一个 DP，估计 65 pts。开始写，结果不记得那个题怎么写了，随便写了一个 $2 ^ {14} \times 2000$ 单次的做法。一跑大样例，发现直接过了。</p><p>这时 10：30，赶快去看 T2，推了一会，毫无收获，马上去看 T3。</p><p>T3 先写了 12 pts，想了一想，可以大力 $O(n ^ 5)$，按照树形背包的复杂度分析可以到 $O(n ^ 4)$，中间有 6 种情况，似乎很难写。有想了一会，发现两次用最大值更新可以去掉一些不必要的状态，可以做到 $O(n ^ 3)$。</p><p>赶忙开始写，此时已经 11：25 了。没有精力去认真调该题，虽然说是没有放弃，但是看着 35 行左右的转移方程，还是无能为力，还是交了个 $O(n!)$ 的代码。</p><p>预估分数：$65 + 0 + 12 = 77$。</p><h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><p>突然说 18：00 出成绩，先发下来数据。一测发现 D1T1 100 pts，但是 D2T1 挂成了 40 pts，发现原因是把含有大质数的直接当 01 背包处理了（似乎我写寿司晚宴就犯了这个错误），一改，直接 85 pts。发现最后的容斥似乎比较好想，不过我没时间了。T3 写出 44 pts 的人似乎不多，多数人是 12 pts，也有一些是 28 pts。</p><p>出成绩发现 D1T1 又挂了 10 pts，开头加一个空格是什么东西？</p><p>总分：$90 + 20 + 28 + 40 + 0 + 12 = 190$，暴力分都没有完全打满，整场比赛的分数没有一点亮点。</p><p>据说会在队线附近，比较紧张。被抓回去学了几天 whk。（暴力分也能进队？</p><p>UPD：居然踩线进队了。</p><h2 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h2><p>上午正准备月考，结果来了个“踩线进队”的消息，真是吃惊不小。幸好 NOIP T3 随机化骗了 96 pts，把我送进去了。不过这个消息显然对月考一点都不友好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然说是侥幸踩线了，不过暴露出了不少问题，借这里也写一下吧。</p><h3 id="1）挂分导致心态波折"><a href="#1）挂分导致心态波折" class="headerlink" title="1）挂分导致心态波折"></a>1）挂分导致心态波折</h3><p>明明可以写出 D1T1，D2T1（85 pts），结果却因为自己平时训练的时候没有注意这些细节，导致丢掉该得的分数。平常写代码遇到问题时，没有仔细理解就放过去了，这导致在考场写代码时也会出现同样的问题。</p><h3 id="2）时间安排不当导致没有时间"><a href="#2）时间安排不当导致没有时间" class="headerlink" title="2）时间安排不当导致没有时间"></a>2）时间安排不当导致没有时间</h3><p>D1T2 有精力可以做出 40 pts，结果总以为自己可以得到更高的分数，导致最后一点也没有得到。D2T1、D2T3 纷纷因为我在 D2T3 的难写 $O(n ^ 3)$ 上死磕，结果没有时间。如果先写了 $O(n ^ 4)$ 的朴素 DP，至少也有 28 pts 了。在平常考试时，应更加注意时间的合理分配。</p><p>不管怎样，还是奔赴下一站吧。NOI2022，相会！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1119H Ex</title>
      <link href="/2022/04/11/CF1119H/"/>
      <url>/2022/04/11/CF1119H/</url>
      
        <content type="html"><![CDATA[<p>神仙的集合幂级数应用。</p><span id="more"></span><p>题意：有 $n$ 个物品，每个物品存在 $m$ 种子物品，权值为 $a_{i, j}$，每个子物品个数为 $w_j$。从每种物品中选择一个子物品，定义总权值为权值的异或和。求最后每种权值有多少种选法。满足 $a_{i, j} &lt; 2 ^ k$，$m$ 较小。CF 原题满足 $m = 3, k = 17,n\leq 2 ^ {17}$，对 998244353 取模。</p><p>考虑朴素的 FWT 卷积，先对每一个物品 FWT 一下，然后逐位乘起来，最后 FWT 逆变换回来，时间复杂度显然为 $O(nk2 ^ k)$，显然过不去。</p><p>发现有一个特殊的性质：每一个的个数都是 $w_{1, 2, \dots, m}$，有限的组合一定只有 $2 ^ m$ 种。而 $m$ 较小，我们或许可以从这里入手。</p><p>考虑每一个物品的 $p$ 位是什么，记录状态 $s$ 有 $m$ 位，他对应的权值为 $\sum_{i = 0} ^ {m - 1} (-1) ^ {i\in s} w_i$。我们可以对于每一位 $p$，求出 $n$ 个物品中，$s = 0, 1, \dots, 2 ^ m - 1$ 分别有多少种，快速幂求能求出每一位最后的权值，逆变换即可。我们针对 $p$ 这一位进行讨论。</p><p>现在我们考虑计算 $c_{0, 1, \dots, 2 ^ m - 1}$，这显然需要我们寻找 $2 ^ m$ 个方程来计算。哪里有 $2 ^ m$ 个方程呢？我们考虑对于任意 $T\subseteq \{1, 2, \dots, m\}$，计算<strong>只有权值为 $\sum_{i = 1} ^ n val_i = \oplus_{j\in T}a_{i, j}$ FWT 之后的结果</strong>。</p><p>考虑 FWT 的计算过程，即为 $f’(p) = \sum_{i = 0} ^ {2 ^ n - 1}f(i)(-1) ^ {i\odot p}$。这样拆开看，首先，如果 $\mid T\mid = 1$，显然 $f’(p)$ 就是唯一的一个 $w_j$ 乘上一个 1 或者 -1 的系数。否则，我们将每一个 $val_i$ 贡献到 $p$ 上，系数就是 $(-1) ^ {val_i\odot p}$。而整个需要再乘上 $\sum_{j\in T}w_j$，因为开始我们计算的时候没有带上这个权值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 集合幂级数 </tag>
            
            <tag> CF </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合幂级数浅谈</title>
      <link href="/2022/04/09/set-power-series/"/>
      <url>/2022/04/09/set-power-series/</url>
      
        <content type="html"><![CDATA[<p>有点重要的知识点，不记得省选考不考了。</p><span id="more"></span><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>一个长度为 $2 ^ n$ 的序列，有一个生成函数为 $F(x) = \sum_{i = 0} ^ {2 ^ n - 1}f(i) x ^ i$，这个生成函数就叫<strong>集合幂级数</strong>。</p><p>为什么叫集合幂级数呢？是因为我们可以把 $i$ 看作一个 $\{0, 1, \cdots, n - 1\}$ 的子集并状态压缩。</p><p>定义以下几个计算：</p><ol><li>或卷积：$c(i) = \sum_{j \mid k = i}a(j)b(k)$。</li><li>与卷积：$c(i) = \sum_{j\odot k = i}a(j)b(k)$。</li><li>异或卷积：$c(i) = \sum_{j\oplus k = i}a(j)b(k)$。</li><li>子集卷积：$c(i) = \sum_{j\odot k = 0, j \mid k = i}b(j)c(k)$。</li></ol><p>还有一些奇怪的科技，如子集 ln，子集 exp，这里先鸽了。</p><p>这些东西如果是暴力计算的话，显然是 $O(4 ^ n)$ 的，我们考虑有没有更优的做法。</p><h2 id="2-FMT-FWT"><a href="#2-FMT-FWT" class="headerlink" title="2. FMT / FWT"></a>2. FMT / FWT</h2><h3 id="1）FMT"><a href="#1）FMT" class="headerlink" title="1）FMT"></a>1）FMT</h3><p>定义高维前缀和为：$b(i) = \sum_{j\subseteq i}a(j)$。容易发现暴力做是 $O(3 ^ n)$ 的。</p><p>为什么叫高位前缀和呢？因为他相当于是 $n$ 维数组做前缀和，每维只有 01 两种。（<del>所以好像就有了 $k$ 进制下的高维前缀和</del>）</p><p>考虑如果只有 2 维，怎么做呢？</p><p>显然枚举每一维，再对该维前缀和，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++ j) a[i][j] += a[i][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) a[i][j] += a[i - <span class="number">1</span>][j];</span><br></pre></td></tr></table></figure><p>显然是枚举了两维，虽然和平常写法不同，但是如果手玩一下发现是对的。</p><p>扩展到 $n$ 维，我们就可以得到一个简短的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); ++ j)</span><br><span class="line">        <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) a[j] += a[j ^ (<span class="number">1</span> &lt;&lt; i)];</span><br></pre></td></tr></table></figure><p>这个代码显然是 $O(n2 ^ n)$ 的。</p><p>同理，我们也可以得到高位后缀和的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); ++ j)</span><br><span class="line">        <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) a[j ^ (<span class="number">1</span> &lt;&lt; i)] += a[j];</span><br></pre></td></tr></table></figure><p>高维前缀和和高维后缀和统称为<strong>快速莫比乌斯变换</strong>，简写为 FMT。</p><h3 id="2）FWT"><a href="#2）FWT" class="headerlink" title="2）FWT"></a>2）FWT</h3><p>定义 $\displaystyle \text{FWT}(A) = \sum_{i = 0} ^ {2 ^ n - 1}x ^ i\sum_{j = 0} ^ {2 ^ n - 1}(-1) ^ {|i\odot j|}[x ^ j]A(x)$，这个东西就叫<strong>快速沃尔什变换</strong>，简写为 FWT。显然暴力计算是 $O(4 ^ n)$ 的。</p><p>类似于 FMT，我们逐维考虑。枚举每一维 $i$，假设我们枚举到 $j$ 不包含 $i$ 这一维。那么对于不包含 $i$ 的 $j$，显然会将两个都加起来，因为自己是 0，不管与谁都是 0，即 $a_j := a_j + a_{j\mid 2^i}, $，而包含 $i$ 的 $j\mid2^i$ 就不同了，如果是 $a_{j\mid 2 ^ i}$，显然贡献到 $a_{j\mid 2 ^ i}$ 就是 -1 了，即 $a_{j\mid2 ^ i}:= a_j - a_{j\mid 2 ^ i}$。</p><p>我们也可以写出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); ++ j)</span><br><span class="line">        <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = a[j], y = a[j | (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">            a[j] = x + y, a[j | (<span class="number">1</span> &lt;&lt; i)] = x - y;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>我们还可以写出另一份代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bit, tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++ j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = a[i + j], y = a[i + j + mid];</span><br><span class="line">            a[i + j] = x + y, a[i + j + mid] = x - y;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>发现和 NTT 其实是很像的。其实集合幂级数和多项式是有很多相似点的，我们这里才刚刚看到。</p><p>显然，时间复杂度为 $O(n2 ^ n)$。</p><h2 id="3-实现卷积"><a href="#3-实现卷积" class="headerlink" title="3. 实现卷积"></a>3. 实现卷积</h2><h3 id="1）与卷积"><a href="#1）与卷积" class="headerlink" title="1）与卷积"></a>1）与卷积</h3><p>考虑证明假设 $C(x) = \sum_{i = 0} ^ {2 ^ n - 1}x ^ i \sum_{j\odot k = i} [x ^ j]A(x) * [x ^ k]B(x)$，那么对 $A, B, C$ 高位前缀和后，$C(x) = \sum_{i = 0} ^ {2 ^ n - 1}x ^ i[x ^ i]A(x) * [x ^ i]B(x)$。</p><p>考虑每一对 $j, k$，最后 $j, k$ 一定会贡献到 $j\odot k$ 的所有子集，即 $\forall x\subseteq (j\odot k)$。而 $C$ 贡献显然也是 $\forall x\subseteq i$，这和前面的贡献是相同的。</p><p>于是我们先对 $A, B$ 高位前缀和，乘起来，再做高位前缀和的逆变换就可以得到 $C$ 了。</p><p>逆变换就将加号变为减号即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); ++ j)</span><br><span class="line">        <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) a[j] -= a[j ^ (<span class="number">1</span> &lt;&lt; i)];</span><br></pre></td></tr></table></figure><h3 id="2）与卷积"><a href="#2）与卷积" class="headerlink" title="2）与卷积"></a>2）与卷积</h3><p>考虑类似于或卷积的方法，这里不再赘述，证明留给读者。</p><h3 id="3）异或卷积"><a href="#3）异或卷积" class="headerlink" title="3）异或卷积"></a>3）异或卷积</h3><p>前面已经定义了 $FWT(A)$，类似于 FMT，我们证明 $FWT(C) = FWT(A) * FWT(b)$。</p><p>还是考虑 $i, j, p$ 的贡献，$i\to p$ 的贡献显然是 $a(i)(-1) ^ {\mid p\odot i\mid }$，$j\to p$ 的贡献显然是 $b(j)(-1) ^ {\mid p\odot j\mid }$。</p><p>考虑 $i\oplus j$ 对 $p$ 的贡献，显然是 $(-1) ^ {(i\oplus j)\odot p}$。所以我们考虑证明 $(-1) ^ {\mid (i\oplus j)\odot p\mid } = (-1) ^ {\mid i\odot p\mid }(-1) ^ {\mid j\odot p\mid }$。</p><p>容易发现 $p$ 的限制就是将 $i, j$ 中 $p$ 该位为 1 的位拿出来，其余的不管，我们可以先对 $i$ 赋值为 $i\odot p$，$j$ 同理，显然最后的答案左边就是 $(-1) ^ {\mid i\oplus j\mid}$，容易发现就是 $i$ 的 1 个数和 $j$ 的 1 个数相加。左右显然相等。</p><p>逆变换还是将操作反过来即可。这里给出一种实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++ j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = a[i + j], y = a[i + j + mid];</span><br><span class="line">            a[i + j] = (x + y) &gt;&gt; <span class="number">1</span>, a[i + j + mid] = (x - y) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>另外，可以像 NTT 一样实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++ j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = a[i + j], y = a[i + j + mid];</span><br><span class="line">            a[i + j] = x + y, a[i + j + mid] = x - y;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] &gt;&gt;= n;</span><br></pre></td></tr></table></figure><h3 id="4）子集卷积"><a href="#4）子集卷积" class="headerlink" title="4）子集卷积"></a>4）子集卷积</h3><p>先不考虑 $j\odot k = 0$ 的情况，容易发现这就是一个简单的或卷积。但是这个条件似乎不好处理。</p><p>发现当 $j, k\to j| k$ 是有贡献的，当且仅当 $\mid j\mid + \mid k\mid = \mid j|k\mid$，也就是说，我们限制的集合的大小。这启示我们按照集合大小分类。</p><p>我们考虑计算集合大小分别为 $a$ 和 $b$ 的或卷积，贡献到集合大小为 $a + b$ 的位置上。这样暴力做是 $O(n ^ 3 2 ^ n)$ 的，但是发现中间对 $a, b$ 的或卷积是由重复的，我们可以先将 $a = 0, \dots n - 1, b = 0, \dots n - 1$ 的高维前缀和后，再批量贡献到 $a + b$，再将 $a + b = 0, \dots, n - 1$ 的高维前缀和逆变换。容易发现时间复杂度是 $O(n ^ 2 2 ^ n)$ 的。代码在后面的例题。</p><h2 id="4-例题"><a href="#4-例题" class="headerlink" title="4. 例题"></a>4. 例题</h2><h3 id="T1：模板"><a href="#T1：模板" class="headerlink" title="T1：模板"></a>T1：模板</h3><p><a href="https://www.luogu.com.cn/problem/P4717">FMT / FWT 模板</a></p><p><a href="https://www.luogu.com.cn/problem/P6097">子集卷积模板 lg</a>，<a href="https://loj.ac/p/152">子集卷积模板 LOJ</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">base_or</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; ++ j)</span><br><span class="line"><span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) (a[j] += a[j ^ (<span class="number">1</span> &lt;&lt; i)] * inv) %= Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; ++ j) a[j] = (a[j] + Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_or</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(a, A, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * tot), <span class="built_in">memcpy</span>(b, B, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * tot);</span><br><span class="line"><span class="built_in">base_or</span>(a, <span class="number">1</span>), <span class="built_in">base_or</span>(b, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = (LL)a[i] * b[i] % Mod;</span><br><span class="line"><span class="built_in">base_or</span>(c, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, c[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">base_and</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = tot - <span class="number">1</span>; j; -- j)</span><br><span class="line"><span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) (a[j ^ (<span class="number">1</span> &lt;&lt; i)] += a[j] * inv) %= Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; ++ j) a[j] = (a[j] + Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_and</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(a, A, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * tot), <span class="built_in">memcpy</span>(b, B, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * tot);</span><br><span class="line"><span class="built_in">base_and</span>(a, <span class="number">1</span>), <span class="built_in">base_and</span>(b, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = (LL)a[i] * b[i] % Mod;</span><br><span class="line"><span class="built_in">base_and</span>(c, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, c[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">base_xor</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (inv == <span class="number">-1</span>) inv = inv2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; ++ j) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">LL x = a[j], y = a[j | (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">a[j] = (x + y) % Mod * inv % Mod;</span><br><span class="line">a[j | (<span class="number">1</span> &lt;&lt; i)] = (x - y + Mod) % Mod * inv % Mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_xor</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(a, A, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * tot), <span class="built_in">memcpy</span>(b, B, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * tot);</span><br><span class="line"><span class="built_in">base_xor</span>(a, <span class="number">1</span>), <span class="built_in">base_xor</span>(b, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = (LL)a[i] * b[i] % Mod;</span><br><span class="line"><span class="built_in">base_xor</span>(c, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, c[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++ i) <span class="built_in">FWT</span>(a[i], bit, <span class="number">1</span>), <span class="built_in">FWT</span>(b[i], bit, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bit - i; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; bit); ++ k)</span><br><span class="line">c[i + j][k] = (c[i + j][k] + (LL)a[i][k] * b[j][k]) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++ i) <span class="built_in">FWT</span>(c[i], bit, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T2：Sum-the-Fibonacci"><a href="#T2：Sum-the-Fibonacci" class="headerlink" title="T2：Sum the Fibonacci"></a>T2：Sum the Fibonacci</h3><p><a href="https://codeforces.com/problemset/problem/914/G">题目传送门 Codeforces</a></p><p>也是模板，请读者自行实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 集合幂级数 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF643G</title>
      <link href="/2022/04/09/CF643G/"/>
      <url>/2022/04/09/CF643G/</url>
      
        <content type="html"><![CDATA[<p>线段树 + 众数的好题。</p><span id="more"></span><p>题意：给定长度为 $n$ 的序列和常数 $p$，$q$ 次操作，区间赋值或是查询区间出现次数大于 $p\%$ 的数。可以有无关输出，但总数不能超过 $\left\lfloor\dfrac{100}p \right\rfloor$。$20\leq p\leq 100, n, q\leq 1.5\times 10 ^ 5$。</p><p>考虑 $p &gt; 50$ 怎么做。维护一个 <code>(x, cnt)</code>，表示一个数和当前数出现次数减去非当前数的出现次数。显然 $cnt &gt; 0$ 的数最多只有一个，也就是说，我们只需要维护一个 <code>pair</code> 即可。来了新的一个数时，如果等于当前数，显然 <code>cnt ++</code>，否则 <code>cnt --</code>。如果当前的 $cnt$ 已经 $\leq 0$ 了，说明这个数是不优的，一定不可能成为答案，我们就删除这个 <code>pair</code>。如果新来一个数时 <code>pair</code> 是空的，我们直接设置为 <code>(x, 1)</code> 即可。</p><p>考虑证明可行。显然一个数 $x$ 如果出现频率大于 $50\%$，那么到最后的时候，他一定没有被其他数所换下，因为即使所有数都攻击 $x$ 的 $cnt$，最后仍然 $cnt &gt; 0$，也就是不会被弹出。至此我们证明的这一定是可行的。</p><p>扩展该做法，维护 $\left\lfloor\dfrac{100}p \right\rfloor$ 个 <code>(x, cnt)</code>，如果来了一个数是其中的某一个数，直接对这个 <code>(x, cnt)</code> 加一。否则对每一个 <code>(x, cnt)</code> 减一，如果有 $cnt = 0$，则删除。显然如不满 $\left\lfloor\dfrac{100}p \right\rfloor$ 个的话，我们就设置一个 <code>(x, 1)</code> 即可。</p><p>考虑正确性。如果这个数被弹出仅当至少出现了 $\left\lfloor\dfrac{100}p \right\rfloor$ 个和他互不相同的数，并且这个数仅出现了一次，如果再出现这个数也至少有 $\left\lfloor\dfrac{100}p \right\rfloor$ 个和他不同的数，说明这个数的出现频率不可能达到 $p%$，得证。</p><p>区间操作直接直接使用线段树维护即可，合并信息的时候可以将一边的数按照 <code>cnt</code> 次出现计算，暴力加入另外一边（显然没有出现在左右的 <code>pair</code> 中则不可能出现在最终的 <code>pair</code> 中）。假设 $k = \left\lfloor\dfrac{100}p \right\rfloor$，则时间复杂度为 $O(k ^ 2n\log n)$。</p><p>题外话：可不可以使用这个维护区间众数呢？欢迎在评论区留言。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Major</span> &#123;</span></span><br><span class="line">    PII dat[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">Major</span>() &#123;  &#125;</span><br><span class="line">    <span class="built_in">Major</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> cnt) &#123; dat[<span class="number">0</span>] = &#123;x, cnt&#125;; &#125;</span><br><span class="line">    PII&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> dat[x]; &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">int</span> k; <span class="comment">// 维护 k 个 pair</span></span><br><span class="line"></span><br><span class="line">Major <span class="keyword">operator</span> +(Major a, Major b) <span class="comment">// 合并两边的 pair</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = b[i].first, cnt = b[i].second, flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k &amp;&amp; !flag; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (a[j].first == x) flag = <span class="number">1</span>, a[j].second += cnt;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k &amp;&amp; !flag; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (!a[j].first) a[j] = &#123;x, cnt&#125;, flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">1e9</span>, pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">chkmin</span>(mx, a[j].second)) pos = j;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; a[pos].second)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++ j) a[j].second -= cnt;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++ j) a[j].second -= mx;</span><br><span class="line">            a[pos] = &#123;x, cnt - mx&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> CF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF653G</title>
      <link href="/2022/04/07/CF653G/"/>
      <url>/2022/04/07/CF653G/</url>
      
        <content type="html"><![CDATA[<p>一道埃筛 + 组合数学的题目。</p><span id="more"></span><p>题意：给定一个序列 $\{a\}$，执行以下的操作直到所有数相等：乘一个质数或除一个质数。求所有子序列最少操作次数的和，对 $10 ^ 9 + 7$ 取模。$n, a_i\leq 3\times 10 ^ 5$，5 s。可以加强到 $n, a_i\leq 2\times 10 ^ 7$。</p><p>容易发现每一个质数是独立的，可以分开计算贡献。另外，显然当取质数次数的中位数是最优的策略。</p><p>对每一个质数分别考虑，假设当前按质数次数降序排名为 $i$ 的数次数为 $x_i$，中位数为 $x$，那么答案为 $|x_i - x|$。</p><p>如果我们将整个展开，发现 $\dfrac n2$ 个数 $x$ 的贡献是负，$\dfrac n2$ 个数 $x$ 的贡献是正，那么我们只需要考虑 $x_i$ 的贡献。</p><p>假设排名小于 $i$ 的选了 $a$ 个（$0\leq a&lt; i$），大于 $i$ 的选了 $b$ 个（$0\leq b&lt; n - i + 1$），那么根据 $a$ 和 $b$ 的大小可以分为：</p><ol><li>$a &lt; b$，则 $x_i$ 贡献为正。</li><li>$a = b$，则 $x_i$ 贡献为 0。</li><li>$a &gt; b$，则 $x_i$ 贡献为负。</li></ol><p>$a, b$ 的相对关系看起来不好枚举，我们换做 $i - 1 - a + b$ 与 $i - 1$ 的大小关系可能更好枚举。于是我们可以得到下面的式子：<br>$$<br>\sum_{j = i} ^ {n - 1} \binom{n - 1}{j} - \sum_{j = 0} ^ {i - 2} \binom{n - 1}{j}<br>$$</p><p>我们可以预处理 $f(k) = \sum_{i = k}^{n - 1} \binom{n - 1}i - \sum_{i = 0}^{k - 2}\binom{n - 1}i$，可能会更好求。</p><p>发现 $x_i$ 一样的段，贡献是连续的，也就是 $f(k)$ 是一段的和。假设枚举次幂 $t$，设 $x_i\geq t$ 的个数为 $a$，$x_i &gt; t$ 的个数为 $b$，那么 $t$ 的贡献就是：<br>$$<br>t\sum_{i = b + 1} ^ a f(i)<br>$$<br>再次前缀和 $g(i) = \sum_{j = 1} ^ i f(j)$，那么这个贡献也可以 $O(1)$ 计算。那么瓶颈在于计算 $x_i\geq t$ 的个数。这个可以通过埃筛来计算。</p><p>具体来说，我们直接考虑枚举质数 $p$，然后对于他的次幂，暴力计算次幂的倍数有多少个。据说时间复杂度是 $O(n\log\log n)$ 的，实测 $4\times 10 ^ 7$ 也只要 0.5s（不算读入）。有好心人发一下证明吗？</p><p>代码比较简短。放一个主函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++ j) <span class="built_in">adj</span>(pre[j] = pre[j - <span class="number">1</span>] + <span class="built_in">C</span>(n - <span class="number">1</span>, j) - Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, tmp; i &lt;= n; ++ i)</span><br><span class="line"><span class="built_in">adj</span>(ans[i] = ans[i - <span class="number">1</span>] + <span class="built_in">adj</span>(<span class="built_in">adj</span>(tmp = pre[n - <span class="number">1</span>] - pre[i - <span class="number">1</span>]) -= (i == <span class="number">1</span> ? <span class="number">0</span> : pre[i - <span class="number">2</span>])) - Mod);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= mx; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (j = i &lt;&lt; <span class="number">1</span>; j &lt;= mx; j += i) st[j] = <span class="literal">true</span>;</span><br><span class="line">LL k = i;</span><br><span class="line"><span class="keyword">for</span> (cntp[j = <span class="number">1</span>] = <span class="number">0</span>; k &lt;= mx; cntp[++ j] = <span class="number">0</span>, k *= i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = k; l &lt;= mx; l += k) cntp[j] += cnt[l];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = j - <span class="number">1</span>, tmp; l; -- l)</span><br><span class="line">res = (res + (LL)<span class="built_in">adj</span>(tmp = ans[cntp[l]] - ans[cntp[l + <span class="number">1</span>]]) * l) % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> 狄利克雷卷积 </tag>
            
            <tag> 数论 </tag>
            
            <tag> CF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF843D</title>
      <link href="/2022/04/06/CF843D/"/>
      <url>/2022/04/06/CF843D/</url>
      
        <content type="html"><![CDATA[<p>Dijkstra 的好题。</p><span id="more"></span><p>题意：给定一张图，可能询问某点到 1 的最短距离或是给 $c$ 条边的边权加 1。$n, m\leq 10 ^ 5, q\leq 2000, \sum c\leq 10 ^ 6$。</p><p>直接考虑朴素的 Dijkstra，每次我们加边的时候，都暴力重构长度。时间复杂度 $O(mq\log n)$，很卡。<del>标算都卡的很，这还能过？</del></p><p>另一种方法是用 SPFA 代替，时间复杂度 $O(kmq)$，<del>好像被构造卡了</del>。</p><p>10 s 的时间，看样子不是什么特别优的算法，应该是 $O(mq)$。</p><p>似乎只有 BFS 可以做到这个复杂度，01 双端队列似乎可以解决！</p><p>但是我们没有考虑原来的边的边权，这个显然是有问题的，因为对于边权非 1 的情况会处理错误。那么有什么方法呢？</p><p>考虑 Dijkstra 的算法流程：</p><blockquote><ol><li>找到当前未扩展的点中，距离起点最近的点。</li><li>松弛其他点到起点的距离。</li></ol></blockquote><p>在标准的 Dijkstra 算法中，我们使用了一个堆实时维护。我们是否可以找到另外的替代呢？直接考虑最暴力的桶，于是我们得到了一个 $O(m + W)$ 的做法，其中 $W$ 是指最短路的值域范围。</p><p>每次加 $c$ 条边的边权时，到其他所有点的距离变化一定不超过 $\min\{c, n - 1\}$（最短路不超过 $n - 1$ 条边），这启示我们可以使用桶 - Dijkstra 的算法来计算增量。</p><p>但是在一般的认知中，是没有办法求最短路的增量的。可以考虑类似 Johnson 全源最短路的做法，我们设置一条边的新权值为 $e(u, v)’ = e(u, v) + dis(u) - dis(v)$。类似 Johnson 的证明，我们三角不等式易得边权仍然是非负的。而我们走到一个点的时候，他的势能加上他的新图上的距离就是原图上的最短路。而新图的距离是好求的，于是我们可以得到单次 $O(m + W) = O(m)$ 的做法了。总时间复杂度 $O(m\log m + mq)$（开始必须跑一遍 Dijkstra</p><p>注意仍然比较卡常，注意实现细节的错误可能导致 TLE。放一个代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="keyword">int</span>&gt; q[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> Lim = n - <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Lim; ++ i)</span><br><span class="line"><span class="keyword">while</span> (!q[i].<span class="built_in">empty</span>()) q[i].<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) now[i] = n;</span><br><span class="line">q[<span class="number">0</span>].<span class="built_in">push</span>(<span class="number">1</span>), now[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, x; l &lt;= mx; ++ l)</span><br><span class="line"><span class="keyword">while</span> (!q[l].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">x = q[l].<span class="built_in">front</span>();</span><br><span class="line">q[l].<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (now[x] &lt; l) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[i, v] : g[x])</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">chkmin</span>(now[v], <span class="built_in"><span class="keyword">int</span></span>(now[x] + w[i] + d[x] - d[e[i]])) &amp;&amp; now[v] &lt;= Lim)</span><br><span class="line">q[now[v]].<span class="built_in">push</span>(v), <span class="built_in">chkmax</span>(mx, now[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (d[i] &lt; (INF &gt;&gt; <span class="number">1</span>)) d[i] += now[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> CF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P7843</title>
      <link href="/2022/04/04/P7843/"/>
      <url>/2022/04/04/P7843/</url>
      
        <content type="html"><![CDATA[<p>分治的妙妙题。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给定 $m$ 个双向的 2-SAT 限制（即 $u_i$ 选了 $x_i$ 则 $v_i$ 要选 $y_i$，同样 $v_i$ 选了 $y_i$ 则 $u_i$ 要选$x_i$），$q$ 次询问 $[l, r]$ 最少能划分成多少段有解的 2-SAT 限制。</p><p>$n\leq 10 ^ 5, m\leq 6\times 10 ^ 5, q\leq 10 ^ 6$，时限 2.5 s。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>首先考虑如何判定 2-SAT 限制是否有解，发现这个 Tarjan 实质是在求联通分量（因为有双向边，联通分量一定是强连通分量）。</p><p>那么，我们可以使用一个并查集维护联通性，如果一次之后出现了 $u_i$ 和 $u_i$ 的反面在一个强连通分量，则不合法。</p><p>如何求一个区间最少划分成多少个有解的 2-SAT 问题？这个可以简单的贪心，预处理每一个限制一直向右扩展到哪一处开始不合法（显然不合法之后不可能再合法），前面的显然划为一段，如此贪心。这个贪心过程可以使用倍增优化，也就是说，如果我们能找到从一个限制一直向右扩展到哪一处开始不合法，我们可以倍增跳，做到 $O(q\log n)$ 的复杂度，显然已经足够了。问题在于如何求哪一处开始不合法。</p><p>记 $f(i)$ 为极短的 $[i, f(i)]$ 为无解的限制，这个就类似一个 DP 了。我们发现似乎没有什么方法可以做到比较优的复杂度，因为这个和一般的 DP 又不尽相同。</p><p>考虑 $f(i)$ 的性质，我们发现，$f(i)$ 显然是具有单调性的，这启示我们向 DP 的决策单调性的方向思考。</p><p>类似于决策单调性的求法，我们考虑二分，<code>solve(l, r, sl, sr)</code> 表示处理 $[l, r]$ 之间的$f(i)$，已知答案区间为 $[sl, sr]$。直接计算 $f(mid)$，然后向下递归即可。</p><p>如何计算 $f(mid)$，如果我们暴力向右扩展的话，其实复杂度是错误的。回顾决策单调性的写法与时间复杂度的证明，我们取的时候，必须只能在 $[sl, sr]$ 之间计算，也就是说，我们的时间复杂度应只与 $sr - sl$ 有关。但是这个题，我们发现，如果 $mid &lt; sl$，即使我们知道答案不会出现在这一段区间，我们还是得扫一遍，为后面判断做铺垫，而这造成了错误，使得复杂度不对。如何处理他呢？</p><p>感觉上，这个东西应该是留给上一层计算才对，于是我们强制要求<strong>在 $[r + 1, sl - 1]$ 之间的限制已经被加入并查集了</strong>。这样才能保证我们计算的时候，不会进入多余的无用的计算。递归结束时显然要撤回，所以用可撤销并查集，预处理时间复杂度 $O(m\log m\log n)$，总时间复杂度为 $O(m\log m\log n + q\log n)$。至于为什么不将 $[mid, sl - 1]$ 或是 $[l, sl - 1]$ 加入并查集，是因为这不是 $[l, r]$ 所有节点所必需的，所以先不管。具体在实现部分讲。</p><h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h2><p>这个题由于要保证 $[r + 1, sl - 1]$ 的在进入该层前已经加入了并查集了，所以我们注意我们如果要计算 $f(mid)$，要先将 $[mid, \min{r, sl - 1}]$ 的加入，然后再从 $sl$ 向右扫。如果要向左区间递归，那么 $[mid, sl - 1]$ 的保留（因为向 $[l, mid - 1]$ 递归），所以我们要将第一次加入的边保留。而向右区间，则是 $[r, f(mid) - 1]$，这个直接实现即可。</p><p>考虑复杂度，同整体二分，$O(m\log m)$，加上可撤销并查集，$O(m\log m\log n)$，可以通过。</p><p>注意可能前面上层的就已经不合法了，所以要将前面是否合法并向下递归。还要注意判断自相矛盾的情况。可能比较难写，放一个二分的代码。（到底是什么二分 / 分治呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span> &#123;</span>  &#125; dsu ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> dsu.<span class="built_in">find</span>(x) != dsu.<span class="built_in">find</span>(x ^ <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> sl, <span class="keyword">int</span> sr, <span class="keyword">bool</span> frm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// printf(&quot;Solve [%d, %d] : [%d, %d]\n&quot;, l, r, sl, sr);</span></span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (sl == sr) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++ i) f[i] = sl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, now = frm, st = dsu.top;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &lt;= r &amp;&amp; i &lt; sl; ++ i) &#123;</span><br><span class="line">dsu.<span class="built_in">merge</span>(opt[i].first, opt[i].second);</span><br><span class="line">dsu.<span class="built_in">merge</span>(opt[i].first ^ <span class="number">1</span>, opt[i].second ^ <span class="number">1</span>);</span><br><span class="line">now &amp;= <span class="built_in">check</span>(opt[i].first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> bac = dsu.top, ls = now;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = std::<span class="built_in">max</span>(sl, mid); i &lt;= sr; ++ i) &#123;</span><br><span class="line">dsu.<span class="built_in">merge</span>(opt[i].first, opt[i].second);</span><br><span class="line">dsu.<span class="built_in">merge</span>(opt[i].first ^ <span class="number">1</span>, opt[i].second ^ <span class="number">1</span>);</span><br><span class="line">now &amp;= <span class="built_in">check</span>(opt[i].first);</span><br><span class="line"><span class="keyword">if</span> (!now) &#123;</span><br><span class="line">f[mid] = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (now) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &lt;= r; ++ i) f[i] = m + <span class="number">1</span>;</span><br><span class="line">dsu.<span class="built_in">back</span>(bac);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">solve</span>(l, mid - <span class="number">1</span>, sl, sr, ls), dsu.<span class="built_in">back</span>(st);</span><br><span class="line">&#125;</span><br><span class="line">dsu.<span class="built_in">back</span>(bac), <span class="built_in">solve</span>(l, mid - <span class="number">1</span>, sl, f[mid], ls);</span><br><span class="line">dsu.<span class="built_in">back</span>(st), now = frm;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = std::<span class="built_in">max</span>(sl, r + <span class="number">1</span>); i &lt; f[mid]; ++ i) &#123;</span><br><span class="line">dsu.<span class="built_in">merge</span>(opt[i].first, opt[i].second);</span><br><span class="line">dsu.<span class="built_in">merge</span>(opt[i].first ^ <span class="number">1</span>, opt[i].second ^ <span class="number">1</span>);</span><br><span class="line">now &amp;= <span class="built_in">check</span>(opt[i].first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">solve</span>(mid + <span class="number">1</span>, r, f[mid], sr, now), dsu.<span class="built_in">back</span>(st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>, m, <span class="number">1</span>, m + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 2-SAT </tag>
            
            <tag> 分治 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度模板</title>
      <link href="/2022/04/04/high-precision/"/>
      <url>/2022/04/04/high-precision/</url>
      
        <content type="html"><![CDATA[<p>暂不支持负数，可以支持 NTT 加速。</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Polynomial &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">21</span> | <span class="number">10</span>, Mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> rev[N], wn[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x += x &gt;&gt; <span class="number">31</span> &amp; Mod; &#125;</span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL a, LL k = Mod - <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = a * a % Mod)</span><br><span class="line">(k &amp; <span class="number">1</span>) &amp;&amp; (res = res * a % Mod);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poly_bit</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (len &lt;&lt; <span class="number">1</span>)) bit ++;</span><br><span class="line"><span class="keyword">return</span> bit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poly_rev</span><span class="params">(<span class="keyword">int</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; bit); ++ i)</span><br><span class="line">rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> bit, <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">poly_rev</span>(bit);</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &lt; rev[i]) std::<span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LL ak = <span class="built_in">qpow</span>(inv == <span class="number">1</span> ? <span class="number">3</span> : (Mod + <span class="number">1</span>) / <span class="number">3</span>, (Mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">wn[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mid; ++ i) wn[i] = wn[i - <span class="number">1</span>] * ak % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> *a1 = a + i, *a2 = a + i + mid, *w = wn, *ed = a2; a1 &lt; ed; ++ a1, ++ a2, ++ w)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = *a1, y = *a2 * <span class="built_in">LL</span>(*w) % Mod;</span><br><span class="line">*a1 = <span class="built_in">adj</span>(x + y - Mod), *a2 = <span class="built_in">adj</span>(x - y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inv == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">LL Inv = <span class="built_in">qpow</span>(tot);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = a[i] * Inv % Mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Cannot calculate negative numbers</span></span><br><span class="line"><span class="comment">/// using mul(), qpow() (calculated using NTT) when necesary, otherwise use operator *, pow()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigNumber</span> &#123;</span></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> a[x]; &#125;</span><br><span class="line"><span class="built_in">BigNumber</span>() &#123;  &#125;</span><br><span class="line"><span class="built_in">BigNumber</span>(LL x) &#123; <span class="keyword">while</span> (x) a.<span class="built_in">push_back</span>(x % <span class="number">10</span>), x /= <span class="number">10</span>; <span class="keyword">if</span> (a.<span class="built_in">empty</span>()) a.<span class="built_in">push_back</span>(<span class="number">0</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">len</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a.<span class="built_in">size</span>(); &#125;</span><br><span class="line"><span class="keyword">friend</span> BigNumber <span class="keyword">operator</span> +(BigNumber a, BigNumber b)</span><br><span class="line">&#123;</span><br><span class="line">BigNumber res;</span><br><span class="line">res.a.<span class="built_in">resize</span>(std::<span class="built_in">max</span>(a.<span class="built_in">len</span>(), b.<span class="built_in">len</span>()) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>, sz = a.<span class="built_in">len</span>() + b.<span class="built_in">len</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++ i)</span><br><span class="line">t += a[i] + b[i], res[i] = t % <span class="number">10</span>, t /= <span class="number">10</span>;</span><br><span class="line"><span class="built_in">assert</span>(!t);</span><br><span class="line"><span class="keyword">while</span> (res.<span class="built_in">len</span>() &gt; <span class="number">1</span> &amp;&amp; !res.a.<span class="built_in">back</span>()) res.a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> BigNumber <span class="keyword">operator</span> +(LL a, BigNumber b) &#123; <span class="keyword">return</span> <span class="built_in">BigNumber</span>(a) + b; &#125;</span><br><span class="line"><span class="keyword">friend</span> BigNumber <span class="keyword">operator</span> +(BigNumber b, LL a) &#123; <span class="keyword">return</span> <span class="built_in">BigNumber</span>(a) + b; &#125;</span><br><span class="line">BigNumber&amp; <span class="keyword">operator</span> +=(BigNumber b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> + b; &#125;</span><br><span class="line">BigNumber&amp; <span class="keyword">operator</span> +=(LL b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> + b; &#125;</span><br><span class="line"><span class="keyword">friend</span> BigNumber <span class="keyword">operator</span> *(BigNumber a, BigNumber b)</span><br><span class="line">&#123;</span><br><span class="line">BigNumber res;</span><br><span class="line">res.a.<span class="built_in">resize</span>(a.<span class="built_in">len</span>() + b.<span class="built_in">len</span>() + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">len</span>(); ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.<span class="built_in">len</span>(); ++ j)</span><br><span class="line">res[i + j] += a[i] * b[j];</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">len</span>(); ++ i) t += res[i], res[i] = t % <span class="number">10</span>, t /= <span class="number">10</span>;</span><br><span class="line"><span class="built_in">assert</span>(!t);</span><br><span class="line"><span class="keyword">while</span> (res.<span class="built_in">len</span>() &gt; <span class="number">1</span> &amp;&amp; !res.a.<span class="built_in">back</span>()) res.a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> BigNumber <span class="keyword">operator</span> *(BigNumber a, LL b) &#123; <span class="keyword">return</span> a * <span class="built_in">BigNumber</span>(b); &#125;</span><br><span class="line">BigNumber&amp; <span class="keyword">operator</span> *=(BigNumber b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> * b; &#125;</span><br><span class="line">BigNumber&amp; <span class="keyword">operator</span> *=(LL b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> * <span class="built_in">BigNumber</span>(b); &#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(BigNumber a, BigNumber b) &#123; <span class="keyword">return</span> a.a == b.a; &#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(BigNumber a, BigNumber b) &#123;</span><br><span class="line"><span class="keyword">if</span> (a.<span class="built_in">len</span>() ^ b.<span class="built_in">len</span>()) <span class="keyword">return</span> a.<span class="built_in">len</span>() &lt; b.<span class="built_in">len</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = a.<span class="built_in">len</span>() - <span class="number">1</span>; ~j; -- j)</span><br><span class="line"><span class="keyword">if</span> (a[j] ^ b[j]) <span class="keyword">return</span> a[j] &lt; b[j];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;(BigNumber a, BigNumber b) &#123; <span class="keyword">return</span> b &lt; a; &#125;</span><br><span class="line"><span class="keyword">friend</span> BigNumber <span class="keyword">operator</span> -(BigNumber a, BigNumber b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(a &gt; b || a == b);</span><br><span class="line">BigNumber res;</span><br><span class="line">res.a.<span class="built_in">resize</span>(a.<span class="built_in">len</span>()), b.a.<span class="built_in">resize</span>(a.<span class="built_in">len</span>());</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">len</span>(); ++ i)</span><br><span class="line">t += a[i] - b[i], t += <span class="number">1000</span>, res[i] = t % <span class="number">10</span>, t /= <span class="number">10</span>, t -= <span class="number">100</span>;</span><br><span class="line"><span class="built_in">assert</span>(!t);</span><br><span class="line"><span class="keyword">while</span> (res.<span class="built_in">len</span>() &gt; <span class="number">1</span> &amp;&amp; !res.a.<span class="built_in">back</span>()) res.a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">BigNumber <span class="keyword">operator</span> -(LL b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> - <span class="built_in">BigNumber</span>(b); &#125;</span><br><span class="line">BigNumber&amp; <span class="keyword">operator</span> -=(BigNumber b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> - b; &#125;</span><br><span class="line">BigNumber&amp; <span class="keyword">operator</span> -=(LL b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> - <span class="built_in">BigNumber</span>(b); &#125;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> BigNumber <span class="title">mul</span><span class="params">(BigNumber a, BigNumber b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Polynomial;</span><br><span class="line"><span class="keyword">int</span> bit = <span class="built_in">poly_bit</span>(std::<span class="built_in">max</span>(a.<span class="built_in">len</span>(), b.<span class="built_in">len</span>()) + <span class="number">1</span>), tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">a.a.<span class="built_in">resize</span>(tot), b.a.<span class="built_in">resize</span>(tot), <span class="built_in">NTT</span>(a.a.<span class="built_in">data</span>(), bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b.a.<span class="built_in">data</span>(), bit, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = (LL)a[i] * b[i] % Mod;</span><br><span class="line"><span class="built_in">NTT</span>(a.a.<span class="built_in">data</span>(), bit, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">len</span>(); ++ i) t += a[i], a[i] = t % <span class="number">10</span>, t /= <span class="number">10</span>;</span><br><span class="line"><span class="built_in">assert</span>(!t);</span><br><span class="line"><span class="keyword">while</span> (a.a.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; !a.a.<span class="built_in">back</span>()) a.a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">friend</span> BigNumber <span class="title">pow</span><span class="params">(BigNumber a, LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">BigNumber <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>, a = a * a)</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) res = res * a;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">friend</span> BigNumber <span class="title">qpow</span><span class="params">(BigNumber a, LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">BigNumber <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>, a = <span class="built_in">mul</span>(a, a))</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) res = <span class="built_in">mul</span>(res, a);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) ;</span><br><span class="line">a.<span class="built_in">push_back</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) a.<span class="built_in">push_back</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">std::<span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">len</span>() - <span class="number">1</span>; ~j; -- j) <span class="built_in">putchar</span>(a[j] | <span class="number">48</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span> &gt;&gt;(std::istream &amp;is, BigNumber &amp;t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> &amp;a = t.a;</span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ((is &gt;&gt; c, c) &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) ;</span><br><span class="line">a.<span class="built_in">push_back</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> ((is &gt;&gt; c, c) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) a.<span class="built_in">push_back</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">std::<span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt;(std::ostream &amp;os, BigNumber t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l = t.<span class="built_in">len</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; ~i; -- i) os &lt;&lt; t[i];</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>狄利克雷生成函数</title>
      <link href="/2022/04/02/Dirichlet-generating-function/"/>
      <url>/2022/04/02/Dirichlet-generating-function/</url>
      
        <content type="html"><![CDATA[<p>解决数论函数的有利武器。</p><span id="more"></span><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>定义一个数列的<strong>狄利克雷生成函数</strong>（DGF）为：<br>$$<br>\tilde F(x) = \sum_{i\geq 1} \dfrac{f_i}{i^x}<br>$$<br>我们如果将 ${f_i}$ 看作是一个从 $\mathbb N _ +$ 到 $\mathbb Z$ 的一个函数，那么该生成函数就与一个数论函数相对应。一般来说，$f_1 = 1$。下文默认 $f_1 = 1$。</p><p>如果该函数是积性的，即满足 $\forall i\bot j, f(ij) = f(i) \times f(j)$，那么 $\tilde F(x)$ 的表达可以由质数以及质数的幂的值来表达，记作（设 $P$ 表示全体质数集合）：<br>$$<br>\tilde F(x) = \prod_{p\in P}(1 + \dfrac {f(p)}{p ^ x} + \dfrac{f(p) ^ 2}{p ^ {2x}} + …)<br>$$</p><h2 id="2-狄利克雷函数的卷积"><a href="#2-狄利克雷函数的卷积" class="headerlink" title="2. 狄利克雷函数的卷积"></a>2. 狄利克雷函数的卷积</h2><p>就是一个简单的定义。</p><p>定义：<br>$$<br>\tilde F(x)\tilde G(x) = \sum_{ij}\dfrac {f(i)g(j)}{ij}<br>$$<br>这个和 $(f * g)(x) = \sum_{d | x}f(d)g(\dfrac xd)$ 是相同的。</p><h2 id="3-常见函数"><a href="#3-常见函数" class="headerlink" title="3. 常见函数"></a>3. 常见函数</h2><h3 id="1）常值函数"><a href="#1）常值函数" class="headerlink" title="1）常值函数"></a>1）常值函数</h3><p>在数论中，我们常见到 $I(x) = 1$ 的函数，即 ${1, 1, 1, …}$ 的数列。他的 DGF 为<strong>黎曼函数</strong>，记作 $\zeta (x)$。</p><p>常值函数显然也是积性函数，我们尝试使用质数及质数的幂的值来表达，即：<br>$$<br>\tilde F(x) = \prod_{p\in P}(1 + \dfrac 1{p ^ x} + \dfrac 1{p ^ {2x}} + …)<br>$$<br>我们将质数内部的用等比数列求和展开，公比 $p^{-x}$，即为：<br>$$<br>1 + \dfrac 1{p ^ x} + \dfrac 1{p ^ {2x}} + … = \dfrac{-1}{p ^ {-x} - 1} = \dfrac 1{1 - p^{-x}}<br>$$<br>那么，我们得到黎曼函数的另外的表达方式：<br>$$<br>\zeta(x) = \prod_{p\in P}\dfrac 1{1 - p ^ {-x}}<br>$$</p><h3 id="2）标号函数"><a href="#2）标号函数" class="headerlink" title="2）标号函数"></a>2）标号函数</h3><p>（记不得叫什么了</p><p>定义 $id(x) = x$，那么我们来探究一下 ${1, 2, 3\dots}$ 的 DGF。</p><p>还是根据积性函数的性质，我们可以得到：<br>$$<br>\tilde F(x) = \prod_{p\in P}(1 + \dfrac{p}{p ^ x} + \dfrac{p ^ 2}{p ^ {2x}}+ \dots)<br>$$<br>等比数列求和，可以得到：<br>$$<br>\tilde F(x) = \prod_{p\in P}\dfrac 1{1 - p ^ {1 - x}}<br>$$<br>而这个由可以表示成黎曼函数：<br>$$<br>\tilde F(x) = \zeta(x - 1)<br>$$<br>如果我们将这个换成 $id ^ k(x) = x ^ k$，那么答案就是：<br>$$<br>\tilde F(x) = \prod_{p\in P}\dfrac 1{1 - p ^ {k - x}} = \zeta(x - k)<br>$$</p><h3 id="3）莫比乌斯函数"><a href="#3）莫比乌斯函数" class="headerlink" title="3）莫比乌斯函数"></a>3）莫比乌斯函数</h3><p>对于一般的函数，我们通常讨论在质数点的取值来得到 DGF。<br>$$<br>\tilde F(x) = \prod_{p\in P}(1 + \dfrac{-1}{p ^ x}) = \prod_{p\in P}\dfrac{p ^ x - 1}{p ^ x}<br>$$<br>这个怎样用黎曼函数表示呢？</p><p>发现 $\displaystyle \dfrac 1{\tilde F(x)} = \prod_{p\in P}\dfrac{p ^ x}{p ^ x - 1} = \prod_{p\in P}\dfrac 1{1 - p ^ {-x}} = \zeta(x)$，所以 $\tilde F(x) = \dfrac 1{\zeta(x)}$。</p><h3 id="4）欧拉函数"><a href="#4）欧拉函数" class="headerlink" title="4）欧拉函数"></a>4）欧拉函数</h3><p>同样，直接上式子：<br>$$<br>\tilde F(x) = \prod_{p\in P}(1 + \dfrac{p - 1}{p ^ x} + \dfrac{p(p - 1)}{p ^ {2x}} + \dfrac{p ^ 2(p - 1)}{p ^ {3x}} + \dots)<br>$$<br>我们直接考虑先改成封闭形式：<br>$$<br>\begin{aligned}<br>\tilde F(x) &amp;= \prod_{p\in P}(1 + \dfrac{p}{p ^ x} + \dfrac{p ^ 2}{p ^ {2x}} + \dots - \dfrac{1}{p ^ x} (1 + \dfrac{p}{p ^ x} + …))<br>\\&amp;= \prod_{p\in P}(\dfrac 1{1 - p ^ {1 - x}} - \dfrac{p ^ {-x}}{1 - p ^ {1 - x}}) \\ &amp;= \prod_{p\in P}\dfrac{1 - p ^ {-x}}{1 - p ^ {1 - x}}<br>\\ &amp;= \dfrac{\zeta(x - 1)}{\zeta(x)}<br>\end{aligned}<br>$$<br>那么，这个和 $id^0 = I$ 卷积，就可以得到：$\dfrac{\zeta(x - 1)}{\zeta(x)} * \zeta(x) = \zeta(x - 1)$。这对应着 $id(x)$。</p><h3 id="5）约数-k-次幂"><a href="#5）约数-k-次幂" class="headerlink" title="5）约数 k 次幂"></a>5）约数 k 次幂</h3><p>首先定义 $\sigma_0(x) = \sum_{d | x}$，表示约数个数。而 $\sigma_k(x) = \sum_{d | x}d ^ k$。这里给出 $\sigma_1(k)$ 的推导。<br>$$<br>\begin{aligned}<br>\tilde F(x) &amp;= \prod_{p\in P}(1 + \dfrac{p ^ 2 - 1}{p ^ x(p - 1)} + \dfrac{p ^ 3 - 1}{p ^ {2x}(p - 1)} + \dots)<br>\\ &amp;= \prod_{p\in P}\dfrac 1{p - 1}((\dfrac{p}{p ^ {0x}} + \dfrac{p ^ 2}{p ^ x} + \dots) - (\dfrac{1}{p ^ {0x}} + \dfrac{1}{p ^ {x}} + \dots))<br>\\ &amp;= \prod_{p \in P}\dfrac 1{p - 1}(\dfrac{p}{1 - p ^ {1 - x}} - \dfrac{1}{1 - p ^ {-x}})<br>\\ &amp;= \prod_{p\in P}\dfrac 1{p - 1}\dfrac{p - 1}{(1 - p ^ {1 - x})(1 - p ^ {-x})}<br>\\ &amp;= \prod_{p\in P}\dfrac{1}{(1 - p^{-x})(1 - p^{1 - x})}<br>\\ &amp;= \zeta(x)\zeta(x - 1)<br>\end{aligned}<br>$$<br>而对于 $\sigma_k(x) = \sum_{d | x}d ^ k$，我们有：$\tilde F(x) = \zeta(x)\zeta(x - k)$。本处证明略去。</p><h3 id="6）乘上-x-k"><a href="#6）乘上-x-k" class="headerlink" title="6）乘上  $x^k$"></a>6）乘上  $x^k$</h3><p><strong>结论：</strong>若 $f(x)$ 的 DGF 是 $\tilde F(x)$，那么 $g(x) = f(x)\times x ^ k$ 的 DGF 是 $\tilde G(x) = \tilde F(x - k)$。这个可以通过改变质数处的取值得到。证明略去。</p><h2 id="4-例题"><a href="#4-例题" class="headerlink" title="4. 例题"></a>4. 例题</h2><h3 id="T1：简单的数学题"><a href="#T1：简单的数学题" class="headerlink" title="T1：简单的数学题"></a>T1：简单的数学题</h3><p>求 $\sum_{i = 1}^n i ^ 2\varphi(i)$，使用杜教筛。</p><p>直接使用 $\tilde F(x) = \dfrac{\zeta(x - 3)}{\zeta(x - 2)}$，那么 $f(i) * id^2(i) = id^3(i)$。直接筛就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">get_sphi</span><span class="params">(LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; N) <span class="keyword">return</span> sphi[n];</span><br><span class="line"><span class="keyword">if</span> (Sphi.<span class="built_in">find</span>(n) != Sphi.<span class="built_in">end</span>()) <span class="keyword">return</span> Sphi[n];</span><br><span class="line">LL ans = <span class="built_in">sum3</span>(n);</span><br><span class="line"><span class="keyword">for</span> (ll l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">ans = (-(<span class="built_in">sum2</span>(r) - <span class="built_in">sum2</span>(l - <span class="number">1</span>)) * <span class="built_in">get_sphi</span>(n / l) % Mod + ans + Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Sphi[n] = ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOI Online 2022 游记</title>
      <link href="/2022/04/01/NOI-Online-2022/"/>
      <url>/2022/04/01/NOI-Online-2022/</url>
      
        <content type="html"><![CDATA[<p>考的似乎比较套路，没有去年的思维 / 数学。</p><span id="more"></span><p>以考试当天为 Day 0。</p><h2 id="Day-？"><a href="#Day-？" class="headerlink" title="Day ？"></a>Day ？</h2><p>很早就报名了，都快忘记这件事了（</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>在学校考试。</p><p>校内又说什么要占机房考试，好不容易在 8：20 的时候才到机房安心坐下来。</p><p>8：30 开题，还好没咕，不像 NOI 线上，一个小时还没拿到题。</p><p>结果盯着 T1 发呆了许久，满脑子里都是二维数点 $O(n\log^2 n)$，根本做不了这题。半个小时过去了，没有任何收获。</p><p>意识到事情没对，马上开 T2，发现是一个输出一个方案即可的题，似乎哪年 NOI 考过这样的题，还是随机化过去的？</p><p>tg 应该不是这类题目，推了推性质，发现可以按 <code>size</code> 分类，相同 <code>size</code> 的只可能不交或是完全相同，否则一定合法。</p><p>胡了一个只用判 <code>size</code> 相邻的做法，发现没对，可以按 <code>size</code> 倒序插入，用桶维护哪个点被那个集合覆盖，如果新来的一个集合覆盖的颜色不止一种，一定合法。</p><p>赛时没想清楚，随便输出一个颜色，考后才发现要输出不同颜色中 <code>size</code> 最小的。</p><p>写完 T2，过样例，由于不会造数据，只好跳过。此时 10：10。</p><p>发现 T3 似乎是一个简单题，拆一拆贡献，记录每一个位置的数被统计为最大值 / 最小值了多少次，发现剩下的是一个三维偏序（才没想什么还可以转化为二维偏序的方法），可以 $O(n\log^2 n)$，做 8 次，感觉有点卡。</p><p>马上开始码，还算顺利，没调多久就过了所有样例，极限数据 1.79 s，感觉很稳。</p><p>回过头来看 T1，已是 10：50。大力猜一手结论，应该是直接找到后面第一个比自己大的，然后如果颜色相同一直向前跳，扫描线处理询问，可以做到 $O(n\log n)$（不算向前跳的假的复杂度）。</p><p>发现要码 2 个线段树，心态不好，看到自己只有 30 min 左右的时间了，结果写完死活过不了大样例，此时已经是 11：40 了。</p><p>发现中间有一步不应该将因颜色相同而跳过的点删去，改了过后，过了大样例，还只要 0.5 s，马上交上去，11：47。</p><p>跳了过程可以用并查集优化，快速码了一个，11：51，<del>发现自己 AK 了</del>，<strong>交不上去了！</strong></p><p>最后 10 min 中，在狂躁之中度过，发现一点转机都没有，守到 12 点，唉声叹气地走了。</p><p>出来议论，发现一些人做出来 T1 了，连低一个年级的同学都有人做出来。可惜我没交上去（悲</p><p>但是大家似乎没做出来 T3，似乎随便写写，得了个暴力 + 部分分。赶紧去食堂吃饭了。</p><p>下午还得考试，又回到机房，12：28，了转反，<strong>考试延期了半个小时！</strong></p><p>确认一下是不是真的，马上将自己的 T1 交了上去。不知道自己怎么样了呢。</p><p>水了一会，又去看各大 OJ 有没有测的，发现 InfOJ 可以测，<del>但是已经排了 24 页的提交记录了</del>。</p><p>13：30 左右，lg 可以测了，发现 T1，T2，T3 都过了，心态很不错。看到 T2 有人说要取 <code>size</code> 最小的，没在意。</p><p>等到看到 InfOJ 可以测 T2 时，发现只有 Subtask 2 没过，连 Subtask 6 都过了，80 pts。我相信 CCF 的数据应该不强（flag</p><p>lg 加强了几次 T2 数据，结果随便就过了，不知道该相信哪边（<del>事后看显然是 InfOJ</del></p><p>等 CCF 数据。</p><h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><p>看到 CCF 出了一个“成绩公示”，结果什么都是访问异常，啥也看不到。</p><p>看到有人说用另外的网址可以看到成绩，<strong>开幕雷击</strong>，一车人直接 AK 了！</p><p>发现 CCF 数据实在是强，直接 10 个点卡了我四个点，T2 直接 60 pts，和随机化寻找一个分了（<del>我可是写挂了正解呀</del></p><p>$100 + 60 + 100 = 260$。</p><p>结果 lg 上一车人说数据过水，痛苦面具。水一点该多好啊，<del>难得接近 AK 一次</del>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于这种偏结论或乱搞的题目，感觉自己很多细节没有想清楚，这种东西赛时很难检查到，赛后后悔也来不及了。还是多做这种结论题吧。</p><p>还有，怎么没考 DP？一考大概率裂开。</p><p>等联合省选。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF Round#775</title>
      <link href="/2022/03/08/CF-Round-775/"/>
      <url>/2022/03/08/CF-Round-775/</url>
      
        <content type="html"><![CDATA[<p>状态不错，F 只想得到线段树，思路还没清晰，就结束了……</p><p>比赛记录：ABCDE Accepted，Scores：6328，Rank #7，Rating 1663 -&gt; 1962。</p><p>改题进度：ABCDE Accepted。</p><p><a href="https://codeforces.com/contest/1649/">比赛传送门</a></p><span id="more"></span><h3 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h3><p>题意不描述了。</p><p>签到题，从左端点一直向右走，从右端点一直向左走，遇上了就是 0，否则答案就是两点距离。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n &amp;&amp; a[i]) i ++;</span><br><span class="line"><span class="keyword">if</span> (i &gt; n) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j = n;</span><br><span class="line"><span class="keyword">while</span> (j &amp;&amp; a[j]) j --;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, j - i + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B."></a>B.</h3><p>题意：有 $n$ 个人传球，已知每个人传出的次数，可以拿到球后不传，问至少要多少个球。</p><p>考虑贪心，要满足传出次数最多的人，就让剩下的人都传给他，如果还不能满足，剩余的传出次数，每一个都要一个球。否则一个球就可以完成。</p><p>注意特判全是 0 的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) flag |= !!a[i];</span><br><span class="line"><span class="keyword">if</span> (!flag) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">LL sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) sum += a[i];</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">LL</span>(*std::<span class="built_in">max_element</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>)) &lt;&lt; <span class="number">1</span>) &lt;= sum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="number">2LL</span> * (*std::<span class="built_in">max_element</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>)) - sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h3><p>题意：给出 $n\times m$ 的矩形，每个点有一个颜色，求所有颜色相同的点两两之间的曼哈顿距离和。$n\times m \leq 10^5,c_{i, j}\leq 10^5$。</p><p>也许我的做法劣一些，但是也不慢，多一只 $\log$。</p><p>考虑将所有颜色相同的点按 $x$ 排序，统计答案的时候，由 $y$ 的情况分为两种：$y \leq y_{now}, y &gt; y_{now}$。分别用树状数组维护即可，时间复杂度 $O(nm\log m)$。</p><p>似乎可以直接拆贡献计算做到 $O(nm)$？没管。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span>  &#125; f, g, cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt; N; ++ c)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : al[c]) &#123;</span><br><span class="line">res += (LL)cnt.<span class="built_in">ask</span>(p.y) * (p.x + p.y) + f.<span class="built_in">ask</span>(p.y);</span><br><span class="line">res += (LL)(cnt.<span class="built_in">ask</span>(m) - cnt.<span class="built_in">ask</span>(p.y)) * (p.x - p.y) + (g.<span class="built_in">ask</span>(m) - g.<span class="built_in">ask</span>(p.y));</span><br><span class="line">f.<span class="built_in">add</span>(p.y, -p.x - p.y), g.<span class="built_in">add</span>(p.y, p.y - p.x), cnt.<span class="built_in">add</span>(p.y, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : al[c]) &#123;</span><br><span class="line">f.<span class="built_in">add</span>(p.y, p.x + p.y), g.<span class="built_in">add</span>(p.y, p.x - p.y), cnt.<span class="built_in">add</span>(p.y, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D."></a>D.</h3><p>题意：判断一个集合是否满足 $\forall x, y\in S\land x\geq y, s.t. \left\lfloor\dfrac xy \right\rfloor \in S$。$|S|\leq 10^6, \forall x \in S, x\leq 10^6$。</p><p>暴力枚举显然是 $O(n ^ 2)$ 的。</p><p>我们可以考虑枚举 $x$ 和 $\left\lfloor\dfrac yx\right\rfloor = k$，如果 $x$ 存在，$[kx, (k + 1)x)$ 中间也有数，那么 $k$ 必须存在，否则不合法。</p><p>看似是 $O(n ^ 2)$ 的，但是我们发现对于每个 $x$，需要枚举的 $k$ 仅为 $\dfrac{C}{x}$，其中 $C$ 为最大的数。</p><p>所以时间复杂度为 $O(C + \dfrac C2 + \dfrac C3 + …)$，为调和级数，$O(C\ln C)$。</p><p>至于怎么统计一个区间出现过没有数，直接前缀和即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++ i) h[i] += h[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++ i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = i, r, j = <span class="number">0</span>; l &lt;= c; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (h[i] == h[i - <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">r = std::<span class="built_in">min</span>(c, l + i - <span class="number">1</span>), j ++;</span><br><span class="line"><span class="keyword">if</span> (h[r] == h[l - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (h[j] == h[j - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E."></a>E.</h3><p>题意：给定由数字组成的字符串 $s$ 和 $t$，求有多少种重排后的 $s$ 满足 $s$ 的字典序小于 $t$，答案对 998244353 取模。$|s|, |t|\leq 2\cdot 10^5, s_i, t_i\leq 2\cdot 10^5$。</p><p>比较思维的一个组合计数，但不是特别难。</p><p>考虑类似数位 DP 的方法，枚举出现差异为第 $i$ 位，那么前 $i - 1$ 项都是相同的。</p><p>假设我们暴力的话，我们枚举 $i$ 填入的数，显然填入的数 $x &lt; b_i$，那么剩下的位置就可以随意组织了。因为有重复元素，不直接是阶乘，而是：<br>$$<br>ans = \dfrac{(n - i)!}{cnt_1!cnt_2!cnt_3!…}<br>$$<br>现在我们考虑快速将所有填入的 $x$ 的答案全部统计了。</p><p>假设我们不限制这一位，答案是：<br>$$<br>ans = \dfrac{(n - i + 1)!}{cnt_1!cnt_2!…cnt_x!…}<br>$$<br>限制之后，答案是：<br>$$<br>ans = \dfrac{(n - i)!}{cnt_1!cnt_2!…(cnt_x - 1)!…}<br>$$<br>所以我们要在原来的基础上乘以 $\dfrac{cnt_x}{n - i + 1}$。</p><p>所以我们直接维护 $cnt_x$ 的前缀和，用树状数组就可以在 $O(\log n)$ 的时间内维护。</p><p>至于如何维护不限制情况下的答案，我们也可以使用类似的办法。</p><p>填这一位之前：<br>$$<br>ans = \dfrac{(n - i + 1)!}{cnt_1!cnt_2!…cnt_x!…}<br>$$<br>假设 $b_i = x$，也就是我们要填入 $x$，那么答案变为了：<br>$$<br>ans = \dfrac{(n - i)!}{cnt_1!cnt_2!…(cnt_x - 1)!…}<br>$$<br>所以答案乘上了 $\dfrac{cnt_x}{n - i + 1}$，先维护每个数的逆元就可以 $O(1)$ 维护了。</p><p>可能无法在 $i$ 处填入 $b_i$，注意要快速退出。</p><p>注意如果 $n &lt; m$ 且前 $n$ 个都可以填入，答案要加 1（因为前面一样，长度小的排前面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span>  &#125; bt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = std::<span class="built_in">min</span>(n, m);</span><br><span class="line">LL res = <span class="number">0</span>, now = fact[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cnt[a[i]] ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) now = now * infact[cnt[i]] % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) bt.<span class="built_in">add</span>(i, cnt[i]);</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">res = (res + bt.<span class="built_in">ask</span>(b[i] - <span class="number">1</span>) * now % Mod * inv[n - i + <span class="number">1</span>]) % Mod;</span><br><span class="line"><span class="keyword">if</span> (!cnt[b[i]]) &#123;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">bt.<span class="built_in">add</span>(b[i], <span class="number">-1</span>), now = now * inv[n - i + <span class="number">1</span>] % Mod * (cnt[b[i]] --) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (res + ((n &lt; m) &amp;&amp; flag)) % Mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 做题记录 </tag>
            
            <tag> CF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF Round#773</title>
      <link href="/2022/02/25/CF-Round-773/"/>
      <url>/2022/02/25/CF-Round-773/</url>
      
        <content type="html"><![CDATA[<p>Div 2 当场降智，直接变成了 SpeedForces 了。</p><p>比赛记录：ABC Accepted，Scores：2247，Rank：872。</p><p>改题进度：ABCF Accepted。</p><span id="more"></span><h4 id="A"><a href="#A" class="headerlink" title="A"></a>A</h4><p>题意：给一个三角形，求不能通过不穿过三角形的直线到达 y 轴的线段长度。</p><p>显然如果想要不能到达 y 轴，一定是平行于 y 轴的线才有可能。</p><p>如果第三个点在这两个点的上方，答案也显然是 0：</p><img src="/2022/02/25/CF-Round-773/A.png" class=""><p>按 y 坐标排序即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PDD p[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++ i)</span><br><span class="line">std::cin &gt;&gt; p[i].first &gt;&gt; p[i].second;</span><br><span class="line">std::<span class="built_in">sort</span>(p, p + <span class="number">3</span>, [](PDD a, PDD b) &#123; <span class="keyword">return</span> a.second &lt; b.second ;&#125;);</span><br><span class="line"><span class="keyword">if</span> (p[<span class="number">1</span>].second != p[<span class="number">2</span>].second) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>, std::<span class="built_in">abs</span>(p[<span class="number">1</span>].first - p[<span class="number">2</span>].first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B"><a href="#B" class="headerlink" title="B"></a>B</h4><p>题意：给一个长度为 $n$ 的数组，对于每一个 $k\in[1, n]$，求出划分为 $k$ 个集合后，求每一个集合的不同元素的个数总和的最小值。</p><p>显然我们将相同的元素放在一起，答案也至少是这个数组中数的不同的个数 $j$。</p><p>显然答案 $\geq k$。尝试证明答案 $ans_k = \max(k, j)$。</p><p>当 $k &lt; j$ 的时候，我们将相同的放在一起，会出现 $j$ 个集合，然后任意合并一些，答案不变，所以 $ans_k = j$。</p><p>当 $k \geq j$ 的时候，我们仍然将相同的放在一起，然后操作 $k - j$ 次，每一次分裂一个集合。显然答案每次加 1，总答案为 $j + (k - j) = k$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (a[i] != a[i - <span class="number">1</span>]) cnt ++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, cnt);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cnt + <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br></pre></td></tr></table></figure><h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><p>题意：定义一个数列是好的，为可以划分为 $\dfrac n2$ 对（显然 $n$ 为偶数），每一对中两数之商为 $x$。给一个序列，添加最少的数使得序列是好的。$n\leq 2\cdot 10^5,2\leq x \leq10^6$。</p><p>我们直接找到可以匹配的最大对数，让剩下的每一个都加一个数与之匹配即可。问题转化为求最大匹配数。</p><p>直接将所有数扔入一个 <code>multiset</code>，然后从小向大枚举。如果还没有匹配的话，说明不能和小的匹配，直接找一个 $a_i \cdot x$，看一下有没有，有就删一个。</p><p>最后直接输出 <code>multiset</code> 的 <code>size()</code> 即可。</p><p>注意如果只删一个数，应该写为 <code>erase(find(x))</code> 而不是 <code>erase(x)</code>，那样会删掉所有的相同元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::multiset&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = a.<span class="built_in">begin</span>(); iter != a.<span class="built_in">end</span>(); iter ++)</span><br><span class="line">&#123;</span><br><span class="line">LL now = *iter;</span><br><span class="line"><span class="keyword">auto</span> t = a.<span class="built_in">find</span>(now * x);</span><br><span class="line"><span class="keyword">if</span> (t != a.<span class="built_in">end</span>()) a.<span class="built_in">erase</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in"><span class="keyword">int</span></span>(a.<span class="built_in">size</span>()));</span><br></pre></td></tr></table></figure><h4 id="F"><a href="#F" class="headerlink" title="F"></a>F</h4><p>给定 $n$ 个长度为 $m$ 的数组，每个数组有一个权值 $w$，找到两个数组使得数字没有重复，求这两个数组权值和的最小值。$n \leq 10^5, m\leq 5$，保证一个数组内数字没有重复。</p><p>比赛直接降智，胡了个错误的 Tarjan，没想到暴力就过去了……</p><p>笔者也不会题解主要介绍的方法 $O(n2^m)$，但是 $O(\dfrac{n^2m}\omega)$ 的算法就是香啊！</p><p>我们直接考虑暴力怎么做：直接枚举每一个数，将包含这个数的所有数组互相都设为不可用。即开一个二维 <code>boolean</code> 数组，$a[i][j]$ 表示 $i, j$ 数组能不能选在一起。枚举每一个数时，设包含这个数的数组集合为 $S$，则 $[i \in S][j \in S] a[i][j] \leftarrow 0$。</p><p>看到我们只用枚举每个数，我们可以先存下来每一个数对应的 $S$（？，然后枚举到一个数组的时候，直接 &amp;$S$ 即可。时空复杂度均为 $O(\dfrac{n^2m}\omega)$，然后就成功 MLE（还不是最惨的，我加了些优化，变为了 $O(\dfrac {n^2}\omega)$）：</p><img src="/2022/02/25/CF-Round-773/F_submission.png" class=""><p>怎么办呢？</p><p>我们发现，有很多 $S$ 只有一两个位置有 $1$，但是我们却存了不知多少个 0。我们直接考虑设定阈值 $T$，当 $\mid S \mid \leq T$ 时我们直接让 $S$ 暴力更新即可。可以发现，最多有 $\dfrac {nm}T$ 个数我们要开 $\text{bitset}$，所以空间复杂度为 $O(nm + \dfrac{n^2m}{T\omega})$，时间复杂度为 $O(nmT + \dfrac{n^2m}{w})$，取 $T = 500\sim 1000$ 比较合适的样子。（但是我开的 50 也过了</p><p>注意指针等的使用，可能有些难写，给出整个代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, Block = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arr</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>], w;</span><br><span class="line">&#125; c[N];</span><br><span class="line">std::bitset&lt;N&gt; bt[<span class="number">505</span>], tmp, *bk[N &lt;&lt; <span class="number">3</span>], *it = bt;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; al, ha[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">al.<span class="built_in">reserve</span>(n * m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i].a[j]);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i].w);</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(c + <span class="number">1</span>, c + n + <span class="number">1</span>, [&amp;](<span class="keyword">const</span> Arr &amp;c1, <span class="keyword">const</span> Arr &amp;c2) &#123; <span class="keyword">return</span> c1.w &lt; c2.w; &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">al.<span class="built_in">push_back</span>(c[i].a[j]);</span><br><span class="line">std::<span class="built_in">sort</span>(al.<span class="built_in">begin</span>(), al.<span class="built_in">end</span>());</span><br><span class="line">al.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(al.<span class="built_in">begin</span>(), al.<span class="built_in">end</span>()), al.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">int</span> sz = al.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">c[i].a[j] = std::<span class="built_in">lower_bound</span>(al.<span class="built_in">begin</span>(), al.<span class="built_in">end</span>(), c[i].a[j]) - al.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) ha[c[i].a[j]].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; ++ i) &#123;</span><br><span class="line"><span class="keyword">if</span> (ha[i].<span class="built_in">size</span>() &lt;= Block) <span class="keyword">continue</span>;</span><br><span class="line">bk[i] = it ++, bk[i]-&gt;<span class="built_in">set</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> pos : ha[i]) bk[i]-&gt;<span class="built_in">reset</span>(pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">2e9</span> + <span class="number">7</span>, t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">std::bitset&lt;N&gt; now;</span><br><span class="line">now.<span class="built_in">set</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line"><span class="keyword">if</span> (ha[c[i].a[j]].<span class="built_in">size</span>() &lt;= Block)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> pos : ha[c[i].a[j]]) now[pos] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> now &amp;= *bk[c[i].a[j]];</span><br><span class="line"><span class="keyword">if</span> ((t = now._Find_next(<span class="number">0</span>)) &lt;= n) ans = std::<span class="built_in">min</span>(ans, c[i].w + c[t].w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 做题记录 </tag>
            
            <tag> CF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Min_25 筛</title>
      <link href="/2022/02/13/Min-25-Sieve/"/>
      <url>/2022/02/13/Min-25-Sieve/</url>
      
        <content type="html"><![CDATA[<p>非常 NB 的一个筛法，虽然复杂度可能会趋近线性 $O(n ^ {1 - \epsilon})$，但是在 OI 范围内非常不错。</p><span id="more"></span><h2 id="1-算法介绍"><a href="#1-算法介绍" class="headerlink" title="1. 算法介绍"></a>1. 算法介绍</h2><p>要么是 $O(\dfrac{n ^ {\frac34}}{\log n})$，还有一种是 $O(n ^ {1 - \epsilon})$，反正可以在 $10^{10}$ 范围内跑 1s 左右。</p><h2 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2. 算法流程"></a>2. 算法流程</h2><p>感觉比杜教筛更好构造。</p><p>假设 $f(x)$ 的前缀和是我们要求的。</p><p>分为两步：先求出在当 $x \in P$（表示 $x$ 是质数）的 $f(x)$ 的前缀和，第二步通过质数的前缀和求出整个的前缀和。</p><h3 id="1）求-g-x-f-x-x-in-P-的前缀和"><a href="#1）求-g-x-f-x-x-in-P-的前缀和" class="headerlink" title="1）求 $g(x) = f(x)[x \in P]$  的前缀和"></a>1）求 $g(x) = f(x)[x \in P]$  的前缀和</h3><p>我们找到一个多项式 $g(x)$，使得 $x \in P$ 的时候 $f(x) = g(x)$。</p><p>定义 $\text{lpf}(x)$ 是 $x$ 的最小质因数，$p_x$ 表示第 $x$ 个质数。</p><p>先将多项式拆为多个 $x ^ k$，这样的话 $g(x)$ 就是一个完全积性函数了，即满足 $g(ab) = g(a) \cp g(b)$。</p><p>我们定义 $h(n, k) = \sum_{i = 1}^n [i \in P \lor \text{lpf}(i) &gt; p_k]g(i)$。</p><p><del>（显然状态数比 $n$ 还大）</del></p><p>我们考虑从 $h(…, k - 1)$ 转移到 $h(n, k)$。</p><p>考虑 $h(n, k - 1)$ 变为 $h(n, k)$，需要减去 $\text{lpf}(x) = p_k$ 的数。</p><p>如果我们将 $x$ 除以 $p_k$，又怎么样呢？</p><p>那么剩下的变为 $\text{lpf}(\dfrac x{p_k})\geq p_k$。至于为什么是 $\geq$，是因为可能有单个数可能有多个 $p_k$ 质因子。</p><p>这不和 $h(\dfrac n{p_k}, k - 1)$ 定义很像了吗！</p><p>对比一下：<br>$$<br>\begin{aligned}<br>h(\dfrac n{p_k}, k - 1) &amp;= \sum_{i = 1}^{\frac n{p_k}}[i \in P \lor \text{lpf}(i) \geq p_k]g(i)\\<br>&amp;= \sum_{i = 1}^{\frac n{p_k}}[\text{lpf}(i) \geq p_k]g(i) + h(p_{k - 1}, p_{k - 1})<br>\end{aligned}<br>$$<br>其中为什么要加 $h(p_{k - 1}, p_{k - 1})$ 呢？因为 $h(\dfrac n{p_k}, k - 1)$ 包含了 $[1, \dfrac{n}{p_k}]$ 所有质数，而小于 $p_k$ 的质数我们前面的是没有计算到的，所以要加上 $[1, p_{k - 1}]$ 的所有质数的函数值，显然 $g(p_{k - 1}, p_{k - 1})$ 就可以满足要求。这样我们就可以得出：<br>$$<br>\begin{aligned}<br>\sum_{i = 1}^{\frac n{p_k}}[\text{lpf}(i) \geq p_k]g(i) = h(\dfrac n{p_k}, k - 1) - h(p_{k - 1}, p_{k - 1})<br>\end{aligned}<br>$$<br>又由于 $g$ 是完全积性函数（记得前面我们拆开多项式的目的吗？），我们可以得到这样的递推式：<br>$$<br>\begin{aligned}<br>h(n, k) &amp;= h(n, k - 1) - \sum_{i = 1}^n [\text{lpf}(i) = p_k] g(i)\\<br>&amp;= h(n, k - 1) - g(p_k)\sum_{i = 1}^{\frac n{p_k}} [\text{lpf}(i) \geq p_k]g(i)\\<br>&amp;= h(n, k - 1) - g(p_k)(h(\dfrac n{p_k}, k - 1) - h(p_{k - 1}, k - 1))<br>\end{aligned}<br>$$<br>按照这个递推，最后我们就可以得到所有质数位置的值的前缀和，即为 $h(n, k)$，其中 $p_k &gt; \sqrt n$。</p><h3 id="2）根据质数点的值求整个的前缀和"><a href="#2）根据质数点的值求整个的前缀和" class="headerlink" title="2）根据质数点的值求整个的前缀和"></a>2）根据质数点的值求整个的前缀和</h3><p>现在我们经过第一步的计算，已经知道了只有质数点的值 $g(x) = [x \in P]f(x)$ 的前缀，记为 $r(x)$。</p><p>我们定义 $S(n, k)$ 表示 $\displaystyle \sum_{i = 2}^n [\text{lpf}(i) &gt; p_k]f(k)$。</p><p>类似刚刚推导 $h(n, k)$ 的方法，我们可以较为简单的求，注意是积性函数而不是完全积性函数。</p><p>我们考虑最小的质因数 $p_v &gt; p_k$，然后枚举 $p_v$ 的指数。如是就可以从 $S(\dfrac n{p_v^e}, v)$ 转移，因为剩下的质因数都得大于 $p_v$。</p><p>注意我们的 $S(n, k)$ 没有定义 1，所以我们还要先加上 $&gt; p_k$ 的质数的所有的和，这样我们就可以直接使用 $r(n) - h(p_k, k)$ 代替。</p><p>注意如果 $e \not= 1$，$p_v^e$ 本身就是合数，没有包含在 $r(n) - h(p_k, k)$ 中，所以我们要加上他们。</p><p>根据积性函数的定义，我们可以得到：<br>$$<br>\begin{aligned}<br>S(n, k) = r(n) - h(p_k, k) + \sum_{v = i + 1}^{p_v \leq n}\sum_{e = 1}^{p_v^e \leq n} f(p_v^e)(S(\dfrac n{p_e^v}, v) + [v\not= 1])<br>\end{aligned}<br>$$</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p>显然，如果一个数不是质数，那么 $\text{lpf}(n) \leq \sqrt n$，所以我们计算 $h(n, k)$ 的时候可以直接处理 $[1, \sqrt n]$ 的所有质数就可以了。</p><p>但是我们如果直接循环 $h(i, k)(i \in [1, n], p_k \leq \sqrt n)$，那么肯定暴力都跑不过。</p><p>可以发现，除了 $h(p_{k - 1}, k - 1)$，其余都是和 $n$ 有关。又有一个整除的小定理：<br>$$<br>\left\lfloor\dfrac{\left\lfloor\dfrac na\right\rfloor}{b}\right\rfloor = \left\lfloor\dfrac n{ab}\right\rfloor<br>$$<br>这说明，不管我们除什么，前面的 $h(n, k), h(\dfrac n{p_k}, k - 1)$ 都只会访问到 $\dfrac ni(i \in [1, n])$，而这个最多只有 $O(\sqrt n)$ 个取值。</p><p>这个实现可以直接整除分块，将可以访问到的值存到两个数组，可以表示为：<br>$$<br>id(x) =<br>\begin{cases}<br>id1(x) (x \leq \sqrt n)\\<br>id2(\left\lfloor\dfrac nx\right\rfloor) (x &gt; \sqrt n)<br>\end{cases}<br>$$<br>当然偷懒的话可以多一个 $\log$ 的 <code>map</code>，但是似乎也不难，直接写整除分块了（本身算法就有点卡，还是不要给自己添麻烦吧 qwq</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_id</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x &lt;= sq ? id1[x] : id2[n / x];&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (LL l = <span class="number">1</span>, r, t; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = n / (n / l), t = n / r;</span><br><span class="line">a[++ tot] = t;<span class="comment">//a 存的是这个位置存的是哪个数</span></span><br><span class="line"><span class="keyword">if</span> (t &lt;= sq) id1[t] = tot;</span><br><span class="line"><span class="keyword">else</span> id2[n / t] = tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接着简单的分析复杂度：枚举质数 $O(\dfrac{\sqrt n}{\ln \sqrt n})$，枚举 $O(\sqrt n)$ 个数，前面时间复杂度为 $O(\dfrac n{\ln \sqrt n})$，显然跑不进 1s。</p><p>我们还有一个优化：在枚举 $h(n, k)$ 的时候，我们可以发现 $h(\dfrac n{p_k}, k - 1) - h(p_{k - 1}, k - 1)$ 有贡献时，肯定需要满足 $\dfrac{n}{p_k} \geq p_k$，否则 $h(\dfrac n{p_k}, k - 1)$ 就全是质数，并且只有 $[1, p_k)$ 中的质数，也就是 $h(p_{k - 1}, k - 1)$，那么后面贡献就是 0。所以我们只需枚举 $n$ 到 $p_k ^ 2$。</p><p>另外，$h(p_{k - 1}, k - 1)$ 最多也只有 $O(\dfrac{\sqrt n}{\ln \sqrt n})$ 个，我们直接预处理就可以了。这个我们记为 $sp_{k - 1}$。</p><p>（代码用的是 $g(n, k)$ 表示 $h(n, k)$，且只开了一维数组，因为访问的时候一定是标号小（即对应的 <code>a[]</code> 大）的从小的转移，可以用标号从小到大）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">LL le = (LL)prime[i] * prime[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; a[j] &gt;= le; ++ j)</span><br><span class="line">g[j] -= g[<span class="built_in">get_id</span>(a[j] / prime[i])] - sp[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于后面是同样的，我们计算 $S(n, k)$ 时，如果 $p_v^2 &gt; n$，只能枚举 $e = 1$，那么 $[e \not= 1] = 0$，$S(\dfrac{n}{p_v}, v)$ 由于 $\dfrac n{p_v} &lt; p_v$ 所以就为 0，我们就无需枚举。</p><p>反正后面 $S(n, k)$ 是不需要记忆化的（跑得还挺快</p><p>最后注意 $S(n, 0) = \sum_{i = 2}^n f(i)$，返回这个，需要加 $f(1)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">S</span><span class="params">(LL n, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (prime[i] &gt;= n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> now = <span class="built_in">get_id</span>(n);</span><br><span class="line">LL res = (f[now] - sp[i] + Mod) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nw = i + <span class="number">1</span>; nw &lt; cnt &amp;&amp; ((LL)prime[nw]) * prime[nw] &lt;= n; ++ nw)</span><br><span class="line"><span class="keyword">for</span> (LL now = prime[nw], k = <span class="number">1</span>; now &lt;= n; k ++, now *= prime[nw])&#123;</span><br><span class="line">LL t = now % Mod;</span><br><span class="line">res = (res + <span class="built_in">f</span>(now) % Mod * ((<span class="built_in">S</span>(n / now, nw) + (k != <span class="number">1</span>)) % Mod) % Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-例题"><a href="#4-例题" class="headerlink" title="4. 例题"></a>4. 例题</h2><h4 id="T1：区间素数个数"><a href="#T1：区间素数个数" class="headerlink" title="T1：区间素数个数"></a>T1：区间素数个数</h4><p><a href="https://loj.ac/p/6235">题目传送门 LOJ</a></p><p>观察到这个函数并不是积性函数，所以我们似乎没法使用杜教筛等算法求解。</p><p><del>观察标题可得，</del>我们可以发现，$h(n, x)(p_x &gt; \sqrt n)$ 就是 $\sum_{i = 1}^n[i \in P]g(i)$，我们直接让 $g(x) = 1$，即可求出 $[1, n]$ 的质数个数即可。</p><details><summary> 点击查看代码 </summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> id1[N], id2[N], tot, prime[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line">LL g[N], n, sq, a[N], sp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">st[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) prime[cnt ++] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; i * prime[j] &lt; N; ++ j)</span><br><span class="line">&#123;</span><br><span class="line">st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_id</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x &lt;= sq ? id1[x] : id2[n / x];&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this problem has a times 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solveg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i) sp[i] = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i) g[i] = a[i] - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">LL le = (LL)prime[i] * prime[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; a[j] &gt;= le; ++ j)</span><br><span class="line">g[j] -= g[<span class="built_in">get_id</span>(a[j] / prime[i])] - sp[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line">sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="built_in">sieve</span>(sq + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (LL l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">a[++ tot] = n / r;</span><br><span class="line"><span class="keyword">if</span> (n / r &lt;= sq) id1[n / r] = tot;</span><br><span class="line"><span class="keyword">else</span> id2[n / (n / r)] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">solveg</span>();</span><br><span class="line">std::cout &lt;&lt; g[<span class="built_in">get_id</span>(n)] &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h4 id="T2：简单的函数"><a href="#T2：简单的函数" class="headerlink" title="T2：简单的函数"></a>T2：简单的函数</h4><p><a href="https://loj.ac/p/6053">题目传送门 LOJ</a></p><p>首先有一个小学老师教的结论：偶质数只有 2。</p><p>那么，$f(i) = i\oplus 1 (i \in P)$ 就是：<br>$$<br>\begin{cases}<br>i - 1 (i \not= 2)\\<br>i - 1 + 2 (i = 2)<br>\end{cases}<br>$$<br>我们就可以通过先筛 $g(i) = i,g(i) = 1$ 来得到 $f(i)(i \in P)$。</p><p>最后，我们计算 $\sum_{i = 1}^n f(i)$ 的时候，由于 $f(2) = 3$，所以我们在筛到 $2$ 的时候应该加上 2。</p><p>具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">S</span><span class="params">(LL n, <span class="keyword">int</span> x)</span><span class="comment">//x 从 0  开始标号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (prime[x] &gt;= n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">LL res = (f[<span class="built_in">get_id</span>(n)] - sp[x] + Mod + <span class="number">2</span> * (x == <span class="number">-1</span> &amp;&amp; n &gt; <span class="number">1</span>)) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nw = x + <span class="number">1</span>; (LL)prime[nw] * prime[nw] &lt;= n &amp;&amp; nw &lt; cnt; ++ nw)</span><br><span class="line"><span class="keyword">for</span> (LL k = <span class="number">1</span>, pk = prime[nw]; pk &lt;= n; ++ k, pk *= prime[nw])</span><br><span class="line">res += (prime[nw] ^ k) * (<span class="built_in">S</span>(n / pk, nw) + (k != <span class="number">1</span>)) % Mod;</span><br><span class="line"><span class="keyword">return</span> res % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3：DIVCNTK"><a href="#T3：DIVCNTK" class="headerlink" title="T3：DIVCNTK"></a>T3：DIVCNTK</h4><p><a href="https://www.spoj.com/problems/DIVCNTK/">题目传送门 SPOJ</a></p><p>要求 $\sum_{i = 1}^n d(i ^ k)\bmod 2^{64}$，其中 $d(x)$ 代表 $x$ 的约数个数。</p><p>我们可以简单的发现，$d(x ^ k)$ 是积性函数：$d(a^kb^k) = d(a^k)d(b^k) (a \perp b)$。</p><p>令 $f(x) = d(x ^ k)$，我们再尝试推一下 $f(p ^ c) = c(k + 1)$。发现这是一个简单的多项式，我们尝试拆开 $f(p^c) = c$，Min_25 筛即可。</p><p>代码不给了，留作练习题<del>（逃</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> Min_25 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC016F 题解</title>
      <link href="/2022/02/07/AGC016F/"/>
      <url>/2022/02/07/AGC016F/</url>
      
        <content type="html"><![CDATA[<p>$SG$ 函数的妙用。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给定一个有向图，其中边都是小编号向大编号连边。现在 Alice 和 Bob 交替移动两个石子。两个石子最开始在 1 和 2。</p><p>现在要求只保留一些边，求在剩下的图中 Alice 能胜的情况个数。答案模 $1e9 + 7$。</p><h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2. 题解"></a>2. 题解</h2><p>很明显，我们需要求 $sg(1) != sg(2)$ 的方案数，这个可以简单的用总数减 $sg(1) = sg(2)$  的方案数。</p><p>怎么做呢？</p><p>我们枚举点集 $S$，让这些点的 $sg(x) = 0$，设剩下的点集为 $T$。</p><p>明显，$S$ 之间没有边，$T$ 中的点都有至少一条边连向 $S$。</p><p>然后，我们如果将 $S$ 删去，那么 $sg(x), x\in T$ 都会减 1。于是就可以从 $f(T)$ 转移到 $f(S \cup T)$。</p><p>题目给的限制就是 $1, 2$ 被分在同一个集合里了。</p><p>我们暴力枚举 $S$，枚举子集的时间复杂度为 $O(3 ^ n)$，可以通过。</p><p><strong>总结：删掉 $sg = 0$ 的状态，所有状态 $sg$ 减一。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">out[-- u] |= (<span class="number">1</span> &lt;&lt; -- v);</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j; j = (j - <span class="number">1</span>) &amp; i)&#123;</span><br><span class="line"><span class="keyword">if</span> ((i &amp; <span class="number">1</span>) ^ (i &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> ((j &amp; <span class="number">1</span>) ^ (j &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">LL now = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++ k)</span><br><span class="line"><span class="keyword">if</span> ((i ^ j) &gt;&gt; k &amp; <span class="number">1</span>) now = now * (pw[cnt[out[k] &amp; j]] - <span class="number">1</span>) % Mod;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j &gt;&gt; k &amp; <span class="number">1</span>) now = now * (pw[cnt[out[k] &amp; (i ^ j)]]) % Mod;</span><br><span class="line">f[i] = (f[i] + f[i ^ j] * now) % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 状态压缩 </tag>
            
            <tag> DP 及其优化 </tag>
            
            <tag> AtCoder </tag>
            
            <tag> SG 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF566C</title>
      <link href="/2022/01/24/CF566C/"/>
      <url>/2022/01/24/CF566C/</url>
      
        <content type="html"><![CDATA[<p>求导的思想找极值点挺不错的，还有点分治降低树的高度。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p><a href="https://www.luogu.com.cn/problem/CF566C">题目传送门 Luogu</a></p><p><a href="https://codeforces.com/problemset/problem/566/C">题目传送门 Codeforces</a></p><p>求有点权、边的长度的树的重心，距离定义为 $(\sum w)^{\frac32}$，注意要求落在点上，并且求出该点到其他点的距离和。</p><p>$n\leq 2 \times 10 ^ 5$。</p><h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2. 题解"></a>2. 题解</h2><p>首先，暴力 $O(n ^ 2)$ 可以 TLE。</p><p>假设距离和函数为 $f(x) = \sum_{i = 1}^n d(i, x)^\frac32$。</p><p>我们考虑假设退化成一条链的情况：这个一定是一个下凸函数，我们可以直接三分答案，每一次求 $f(x)$ 为 $O(n)$ 的，总复杂度为 $O(n \log n)$。</p><p>可不可以不用三分呢？</p><p>观察到这个函数是一个多项式，我们可以对其求导。</p><p>最开始，这个导函数一直是负，突然到了最优解 $u$ 附近的时候，边为了正，很明显，我们可以先得到导函数，再对导函数二分查找第一次变为正的位置。</p><p>但是我们来到树上的时候，不能一步跳很远，只能单步跳，时间复杂度明显和高度 $h$ 有关，为 $O(nh)$，怎么办呢？</p><p>相信你已经想到了，直接<strong>点分治重构树</strong>！</p><p>我们看一下哪棵子树的导函数是小于 0 的，有小于 0 的向那边跳就是了。</p><p>同时有前面的理论，我们可以发现，树的重心一定只有一个（可能不在点上而在边上），他向四周扩散都是变大的。</p><p>我们层层逼近，一定只有 $\log n$ 层，时间复杂度为 $O(n \log n)$，可以通过。</p><p><strong>总结：求导逼近极值点；点分治降低树高度</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">double</span> &amp;dev, <span class="keyword">int</span> nowd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// if (vis[x]) return;</span></span><br><span class="line">sum += <span class="built_in">pow</span>(nowd, <span class="number">1.5</span>) * a[x], dev += <span class="number">1.5</span> * <span class="built_in">sqrt</span>(nowd) * a[x];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (e[i] != fa) <span class="built_in">dfs</span>(e[i], x, dev, nowd + w[i]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[x]) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">get_wc</span>(x, <span class="number">-1</span>, <span class="built_in">get_size</span>(x, <span class="number">-1</span>), x);<span class="comment">//求重心</span></span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> sumd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line">dv[e[i]] = <span class="number">0</span>, <span class="built_in">dfs</span>(e[i], x, dv[e[i]], w[i]), sumd += dv[e[i]];<span class="comment">//求导数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum &lt; res) res = sum, ansu = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sumd - <span class="number">2</span> * dv[e[i]] &lt;= <span class="number">0</span>)&#123;<span class="comment">//这里是一步推导，我们如果向这边的话，其他的导数为正，这个为负，也就是总和减去两倍当前的导数</span></span><br><span class="line"><span class="built_in">work</span>(e[i]);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 分治 </tag>
            
            <tag> 点分治和点分树 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> CF </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UOJ671诡异操作 题解</title>
      <link href="/2022/01/24/UOJ671/"/>
      <url>/2022/01/24/UOJ671/</url>
      
        <content type="html"><![CDATA[<p>思想值得借鉴。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p><a href="https://uoj.ac/problem/671">题目传送门 UOJ</a></p><p>给定长度为 $n$ 的数组，最大为 $2^{128} - 1$，要求支持以下操作：</p><ol><li>$\forall i \in [l, r],\  a(i):= \dfrac{a(i)}{v}$。</li><li>$\forall i \in [l, r],\ a(i) := a(i)$ &amp; $v$。</li><li>求 $\sum_{i = l}^r a(i)$，答案对 $2^{128}$ 取模。</li></ol><p>$n\leq 3\times10^5, q\leq 2 \times 10 ^ 5$，时限 3s，空间 1GB。</p><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><p>$a(i)$ 用 <code>__uint128_t</code> 存储，可能常数有<del>亿</del>点大。</p><p>首先观察 $a(i)$ 在操作中不断减小，所以最多被除 $\log a(i)$ 次，存一下该区间有没有非 0 的数，没有的话直接退出。时间复杂度易得为 $O(q(\log n + \log a(i)))$。</p><p>对于第二个操作，我们可以先在这个区间上打一个标记，然后可以用一个 128 的数组存下来每一位出现了多少次，然后 &amp;v 的时候直接将对应的 1 位赋值为 0，更新答案即可。时间复杂度为 $O(q\log n\log a(i))$。<del>（然后你会发现 5000 的点都要跑 1s+）</del></p><p>怎么优化呢？</p><p>我们只要考虑压缩 128 的数组。这个数组每一个数都不大于 $len$，用 short 就可以存下来，显然信息密度不够。</p><p>我们考虑<strong>将 128 数组里的每一个位里存的数二进制拆分，然后将答案存入一个 $\log len$ 的数组。</strong></p><p>具体来说，比如有一个 $2^5$ 出现了 5 次，那么我们就在 $cnt[0]$ 和 $cnt[2]$ 插入 $2^5$。这样就可以实现一个 $\log a_i$ 向 $\log len$ 的方向转变。</p><p>我们再来看，如果 &amp;v 的时候怎么样呢？之间每一位都 &amp;v 就可以了，因为每一位存的是出现 $2^i$ 次的数的总和，而又不会互相干扰。</p><p>求和的时候，直接 $\sum cnt(i) \times 2^i$ 就可以了，时间复杂度同样是 $\log len$。</p><p>所以我们就可以得到复杂度为 $O(\log n \log len) = O(\log^2 n)$。</p><p>总时间复杂度为 $O(q(\log a(i) + \log^2 n))$，空间复杂度 $O(n \log n)$，卡一卡就可以过了。（但是有些 Hack 数据真的毒瘤，$cnt$ 数组用 <code>vector</code> 实现就 T 了，必须使用数组。</p><p><strong>总结：可以将一个 $\log a$ 长但存的数不大的数组通过二进制拆分的手段压缩为 $\log len$。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) (x &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) (x &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="keyword">using</span> u128 = <span class="keyword">__uint128_t</span>;</span><br><span class="line"><span class="keyword">const</span> u128 Mand = <span class="number">-1</span>;<span class="comment">//明显任意一个数 &amp;Mand 不变</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[x].any = tr[<span class="built_in">l</span>(x)].any | tr[<span class="built_in">r</span>(x)].any;</span><br><span class="line">u128 now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tr[x].sz; ++ i)&#123;</span><br><span class="line">u128 le = i &lt; tr[<span class="built_in">l</span>(x)].sz ? tr[<span class="built_in">l</span>(x)].cnt[i] : <span class="number">0</span>,</span><br><span class="line">ri = i &lt; tr[<span class="built_in">r</span>(x)].sz ? tr[<span class="built_in">r</span>(x)].cnt[i] : <span class="number">0</span>;</span><br><span class="line">tr[x].cnt[i] = (le ^ ri) ^ now;</span><br><span class="line">now = (le &amp; ri) | ((le ^ ri) &amp; now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_and</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">const</span> u128 &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[x].lt &amp;= v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tr[x].sz; ++ i) tr[x].cnt[i] &amp;= v;</span><br><span class="line">tr[x].any = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tr[x].sz; ++ i) tr[x].any |= (tr[x].cnt[i] &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].lt == Mand) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">update_and</span>(<span class="built_in">l</span>(x), tr[x].lt), <span class="built_in">update_and</span>(<span class="built_in">r</span>(x), tr[x].lt);</span><br><span class="line">tr[x].lt = Mand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_div</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">const</span> u128 &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tr[x].any) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l == tr[x].r)</span><br><span class="line">&#123;</span><br><span class="line">tr[x].cnt[<span class="number">0</span>] /= v, tr[x].any = (tr[x].cnt[<span class="number">0</span>] &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="built_in">update_div</span>(<span class="built_in">l</span>(x), v), <span class="built_in">update_div</span>(<span class="built_in">r</span>(x), v);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_and</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">const</span> u128 &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> <span class="built_in">update_and</span>(x, v);</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="keyword">int</span> mid = (tr[x].l + tr[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify_and</span>(<span class="built_in">l</span>(x), l, r, v);</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify_and</span>(<span class="built_in">r</span>(x), l, r, v);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_div</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">const</span> u128 &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> <span class="built_in">update_div</span>(x, v);</span><br><span class="line"><span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="keyword">int</span> mid = (tr[x].l + tr[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify_div</span>(<span class="built_in">l</span>(x), l, r, v);</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify_div</span>(<span class="built_in">r</span>(x), l, r, v);</span><br><span class="line"><span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小圆覆盖</title>
      <link href="/2022/01/20/mininum-circle/"/>
      <url>/2022/01/20/mininum-circle/</url>
      
        <content type="html"><![CDATA[<p>还是一个计算几何。</p><span id="more"></span><h2 id="1-性质"><a href="#1-性质" class="headerlink" title="1. 性质"></a>1. 性质</h2><h3 id="1）唯一性"><a href="#1）唯一性" class="headerlink" title="1）唯一性"></a>1）唯一性</h3><p>明显，如果我们能找到两个圆的话，他们的交也一定是可以的。我们可以尝试构造以相交的弦为直径构造一个圆，很明显会更小。</p><img src="/2022/01/20/mininum-circle/%E5%94%AF%E4%B8%80%E6%80%A7.png" class=""><h3 id="2）"><a href="#2）" class="headerlink" title="2）"></a>2）</h3><p><strong>如果 $P$ 不在集合 $S$ 的最小覆盖圆的内部，则 $P$ 在 ${P}\cup S$ 的最小覆盖圆的边上。</strong></p><p>首先，一个最小覆盖圆肯定会经过集合内的至少三个点。（在集合点数 $\geq 3$ 的时候）</p><p>反证：假设 $P$ 不在 ${P}\cup S$ 的最小覆盖圆的边上，那么 ${P}\cup S$ 的最小覆盖圆就是 $S$ 的最小覆盖圆。</p><p>但是 $S$ 的最小覆盖圆是无法覆盖到 $P$ 的，所以就会导致 ${P}\cup S$ 的最小圆覆盖无法覆盖到 $P$，矛盾，故原命题成立。</p><h2 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2. 算法流程"></a>2. 算法流程</h2><p>首先随机化，防止复杂度退化。</p><p>接着，我们将圆设置为 $(p(1), 0)$，表示圆心和半径。</p><p>然后，我们枚举每一个点，如果当前点 $p(i)$ 不在最小覆盖圆里的话，那么，我们由前面的性质得到，$p(i)$ 一定在 ${1, …, i}$ 的最小圆覆盖的边上。</p><p>现在，我们将圆设置为 $(p(i), 0)$，然后再暴力枚举前面的点。</p><p>如果如果 $p(j)$ 不在圆内的话，那么 $p(j)$ 在 ${1, …, j}\cup{i}$ 的最小圆覆盖的边上。同时，由于 $p(i)$ 不在 ${1, …, i - 1}$ 的最小圆覆盖里，那么一定导致 $p(i)$ 不在 ${1, …, j}$ 的最小覆盖圆上。</p><p>那么，我们就可以得到，$p(i), p(j)$ 都在 ${1, …, j}\cup {i}$ 的圆的边上。</p><p>因为找一个圆需要 $3$ 个点才能确定，所以我们再去寻找一个点。</p><p>我们将圆设置为 $p(i), p(j)$ 为直径的圆，再从前循环 $p(k)$，寻找到 $p(k)$ 不在 $p(i), p(j)$ 为直径的圆上。仿照前面的证明，我们就可以得到 $p(k), p(i), p(j)$ 都在圆上，我们就是求出了 ${1, …, k} \cup{i, j}$ 的最小圆覆盖。</p><p>最后我们一直循环，直到最后覆盖到了 ${1, …, i - 1}\cup{i}$ 也就是 ${1, …, i}$ 的圆覆盖。</p><h2 id="3-复杂度"><a href="#3-复杂度" class="headerlink" title="3. 复杂度"></a>3. 复杂度</h2><p>看似有 $O(n ^ 3)$，但是两步判断都是 $\dfrac{3}{n}$ 的概率，我们就可以得到时间复杂度为 $O(n)$。（感觉特别玄学</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">get_point</span><span class="params">(Point p1, Point k1, Point p2, Point k2)</span></span>&#123;</span><br><span class="line">Point u = p1 - p2;</span><br><span class="line"><span class="keyword">double</span> t = (k2 * u) / (k1 * k2);</span><br><span class="line"><span class="keyword">return</span> p1 + k1 * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Circle <span class="title">circle_by_point</span><span class="params">(Point a, Point b, Point c)</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> l1 = <span class="built_in">get_line</span>(a, b), l2 = <span class="built_in">get_line</span>(a, c);</span><br><span class="line">Point o = <span class="built_in">get_point</span>(l1.first, l1.second, l2.first, l2.second);</span><br><span class="line"><span class="keyword">return</span> &#123;o, <span class="built_in">dist2</span>(a, o)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Circle <span class="title">min_circle</span><span class="params">(Point *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">random_shuffle</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line">Circle ans = &#123;p[<span class="number">1</span>], <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">in_circle</span>(ans, p[i])) <span class="keyword">continue</span>;</span><br><span class="line">ans = &#123;p[i], <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++ j)&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">in_circle</span>(ans, p[j])) <span class="keyword">continue</span>;</span><br><span class="line">ans = &#123;(p[i] + p[j]) / <span class="number">2</span>, <span class="built_in">dist2</span>((p[i] + p[j]) / <span class="number">2</span>, p[i])&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; j; ++ k)</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">in_circle</span>(ans, p[k])) ans = <span class="built_in">circle_by_point</span>(p[i], p[j], p[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans.r = <span class="built_in">sqrt</span>(ans.r);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凸包与旋转卡壳</title>
      <link href="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/"/>
      <url>/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<p>前置知识：计算几何。</p><span id="more"></span><h2 id="1-凸包"><a href="#1-凸包" class="headerlink" title="1. 凸包"></a>1. 凸包</h2><p>直接理解为我们用一条橡皮筋围住这些点。</p><p>我们就不再介绍 Javis 算法，直接介绍两个时间复杂度更优的 Graham 和 Andrew 算法。</p><h3 id="1）Graham-算法"><a href="#1）Graham-算法" class="headerlink" title="1）Graham 算法"></a>1）Graham 算法</h3><p>我们首先选择最左下方的点，注意到这个点一定是凸包上的点。假设这个点为 A。</p><p>接着，我们按照 A 点与这些点的连线与水平线的夹角排序。注意到如果夹角相同，将最远的点放在最前面。</p><p>接着，我们扫描整个数组，同时维护一个栈，记录当前的凸包里的点。</p><p>我们要加入一个点的时候，如果当前的栈里的点会和这个点形成一个顺时针的转角的话，我们就将栈顶弹出。</p><img src="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/%E5%87%B8%E5%8C%851.png" class=""><p>看到这个图，我们现在要将红线上面的点加入，容易发现红线下面这个点是一定不需要的，我们直接弹出即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Point &amp;t1, <span class="keyword">const</span> Point &amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t1 - p[<span class="number">1</span>]) * (t2 - p[<span class="number">1</span>]) &gt; eps || (<span class="built_in">fabs</span>((t1 - p[<span class="number">1</span>]) * (t2 - p[<span class="number">1</span>])) &lt; eps &amp;&amp; <span class="built_in">dist</span>(p[<span class="number">1</span>], t1) &gt; <span class="built_in">dist</span>(p[<span class="number">1</span>], t2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    <span class="keyword">if</span> (p[i].y &lt; p[t].y || (<span class="built_in">fabs</span>(p[i].y - p[t].y) &lt; eps &amp;&amp; p[i].x &lt; p[t].x)) t = i;</span><br><span class="line"><span class="built_in">swap</span>(p[<span class="number">1</span>], p[t]);</span><br><span class="line"><span class="built_in">sort</span>(p + <span class="number">2</span>, p + n + <span class="number">1</span>, cmp);</span><br><span class="line">stk[++ top] = p[<span class="number">1</span>], stk[++ top] = p[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; (stk[top] - stk[top - <span class="number">1</span>]) * (p[i] - stk[top]) &lt; -eps) top --;</span><br><span class="line">    stk[++ top] = p[i];</span><br><span class="line">&#125;</span><br><span class="line">stk[++ top] = p[<span class="number">1</span>];<span class="comment">//第一个点进入两次，便于计算周长面积</span></span><br></pre></td></tr></table></figure><h3 id="2）Andrew-算法"><a href="#2）Andrew-算法" class="headerlink" title="2）Andrew 算法"></a>2）Andrew 算法</h3><p>我们不再按照夹角排序，直接使用 x 坐标排序，结果又如何呢？</p><p>我们这么遍历，发现只会走到一半的凸壳。</p><p>于是，我们再会过来遍历一次，就可以把另一半的凸壳遍历到了！</p><p>这个算法避免的一些复杂的夹角的计算，常数略小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2)</span></span>&#123;<span class="keyword">return</span> (p1.x == p2.x) ? (p1.y &lt; p2.y) : p1.x &lt; p2.x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Andrew</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; (p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> ((p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt; <span class="number">0</span>) usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> top --;</span><br><span class="line">usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">usd[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (usd[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; (p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> ((p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt; <span class="number">0</span>) usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> top --;</span><br><span class="line">usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）例题"><a href="#3）例题" class="headerlink" title="3）例题"></a>3）例题</h3><h4 id="T1：信用卡凸包"><a href="#T1：信用卡凸包" class="headerlink" title="T1：信用卡凸包"></a>T1：信用卡凸包</h4><p><a href="https://www.luogu.com.cn/problem/P3829">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2938/">题目传送门 AcWing</a></p><p>我们可以发现，一个凸多边形的外角是 $360^{\circ}$。</p><p>那么，圆形一定贡献的是一个周角的大小。剩下的，我们发现可以向内平移到圆心的位置。按圆心凸包即可。</p><img src="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/%E5%87%B8%E5%8C%852.png" class=""><p>可以发现，黑直线的长度就是红线的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %lf %lf %lf&quot;</span>, &amp;n, &amp;a, &amp;b, &amp;R);</span><br><span class="line">a -= <span class="number">2</span> * R, b -= <span class="number">2</span> * R;</span><br><span class="line"><span class="keyword">double</span> x, y, th;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf&quot;</span>, &amp;x, &amp;y, &amp;th);</span><br><span class="line">x += eps, y += eps, th += eps;</span><br><span class="line">p[(i &lt;&lt; <span class="number">2</span>) - <span class="number">3</span>] = (Point)&#123;x, y&#125; + <span class="built_in">rotate</span>(&#123;b / <span class="number">2</span>, a / <span class="number">2</span>&#125;, th);</span><br><span class="line">p[(i &lt;&lt; <span class="number">2</span>) - <span class="number">2</span>] = (Point)&#123;x, y&#125; + <span class="built_in">rotate</span>(&#123;-b / <span class="number">2</span>, a / <span class="number">2</span>&#125;, th);</span><br><span class="line">p[(i &lt;&lt; <span class="number">2</span>) - <span class="number">1</span>] = (Point)&#123;x, y&#125; + <span class="built_in">rotate</span>(&#123;-b / <span class="number">2</span>, -a / <span class="number">2</span>&#125;, th);</span><br><span class="line">p[(i &lt;&lt; <span class="number">2</span>)] = (Point)&#123;x, y&#125; + <span class="built_in">rotate</span>(&#123;b / <span class="number">2</span>, -a / <span class="number">2</span>&#125;, th);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Andrew</span>(n &lt;&lt; <span class="number">2</span>);</span><br><span class="line"><span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; top; ++ i)</span><br><span class="line">res += <span class="built_in">dist</span>(p[stk[i]], p[stk[i + <span class="number">1</span>]]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>, res + <span class="number">2</span> * <span class="built_in">acos</span>(<span class="number">-1</span>) * R);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-半平面交"><a href="#2-半平面交" class="headerlink" title="2. 半平面交"></a>2. 半平面交</h2><p>我们介绍一种办法（我似乎并不知道是什么算法），能在 $O(n \log n)$ 的时间求出围住的凸多边形（注意好像不能判断无解的情况）。</p><p>为了方便，我们定义半平面存储为一条有向直线，在这条直线逆时针（可以理解为左边）的部分即为半平面。</p><h3 id="1）算法流程"><a href="#1）算法流程" class="headerlink" title="1）算法流程"></a>1）算法流程</h3><p>我们首先按照每条线与 $x$ 轴的夹角排序，如果相同，说明是平行的，我们按照从左至右的顺序。</p><p>然后，我们顺次插入每一个半平面。我们维护一个如此的双端队列来表示当前的半平面。</p><img src="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A41.png" class=""><p>接着，我们插入的时候，看一下有没有在当前半平面外面的交点，也就是判断有没有在直线顺时针的点，有的话就删除。</p><img src="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A42.png" class=""><p>比如蓝点在新加入的蓝线右边，所以肯定会导致最后加入的黑线被弹出队尾。</p><p>注意有可能线的方向不定导致会弹出队首，所以前后都要判断。</p><p>最后的时候，我们再用队首来尝试弹出队尾，队尾尝试弹出队首。</p><p>注意我们求夹角的时候，可以使用 <code>atan2(x, y)</code>，这样可以防止出现 <code>nan</code> 的情况，因为他会判断 $y$ 是否等于 0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">get_point_</span><span class="params">(Point p1, Point k1, Point p2, Point k2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point u = p1 - p2;</span><br><span class="line"><span class="keyword">double</span> t = (k2 * u) / (k1 * k2);</span><br><span class="line"><span class="keyword">return</span> &#123;t * k1.x + p1.x, t * k1.y + p1.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">get_point</span><span class="params">(<span class="keyword">const</span> Line &amp;l1, <span class="keyword">const</span> Line &amp;l2)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">get_point_</span>(l1.st, l1.ed - l1.st, l2.st, l2.ed - l2.st);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">on_right</span><span class="params">(<span class="keyword">const</span> Line &amp;a, <span class="keyword">const</span> Line &amp;b, <span class="keyword">const</span> Line &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point t = <span class="built_in">get_point</span>(b, c);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sgn</span>((a.ed - a.st) * (t - a.st)) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">half_plane</span><span class="params">(Line l[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(l + <span class="number">1</span>, l + n + <span class="number">1</span>, lcmp);</span><br><span class="line">hh = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; !<span class="built_in">cmp</span>(<span class="built_in">angle</span>(l[i]), <span class="built_in">angle</span>(l[i - <span class="number">1</span>]))) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[i], l[q[tt - <span class="number">1</span>]], l[q[tt]])) tt --;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[i], l[q[hh]], l[q[hh + <span class="number">1</span>]])) hh ++;</span><br><span class="line">q[++ tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[q[hh]], l[q[tt - <span class="number">1</span>]], l[q[tt]])) tt --;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[q[tt]], l[q[hh]], l[q[hh + <span class="number">1</span>]])) hh ++;</span><br><span class="line">q[++ tt] = q[hh];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）例题"><a href="#2）例题" class="headerlink" title="2）例题"></a>2）例题</h3><h4 id="T2：-JLOI-2013-赛车"><a href="#T2：-JLOI-2013-赛车" class="headerlink" title="T2：[JLOI 2013]赛车"></a>T2：[JLOI 2013]赛车</h4><p><a href="https://www.luogu.com.cn/problem/P3256">题目传送门 Luogu</a></p><p>半平面交的模板题，注意用 <code>long double</code>，并且把精度调高一点。</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> LD;</span><br><span class="line"><span class="keyword">const</span> LD eps = <span class="number">1e-18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">LD x, y;</span><br><span class="line">Point <span class="keyword">operator</span> +(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x + t.x, y + t.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Point <span class="keyword">operator</span> -(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">LD <span class="keyword">operator</span> *(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * t.y - y * t.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">Point st, ed;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; id;</span><br><span class="line">&#125;l[N];</span><br><span class="line"><span class="keyword">int</span> q[N], hh, tt;</span><br><span class="line"><span class="keyword">int</span> ki[N], vi[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> angle = [](<span class="keyword">const</span> Line &amp;l)&#123;<span class="keyword">return</span> <span class="built_in">atan2</span>(l.ed.y - l.st.y, l.ed.x - l.st.x);&#125;;</span><br><span class="line"><span class="keyword">auto</span> sgn = [](LD x)&#123;<span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">fabs</span>(x) &lt; eps) ? <span class="number">0</span> : (x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>);&#125;;</span><br><span class="line"><span class="keyword">auto</span> cmp = [](LD x, LD y)&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>(x - y);&#125;;</span><br><span class="line"><span class="keyword">auto</span> lcmp = [](<span class="keyword">const</span> Line &amp;l1, <span class="keyword">const</span> Line &amp;l2)&#123;</span><br><span class="line">LD A = <span class="built_in">angle</span>(l1), B = <span class="built_in">angle</span>(l2);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cmp</span>(A, B) == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">sgn</span>((l1.ed - l1.st) * (l2.ed - l1.st)) &lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> A &lt; B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">get_point_</span><span class="params">(Point p1, Point k1, Point p2, Point k2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point del = p1 - p2;</span><br><span class="line">LD t = (k2 * del) / (k1 * k2);</span><br><span class="line"><span class="keyword">return</span> &#123;t * k1.x + p1.x, t * k1.y + p1.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">get_point</span><span class="params">(<span class="keyword">const</span> Line &amp;l1, <span class="keyword">const</span> Line &amp;l2)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">get_point_</span>(l1.st, l1.ed - l1.st, l2.st, l2.ed - l2.st);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">on_right</span><span class="params">(<span class="keyword">const</span> Line &amp;a, <span class="keyword">const</span> Line &amp;b, <span class="keyword">const</span> Line &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point t = <span class="built_in">get_point</span>(b, c);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sgn</span>((t - a.st) * (a.ed - a.st)) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">half_plane</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(l + <span class="number">1</span>, l + n + <span class="number">1</span>, lcmp);</span><br><span class="line">hh = <span class="number">1</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; !<span class="built_in">cmp</span>(<span class="built_in">angle</span>(l[i]), <span class="built_in">angle</span>(l[i - <span class="number">1</span>]))) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[i], l[q[tt - <span class="number">1</span>]], l[q[tt]])) tt --;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[i], l[q[hh]], l[q[hh + <span class="number">1</span>]])) hh ++;</span><br><span class="line">q[++ tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[q[tt]], l[q[hh]], l[q[hh + <span class="number">1</span>]])) hh ++;</span><br><span class="line"><span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">on_right</span>(l[q[hh]], l[q[tt - <span class="number">1</span>]], l[q[tt]])) tt --;</span><br><span class="line">q[++ tt] = q[hh];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = hh; i &lt; tt; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : l[q[i]].id) ans.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : ans) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;PII, vector&lt;<span class="keyword">int</span>&gt; &gt; ids;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">l[++ cnt] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">10000</span>, <span class="number">0</span>&#125;, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>)&#125;;</span><br><span class="line">l[++ cnt] = &#123;&#123;<span class="number">0</span>, <span class="number">10000</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>)&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; ki[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; vi[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">ids[&#123;ki[i], vi[i]&#125;].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : ids)</span><br><span class="line">l[++ cnt] = &#123;&#123;<span class="number">0</span>, c.first.first&#125;, &#123;<span class="number">1</span>, c.first.first + c.first.second&#125;, c.second&#125;;</span><br><span class="line"><span class="built_in">half_plane</span>(cnt);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="3-三维凸包"><a href="#3-三维凸包" class="headerlink" title="3. 三维凸包"></a>3. 三维凸包</h2><h3 id="1）三维空间向量"><a href="#1）三维空间向量" class="headerlink" title="1）三维空间向量"></a>1）三维空间向量</h3><h4 id="a-加减、数乘、模长"><a href="#a-加减、数乘、模长" class="headerlink" title="a. 加减、数乘、模长"></a>a. 加减、数乘、模长</h4><p>与二维向量相同，不再赘述。</p><h4 id="b-点乘"><a href="#b-点乘" class="headerlink" title="b. 点乘"></a>b. 点乘</h4><p>得到是一个数。</p><p>$(x1, y1, z1) \cdot (x2, y2, z2) = x1x2 + y1y2 + z1z2$。</p><p>注意满足 $|A||B|\cos&lt;A, B&gt; = A \cdot B$。</p><h4 id="c-叉乘"><a href="#c-叉乘" class="headerlink" title="c. 叉乘"></a>c. 叉乘</h4><p>得到不是数，是一个行列式的结果。<br>$$<br>det\left(<br>\begin{matrix}<br>i &amp; j &amp; k\<br>x1 &amp; y1 &amp; z1\<br>x2 &amp; y2 &amp; z2<br>\end{matrix}<br>\right)<br>$$<br>注意 $i, j, k$ 是空间单位向量，得到的明显也是一个三位向量。</p><p>展开行列式，可以得到：$(x1, y1, z1) \times (x2, y2, z2) = (y1z2 - y2z1, x2z1 - x1z2, x1y2 - x2y1)$。</p><h4 id="d-多面体欧拉定理"><a href="#d-多面体欧拉定理" class="headerlink" title="d. 多面体欧拉定理"></a>d. 多面体欧拉定理</h4><p>点数 - 棱数 + 面数 = 2。</p><h4 id="e-平面的法向量"><a href="#e-平面的法向量" class="headerlink" title="e. 平面的法向量"></a>e. 平面的法向量</h4><p>法向量是指垂直于</p><p>任意取两个向量</p><h3 id="2）三维凸包-增量法"><a href="#2）三维凸包-增量法" class="headerlink" title="2）三维凸包 - 增量法"></a>2）三维凸包 - 增量法</h3><p>其实是一个暴力算法，时间复杂度为 $O(n ^ 2)$。</p><p>我们首先找到任意不共面的 4 个点，使得可以形成一个凸包。</p><p>然后，我们尝试加入每一个点。</p><p>如果它在凸包里，则跳过；否则我们考虑加入。</p><p>假设这个点是一个太阳，那么一定会有一些面是“白天”，还有一些棱是“晨昏线”。</p><p>我们将”白天“全部删除，并且将”晨昏线“与新加的点相连，形成新的凸包。</p><p>具体看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Convex_3d</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> bitset&lt;N&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, ncnt = <span class="number">0</span>;</span><br><span class="line">pl[++ cnt] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, pl[++ cnt] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">ncnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++ j)&#123;</span><br><span class="line"><span class="keyword">bool</span> t = pl[j].<span class="built_in">above</span>(p[i]);</span><br><span class="line"><span class="keyword">if</span> (!t) np[++ ncnt] = pl[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++ k)</span><br><span class="line">g[pl[j].v[k]][pl[j].v[(k + <span class="number">1</span>) % <span class="number">3</span>]] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++ k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a = pl[j].v[k], b = pl[j].v[(k + <span class="number">1</span>) % <span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span> (g[a][b] &amp;&amp; !g[b][a]) np[++ ncnt] = &#123;a, b, i&#125;;</span><br><span class="line">&#125;</span><br><span class="line">cnt = ncnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++ j) pl[j] = np[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-旋转卡壳"><a href="#4-旋转卡壳" class="headerlink" title="4. 旋转卡壳"></a>4. 旋转卡壳</h2><p>其实不是一种模板或者算法，而是一种思想或者是做题的技巧。</p><h3 id="1）思想"><a href="#1）思想" class="headerlink" title="1）思想"></a>1）思想</h3><p>我们定义<strong>对踵点</strong>为任意两条平行的直线，向中间靠拢的时候碰到的点。</p><img src="/2022/01/19/%E5%87%B8%E5%8C%85%E4%B8%8E%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B31.png" class=""><p>很明显，我们的对踵点的个数是 $O(n)$ 级别的，所以我们并不需要枚举每一条平行的直线。我们可以考虑直接枚举与凸包边平行的边。</p><p>下面假设我们要寻找直径，也就是最长的线段。</p><p>我们先确定 $p(i)$ 为对踵点的一端，我们怎样才能寻找到与之相对的对踵点呢？</p><p>很明显，我们可以暴力枚举，但时间复杂度是 $O(n ^ 2)$，不优。</p><p>我们可以发现，随着我们的 $p(i)$ 一直都是顺时针（或者逆时针）旋转的，$p(j)$ 也一定是顺时针旋转的。</p><p>所以，我们可以使用双指针算法，可以做到 $O(n)$，瓶颈在前面的凸包，时间复杂度为 $O(n \log n)$。</p><p>怎样判断哪个点是最远的呢？我们回顾<strong>叉积</strong>的定义，发现是三角形的面积。我们再拉一个 $p(i + 1)$ 过来，就可以求面积了，同时这条直线就是 $p(i), p(i + 1)$。</p><p>具体看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">2</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ((s[i + <span class="number">1</span>] - s[i]) * (s[j] - s[i]) &lt; (s[i + <span class="number">1</span>] - s[i]) * (s[j + <span class="number">1</span>] - s[i])) j = (j + <span class="number">1</span>) % n;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(<span class="built_in">dist2</span>(s[i], s[j]), <span class="built_in">dist2</span>(s[i + <span class="number">1</span>], s[j])));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2）例题-1"><a href="#2）例题-1" class="headerlink" title="2）例题"></a>2）例题</h3><h4 id="T1：求最远点距离"><a href="#T1：求最远点距离" class="headerlink" title="T1：求最远点距离"></a>T1：求最远点距离</h4><p><a href="https://www.luogu.com.cn/problem/P1452">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/description/2941/">题目传送门 AcWing</a></p><p>刚才讲到的，直接上代码。</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    Point <span class="keyword">operator</span> -(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    LL <span class="keyword">operator</span> *(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (LL)x * t.y - (LL)y * t.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="keyword">int</span> stk[N], top, n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> cmp = [](Point t1, Point t2)&#123;</span><br><span class="line">    <span class="keyword">return</span> t1.x == t2.x ? t1.y &lt; t2.y : t1.x &lt; t2.x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dist2</span><span class="params">(Point p1, Point p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Andrew</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> usd[N];</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; (p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt;= <span class="number">0</span>)</span><br><span class="line">            usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line">        usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    usd[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (usd[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; (p[stk[top]] - p[stk[top - <span class="number">1</span>]]) * (p[i] - p[stk[top]]) &lt; <span class="number">0</span>)</span><br><span class="line">            usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line">        usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    top --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">get_dist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">dist2</span>(p[stk[<span class="number">1</span>]], p[stk[<span class="number">2</span>]]);</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">2</span>; i &lt;= top; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ((p[stk[i + <span class="number">1</span>]] - p[stk[i]]) * (p[stk[j]] - p[stk[i]]) &lt; (p[stk[i + <span class="number">1</span>]] - p[stk[i]]) * (p[stk[j + <span class="number">1</span>]] - p[stk[i]]))</span><br><span class="line">            j = j % top + <span class="number">1</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(<span class="built_in">dist2</span>(p[stk[i + <span class="number">1</span>]], p[stk[j]]), <span class="built_in">dist2</span>(p[stk[i]], p[stk[j]])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">    <span class="built_in">Andrew</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">get_dist</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h4 id="T2：最小矩形覆盖"><a href="#T2：最小矩形覆盖" class="headerlink" title="T2：最小矩形覆盖"></a>T2：最小矩形覆盖</h4><p><a href="https://www.luogu.com.cn/problem/P3187">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2144/">题目传送门 AcWing</a></p><p>先搁着 qwq</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> INF = <span class="number">1e20</span>, eps = <span class="number">1e-12</span>, Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point <span class="keyword">operator</span> +(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + t.x, y + t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> -(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> *(<span class="keyword">double</span> t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x * t, y * t&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> /(<span class="keyword">double</span> t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x / t, y / t&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> *(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * t.y - y * t.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> &amp;(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * t.x + y * t.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N], ans[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> stk[N], top, n;</span><br><span class="line"><span class="keyword">double</span> mxa = INF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(x) &lt; eps ? <span class="number">0</span> : (x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>(x - y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">(Point a)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(a &amp; a);&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">(Point a, Point b, Point c)</span></span>&#123;<span class="keyword">return</span> (b - a) * (c - a);&#125;</span><br><span class="line"><span class="function">Point <span class="title">normal</span><span class="params">(Point t)</span></span>&#123;<span class="keyword">return</span> t / <span class="built_in">len</span>(t);&#125;</span><br><span class="line"><span class="function">Point <span class="title">rotate</span><span class="params">(Point a, <span class="keyword">double</span> th)</span></span>&#123;<span class="keyword">return</span> &#123;a.x * <span class="built_in">cos</span>(th) + a.y * <span class="built_in">sin</span>(th), a.y * <span class="built_in">cos</span>(th) - a.x * <span class="built_in">sin</span>(th)&#125;;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pcmp</span><span class="params">(Point a, Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">project</span><span class="params">(Point a, Point b, Point c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((b - a) &amp; (c - a)) / <span class="built_in">len</span>(b - a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Andrew</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> usd[N];</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, pcmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">area</span>(p[stk[top - <span class="number">1</span>]], p[stk[top]], p[i]) &gt;= <span class="number">0</span>)</span><br><span class="line">            usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line">        usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    usd[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (usd[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">area</span>(p[stk[top - <span class="number">1</span>]], p[stk[top]], p[i]) &gt;= <span class="number">0</span>)</span><br><span class="line">            usd[stk[top --]] = <span class="literal">false</span>;</span><br><span class="line">        usd[stk[++ top] = i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(stk + <span class="number">1</span>, stk + top + <span class="number">1</span>);</span><br><span class="line">    top --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_ju</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">3</span>, k = <span class="number">2</span>, l = <span class="number">3</span>; i &lt;= top; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        Point d = p[stk[i]], e = p[stk[i + <span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cmp</span>(<span class="built_in">area</span>(d, e, p[stk[j]]), <span class="built_in">area</span>(d, e, p[stk[j + <span class="number">1</span>]])) &lt; <span class="number">0</span>)</span><br><span class="line">            j = j % top + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cmp</span>(<span class="built_in">project</span>(d, e, p[stk[k]]), <span class="built_in">project</span>(d, e, p[stk[k + <span class="number">1</span>]])) &lt; <span class="number">0</span>)</span><br><span class="line">            k = k % top + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) l = j;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cmp</span>(<span class="built_in">project</span>(d, e, p[stk[l]]), <span class="built_in">project</span>(d, e, p[stk[l + <span class="number">1</span>]])) &gt; <span class="number">0</span>)</span><br><span class="line">            l = l % top + <span class="number">1</span>;</span><br><span class="line">        Point x = p[stk[j]], y = p[stk[k]], z = p[stk[l]];</span><br><span class="line">        <span class="keyword">double</span> h = <span class="built_in">area</span>(d, e, x) / <span class="built_in">len</span>(e - d),</span><br><span class="line">               w = ((y - z) &amp; (e - d)) / <span class="built_in">len</span>(e - d);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; h &lt;&lt; &#x27; &#x27; &lt;&lt; w &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (h * w &lt; mxa)&#123;</span><br><span class="line">            mxa = h * w;</span><br><span class="line">            ans[<span class="number">0</span>] = d + <span class="built_in">normal</span>(e - d) * <span class="built_in">project</span>(d, e, y);</span><br><span class="line">            ans[<span class="number">3</span>] = d + <span class="built_in">normal</span>(e - d) * <span class="built_in">project</span>(d, e, z);</span><br><span class="line">            Point t = <span class="built_in">normal</span>(<span class="built_in">rotate</span>(e - d, -Pi / <span class="number">2</span>));</span><br><span class="line">            ans[<span class="number">1</span>] = ans[<span class="number">0</span>] + t * h;</span><br><span class="line">            ans[<span class="number">2</span>] = ans[<span class="number">3</span>] + t * h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">    <span class="built_in">Andrew</span>();</span><br><span class="line">    <span class="comment">// cout &lt;&lt; top &lt;&lt; endl, exit(0);</span></span><br><span class="line">    <span class="built_in">find_ju</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.5lf\n&quot;</span>, mxa);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cmp</span>(ans[i].y, ans[k].y) &lt; <span class="number">0</span> || !<span class="built_in">cmp</span>(ans[i].y, ans[k].y) &amp;&amp; <span class="built_in">cmp</span>(ans[i].x, ans[k].x) &lt; <span class="number">0</span>)</span><br><span class="line">            k = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i, k ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">4</span>) k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> x = ans[k].x + eps, y = ans[k].y + eps;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt; eps) x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(y) &lt; eps) y = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.5lf %.5lf\n&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
            <tag> 凸包 </tag>
            
            <tag> 旋转卡壳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算几何基础</title>
      <link href="/2022/01/19/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/01/19/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>需要的初高中几何知识是比较多的。</p><span id="more"></span><h2 id="1-数学基础"><a href="#1-数学基础" class="headerlink" title="1. 数学基础"></a>1. 数学基础</h2><p>$$<br>\begin{aligned}<br>\pi &amp;= \arccos(-1)\\<br>c^2 &amp;= a^2 + b^2 - 2ab\cos\theta<br>\end{aligned}<br>$$</p><p>第一个的原理来自于：$\cos \pi = -1$。</p><p>第二个是一个余弦定理。</p><h2 id="2-关于浮点数"><a href="#2-关于浮点数" class="headerlink" title="2. 关于浮点数"></a>2. 关于浮点数</h2><p>比如我们比较两个数的时候，他们可能因为计算的误差而不同。所以我们必须定义一个 $\epsilon$，表示两个的差别，如果在 $\epsilon$ 中的话，我们就认为这两个数相等。$\epsilon$ 可以定义为 $10^{-8}, 10^{-9}$ 等等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_equal</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(x - y) &lt; eps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，如果比较两个数的大小，我们同样也要使用 $\epsilon$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x - y) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-向量"><a href="#3-向量" class="headerlink" title="3. 向量"></a>3. 向量</h2><p>首先，简单的向量加减不再展开。</p><p>我们先介绍点乘：$a \cdot b = |a||b|\cos&lt;a, b&gt;$。</p><p>如果在二维点坐标下计算，就是 $(a, b) \cdot (c, d) = ac + bd$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dot</span><span class="params">(Point a, Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们计算一个向量的模的时候，可以直接计算就是了，也可以 $|a| = \sqrt{a \cdot a}$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">(Point a)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">dot</span>(a, a));&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用点乘来计算两个之间的夹角。</p><p>$\cos&lt;a, b&gt; = \dfrac{a\cdot b}{|a||b|}$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_angle</span><span class="params">(Point a, Point b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">acos</span>(<span class="built_in">dot</span>(a) / <span class="built_in">length</span>(a) / <span class="built_in">length</span>(b));&#125;</span><br></pre></td></tr></table></figure><p>还有一种乘法，是叉乘：$a\times b = |a||b|\sin&lt;a, b&gt;$。</p><p>如果是二维点坐标，就是 $(a, b)\times (c, d) = ad - bc$。</p><p>如果叉乘大于 0 的话，那么 $a$ 向量在 $b$ 向量的顺时针的方向。注意叉乘没有交换性。一般将叉乘重载为乘法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Point a, Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个，我们转一个角。</p><p>直接写出公式，证明可以使用和差角公式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">rotate</span><span class="params">(Point a, <span class="keyword">double</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;a.x * <span class="built_in">cos</span>(c) - a.y * <span class="built_in">sin</span>(c), a.x * <span class="built_in">sin</span>(c) + a.y * <span class="built_in">cos</span>(c)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-计算几何"><a href="#4-计算几何" class="headerlink" title="4. 计算几何"></a>4. 计算几何</h2><p>似乎能写的似乎不多……</p><p>我们简单的看几个比较常用的。</p><h3 id="1）直线相交"><a href="#1）直线相交" class="headerlink" title="1）直线相交"></a>1）直线相交</h3><p>首先，判断两个直线是否相交：$a\times b \not= 0$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_cross</span><span class="params">(Point a, Point b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">cross</span>(a, b) != <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="2）线段相交"><a href="#2）线段相交" class="headerlink" title="2）线段相交"></a>2）线段相交</h3><p>分为两步：快速排斥实验和跨立实验。</p><p>快速排斥实验是指如果两个线段所在的矩形如果不相交，那么两条线段一定不相交。</p><img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C.png" class=""><p>如果两个线段所在的矩形是相交的，也不说明两条线段是相交的。</p><img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/%E5%BF%AB%E9%80%9F%E6%8E%92%E6%96%A5%E5%AE%9E%E9%AA%8C2.png" class=""><p>我们需要判断两个线段相交的话，需要判断一个线段的两个点是否在另外一个线段所在直线的两侧。</p><p>具体来说，就是判断 $(p3 - p1) \times (p2 - p1)$ 与 $(p4 - p1) \times (p2 - p1)$ 是否异号。</p><p>另外，我们可以直接对这两条线段都这么计算，可以省去第一步。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cross_seg</span><span class="params">(Point p1, Point p2, Point p3, Point p4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (((p1 - p3) * (p4 - p3)) * ((p2 - p3) * (p4 - p3)) &gt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (((p3 - p1) * (p2 - p1)) * ((p4 - p1) * (p2 - p1)) &gt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）判断一个点是否在多边形内"><a href="#3）判断一个点是否在多边形内" class="headerlink" title="3）判断一个点是否在多边形内"></a>3）判断一个点是否在多边形内</h3><p>注意不一定是凸多边形。</p><p>有一个结论：<strong>经过凸多边形的边奇数次，就在凸多边形内。</strong></p><p>很明显，没经过一次边，就会导致从外到内，或者从内到外。最后一定是在外部，所以奇数次的话该点就在里面。</p><p>注意这个结论在经过某一个顶点或者射线与边重合时并不适用，所以我们随机一个在凸多边形外部的点判断就可以了。</p><p>（不保证代码正确</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in_polygon</span><span class="params">(Point *p, Point a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p[n + <span class="number">1</span>] = p[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>((p[<span class="number">1</span>] - p[i]) * (p[i + <span class="number">1</span>] - p[i])) &lt; eps &amp;&amp;</span><br><span class="line"><span class="built_in">dot</span>(p[<span class="number">1</span>] - p[i], p[i + <span class="number">1</span>] - p[i]) &gt; eps &amp;&amp; <span class="built_in">dot</span>(p[i + <span class="number">1</span>] - p[<span class="number">1</span>], p[i + <span class="number">1</span>] - p[i]) &gt; eps)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Point c = &#123;(<span class="keyword">double</span>)<span class="built_in">rand</span>(), (<span class="keyword">double</span>)<span class="built_in">rand</span>()&#125;;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; !flag; ++ i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>((c - a) * (p[i] - a)) &lt; eps &amp;&amp; <span class="built_in">fabs</span>((c - a) * (p[i + <span class="number">1</span>] - a)) &lt; eps)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">flag ^= <span class="built_in">cross_seg</span>(a, c, p[i], p[i + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4）多边形面积"><a href="#4）多边形面积" class="headerlink" title="4）多边形面积"></a>4）多边形面积</h3><p>这是一个结论，我们就不证明了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sum_area</span><span class="params">(Point *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++ i)</span><br><span class="line">res += (p[i + <span class="number">1</span>] - p[<span class="number">1</span>]) * (p[i] - p[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-例题"><a href="#5-例题" class="headerlink" title="5. 例题"></a>5. 例题</h2><h3 id="T1：玩具"><a href="#T1：玩具" class="headerlink" title="T1：玩具"></a>T1：玩具</h3><p><a href="http://poj.org/problem?id=2318">题目传送门 POJ</a></p><p>我们二分，找到第一个在该点左边的隔板。判断这个点是否在线段的右边（这里是顺时针方向），直接用叉乘即可。</p><details><summary>完整代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">LL x, y;</span><br><span class="line">Point <span class="keyword">operator</span> +(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x + t.x, y + t.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Point <span class="keyword">operator</span> -(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">LL <span class="keyword">operator</span> *(Point t)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * t.y - y * t.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;L, R, now, up[N], dn[N];</span><br><span class="line"><span class="keyword">int</span> n, m, cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> is_fir = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %lld %lld %lld %lld&quot;</span>, &amp;m, &amp;L.x, &amp;R.y, &amp;R.x, &amp;L.y);</span><br><span class="line">up[<span class="number">0</span>] = &#123;L.x, L.y&#125;, dn[<span class="number">0</span>] = &#123;L.x, R.y&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;dn[i].x, &amp;up[i].x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) up[i].y = L.y, dn[i].y = R.y;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) cnt[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!is_fir) <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cse = <span class="number">1</span>; cse &lt;= m; ++ cse)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;now.x, &amp;now.y);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((now - up[mid]) * (dn[mid] - up[mid]) &gt; <span class="number">0</span>) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cnt[l] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>, i, cnt[i]);</span><br><span class="line">is_fir = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3321</title>
      <link href="/2021/12/27/P3321/"/>
      <url>/2021/12/27/P3321/</url>
      
        <content type="html"><![CDATA[<p>比较难想，但其实是一个套路。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给定匹配串 $a$ 和原串 $b$，要求像 KMP 一样匹配，但是有通配符（指和每一个都可以匹配），给出所有的起点可以匹配。</p><p>$|a|,|b|\leq 10 ^ 5 $。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>（以下字符串默认从 0 开始）</p><p>首先，肯定不是暴力枚举每一个通配符的匹配字符。</p><p>其中，对于一个字符串 $s$，构造<br>$$<br>F(x) = \sum_{i = 0}^{|s| - 1} [s(i) == ‘*’]\times s(i) \ x ^ i<br>$$<br>表示如果是通配符的话，就是 0，否则就是原字符本身。</p><p>我们现在假设要求 $k$ 这个位置能否匹配。</p><p>我们考虑构造：<br>$$<br>H_k = \sum_{i = 0}^{m - 1} A(i) \times B(i + k - 1) \times (A(i) - B(i + k - 1)) ^ 2\ x ^ i<br>$$<br>那么，$[x^i]H(x)$ 为 0 的话，有 3 种情况：</p><ol><li>$A(i) = 0$</li><li>$B(i) = 0$</li><li>$A(i) = B(i + x - 1)$</li></ol><p>可以发现，这三种情况正好对应的有通配符的情况下的匹配。</p><p>由于每一项非负，所以只要有一项不是 0，所以整个就不是 0。</p><p>那么，我们展开一下：<br>$$<br>H_k = \sum_{i = 0}^{m - 1} (A(i)^3B(i + k - 1) - 2A(i)^2B(i + k - 1) ^ 2 + A(i)B(i + k - 1) ^ 3)<br>$$<br>那么，我们就只需要求出所有的 $H(x)$，每一位都是 $H_k$，只需要统计 0 的个数就可以了。<br>$$<br>H(x) = \sum_{k = 0}^{n - 1}\sum_{i = 0}^{m - 1} (A(i)^3B(i + k - 1) - 2A(i)^2B(i + k - 1) ^ 2 + A(i)B(i + k - 1) ^ 3)<br>$$<br>这个很明显是一个差相等的会放到一个 $H_k$ 中，根据套路，我们把它翻转一个。<br>$$<br>H(x) = \sum_{k = 0}^{n - 1}\sum_{i = 0}^{m - 1} (A(m - i - 1)^3B(i + k - 1) - 2A(m - i - 1)^2B(i + k - 1) ^ 2 + A(m - i - 1)B(i + k - 1) ^ 3)<br>$$<br>直接 NTT 就可以了。注意每一项都要 NTT，而不是一次 NTT 直接计算。</p><p>注意<a href="https://www.luogu.com.cn/discuss/303076">有人卡 998244353</a>，直接把原根换成 5 或者模数换为 167772161 就可以了。但是确实可以被卡。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">Match</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">char</span> *s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; mat;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">strlen</span>(s1), n = <span class="built_in">strlen</span>(s2);</span><br><span class="line">    <span class="built_in">reverse</span>(s1, s1 + m);</span><br><span class="line">    <span class="keyword">static</span> LL f[N], g[N], h[N], a[N], b[N];</span><br><span class="line">    <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (n + m + <span class="number">1</span>)) bit ++;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) h[i] = f[i] = g[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s1[i] == <span class="string">&#x27;*&#x27;</span>) f[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> f[i] = s1[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s2[i] == <span class="string">&#x27;*&#x27;</span>) g[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> g[i] = s2[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//H(i - j) += F(i) * G(j) * (F(i) - G(j)) ^ 2</span></span><br><span class="line">    <span class="comment">//H(i + j - m - 1) += F(i) * G1(m - j - 1) * (F(i) - G1(j)) ^ 2</span></span><br><span class="line">    <span class="comment">/*for (int i = 0; i &lt; tot; ++ i)</span></span><br><span class="line"><span class="comment">        f[i] = (qpow(f[i], 3) * g[i] % Mod - qpow(f[i] * g[i] % Mod, 2) * 2 % Mod + qpow(g[i], 3) * f[i] % Mod + Mod) % Mod;*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = f[i] * f[i] * f[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) b[i] = g[i];</span><br><span class="line">    <span class="built_in">NTT</span>(a, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) h[i] = (h[i] + a[i] * b[i]) % Mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = f[i] * f[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) b[i] = g[i] * g[i];</span><br><span class="line">    <span class="built_in">NTT</span>(a, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) h[i] = (h[i] + (Mod - <span class="number">2</span>) * a[i] % Mod * b[i]) % Mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = f[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) b[i] = g[i] * g[i] * g[i];</span><br><span class="line">    <span class="built_in">NTT</span>(a, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) h[i] = (h[i] + a[i] * b[i]) % Mod;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NTT</span>(h, bit, <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// for (int i = m - 1; i &lt; n; ++ i) cout &lt;&lt; h[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line">    <span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (h[i] == <span class="number">0</span>) mat.<span class="built_in">push_back</span>(i - m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二次剩余与 Cipolla 算法</title>
      <link href="/2021/12/26/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%E4%B8%8E-Cipolla-%E7%AE%97%E6%B3%95/"/>
      <url>/2021/12/26/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%E4%B8%8E-Cipolla-%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>虽说比较困难，但是代码实现十分简单。</p><span id="more"></span><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>我们求解 $x ^ 2 \equiv n \pmod p$，其中 $n, p$ 给定，$p$ 是质数。就是二次剩余，可以记为 $x = \sqrt n$。</p><p>一般使用 Cipolla 算法，时间复杂度是玄学，期望是 $O(\log n)$，一般也比较稳定。</p><h2 id="2-推导过程"><a href="#2-推导过程" class="headerlink" title="2. 推导过程"></a>2. 推导过程</h2><p>首先，证明一下<strong>在 $\bmod p$ 意义下的有 $\sqrt n$ 的 $n$ 的个数有 $\dfrac{p - 1}{2}$ 个。</strong></p><p>首先，我们容易发现，$x$ 与 $p - x$ 在 $\bmod p$ 意义下是相等的。于是我们只需要判断 $x\in[1, \dfrac{p - 1}{2}]$ 的 $x ^ 2$ 是不相同的。这样的话，对于 $\dfrac{p - 1}{2}$ 个 $n$ 都有两个不同的二次剩余对应它。</p><p>使用反证法，我们假设 $x_1,x_2\in[1, \dfrac{p - 1}{2}]$ 的平方是一样的，那么可以得到 $(x_2 +x_1)(x_2 - x_1)\equiv 0\pmod p$。但是 $x_2 + x_1$ 和 $x_2 - x_1$ 都是不可能相等的，所以不可能存在这样的 $x_1$ 和 $x_2$。</p><p>第二个，我们有一个定理：<strong>如果 $n^{\frac{p - 1}{2}}\equiv 1\pmod p$，那么 $n$ 在 $\bmod p$ 下是有二次剩余的。</strong></p><p>这一个比较难证，这里就略过了。但是一个可以明确的地方是 $\forall n, n^{\frac{p - 1}2}\bmod p\in {1, p - 1}$。因为 $n^{p - 1}\bmod p = 1$。</p><p>第三个，我们找到一个 $a$，使得 $a^2 - n$ 是一个非二次剩余。找到 $a$ 的话，我们使用随机化算法，在 $[0, p - 1]$ 中随机，然后判断 $(a ^ 2 - n)^{\frac{p - 1}2}$ 是否等于 $-1\bmod p$。由于有 $\dfrac{p - 1}{2}$ 个数不是二次剩余，所以我们期望 2 次就可以找到一个 $a ^ 2 - n$。这一步的期望是 $O(\log n)$。</p><p>设 $w = a ^ 2 - n$。</p><p>最后一步，我们定义一个二维向量 $(a, b)$，表示 $a + b\sqrt w$。</p><p>我们可以得到第三个结论：<strong>将二维向量当作一个数来乘，$\sqrt n = (a, 1) ^{\frac{p - 1}{2}}$。</strong></p><p>其中，$(a, 1)$ 表示 $a + \sqrt w$ 这个数，我们将这个数 $\dfrac{p - 1}{2}$ 次方，实部就是 $\sqrt n$。</p><p>证明也太难了，我们就不讲了。</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p>首先，我们将向量直接看做复数封装好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    ll x, y;</span><br><span class="line">&#125;;</span><br><span class="line">ll w;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">mul</span><span class="params">(Complex t1, Complex t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(t1.x * t2.x % p + t1.y * t2.y % p * w % p) % p, (t1.x * t2.y % p + t1.y * t2.x % p) % p&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">qpow_com</span><span class="params">(Complex a, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Complex res = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = <span class="built_in">mul</span>(res, a);</span><br><span class="line">        a = <span class="built_in">mul</span>(a, a);</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>qpow_com</code> 表示复数快速幂，其实是比较简单的。</p><p>然后就可以直接实现了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="built_in">rand</span>() % p;</span><br><span class="line">        w = (a * a % p - n + p) % p;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">qpow</span>(w, (p - <span class="number">1</span>) / <span class="number">2</span>) == p - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow_com</span>(&#123;a, <span class="number">1</span>&#125;, (p + <span class="number">1</span>) / <span class="number">2</span>).x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完全版。</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cipolla</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    LL x, y;</span><br><span class="line">&#125;;</span><br><span class="line">LL w, Mod;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">mul</span><span class="params">(Complex a, Complex b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(a.x * b.x % Mod + a.y * b.y % Mod * w % Mod) % Mod, (a.x * b.y + a.y * b.x) % Mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">qpow_com</span><span class="params">(Complex a, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Complex res = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = <span class="built_in">mul</span>(res, a);</span><br><span class="line">        a = <span class="built_in">mul</span>(a, a);</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL a, LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * a % Mod;</span><br><span class="line">        a = a * a % Mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cipolla</span>(<span class="keyword">int</span> _Mod = <span class="number">998244353</span>) : <span class="built_in">Mod</span>(_Mod) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Mod_Sqrt</span><span class="params">(LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL a;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="built_in">rand</span>() % Mod;</span><br><span class="line">        w = (a * a - n + Mod) % Mod;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">qpow</span>(w, (Mod - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) == Mod - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow_com</span>(&#123;a, <span class="number">1</span>&#125;, (Mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>).x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P7590</title>
      <link href="/2021/12/26/P7590/"/>
      <url>/2021/12/26/P7590/</url>
      
        <content type="html"><![CDATA[<p>单调队列。</p><span id="more"></span><h2 id="0-前置知识-amp-废话"><a href="#0-前置知识-amp-废话" class="headerlink" title="0. 前置知识 &amp; 废话"></a>0. 前置知识 &amp; 废话</h2><p>说实话，出题人的办法我没太看懂，于是就想了另外一种方法。</p><p>本题解需要你掌握：单调队列</p><p><a href="https://www.luogu.com.cn/problem/P1886">本算法位置</a></p><p>时间复杂度仍为 $O(n)$，但常数较标程略大，故需要点 <del>玄学优化</del>。</p><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给你一个环，每一个点都可以加一定的权值 x，从一个点到下一个点都要减少一定的权值，要保证随时都要 $x\geq0$，可以在一个点时恰好为 0。</p><p>从每一个点开始时，权值都等于 0。</p><p>如果有一个点可以运动 1 周，输出最小编号，否则输出 “Failed!”。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>出题人的方法我确实没看懂。</p><h3 id="1）朴素"><a href="#1）朴素" class="headerlink" title="1）朴素"></a>1）朴素</h3><p>首先考虑朴素算法。</p><p>定义<br>$$<br>d[x]=a[x]-b[x],sum[x]=\sum_{i=1}^{x}d[i]<br>$$<br>所以如果从 i 可以到 i+1，需要满足：<br>$$<br>a[i]=sum[i+1]-sum[i]\geq 0<br>$$<br>我们可以考虑将环拆成 2 倍的链。</p><p>如果从 i 可以的话，需要满足：<br>$$<br>\forall j\in [i,i+n-1],sum[j]\geq sum[i-1]<br>$$<br>时间复杂度为 $O(n^2)$，期望得分 30 分。</p><p><a href="https://www.luogu.com.cn/paste/oewr50t0">代码放置处</a></p><p>实际打代码时，我们可以以它为对拍代码。</p><h3 id="2）堆优化"><a href="#2）堆优化" class="headerlink" title="2）堆优化"></a>2）堆优化</h3><p>其实，我们不难发现，对于该式，我们可以使用堆优化。</p><p>时间复杂度 $O(n\log n)$，期望得分 70 分。</p><p>不放代码了 <del>逃</del>。</p><h3 id="3）单调队列"><a href="#3）单调队列" class="headerlink" title="3）单调队列"></a>3）单调队列</h3><p>我们进一步挖掘性质，可以发现，我们需要的是 $[i,i+n-1]$ 的最小值，且 i 不断变大。</p><p>这难道不是和单调队列相似吗？</p><p>那么就可以了。</p><p>如果 $j&lt;k,sum[j]&gt;sum[k]$，那么 j 不可能成为某个点的最小值。</p><p>维护一个单调队列，使其保持递增的顺序。</p><p>队头是最小值。</p><p>那么就可以了 吗？ <del>雾</del>。</p><p>单调队列虽然是 $O(n)$,但常数相对于标程更大，而最大 $\sum n=2\times 10^7$，很可能超时。</p><h2 id="3-常数优化"><a href="#3-常数优化" class="headerlink" title="3. 常数优化"></a>3. 常数优化</h2><ol><li>我开始 scanf+O2 竟然超时了，所以快读是时候了。</li><li>听说 register 可以加快，用一用也不错。</li></ol><p>这样一阵 <del>玄学</del> 优化后，我们就不用 O2 最大点也可以只用 600ms 就过了。</p><h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll d[<span class="number">2</span>*N],sum[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">int</span> hh,tt,q[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (hh&lt;=tt&amp;&amp;sum[q[tt]]&gt;=sum[x]) tt--;</span><br><span class="line">q[++tt]=x;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((c=<span class="built_in">getchar</span>())&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) ;</span><br><span class="line">    x=c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c=<span class="built_in">getchar</span>())&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// freopen(&quot;randdata.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">// freopen(&quot;myans.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">re <span class="keyword">int</span> cas,n,x;</span><br><span class="line"><span class="built_in">get</span>(cas);</span><br><span class="line"><span class="keyword">while</span> (cas--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">get</span>(n);</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">get</span>(x),d[i]=x;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">get</span>(x);</span><br><span class="line">d[i]-=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) d[i+n]=d[i];</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;++i) sum[i]=sum[i<span class="number">-1</span>]+d[i];<span class="comment">//,cout&lt;&lt;sum[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">hh=<span class="number">1</span>;tt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">insert</span>(i);</span><br><span class="line">re <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (hh&lt;=tt&amp;&amp;q[hh]&lt;i) hh++;</span><br><span class="line"><span class="built_in">insert</span>(i+n<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// printf(&quot;%d %d\n&quot;,hh,tt);</span></span><br><span class="line"><span class="keyword">if</span> (sum[i<span class="number">-1</span>]&lt;=sum[q[hh]])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="built_in">puts</span>(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P7225</title>
      <link href="/2021/12/26/P7225/"/>
      <url>/2021/12/26/P7225/</url>
      
        <content type="html"><![CDATA[<p>极为简单的交互题目。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>你站在一个格子，你可以移动到相邻的格子（如果相邻的格子不是障碍物的话）。</p><p>现在你需要回答走能走到的格子有哪些。</p><h2 id="2-关于交互题"><a href="#2-关于交互题" class="headerlink" title="2. 关于交互题"></a>2. 关于交互题</h2><p>请确保你知道交互题的评测方式与做法。</p><p>其实，大概的意思就是你和另外一个程序同时运行，并交换数据。</p><p>本蒟蒻由于没做过几道交互题，只能讲到这个地步啦。</p><h2 id="3-本题"><a href="#3-本题" class="headerlink" title="3. 本题"></a>3. 本题</h2><p>主要有两种思路：bfs 和 dfs。</p><p>注意观察 bfs 的性质：他是走到一个位置后，一会在进行扩展。</p><p>但是，本题中，我们希望的是他走的时候，是连续的，并且有回溯过程。</p><p>看到原题，他只会给你当前格子的信息，不会给你其他格子的。</p><p>所以，我们采用 dfs 进行搜索，并时刻记录有没有被访问。</p><p>由于每一个格子访问次数是常数，所以复杂度为 $O(n^2)$。</p><h2 id="4-AC-代码"><a href="#4-AC-代码" class="headerlink" title="4.AC 代码"></a>4.AC 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(i,j) (i-1)*n+j-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> check(i,j) (i&gt;1&amp;&amp;j&gt;1&amp;&amp;i&lt;n&amp;&amp;j&lt;n&amp;&amp;m[i][j]==-1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">705</span>][<span class="number">705</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,n,m[<span class="number">705</span>][<span class="number">705</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">4</span>]=&#123;<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;W&#x27;</span>&#125;;</span><br><span class="line">string ans;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">bool</span> <span class="title">move_to</span><span class="params">(<span class="keyword">char</span> position)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(x+dx[i],y+dy[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">move_to</span>(op[i])) m[x+dx[i]][y+dy[i]]=<span class="number">0</span>,<span class="built_in">dfs</span>(x+dx[i],y+dy[i]),<span class="built_in">move_to</span>(op[<span class="number">3</span>-i]);</span><br><span class="line">            <span class="keyword">else</span> m[x+dx[i]][y+dy[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">string <span class="title">find_out_map</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    ans=<span class="string">&quot;&quot;</span>;n=N;</span><br><span class="line">    <span class="built_in">memset</span>(m,<span class="number">-1</span>,<span class="keyword">sizeof</span> m);</span><br><span class="line">    <span class="built_in">dfs</span>(x,y);</span><br><span class="line">    ans=<span class="string">&quot;&quot;</span>;m[x][y]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (m[i][j]==<span class="number">0</span>) ans+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> ans+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-半个交互库"><a href="#5-半个交互库" class="headerlink" title="5. 半个交互库"></a>5. 半个交互库</h2><p>我自己做的时候，由于没有交互库，无法得知自己是否正确。</p><p>自己手写的代码，算半个交互库，希望对你有所帮助。</p><p>（同时是本题的非交互写法）。</p><p>也增添了评测。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(i,j) (i-1)*n+j-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> check(i,j) (i&gt;1&amp;&amp;j&gt;1&amp;&amp;i&lt;n&amp;&amp;j&lt;n&amp;&amp;m[i][j]==-1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">705</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,n,m[N][N],nowx,nowy;</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">4</span>]=&#123;<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;W&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ansmap[N][N],tot;</span><br><span class="line">string ans,stdans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">move_to</span><span class="params">(<span class="keyword">char</span> position)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++tot&gt;=<span class="number">5e5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Too many operations!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position==<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ansmap[nowx+<span class="number">1</span>][nowy])</span><br><span class="line">        &#123;</span><br><span class="line">            nowx++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ansmap[nowx][nowy<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            nowy--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position==<span class="string">&#x27;W&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ansmap[nowx<span class="number">-1</span>][nowy])</span><br><span class="line">        &#123;</span><br><span class="line">            nowx--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ansmap[nowx][nowy+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            nowy++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(x+dx[i],y+dy[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">move_to</span>(op[i])) m[x+dx[i]][y+dy[i]]=<span class="number">0</span>,<span class="built_in">dfs</span>(x+dx[i],y+dy[i]),<span class="built_in">move_to</span>(op[<span class="number">3</span>-i]);</span><br><span class="line">            <span class="keyword">else</span> m[x+dx[i]][y+dy[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">find_out_map</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*put your code here</span></span><br><span class="line"><span class="comment">      this is mine*/</span></span><br><span class="line">    ans=<span class="string">&quot;&quot;</span>;n=N;</span><br><span class="line">    <span class="built_in">memset</span>(m,<span class="number">-1</span>,<span class="keyword">sizeof</span> m);</span><br><span class="line">    <span class="built_in">dfs</span>(x,y);</span><br><span class="line">    ans=<span class="string">&quot;&quot;</span>;m[x][y]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (m[i][j]==<span class="number">0</span>) ans+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> ans+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;nowx&gt;&gt;nowy&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;stdans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (stdans[<span class="built_in">get</span>(i,j)]!=<span class="string">&#x27;0&#x27;</span>) ansmap[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> ansmap[i][j]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//put in the stdmap</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find_out_map</span>(nowx,nowy,n)==stdans) <span class="built_in">puts</span>(<span class="string">&quot;Accepted.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Wrong Answer!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3329</title>
      <link href="/2021/12/26/P3329/"/>
      <url>/2021/12/26/P3329/</url>
      
        <content type="html"><![CDATA[<p>最小割树的模板题。</p><span id="more"></span><h2 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1. 前置知识"></a>1. 前置知识</h2><p><a href="https://www.luogu.com.cn/problem/P4897">最小割树（Gomory-Hu Tree）</a></p><p>如果你不知道，可以看 <a href="https://mydcwfy.github.io/2021/12/26/Network-flow/">网络流</a> 或 <a href="https://mydcwfy.github.io/2021/12/26/P4897/">最小割树</a> （ <del>都是我的博客</del> ）</p><p>当然，你也可以看一下下面的解释。</p><h2 id="2-最小割树（Gomory-Hu-Tree）"><a href="#2-最小割树（Gomory-Hu-Tree）" class="headerlink" title="2. 最小割树（Gomory-Hu Tree）"></a>2. 最小割树（Gomory-Hu Tree）</h2><p>（ <del>这也是来自我的博客</del> ）</p><p>很明显，不可能每次求最小割（复杂度为 $O(n^4m)$）。</p><p>我们将一个网络流的图转化为一棵树，其中原图 $u$ 到 $v$ 的最小割即为转化到树上。</p><p>树的一个性质是：删除一条边，树变得不连通。</p><p>那么，我们可以任意选 2 个点 $s$ 与 $t$，跑最小割（即最大流），然后再连一条从 $s$ 到 $t$ 的边。</p><p>又 Dinic 算法最后一次 bfs 相当于求一个最小割，原图就被分为了两部分。</p><p>最后分治就可以了，复杂度为 $O(n^3m)$（Dinic 跑不满的，所以不会超时）。</p><p>按这样建出的树，就是一棵无根树。</p><p>我们可以发现一个有趣的性质：$u$ 到 $v$ 的最小割就是树上从 $u$ 到 $v$ 的所有路径长的最小值。</p><p>可以感性地理解一下（ <del>主要是太菜不会证</del> ）：最小割即为最小的路径长，把 $u$ 到 $v$ 的任意一条路径切断，都是割。</p><h2 id="3-回归本题"><a href="#3-回归本题" class="headerlink" title="3. 回归本题"></a>3. 回归本题</h2><p>还是比较简单。</p><p>直接预处理，将所有的点对之间的最小割求出来。</p><p>有一下两种做法。</p><h3 id="1）-直接扫描"><a href="#1）-直接扫描" class="headerlink" title="1） 直接扫描"></a>1） 直接扫描</h3><p>由于出题人比较良心，这个题的 $Q$ 比较少，可以通过 $O(Qn^2)$，还是可以过的。</p><h3 id="2）-使用有序排列"><a href="#2）-使用有序排列" class="headerlink" title="2） 使用有序排列"></a>2） 使用有序排列</h3><p>我们也可以先将所有的最小割排序好，每次询问，直接查询在有序数列中的位置，减下标即可。</p><p><del>我太懒了</del>，使用了第一种。</p><h2 id="4-Code"><a href="#4-Code" class="headerlink" title="4. Code"></a>4. Code</h2><p>注意要建双向边，否则就不是两边都可以被割掉了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF=<span class="number">1e15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line">ll w[M],ans[N][N];</span><br><span class="line"><span class="keyword">int</span> cur[N],d[N],q[N],S,T,n,m;</span><br><span class="line"><span class="keyword">int</span> node[N],tmp1[N],tmp2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">e[idx]=a,ne[idx]=h[b],w[idx]=<span class="number">0</span>,h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">int</span> hh=<span class="number">1</span>,tt=<span class="number">1</span>;</span><br><span class="line">q[<span class="number">1</span>]=S;cur[S]=h[S];d[S]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (hh&lt;=tt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q[hh++];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (!d[e[i]]&amp;&amp;w[i])</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+<span class="number">1</span>;</span><br><span class="line">cur[e[i]]=h[e[i]];</span><br><span class="line"><span class="keyword">if</span> (e[i]==T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[++tt]=e[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findflow</span><span class="params">(<span class="keyword">int</span> x,ll limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x==T) <span class="keyword">return</span> limit;</span><br><span class="line">ll flow=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=cur[x];~i&amp;&amp;flow&lt;limit;i=ne[i])</span><br><span class="line">&#123;</span><br><span class="line">cur[x]=i;</span><br><span class="line"><span class="keyword">if</span> (d[e[i]]==d[x]+<span class="number">1</span>&amp;&amp;w[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">findflow</span>(e[i],<span class="built_in">min</span>(w[i],limit-flow));</span><br><span class="line"><span class="keyword">if</span> (!t) d[e[i]]=<span class="number">-1</span>;</span><br><span class="line">w[i]-=t,w[i^<span class="number">1</span>]+=t,flow+=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i+=<span class="number">2</span>)</span><br><span class="line">w[i]=(w[i]+w[i^<span class="number">1</span>]),w[i^<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">ll r=<span class="number">0</span>,flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">bfs</span>()) <span class="keyword">while</span> (flow=<span class="built_in">findflow</span>(S,INF)) r+=flow;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l==r) <span class="keyword">return</span> ;</span><br><span class="line">S=node[l],T=node[l+<span class="number">1</span>];</span><br><span class="line">ll t=<span class="built_in">dinic</span>();</span><br><span class="line">    <span class="keyword">int</span> s=node[l],tt=node[l+<span class="number">1</span>];</span><br><span class="line">ans[T][S]=ans[S][T]=t;</span><br><span class="line"><span class="comment">//printf(&quot;%d %d:%d\n&quot;,S,T,ans[S][T]);</span></span><br><span class="line"><span class="keyword">int</span> cnt1=<span class="number">0</span>,cnt2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=l;i&lt;=r;++i)</span><br><span class="line"><span class="keyword">if</span> (d[node[i]]) tmp1[++cnt1]=node[i];</span><br><span class="line"><span class="keyword">else</span> tmp2[++cnt2]=node[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt1;++i) node[i+l<span class="number">-1</span>]=tmp1[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt2;++i) node[cnt1+l+i<span class="number">-1</span>]=tmp2[i];</span><br><span class="line"><span class="built_in">work</span>(l,l+cnt1<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">work</span>(l+cnt1,r);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt1;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt2;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ii=node[i+l<span class="number">-1</span>],jj=node[j+cnt1+l<span class="number">-1</span>];</span><br><span class="line">ans[jj][ii]=ans[ii][jj]=<span class="built_in">min</span>(<span class="built_in">min</span>(ans[ii][s],ans[s][tt]),ans[tt][jj]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Case=<span class="number">0</span>;cin&gt;&gt;Case;</span><br><span class="line">    <span class="keyword">while</span> (Case--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">        idx=<span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j) ans[i][j]=INF;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        ll z;</span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lld&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            <span class="built_in">add</span>(x,y,z);<span class="built_in">add</span>(y,x,z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) node[i]=i;</span><br><span class="line">        <span class="built_in">work</span>(<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">int</span> que;cin&gt;&gt;que;</span><br><span class="line">        <span class="keyword">while</span> (que--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;z);</span><br><span class="line">            <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">                    <span class="keyword">if</span> (ans[i][j]&lt;=z) tot++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tot/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF455B</title>
      <link href="/2021/12/26/CF455B/"/>
      <url>/2021/12/26/CF455B/</url>
      
        <content type="html"><![CDATA[<p>SG 函数的简单题目。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>两人交替在开始为空字符串的后面加入字符，要求必须随时为给定的字符串集的某一个串的前缀。将会进行 $k$ 次游戏，上一局输的人作为下一局的先手，最后一局胜利的人获得最终的胜利。在足够聪明的情况下，问第一局的先手是否会赢。</p><p>字符串的总个数 $\leq10^5$，字符串的总字符数 $\leq10^5$，$k\leq10^9$。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>首先，我们可以转化为一个在 Trie 上走，不能走者输的情况。</p><p>考虑 $k=1$ 的情况：这不就是一个 SG 函数的应用吗？</p><p>遍历一遍 Trie，叶节点为先手必败，如果一个节点的某个儿子是先手必败，那么该节点先手必胜，否则先手必败。</p><p>那么，我们可以简单的写出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_trie</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> has_son = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (son[u][i]) has_son = <span class="number">1</span>, <span class="built_in">get_trie</span>(son[u][i]);</span><br><span class="line"><span class="keyword">if</span> (!has_son)&#123;</span><br><span class="line">sg[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (son[u][i] &amp;&amp; !sg[son[u][i]])</span><br><span class="line">&#123;</span><br><span class="line">sg[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sg[u] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们考虑 $k=2$ 的情况。</p><p>如果先手 $k=1$ 是一定会胜而不可能输的（注意，这里指即使先手想输也不可能），那么，先手一定会在前一局的时候尽一切可能去输（感觉有点不合常理），这样他就会获得下一局的先手，而获得最后的胜利。</p><p>所以，我们在 $k&gt;1$ 的时候，不仅要考虑先手能否可以胜利，还要考虑先手能否失败。</p><p>怎样计算先手能否失败呢？我们将前面叶节点的时候设为必胜（是指一定可以输掉游戏，不是原来的游戏的必胜），那么如果最后根节点是必胜的话，那么他一定可以在走到叶节点为必胜状态，也就是可以输掉。</p><p>接着，我们发现先手有四种情况了：可胜可败，只能胜，只能败，不能胜也不能败（由后手控制力）。</p><ol><li><p>可胜可败：发现先手可以操控答案的走向，一定是可以赢的。</p></li><li><p>只能胜：最开始的先手和后手会交替先走，所以现在要看 $k$ 的奇偶，奇就是先手胜，偶就是后者胜。</p></li><li><p>只能败：先手每次都会败，也因为每次都败，每次都是先手，所以最后先手败。</p></li><li><p>不能胜也不能败：后手操控答案的走向，所以一定是输的。</p></li></ol><p>那么，我们就可以写出了最后的判断代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((able_win &amp;&amp; able_lose)) <span class="built_in">puts</span>(<span class="string">&quot;First&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (able_win) <span class="built_in">puts</span>(k &amp; <span class="number">1</span> ? <span class="string">&quot;First&quot;</span> : <span class="string">&quot;Second&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (able_lose) <span class="built_in">puts</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Second&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="3-Code"><a href="#3-Code" class="headerlink" title="3. Code"></a>3. Code</h2><p>前面基本已经展示了，这里给一个完整代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], rt = <span class="number">1</span>, tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> id[N], n, k, flag, sg[N], able_lose, able_win;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u = rt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; s[i]; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!son[u][s[i] - <span class="string">&#x27;a&#x27;</span>]) son[u][s[i] - <span class="string">&#x27;a&#x27;</span>] = ++ tot;</span><br><span class="line">u = son[u][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">id[i] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_trie</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> has_son = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (son[u][i]) has_son = <span class="number">1</span>, <span class="built_in">get_trie</span>(son[u][i]);</span><br><span class="line"><span class="keyword">if</span> (!has_son)&#123;</span><br><span class="line">sg[u] = flag;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line"><span class="keyword">if</span> (son[u][i] &amp;&amp; !sg[son[u][i]])</span><br><span class="line">&#123;</span><br><span class="line">sg[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sg[u] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">insert</span>(i, str);</span><br><span class="line">&#125;</span><br><span class="line">flag = <span class="number">1</span>, <span class="built_in">get_trie</span>(<span class="number">1</span>);<span class="comment">//flag 是指叶节点是胜还是败</span></span><br><span class="line">able_lose = sg[<span class="number">1</span>];</span><br><span class="line">flag = <span class="number">0</span>, <span class="built_in">get_trie</span>(<span class="number">1</span>);</span><br><span class="line">able_win = sg[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> ((able_win &amp;&amp; able_lose)) <span class="built_in">puts</span>(<span class="string">&quot;First&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (able_win) <span class="built_in">puts</span>(k &amp; <span class="number">1</span> ? <span class="string">&quot;First&quot;</span> : <span class="string">&quot;Second&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (able_lose) <span class="built_in">puts</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> SG 函数 </tag>
            
            <tag> CF </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF919E</title>
      <link href="/2021/12/26/CF919E/"/>
      <url>/2021/12/26/CF919E/</url>
      
        <content type="html"><![CDATA[<p>模拟和逆元题目。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>求<br>$$<br>n\cdot a^n\equiv b\pmod p<br>$$<br>在 $[1,x]$ 的正整数解的个数，其中 $a,b,p,x$ 给定。</p><p>$p\leq10^6+3,x\leq10^{12},1\leq a,b&lt;p$。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>首先，看到 $p\leq10^6+3$，一定是要 $O(p)$ 枚举，然后再做。</p><h4 id="a）枚举-n"><a href="#a）枚举-n" class="headerlink" title="a）枚举 $n$"></a>a）枚举 $n$</h4><p>那么，原题转化为了 $t\cdot a^n\equiv b\pmod p$ 的解了。</p><p>很明显是一个 BSGS，时间复杂度为 $O(\sqrt p)$ 或 $O(\sqrt p\log \sqrt p)$，取决于 map 还是 Hash。</p><p>但是，总时间为 $O(p\sqrt p)$，很明显无法通过。</p><h4 id="b）枚举-a-n"><a href="#b）枚举-a-n" class="headerlink" title="b）枚举 $a^n$"></a>b）枚举 $a^n$</h4><p>首先，我们考虑 $a^n$ 的取值有多少种。</p><p>由于 $a^{p-1}\equiv 1\pmod p$，所以循环节一定是 $p-1$，那么我们就可以枚举 $n\bmod (p-1)$，得到所有的 $a^n$ 的取值。</p><p>那么，原题就是 $n\cdot t\equiv b\pmod p$ 的解。</p><p>咦，这不就是一个逆元了吗？</p><p>于是，我们可以 $O(\log p)$ 求出逆元（因为一定有），那么，我们就可以求出 $n\bmod p$ 的值。</p><h4 id="c）合并答案"><a href="#c）合并答案" class="headerlink" title="c）合并答案"></a>c）合并答案</h4><p>这道题在 CF 上有中国剩余定理的标签，大概就是这里用的吧。</p><p>我们已经得到了 $t1=n\bmod (p-1)$ 和 $t2=n\bmod p$ 的值，直接由中国剩余定理就可以了。</p><p>其实手玩也不是不可以，直接设 $n=kp+t2$，代入第一个就可以得到：<br>$$<br>\begin{aligned}<br>kp+t2&amp;\equiv t1 \pmod {p-1}\<br>k+t2&amp;\equiv t1\pmod {p-1}\<br>k&amp;\equiv t2-t1\pmod {p-1}<br>\end{aligned}<br>$$<br>就解出了 $n$ 的最小正整数取值了。</p><p>周期<del>很明显</del>是 $p\cdot(p-1)$，将答案加入即可。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><p>实际实现的时候可以预处理算出 $a$ 的逆元，每次枚举 ${a^t}$ 的逆元的时候可以通过 ${a^{t-1}}^{-1}$ 乘上 $a^{-1}$ 即可。</p><p>码风略丑，请见谅。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; Mod &gt;&gt; x;</span><br><span class="line">ll now = b, inv = <span class="built_in">qpow</span>(a, Mod - <span class="number">2</span>), lim = Mod * (Mod - <span class="number">1</span>), ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (ll modp1 = <span class="number">0</span>; modp1 &lt; Mod - <span class="number">1</span>; ++ modp1, now = now * inv % Mod)</span><br><span class="line">&#123;<span class="comment">//modp1 是枚举的 t，now 就是上面的 b 乘以（ a 的 t 次方的逆元），也就是 t1</span></span><br><span class="line">ll mx = (modp1 - now + (Mod - <span class="number">1</span>)) % (Mod - <span class="number">1</span>) * Mod + now;<span class="comment">//mx 是 n 的最小取值</span></span><br><span class="line">mx = (mx % lim + lim) % lim;<span class="comment">//lim 是 Mod * Mod - 1，是 n 的周期</span></span><br><span class="line"><span class="keyword">if</span> (mx &lt;= x) ans += (x - mx + lim) / lim;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CF </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF306C</title>
      <link href="/2021/12/26/CF306C/"/>
      <url>/2021/12/26/CF306C/</url>
      
        <content type="html"><![CDATA[<p>简单的组合数学。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给出 $n$ 天，以及<strong>互不相同</strong>的 $w$ 件好事、$b$ 件坏事，每天只能出现好事、坏事中的一种，要求发生的顺序为 好事 - 坏事 - 好事 的情况的方案数，答案对 $10^9+9$ 取模。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>首先，<strong>互不相同</strong>可以直接转化为<strong>相同</strong>，也就是我们可以现将答案算出来，然后乘上 $w!\cdot b!$ 即可。</p><p>我们再来想如果处理相同的。</p><p>我们发现，当好事的总天数一定的时候，前面有多少个、后面有多少个其实是不影响答案的，因为前面不管有多少个，其实都是一样的。</p><p>所以，我们可以统计 好事 - 坏事 的情况，然后对于每一个好事天数一定的，我们将一些好事的天放在坏事后面，就可以满足答案了。</p><p>答案将会乘上好事的天数减 1。</p><p>现在思路已经比较明显了：我们直接暴力枚举好事的天数 $x$，那么坏事的天数就是 $n-x$。</p><p>然后，我们发现，要将 $w$ 个好事放入 $x$ 天，每天至少一个，所以方案数就为 $\binom{w-1}{x-1}$。</p><p>坏事同理。</p><p>预处理组合数可以用 $O(n)$ 预处理阶乘及其逆元，不过没必要，直接 $O(n^2)$ 就可以了。</p><h2 id="3-Code"><a href="#3-Code" class="headerlink" title="3. Code"></a>3. Code</h2><p>注意要处理两倍的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; w &gt;&gt; b;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gday = <span class="number">1</span>; gday &lt; n; ++ gday)<span class="comment">//枚举好事的天数</span></span><br><span class="line">        ans = (ans + (gday - <span class="number">1ll</span>) * C[w - <span class="number">1</span>][gday - <span class="number">1</span>] % Mod * C[b - <span class="number">1</span>][n - gday - <span class="number">1</span>] % Mod) % Mod;</span><br><span class="line">    cout &lt;&lt; <span class="number">1ll</span> * ans * fact[w] % Mod * fact[b] % Mod &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> 数论 </tag>
            
            <tag> CF </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1335F</title>
      <link href="/2021/12/26/CF1335F/"/>
      <url>/2021/12/26/CF1335F/</url>
      
        <content type="html"><![CDATA[<p>基环树的简单题目。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><ul><li>给定一个 $n\times m$ 的黑白网格，每一个点都会有一个方向，如果放置的机器人走到这里的话，将会按照该方向走下去。现在要放置最多的机器人，使得机器人永远不会走到同一个点上（每一步中间相遇的不算）。在放置最多的基础上，要求最开始放在黑色上的机器人最多。</li><li>有 $t$ 组数据，$n\times m\leq10^6,\sum n\times m\leq10^6,t\leq5\times10^4$。</li></ul><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>其实如果想到图论的话，就比较简单了。</p><p>首先，我们考虑怎样才能 <strong>永远不相撞</strong>。</p><p>所有的机器人最后一定是在环上一直绕圈，又由于速度相同，所以永远不会相撞。</p><p>易得第一问答案不可能大于环上点的数量（因为如果有多的话，走到最后，一定会有两个机器人在同一个点，明显不符合条件）。</p><p>注意到每一个点有且只有一个出边，所以原图一共有 $n\times m$ 个点，同样也有 $n\times m$ 条边。</p><p>？这不就是基环树吗？</p><p>通过基环树的方法，我们可以简单的找出所有的环。不考虑第二问的话，我们直接将所有的机器人放在环上，这个就是一个最优解。</p><p>那么第一问就解决了，答案就是环的数量。</p><p>下面我们来看第二问：怎样让最多的机器人在黑色点上？</p><p>已经是黑色点的我们可以不管了，我们可以将一些白色的点替换为非环的黑点。</p><p>我们画一个图，来看一下需要满足什么样的条件才可以。</p><img src="/2021/12/26/CF1335F/CF1335F.png" class=""><p>当前，如果我们将一个机器人放在 b 点，经过两步之后，就会走到 c 点，如果最开始放在 a 点，也会走到 c 点。</p><p>所以其实 a 点和 b 点是等价的，换句话说，他们最后在环上的位置是等价的。</p><p>推广一下，对于任意一个点，假设他向上走走到环里需要的步数为 $x$，那么他就等价于环里距他最近的点往回走 $x$ 步得到的点。</p><p>转化为代码，就是：<code>cir[((dep - from) % sz + sz) % sz + 1]</code>，其中 $cir$ 存的是环的编号，从 1 开始，$sz$ 是指环的大小，$from$ 是指离他最近的点<strong>是环中的第几个。</strong></p><p>这几个都是可以在第二次遍历基环树的时候很简单的得到。具体可以看代码。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><p>注意由于有多组数据，不能使用 <code>memset</code> 之类的，而且读入的时候要直接转化为基环树上的编号。</p><p>码风略丑，请见谅。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> cir[N], tot, ed[N], cnt, fu[N];</span><br><span class="line"><span class="keyword">int</span> n, m, blk[N];</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">bool</span> ins[N], vis[N], onc[N], abl[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_c</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> from)</span><span class="comment">//找环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ins[x] = vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (i == (from ^ <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">fu[j] = x;</span><br><span class="line"><span class="keyword">if</span> (!vis[j]) <span class="built_in">dfs_c</span>(j, i);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ins[j])&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = x; k != j; k = fu[k]) cir[++ cnt] = k, onc[k] = <span class="literal">true</span>;</span><br><span class="line">cir[++ cnt] = j, onc[j] = <span class="literal">true</span>;</span><br><span class="line">ed[++ tot] = cnt;</span><br><span class="line"><span class="keyword">if</span> ((i &amp; <span class="number">1</span>)) <span class="built_in">reverse</span>(cir + ed[tot - <span class="number">1</span>] + <span class="number">1</span>, cir + ed[tot] + <span class="number">1</span>);</span><br><span class="line">&#125;<span class="comment">//注意此时如果 i &amp; 1 的话，找到的环和我们的环是相反的，我们要调换过来</span></span><br><span class="line">&#125;</span><br><span class="line">ins[x] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_d</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> cirst, <span class="keyword">int</span> dep, <span class="keyword">int</span> sz)</span><span class="comment">//cirst 表示环在 cir 数组里开始的位置，dep 是指当前的深度（我为了方便，加上了出发点的编号，方便直接计算，无需多余传参）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">abl[cirst + (dep % sz + sz) % sz] |= blk[x];</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[e[i]] || onc[e[i]]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs_d</span>(e[i], cirst, dep - <span class="number">1</span>, sz);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;<span class="keyword">return</span> (i - <span class="number">1</span>) * m + j;&#125;<span class="comment">//转换编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">idx = cnt = tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; ++ i) h[i] = <span class="number">-1</span>, blk[i] = onc[i] = abl[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) blk[<span class="built_in">get</span>(i, j)] = str[j] == <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (str[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span> : <span class="built_in">link</span>(<span class="built_in">get</span>(i, j), <span class="built_in">get</span>(i, j - <span class="number">1</span>));<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span> : <span class="built_in">link</span>(<span class="built_in">get</span>(i, j), <span class="built_in">get</span>(i, j + <span class="number">1</span>));<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span> : <span class="built_in">link</span>(<span class="built_in">get</span>(i, j), <span class="built_in">get</span>(i - <span class="number">1</span>, j));<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> : <span class="built_in">link</span>(<span class="built_in">get</span>(i, j), <span class="built_in">get</span>(i + <span class="number">1</span>, j));<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; ++ i) vis[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; ++ i)</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) <span class="built_in">dfs_c</span>(i, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; ++ i) vis[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = ed[i - <span class="number">1</span>] + <span class="number">1</span>; j &lt;= ed[i]; ++ j) <span class="built_in">dfs_d</span>(cir[j], ed[i - <span class="number">1</span>] + <span class="number">1</span>, j - ed[i - <span class="number">1</span>] - <span class="number">1</span>, ed[i] - ed[i - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> tblk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) tblk += abl[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, cnt, tblk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> CF </tag>
            
            <tag> 题解 </tag>
            
            <tag> 基环树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1175B</title>
      <link href="/2021/12/26/CF1175B/"/>
      <url>/2021/12/26/CF1175B/</url>
      
        <content type="html"><![CDATA[<p>简单的模拟。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p>给定一串语句，并有变量 $x$，初始为 $0$，仅含有一下三种类型：</p><ol><li><code>for n</code>：表示循环 $n$ 次，直到与之匹配的 <code>end</code>。</li><li><code>end</code>：表示循环结束。</li><li><code>add</code>：将 $x$ 加一。</li></ol><p>执行完后，如果 $x\geq2^{32}$，输出 <code>OVERFLOW!!!</code>，否则输出 $x$ 的值。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>$x$ 的值就是 <code>add</code> 的执行次数。</p><p>我们可以在记录一个变量 $mul$，表示当前的语句将会被执行多少次。</p><p>所以碰到 <code>add</code> 的时候，将当前的 $x$ 加上 $mul$ 即可。</p><p>注意，这道题 $mul$ 最大会达到 $100^{5000}$，所以注意我们如果 $mul\geq 2^{32}$，就可以直接赋值为 $2^{32}$。</p><p>但是，这里又有一个问题：$mul=2^{32}$ 之后，碰上 <code>end</code>，我们将要 $mul$ 除以当前的循环次数，明显就错误了。</p><p>处理方法也很简单：用一个栈记录所有的 <code>for n</code>，然后使用前缀积 $pre$ 维护，于是退栈的时候，我们直接将当前的 $mul$ 赋值为 $pre[top-1]$ 即可。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = (<span class="number">1ll</span> &lt;&lt; <span class="number">32</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n, top;</span><br><span class="line">ll x, stk[N], tmp, pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;OVERFLOW!!!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;a&#x27;</span>) x += pre[top];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;tmp);</span><br><span class="line">            stk[++ top] = tmp;</span><br><span class="line">            pre[top] = pre[top - <span class="number">1</span>] * tmp;</span><br><span class="line">            <span class="keyword">if</span> (pre[top]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>) top --;</span><br><span class="line">        <span class="keyword">if</span> (pre[top] &gt; INF) pre[top] = INF + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; INF) <span class="built_in">overflow</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CF </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF337C</title>
      <link href="/2021/12/26/CF337C/"/>
      <url>/2021/12/26/CF337C/</url>
      
        <content type="html"><![CDATA[<p>还是比较好想的，感觉难度应该在黄至绿之间。</p><span id="more"></span><p>话说这道题怎么没人做啊……</p><p>如果有没有考虑到的，请轻喷作者 qwq</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><ul><li>给出 $n$ 道题，答对了 $m$ 道题，按照规则安排 $m$ 道题的顺序，使得分数最小。输出对 $10^9+9$ 取模后的值。</li><li>从前向后扫描，答对一道分数加 $1$，计数器 $cnt$ 加一，如果 $cnt=k$，那么当前分数翻倍，$cnt$ 清零。如果答错 $cnt$ 清零。</li><li>$2\leq k\leq n\leq10^9,0\leq m\leq n$。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们首先考虑的肯定是尽量让 $m$ 道题目被翻倍的次数最少。</p><p>首先，一种情况是我们间隔开 $m$ 道题，使得每一道题都不会翻倍，那么答案就是 $m$。</p><p>具体就是 $k-1$ 道对，$1$ 道错，排列下去最后可以不需要 $1$ 道错误。</p><p>判断条件就是 $(n-m+1)\cdot(k-1)\geq m$。</p><p>第二种情况就是不得不要翻倍。</p><p>考虑第二个样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input:</span><br><span class="line">5 4 2</span><br><span class="line">output:</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>我们发现，不论怎么放错误的那个，一定都会有 $2$ 个会相连。（三个相连可以拆分为 $2+1$</p><p>那么，让相连的放在哪呢？</p><p>如果放在后面的话，一定会使答案变大，所以肯定放在最前面，让翻倍的尽量少。</p><p>所以，就可以构造成这样了：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ha2e8qfg.png"></p><p>注意到，前面会有 $n-(n-m)\cdot k$ 个连续的绿色。</p><p>按照这样计算即可.</p><p>假设前面有 $t$ 个连续的 $k$ 个绿色，前面的绿色的贡献就是 $k\cdot2^t+k\cdot2^{t-1}+…+k\cdot2$，注意最后未满 $k$ 个的由于没有特殊贡献，可以放到后面计算，为 $m-t\cdot k$。</p><p>前面的式子可以化简为 $k\cdot(2^{t+1}-2)$，快速幂即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"><span class="keyword">if</span> ((n - m + <span class="number">1</span>) * (k - <span class="number">1</span>) &gt;= m)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll t = (m - (n - m) * (k - <span class="number">1</span>)) / k;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (k * (<span class="built_in">qpow</span>(<span class="number">2</span>, t + <span class="number">1</span>) - <span class="number">2</span> + Mod) % Mod + m - k * t) % Mod);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CF </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5088</title>
      <link href="/2021/12/26/P5088/"/>
      <url>/2021/12/26/P5088/</url>
      
        <content type="html"><![CDATA[<p>杂题，没有什么说的。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><p><a href="https://www.luogu.com.cn/problem/P5088">原题面</a></p><p>抽象一下题意：</p><p>求 $k1,k2$，使得：<br>$$<br>k1\times N:k2\times M=A:B<br>$$<br>（先使 $\gcd(A,B)=1$</p><p>然后，题目要求的就是 $k1+k2-2$ 的最小值。</p><p>对应到原题意是什么呢？</p><p>我们假设有无穷多个这样的 $N\times M$ 的矩形，然后我们不反射，直接穿过，直到碰到交界的点为止。</p><img src="/2021/12/26/P5088/P5088.png" class=""><p>蓝线是原来的反射路径，但是我们可以通过一系列的翻折，使得路径变为绿线。</p><p>变为绿线，其实已经简洁了许多。</p><p>我们假设横向的有 $k1$ 个 $N$，纵向的有 $k2$ 个 $M$，那么最后 $\zeta$ 的对边是 $k2\times M$，邻边是 $k1\times N$。</p><p>于是，我们可以得到：<br>$$<br>\cot\zeta=\dfrac{k1\times N}{k2\times M}=\dfrac{A}{B}<br>$$<br>也就是上面的式子了。</p><p>至于反射了多少次，其实就是穿过边界了多少次。</p><p><del>大眼观察法</del>易得 $ans=k1+k2-2$。</p><p>问题转化为怎样求 $k1,k2$。</p><p>首先，可以得到一个解：$k1=A\times M,k2=B\times N$。</p><p>然后，我们可以同时除以一个数 $x$。</p><p>那么需要满足：$x|A\times M,x|B\times N$。（不然的话，$k1,k2$ 无法整除 $x$，就不是整数了）。</p><p>综上，我们其实就可以总结出这道题的答案了：<br>$$<br>ans=\dfrac{A\times M+B\times N}{\gcd(A\times M,B\times N)}<br>$$</p><h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h2><p>数据水了一点，没有卡掉 <code>long long</code>。</p><p>唯一注意的是 $A=0$ 或 $B=0$ 的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">read</span>(n, m, a, b);</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">0</span> || b == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>;</span><br><span class="line">ll g = <span class="built_in">Gcd</span>(a, b);</span><br><span class="line">a /= g, b /= g;</span><br><span class="line">ll x = <span class="built_in">Gcd</span>(a * m, b * n);</span><br><span class="line"><span class="built_in">write</span>(a * m / x + b * n / x - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4539</title>
      <link href="/2021/12/26/P4539/"/>
      <url>/2021/12/26/P4539/</url>
      
        <content type="html"><![CDATA[<p>一个区间 DP 的较为简单的题目。</p><span id="more"></span><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1. 题意"></a>1. 题意</h2><ul><li>要求构造一个大小为 $n$ 的二叉树，按照中序遍历标号为 $1\sim n$，然后给定每个编号的频率 $f_i$，并且给定常数 $k,c$ 为实数，请最小化（设根节点深度为 1）：</li></ul><p>$$<br>\sum_{i=1}^nf_i\times(k\times dep_i+c)<br>$$</p><ul><li>$n\leq30,\sum f_i=1,0&lt;k,c\leq100$</li></ul><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>其实可能很多同学<del>（其实就是我）</del>都会想到 <code>Huffman Tree</code>，它是基于一个贪心的想法，但是我们可以比较一下两个的式子。<br>$$<br>\sum_{i=1}^nf_i\times dep_i<br>$$</p><p>$$<br>\sum_{i=1}f_i\times(k\times dep_i+c)<br>$$</p><p>这两个其实是有一定区别的。</p><p>本题中，不同节点是一定会出现祖先关系，并且只有 $n$ 个节点。但是 <code>Huffman Tree</code> 却要求给定的 $n$ 个节点不能出现祖先关系，构造出来后，也会超过 $n$ 个节点。</p><p>那本题怎么做呢？</p><p>首先，我们可以发现一个性质：假设当前子树覆盖的区间为 $[l,r]$，根节点为 $t$，那么左边的子树覆盖的区间为 $[l,t-1]$，右边的子树为 $[t+1,r]$。</p><p>这就是一个典型的区间 DP 了。</p><p>当我们要计算 $dp(l,r)$ 的时候，我们直接枚举根节点 $t$，然后递归计算 $dp(l,t-1)$ 和 $dp(t+1,r)$，然后我们将左右子树直接接在 $t$ 这个节点上。</p><p>怎么计算贡献呢？其实很简单，我们左右的子树的深度都要加一，对于整个的贡献就是 $k\times (s(r)-s(l-1)-f(t))$，其中 $s(i)=\sum_{j=1}^if(j)$。</p><p>再加上 $t$ 的贡献，那么，我们就可以得到式子：<br>$$<br>dp(l,r)=\min_{t\in[l,r]}{dp(l,t-1)+dp(t+1,r)+k\times(s(r)-s(l-1))+c\times f(t) }<br>$$</p><p>时间复杂度为 $O(n^3)$，轻松通过。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><p>采用的递归式写法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) <span class="keyword">return</span> (k + c) * fru[l];</span><br><span class="line"><span class="keyword">double</span> &amp;v = f[l][r];</span><br><span class="line"><span class="keyword">if</span> (v &gt;= <span class="number">0</span>) <span class="keyword">return</span> v;</span><br><span class="line">v = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = l; mid &lt;= r; ++ mid)</span><br><span class="line">v = <span class="built_in">min</span>(v, <span class="built_in">solve</span>(l, mid - <span class="number">1</span>) + k * (s[r] - s[l - <span class="number">1</span>]) + c * fru[mid] + <span class="built_in">solve</span>(mid + <span class="number">1</span>, r));</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DP 及其优化 </tag>
            
            <tag> 题解 </tag>
            
            <tag> 区间 DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CSP-S 2021 复习】DP 总结</title>
      <link href="/2021/12/26/csp-s-2021-review-dp-summary/"/>
      <url>/2021/12/26/csp-s-2021-review-dp-summary/</url>
      
        <content type="html"><![CDATA[<p>CSP-S 2021 前写的。</p><span id="more"></span><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>这个是为了复习前面的提高组的知识，所以可能不会复习提高组之外的知识。</p><p>没有具体的大纲，<del>大纲又没有写清楚</del>，所以只能看着办吧。</p><blockquote><p>【8】 动态规划的 <strong>常用优化</strong></p></blockquote><p>这个是 DP 专题。</p><h2 id="1-大概内容"><a href="#1-大概内容" class="headerlink" title="1. 大概内容"></a>1. 大概内容</h2><ol><li><a href="https://www.luogu.com.cn/blog/mydcwfy-342891/bei-bao-wen-ti">背包问题的基础以及变式</a></li><li>状态自动机模型</li><li><a href="https://mydcwfy.github.io/2021/12/13/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9-DP/">状态压缩 DP</a></li><li><a href="https://www.luogu.com.cn/blog/mydcwfy-342891/qu-jian-dp">区间 DP</a></li><li><a href="https://mydcwfy.github.io/2021/12/13/%E6%A0%91%E5%BD%A2-DP/">树形 DP</a></li><li><a href="https://mydcwfy.github.io/2021/12/13/%E6%95%B0%E4%BD%8D-DP/">数位 DP</a></li><li>单调队列优化 DP</li><li>数据结构优化 DP</li><li>倍增优化 DP</li></ol><h2 id="2-每一个的分类以及大体思路"><a href="#2-每一个的分类以及大体思路" class="headerlink" title="2. 每一个的分类以及大体思路"></a>2. 每一个的分类以及大体思路</h2><h3 id="1）背包问题"><a href="#1）背包问题" class="headerlink" title="1）背包问题"></a>1）背包问题</h3><p>这个其实是比较简单的。（</p><p>看一下这个题：<a href="https://www.luogu.com.cn/problem/P5662">CSP-J 2019 T3</a></p><p>这个题当时我在考场上想了很久， 1h 后才发现有想法。</p><p>一个完全背包的好题。</p><p>其他题我就不推荐了。</p><p>关于代码，其实没有什么好说的，大概就是需要我们发现背包模型的问题。</p><p>比如发现 $n$ 个物品，以及有一定的取用的限制而不能全部取得的时候，可以考虑使用背包。</p><h3 id="2）状态自动机模型"><a href="#2）状态自动机模型" class="headerlink" title="2）状态自动机模型"></a>2）状态自动机模型</h3><p>这个大家可能有一点陌生，其实就是 $f[i][j]$ 表示 $i$ 天并且状态为 $j$ 的某种值。</p><p>推荐这个题：<a href="https://www.acwing.com/problem/content/1059/">AcWIng 1057 股票买卖 IV</a></p><p>分别用 0 表示为已卖出，1 表示手头有股票。</p><p>就可以比较简单的转移了.</p><p>DP 问题其实比较简洁，所以代码没有什么可以多说的。</p><p>当遇到明显是 DP 的时候，但是如果没有状态的话很难转移，那么就可以考虑加上状态一维了。</p><h3 id="3）状态压缩-DP"><a href="#3）状态压缩-DP" class="headerlink" title="3）状态压缩 DP"></a>3）状态压缩 DP</h3><p>这类题目其实有一个比较明显的特征：个数一般不会超过 15 个。</p><p>有以下两题型：</p><ol><li>棋盘式（即存下每一行的状态，然后行之间直接转移）</li><li>集合式（用二进制压缩每一个元素是否在集合内，按照这个转移）</li></ol><p>棋盘式的推荐题：<a href="https://www.luogu.com.cn/problem/P2704">NOI2001</a></p><p>集合式的推荐题：<a href="https://www.luogu.com.cn/problem/P2831">NOIP2016</a></p><p>这两个都非常经典，相信大家都做过。</p><p>NOI2001 的题目要压缩两行，然后按照行的方式来转移。</p><p>同时，这一个题目需要进行一些优化，比如提前存下来一行内合法的状态。</p><p>空间上，需要使用滚动数组实现。</p><p>NOIP2016 的题目是一个重复覆盖问题，当然需要一点的计算几何。</p><p>这里介绍状态压缩的解法。</p><p>需要存下来猪被覆盖的集合，然后每一只小鸟分别转移。</p><p>DLX 的解法就不介绍了。</p><p>这类题首先注意范围，然后还要注意二进制运算的特殊性，可以优化代码难度及常数。</p><h3 id="4）区间-DP"><a href="#4）区间-DP" class="headerlink" title="4）区间 DP"></a>4）区间 DP</h3><p>区间 DP 的题目的数据范围一般还是比较小，但是比状态压缩大一些，一般在 30~100 之间，时间复杂度为 $O(n^3)\sim O(n^5)$，而且一般跑不满。</p><p>区间 DP 分为两种打法，分别是迭代法和递归法。</p><p>迭代法就是一堆 <code>for</code>，而递归法就是 <code>void dp(int x)&#123;...dp(i)...&#125;</code> 之类的。</p><p>这里大概有一维线性，一维环形，二维等几种情况。</p><p>这个就是注意边界问题，还有就是迭代式一定要第一维循环 <code>len</code>，第二维循环头结点，这样才能保证当前状态所用到的状态都是计算过的。</p><h3 id="5）树形-DP"><a href="#5）树形-DP" class="headerlink" title="5）树形 DP"></a>5）树形 DP</h3><p>这一类 DP 大多都是 $O(n)$ 的算法，可能有一些 $O(n\log n)$ 的东西（比如对子树得到的答案排序之类的）。</p><p>这类题目一般都比较麻烦，比如要进行数学推导，将求的东西转化为子树和父节点的信息可以分开维护，然后简单合并。</p><p>还有，这种题还需要换根技巧，就是将父亲的答案也合并进入儿子的答案，将儿子作为根。</p><p>题目不好找，就这样了吧。</p><p>大概有一个这个题：<a href="https://www.luogu.com.cn/problem/P5666">CSP-S2019 T6</a></p><p>（因为我还没做，所以后面在更新</p><h3 id="6）数位-DP"><a href="#6）数位-DP" class="headerlink" title="6）数位 DP"></a>6）数位 DP</h3><p>这种题目其实都有一定的套路，认真看了我的代码的同学应该都有印象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="comment">/*0 / 1*/</span>;</span><br><span class="line">    vector &lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">while</span> (n) nums.<span class="built_in">push_back</span>(n % <span class="number">10</span>), n /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; ~i; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> &amp;x = nums[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x; ++ j) <span class="comment">/*do with j*/</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这样一个套路，也没有多么难。</p><p>推荐一个题：<a href="https://loj.ac/p/10168">LOJ 10168 恨 7 不成妻</a></p><h3 id="7）各种优化"><a href="#7）各种优化" class="headerlink" title="7）各种优化"></a>7）各种优化</h3><p>核心思想就是 <strong>排除无用状态</strong>。</p><h4 id="a-单调队列"><a href="#a-单调队列" class="headerlink" title="a. 单调队列"></a>a. 单调队列</h4><p>这个就是一个简单的道理：如果 a 比 b 差，但是 a 会比 b 先弹出决策选择区（就是 a 可选的时候 b 都可以选），那么 a 就永远没有用。</p><p>比如说这个题：<a href="https://www.luogu.com.cn/problem/P5665">CSP-S2019 T5</a></p><p>这个题就是一个典型的单调队列优化 DP <del>（外带卡时空</del></p><p>这个的转移方程大概是这样：<br>$$<br>f_i=\max_{suf_j\leq s_i-s_j}(f_j+(s_i-s_j)^2)<br>$$</p><p>$$<br>suf_i=s_i-s_j<br>$$</p><p>其中，$suf_i$ 中用到的 $j$ 是 $f_i$ 转移用到的 $j$，表示最后一段的长度。</p><p>首先，很明显 $j$ 越靠后答案一定更优，因为最后一段越小，肯定限制就越小，分的段数就越多，答案就越小。</p><p>但是，转移的条件是 $suf_j+s_j\leq s_i$。</p><p>所以如果 $suf_j+s_j\geq suf_k+s_k$ 并且 $j&lt;k$，那么 $j$ 就没有用了。</p><p>代码大概就长这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt; tt &amp;&amp; a[q[hh + <span class="number">1</span>]] + suf[q[hh + <span class="number">1</span>]] &lt;= a[i])<span class="comment">//breakpoint</span></span><br><span class="line">        hh ++;</span><br><span class="line">    f[i] = f[q[hh]] + (B)(a[i] - a[q[hh]]) * (a[i] - a[q[hh]]);</span><br><span class="line">    suf[i] = a[i] - a[q[hh]];</span><br><span class="line">    <span class="keyword">while</span> (hh &lt; tt &amp;&amp; a[q[tt]] + suf[q[tt]] &gt; a[i] + suf[i]) tt --;</span><br><span class="line">    q[++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>breakpoint</code> 所代表的意思，就是要找到最后一个满足 $suf_j+s_j\leq s_i$ （往后越优）。</p><h4 id="b-数据结构优化"><a href="#b-数据结构优化" class="headerlink" title="b. 数据结构优化"></a>b. 数据结构优化</h4><p>这个最简单的应用就是这个：</p><blockquote><p>给出 $n$ 点的位置 $(x_i,y_i)$，每一个点只能向右上方（包含边界）连有向边，求最长的路径。</p></blockquote><p>这个首先离散化，不是重点，跳过了。</p><p>然后按照 $x$ 的位置倒序枚举，然后对于一个点 $(x_i,y_i)$，前面枚举到的点都 $x_j\geq x_i$，所以我们要在枚举过的点中找到 $y_j\leq y_i$ 中 $f_j$ 的最大值。</p><p>这个可以使用线段树维护，以 $y$ 坐标作为 <code>build(1, 1, n)</code> 的，维护 $f_i$ 的最大值，询问时直接 <code>query(1, y[j], n)</code> 就可以了。</p><h4 id="c-倍增优化"><a href="#c-倍增优化" class="headerlink" title="c. 倍增优化"></a>c. 倍增优化</h4><p>这个是一个经典的问题：<a href="https://www.luogu.com.cn/problem/P1081">NOIP2012 提高组</a></p><p>（虽然经典，可我还是没有过</p><p>所以略过了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> DP 及其优化 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>费用流</title>
      <link href="/2021/12/26/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
      <url>/2021/12/26/%E8%B4%B9%E7%94%A8%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>比较重要并且难想，需要多加练习。</p><span id="more"></span><h2 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>费用流是指所有最大可行流中，费用最小（最大）值。</p><p>前提是最大可行流。</p><p>给每条边幅赋一个费用，则总费用为：</p><p>$$w(f)= \sum f(u,v)\times p(u,v)$$</p><p>如果有最大可行流的话，一定有最小费用最大流。</p><p>因为可行流满足两个条件：</p><ol><li><p>满足容量限制；</p></li><li><p>满足容量守恒。</p></li></ol><p>但是有一些最小费用无法求出来。</p><p>如图，该费用流无法用后面的方法求出来。</p><img src="/2021/12/26/%E8%B4%B9%E7%94%A8%E6%B5%81/%E8%B4%B9%E7%94%A8%E6%B5%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%8D%E4%BE%8B.png" class="" title="如图"><h3 id="2-求法"><a href="#2-求法" class="headerlink" title="2.求法"></a>2.求法</h3><p>Edmonds-Karp 算法为基础。</p><p>将 bfs 换为 spfa，这样每一次都是最短路（即最小代价）。</p><h4 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h4><p>假设当前的 f1 是最小费用，经过一次 spfa 后，得到 f2，新的为 f</p><p>假设 f 不是最小费用，设 f’ 是最小费用，经过 f2‘ 得到。</p><p>那么 $|f’|=|f|$。</p><p>因为都由 f1 扩展而来，可得 $|f2’|=|f2|$</p><p>又$w(f)=|f|*s(f)$，可得 $s(f2’)&lt;s(f2)$，与最短路矛盾。</p><p>所以原命题成立。</p><p>如果原图有负权回路，那么 spfa 会陷入死循环。</p><p>要用到”消圈”的方法，这里不过多赘述。</p><p><a href="https://blog.sengxian.com/algorithms/clearcircle">消圈</a></p><p>建图时，将费用改为$p(u,v)=-p(v,u)$。</p><p>一般情况下，只要原图不存在负环，那么残留网络也不会。</p><p>（因为流量不会绕圈，所以反向边也不会成环）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,ll c,ll d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=d,f[idx]=c,h[a]=idx++;</span><br><span class="line">e[idx]=a,ne[idx]=h[b],w[idx]=-d,f[idx]=<span class="number">0</span>,h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) vis[i]=<span class="number">0</span>,d[i]=INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">q.<span class="built_in">push</span>(S);d[S]=<span class="number">0</span>;flow[S]=INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (f[i]&amp;&amp;(d[e[i]]&gt;d[x]+w[i]))</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+w[i];</span><br><span class="line">pre[e[i]]=i;</span><br><span class="line">flow[e[i]]=<span class="built_in">min</span>(flow[x],f[i]);</span><br><span class="line"><span class="keyword">if</span> (!vis[e[i]]) q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">vis[e[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[T]!=INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">spfa</span>())</span><br><span class="line">&#123;</span><br><span class="line">ll flowd=flow[T];</span><br><span class="line">maxflow+=flowd;mincost+=flowd*d[T];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">f[pre[i]]-=flowd;</span><br><span class="line">f[pre[i]^<span class="number">1</span>]+=flowd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-做题方式"><a href="#3-做题方式" class="headerlink" title="3.做题方式"></a>3.做题方式</h3><p>与最大流相似，都是先将原问题转化为一个网络流，然后证明解是一一对应的，最后证明原答案与新图的答案是相关的。</p><h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4.例题"></a>4.例题</h3><h4 id="T1"><a href="#T1" class="headerlink" title="T1:"></a>T1:</h4><p><a href="https://www.luogu.com.cn/problem/P4015">Luogu P4015 运输问题</a></p><p>先建立一个流网络，从源点到仓库建立 $a(i),0$ 的边，从零售店到汇点建立 $b(i),0$  的边，从仓库到零售店建立 $+\infty,c(i,j)$ 的边。</p><p>易得，最大流一定是满流（因为中间都是 $+\infty$）。</p><p>证明略，比较容易。</p><p>又因为，只有从仓库到零售店的流才会花费，所以最小费用就是原问题的费用。</p><p>注意最小最大费用流都要求。</p><p>我用传参的方式防止了代码过长。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,M=<span class="number">4e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],f[M],idx;</span><br><span class="line"><span class="keyword">int</span> pre[N],d[N],flow[N],c,maxflow;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=d,f[idx]=c,h[a]=idx++;</span><br><span class="line">e[idx]=a,ne[idx]=h[b],w[idx]=-d,f[idx]=<span class="number">0</span>,h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (op) <span class="keyword">return</span> a&lt;b;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+m+<span class="number">1</span>;++i) vis[i]=<span class="number">0</span>,d[i]=(op==<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>)*INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">q.<span class="built_in">push</span>(S);d[S]=<span class="number">0</span>;flow[S]=INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x]=<span class="number">0</span>;<span class="comment">//cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (f[i]&amp;&amp;<span class="built_in">cmp</span>(d[e[i]],d[x]+w[i],op))</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+w[i];</span><br><span class="line">pre[e[i]]=i;</span><br><span class="line">flow[e[i]]=<span class="built_in">min</span>(flow[x],f[i]);</span><br><span class="line"><span class="keyword">if</span> (!vis[e[i]]) q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">vis[e[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[T]!=(op==<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>)*INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initing</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i+=<span class="number">2</span>) f[i]+=f[i^<span class="number">1</span>],f[i^<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">(<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">c=maxflow=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">initing</span>();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">spfa</span>(op))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> flowd=flow[T];</span><br><span class="line">maxflow+=flowd;c+=flowd*d[T];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">f[pre[i]]-=flowd;</span><br><span class="line">f[pre[i]^<span class="number">1</span>]+=flowd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">int</span> x;S=<span class="number">0</span>,T=m+n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="built_in">add</span>(S,i,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="built_in">add</span>(i+n,T,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="built_in">add</span>(i,j+n,INF,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EK</span>(<span class="number">0</span>);cout&lt;&lt;c&lt;&lt;endl;</span><br><span class="line"><span class="built_in">EK</span>(<span class="number">1</span>);cout&lt;&lt;c&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2"><a href="#T2" class="headerlink" title="T2:"></a>T2:</h4><p><a href="https://www.luogu.com.cn/problem/P4016">Luogu P4016 负载平衡问题</a></p><p>可以发现，如果一个站比平均值多，他就要输出，否则就要输入。</p><p>可以将货物看为流量，将站分为2个部分，但是不是所有边都是连接两部的，也有一部之间的。</p><p>最小费用最大流即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>,M=<span class="number">1e4</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],f[M],idx;</span><br><span class="line"><span class="keyword">int</span> pre[N],d[N],flow[N];</span><br><span class="line"><span class="keyword">int</span> n,S,T,maxflow,mincost,a[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=d,f[idx]=c,h[a]=idx++;</span><br><span class="line">e[idx]=a,ne[idx]=h[b],w[idx]=-d,f[idx]=<span class="number">0</span>,h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i) vis[i]=<span class="number">0</span>,d[i]=INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">q.<span class="built_in">push</span>(S);d[S]=<span class="number">0</span>;flow[S]=INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (f[i]&amp;&amp;(d[e[i]]&gt;d[x]+w[i]))</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+w[i];</span><br><span class="line">pre[e[i]]=i;</span><br><span class="line">flow[e[i]]=<span class="built_in">min</span>(flow[x],f[i]);</span><br><span class="line"><span class="keyword">if</span> (!vis[e[i]]) q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">vis[e[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[T]!=INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">spfa</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> flowd=flow[T];</span><br><span class="line">maxflow+=flowd;mincost+=flowd*d[T];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">f[pre[i]]-=flowd;</span><br><span class="line">f[pre[i]^<span class="number">1</span>]+=flowd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;S=<span class="number">0</span>,T=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) sum+=a[i];</span><br><span class="line">sum/=n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">if</span> (sum&gt;a[i]) <span class="built_in">add</span>(i,T,sum-a[i],<span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">add</span>(S,i,a[i]-sum,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">add</span>(i,i+<span class="number">1</span>,INF,<span class="number">1</span>);<span class="built_in">add</span>(i+<span class="number">1</span>,i,INF,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>,n,INF,<span class="number">1</span>);<span class="built_in">add</span>(n,<span class="number">1</span>,INF,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">EK</span>();cout&lt;&lt;mincost&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3"><a href="#T3" class="headerlink" title="T3:"></a>T3:</h4><p><a href="https://www.luogu.com.cn/problem/P4014">Luogu P4014 分配问题</a></p><p>和第一题类似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>,M=<span class="number">4e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],f[M],idx;</span><br><span class="line"><span class="keyword">int</span> pre[N],d[N],flow[N],c,maxflow,S,T;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=d,f[idx]=c,h[a]=idx++;</span><br><span class="line">e[idx]=a,ne[idx]=h[b],w[idx]=-d,f[idx]=<span class="number">0</span>,h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (op) <span class="keyword">return</span> a&lt;b;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+n+<span class="number">1</span>;++i) vis[i]=<span class="number">0</span>,d[i]=(op==<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>)*INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">q.<span class="built_in">push</span>(S);d[S]=<span class="number">0</span>;flow[S]=INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x]=<span class="number">0</span>;<span class="comment">//cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (f[i]&amp;&amp;<span class="built_in">cmp</span>(d[e[i]],d[x]+w[i],op))</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+w[i];</span><br><span class="line">pre[e[i]]=i;</span><br><span class="line">flow[e[i]]=<span class="built_in">min</span>(flow[x],f[i]);</span><br><span class="line"><span class="keyword">if</span> (!vis[e[i]]) q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">vis[e[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[T]!=(op==<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>)*INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initing</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i+=<span class="number">2</span>) f[i]+=f[i^<span class="number">1</span>],f[i^<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">(<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">initing</span>();</span><br><span class="line">c=maxflow=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">initing</span>();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">spfa</span>(op))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> flowd=flow[T];</span><br><span class="line">maxflow+=flowd;c+=flowd*d[T];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">f[pre[i]]-=flowd;</span><br><span class="line">f[pre[i]^<span class="number">1</span>]+=flowd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> x;S=<span class="number">0</span>,T=<span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="built_in">add</span>(i,n+j,<span class="number">1</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">add</span>(S,i,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j) <span class="built_in">add</span>(j+n,T,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">EK</span>(<span class="number">0</span>);cout&lt;&lt;c&lt;&lt;endl;</span><br><span class="line"><span class="built_in">EK</span>(<span class="number">1</span>);cout&lt;&lt;c&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T4"><a href="#T4" class="headerlink" title="T4:"></a>T4:</h4><p><a href="https://www.luogu.com.cn/problem/P4013">P4013 数字梯形问题</a></p><p>只是要拆点。</p><p>同样的建图，只不过这道题比较麻烦，需要处理3个问。</p><p>主要讲一下 3 个问题的衔接。</p><p>第一个转到第二个时，我们将所有点内的边都设为 $+\infty$</p><p>第二个转到第三个时，我们将所有点间的点再都设为 $+\infty$</p><p>但是由于每个出发点只能有一次出发，所以不能更新。</p><p>看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(i,j) (m+m+i-2)*(i-1)/2+j</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>,M=<span class="number">5e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],f[M],idx;</span><br><span class="line"><span class="keyword">int</span> pre[N],d[N],flow[N];</span><br><span class="line"><span class="keyword">int</span> n,m,S,T,maxflow,maxcost,a[N][N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=d,f[idx]=c,h[a]=idx++;</span><br><span class="line">e[idx]=a,ne[idx]=h[b],w[idx]=-d,f[idx]=<span class="number">0</span>,h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i) vis[i]=<span class="number">0</span>,d[i]=-INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">q.<span class="built_in">push</span>(S);d[S]=<span class="number">0</span>;flow[S]=INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (f[i]&amp;&amp;(d[e[i]]&lt;d[x]+w[i]))</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+w[i];</span><br><span class="line">pre[e[i]]=i;</span><br><span class="line">flow[e[i]]=<span class="built_in">min</span>(flow[x],f[i]);</span><br><span class="line"><span class="keyword">if</span> (!vis[e[i]]) q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">vis[e[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[T]!=-INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">maxflow=maxcost=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">spfa</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> flowd=flow[T];</span><br><span class="line">maxflow+=flowd;maxcost+=flowd*d[T];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">f[pre[i]]-=flowd;</span><br><span class="line">f[pre[i]^<span class="number">1</span>]+=flowd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;m&gt;&gt;n;<span class="keyword">int</span> tot=(m+n<span class="number">-1</span>+m)*n/<span class="number">2</span>,idx1,idx2,idx0;</span><br><span class="line">S=<span class="number">0</span>,T=<span class="number">2</span>*tot+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) <span class="built_in">add</span>(S,<span class="built_in">get</span>(<span class="number">1</span>,j),<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">idx0=idx;<span class="comment">//开始的边 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m+n<span class="number">-1</span>;++j) <span class="built_in">add</span>(<span class="built_in">get</span>(n,j)+tot,T,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m+i;++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m+i;++j) <span class="built_in">add</span>(<span class="built_in">get</span>(i,j),<span class="built_in">get</span>(i,j)+tot,<span class="number">1</span>,a[i][j]);</span><br><span class="line">idx1=idx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m+i;++j)</span><br><span class="line"><span class="built_in">add</span>(<span class="built_in">get</span>(i,j)+tot,<span class="built_in">get</span>(i+<span class="number">1</span>,j),<span class="number">1</span>,<span class="number">0</span>),<span class="built_in">add</span>(<span class="built_in">get</span>(i,j)+tot,<span class="built_in">get</span>(i+<span class="number">1</span>,j+<span class="number">1</span>),<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">idx2=idx;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EK</span>();cout&lt;&lt;maxcost&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i+=<span class="number">2</span>) f[i]+=f[i^<span class="number">1</span>],f[i^<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//初始化 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=idx0;i&lt;idx1;i+=<span class="number">2</span>) f[i]=INF;<span class="comment">//点内的边设为INF </span></span><br><span class="line"><span class="built_in">EK</span>();cout&lt;&lt;maxcost&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i+=<span class="number">2</span>) f[i]+=f[i^<span class="number">1</span>],f[i^<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=idx1;i&lt;idx2;i+=<span class="number">2</span>) f[i]=INF;<span class="comment">//点间的边设为INF </span></span><br><span class="line"><span class="built_in">EK</span>();cout&lt;&lt;maxcost&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T5-餐巾计划问题"><a href="#T5-餐巾计划问题" class="headerlink" title="T5:餐巾计划问题"></a>T5:餐巾计划问题</h4><p><a href="https://www.luogu.com.cn/problem/P1251">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2186/">题目传送门 AcWing</a></p><p>对于每一天，干净毛巾的毛巾只可能来自 3 种情况：</p><ol><li><p>新买的</p></li><li><p>快洗部</p></li><li><p>慢洗部</p></li></ol><p>脏的毛巾也只可能来自3种情况：</p><ol><li><p>留到下一天</p></li><li><p>送到慢洗部</p></li><li><p>送到快洗部</p></li></ol><p>我们可以将每天用完的旧毛巾看做点，将每天要用的新毛巾看做另外的点</p><p>新毛巾就可以从 $s$ 到该点，费用为 $p$</p><p>每天都要从该点流 $r(i)$ 到汇点，相当于用了 $r(i)$</p><p>快洗与慢洗就相应连到相应相应早上的点。</p><p>从 $s$ 到晚上的点流量为 $r(i)$，相当于得到 $r(i)$ 条旧毛巾。</p><p>从早上的点到汇点一定是满流，否则就会使货不应求。</p><p>但源点开始的点可以不用满流（可以浪费）。</p><p>并且，前一天的脏毛巾可以留到下一天。</p><p>综上，建图如下（设早上点为$a(i)$，晚上点为 $b(i)$）：</p><ol><li><p>$add(s,b(i),r(i),0)$</p></li><li><p>$add(a(i),t,r(i),0)$</p></li><li><p>$add(b(i),b(i+1),+\infty,0)$</p></li><li><p>$add(s,a(i),+\infty,p)$</p></li><li><p>$add(b(i),a(i+n),+\infty,s)$</p></li><li><p>$add(b(i),a(i+m),+\infty,f)$</p></li></ol><p>注意，$s$ 与 $t$ 只是形式上的源汇点，没有什么实际意义，它象征着整个网络流的正常运作，而与本问题无关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>,INF=<span class="number">0x7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],f[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> pre[N],n,S,T,flow[N],d[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">ll mincost;</span><br><span class="line"></span><br><span class="line">queue &lt;<span class="keyword">int</span>&gt; q; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],f[idx]=c,w[idx]=d,h[a]=idx++;</span><br><span class="line">e[idx]=a,ne[idx]=h[b],f[idx]=<span class="number">0</span>,w[idx]=-d,h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>*n+<span class="number">1</span>;++i) d[i]=INF,vis[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">q.<span class="built_in">push</span>(S);d[S]=<span class="number">0</span>;flow[S]=INF;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (f[i]&amp;&amp;d[e[i]]&gt;d[x]+w[i])</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+w[i];</span><br><span class="line">pre[e[i]]=i;flow[e[i]]=<span class="built_in">min</span>(flow[x],f[i]);</span><br><span class="line"><span class="keyword">if</span> (!vis[e[i]]) q.<span class="built_in">push</span>(e[i]),vis[e[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[T]!=INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">spfa</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ff=flow[T];</span><br><span class="line">mincost+=(ll)ff*d[T];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">f[pre[i]]-=ff;</span><br><span class="line">f[pre[i]^<span class="number">1</span>]+=ff;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,e;</span><br><span class="line">S=<span class="number">0</span>,T=<span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"><span class="built_in">add</span>(i,T,a,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">add</span>(S,i+n,a,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">add</span>(S,i,INF,a);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i+<span class="number">1</span>&lt;=n) <span class="built_in">add</span>(i+n,i+n+<span class="number">1</span>,INF,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (i+b&lt;=n) <span class="built_in">add</span>(i+n,i+b,INF,c);</span><br><span class="line"><span class="keyword">if</span> (i+d&lt;=n) <span class="built_in">add</span>(i+n,i+d,INF,e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EK</span>();</span><br><span class="line">cout&lt;&lt;mincost&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分约束</title>
      <link href="/2021/12/26/Difference-constraint/"/>
      <url>/2021/12/26/Difference-constraint/</url>
      
        <content type="html"><![CDATA[<p>比较重要的知识点。</p><span id="more"></span><p><strong>应用1：求不等式的可行解</strong></p><p><strong>应用2：求最大值或最小值</strong></p><h3 id="1-定义与应用场景"><a href="#1-定义与应用场景" class="headerlink" title="1. 定义与应用场景"></a>1. 定义与应用场景</h3><p>形如<br>$$<br>x(i)\leq x(j) +c(i,j)<br>$$<br>的形式的不等式组，即可用差分约束。</p><p>这类题目大概要求我们要 <strong>数形结合</strong>，可能是最好的解释了。</p><hr><h3 id="2-应用-1"><a href="#2-应用-1" class="headerlink" title="2. 应用 1"></a>2. 应用 1</h3><h3 id="建图方式"><a href="#建图方式" class="headerlink" title="建图方式"></a>建图方式</h3><p>由于最短路一定是最短路<del>（废话</del>，那么每一条边的转移一定是有效的，如果出现了 $dis(i)&gt;dis(j)+w(j,i)$，那么 $dis(i)$ 就不是最短路了。</p><p>所以我们可以得到最短路的三角形不等式：$dis(i)\le dis(j)+w(j,i)$</p><p>对于$x(i)\leq x(j) +c(j,i)$，我们可以从 $j$ 到 $i$ 连一条 $c(j,i)$ 的边。</p><p>但是这里没有源点，我们可以随意找一个点。</p><p><del>真的可以吗</del></p><p>其实是不完全可以的。</p><p>如果从源点到不了所有的边，那么这个点不可行。</p><p>注意，不是遍历到所有的点，因为可能有孤立的点，与主体无关。</p><p>好像一般是不会出现不联通的边吧……</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>先将每一个不等式 $x(i)\leq x(j) +c(j,i)$ 转换成从 $j$ 到 $i$ 连一条 $c(j,i)$ 的边。</p></li><li><p>找一个源点，使它能到每一条边。</p></li><li><p>从这个点找单源最短路。</p></li></ol><p> 有一个问题：有负环是什么情况？</p><p>易得，从一个环到自己且是负的话，就是 $x_i\leq x_j+c(j,i)\leq x_k+c(k,j)+c(j,i)\leq…\leq x_i+c(j,i)+c(k,j)+… $</p><p>又 $c(j,i)+c(k,j)+…&lt;0$，所以就是 $x_i\leq x_i+k$，其中 $k&lt;0$，显然是不可能的。 </p><p>同样，如果原不等式组无解，那么图有负环。（否则一定能构造出一组解）</p><p>如果有解，这一组解就是 $x(i)=dis(i)$。当然，可以加同样的值，原不等式依然成立。</p><p>另外，我们也可用最长路。</p><p>改为 $x(j)\geq x(i)-c(i,j)$ 的方式，并将从 $i$ 到 $j$ 连一条 $-c(i,j)$ 的边。</p><p>我们就反过来了，如果有正环，那么无解了。</p><hr><h3 id="3-应用2"><a href="#3-应用2" class="headerlink" title="3.应用2"></a>3.应用2</h3><p><strong>结论：如果是最小值，那么求最长路；如果是最大值，那么求最短路。</strong></p><p>首先，通过前面的转化，我们发现，对于同一个题，我们既可以构造最长路，也可以构造最短路。</p><p>虽然有些反直觉，为什么是正确的呢？</p><p>假设我们讨论最长路。</p><p>因为最长路，有一个式子 $x(i)\geq x(j)+w(j,i)$，那么一定会有一个 $j$，满足 $x(i)=x(j)+w(j,i)$（否则 $x(i)$ 从何处来？），那么就不会存在小于 $x(i)$ 的解，因为 $x(i)\geq x(j)+w(i,j)$，所以 $x(i)$ 就是所有解答最小值。</p><p>问题1：如何转化 $x(i)\leq c(i)$？</p><p>建立一个超级源点 $x(0)$，从 $0$ 到 $i$ 的建立$c(i)$ 的边。</p><p>以 $x(i)$ 的最大值为例，从 $x(i)$ 出发的不等式链，可以转化为一个只含变量 $x(0)$ 的值。</p><p>所有上界的最小值，即为 $x(i)$ 的最大值。</p><p>我们又可以发现一个有趣的性质：</p><p><strong>每一个不等式链，都是 $0$ 到 $i$ 的一条路径。</strong></p><p>然后，这些上界的最小值，其实就是最短路！</p><p>反过来，求最小值的话，应该求最长路。</p><p>这个就不再赘述。</p><hr><h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4.例题"></a>4.例题</h3><h4 id="T1"><a href="#T1" class="headerlink" title="T1:"></a>T1:</h4><p><a href="https://www.luogu.com.cn/problem/P3275">Luogu P3275 [SCOI2011]糖果</a></p><ol><li><p>$A=B \Leftrightarrow A\geq B,B\geq A$</p></li><li><p>$A&lt;B \Leftrightarrow B\geq A+1$</p></li><li><p>$A\leq B \Leftrightarrow B\geq A$</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>,M=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> d[N],h[N],e[M],ne[M],w[M],cnt[N],n,m,S,idx;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0xcf</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">stack &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(S);d[S]=<span class="number">0</span>;cnt[S]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (d[e[i]]&lt;d[x]+w[i])</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+w[i];</span><br><span class="line">cnt[e[i]]=cnt[x]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (cnt[e[i]]&gt;n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!vis[e[i]]) vis[e[i]]=<span class="number">1</span>,q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">int</span> a,b,op;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span>(op)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:<span class="built_in">add</span>(b,a,<span class="number">0</span>),<span class="built_in">add</span>(a,b,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:<span class="built_in">add</span>(a,b,<span class="number">1</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:<span class="built_in">add</span>(b,a,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:<span class="built_in">add</span>(b,a,<span class="number">1</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:<span class="built_in">add</span>(a,b,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">S=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">SPFA</span>()) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans+=(<span class="keyword">long</span> <span class="keyword">long</span>)d[i];</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2"><a href="#T2" class="headerlink" title="T2:"></a>T2:</h4><p><a href="https://www.acwing.com/problem/content/364/">AcWing 362.区间</a></p><p><strong>差分约束最难的地方就在于找不等关系。</strong></p><p>利用前缀和的思想：</p><ol><li><p>$S(0)=0$</p></li><li><p>$S(i)$ 表示$1$ 到 $i$ 中，选出数的个数。</p></li><li><p>$0\leq S(i)-S(i-1) \leq 1 \Leftrightarrow S(i)\geq S(i-1),S(i-1)\geq S(i)-1$ </p></li><li><p>$S(b)-S(a-1)\geq c$ </p></li></ol><p>可以发现，$0$ 可以遍历到所有点，也可以遍历到所有边。</p><p>那么这样就可以完成对每个点的遍历了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50010</span>,M=<span class="number">150050</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx,w[M];</span><br><span class="line"><span class="keyword">int</span> n,d[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0xcf</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">stack &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">0</span>);d[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (d[e[i]]&lt;d[x]+w[i])</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+w[i];</span><br><span class="line"><span class="keyword">if</span> (!vis[e[i]]) vis[e[i]]=<span class="number">1</span>,q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">int</span> a,b,c,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">a++;b++;ans=<span class="built_in">max</span>(ans,b);</span><br><span class="line"><span class="built_in">add</span>(a<span class="number">-1</span>,b,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;++i) <span class="built_in">add</span>(i<span class="number">-1</span>,i,<span class="number">0</span>),<span class="built_in">add</span>(i,i<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">SPFA</span>();</span><br><span class="line">cout&lt;&lt;d[ans]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3"><a href="#T3" class="headerlink" title="T3:"></a>T3:</h4><p><a href="https://www.acwing.com/problem/content/395/">AcWing 393. 雇佣收银员</a></p><p>特别拿出来讲的目的是其 实现较难。</p><ol><li>$0\leq x(i) \leq num(i)$</li><li>$x(i-7)+x(i-6)+…+x(i-1)+x(i)\geq r(i)$</li></ol><p>不满足形式，用前缀和优化：</p><ol><li><p>$0 \leq s(i)-s(i-1)\leq num(i)$</p></li><li><p>$i\geq 8 \Leftrightarrow s(i)-s(i-8)\geq r(i)$ </p></li><li><p>$0\leq i \leq 7\Leftrightarrow s(i)+s(24)-s(i+16)\geq r(i)$</p></li></ol><p>最后一项有 $3$ 个变量，所以要消元（<del>回到了数学课</del>）。</p><p>消哪个呢？</p><p>看到 $s(24)$ 比较好欺负，又看到时间是允许我们枚举的。</p><p>那么枚举 $s(24)$ 的取值，然后分别跑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">3e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> d[N],cnt[N],num[<span class="number">26</span>],r[<span class="number">26</span>],n,st[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> s24)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);idx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">24</span>;++i) <span class="built_in">add</span>(i<span class="number">-1</span>,i,<span class="number">0</span>),<span class="built_in">add</span>(i,i<span class="number">-1</span>,-num[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;++i) <span class="built_in">add</span>(i+<span class="number">16</span>,i,-s24+r[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">8</span>;i&lt;=<span class="number">24</span>;++i) <span class="built_in">add</span>(i<span class="number">-8</span>,i,r[i]);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">0</span>,<span class="number">24</span>,s24);<span class="built_in">add</span>(<span class="number">24</span>,<span class="number">0</span>,-s24);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s24)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">build</span>(s24);</span><br><span class="line"><span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0xcf</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i) vis[i]=<span class="number">0</span>;</span><br><span class="line">d[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">queue &lt;<span class="keyword">int</span>&gt; q;q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (d[e[i]]&lt;d[x]+w[i])</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+w[i];</span><br><span class="line">cnt[e[i]]=cnt[x]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (cnt[e[i]]&gt;=<span class="number">25</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!vis[e[i]]) vis[e[i]]=<span class="number">1</span>,q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">24</span>;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,r+i);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,st+i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) num[st[i]+<span class="number">1</span>]++;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">SPFA</span>(i))</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 差分约束 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小割</title>
      <link href="/2021/12/26/Min-cut/"/>
      <url>/2021/12/26/Min-cut/</url>
      
        <content type="html"><![CDATA[<p><strong>update：2021-04-13 21:49 根据<a href="https://www.luogu.com.cn/user/185726">RuSun</a>的建议，更改了解题步骤</strong></p><p><strong>请确保你知道网络流、最大流、最小割</strong></p><span id="more"></span><p><a href="https://mydcwfy.github.io/2021/12/26/Network-flow/">我的博客</a></p><p>鉴于最小割模型不宜想到，且变化多端，特出此笔记</p><h2 id="1-应用"><a href="#1-应用" class="headerlink" title="1.应用"></a>1.应用</h2><p>最小割常用来求最小代价，以及最大收益（满足一定条件才能获得）</p><p>最小割的复杂度与最大流相同，为$O(n^2m)$</p><p>由于模板没有可考察的，所以难点一般在建图上。</p><h2 id="2-模型"><a href="#2-模型" class="headerlink" title="2.模型"></a>2.模型</h2><h3 id="0）-前言"><a href="#0）-前言" class="headerlink" title="0） 前言"></a>0） 前言</h3><p>最小割求的是最小代价，即不选某条边的代价</p><p>满流表示的是割断该条边，并支付该代价</p><p>未满流的边，一般视为0</p><p>最小割求的是边的割，如果是点的代价，则使用拆点法</p><p>对于不能割断的边，将其流量设为 $+\infty$</p><h3 id="1）-最小代价型"><a href="#1）-最小代价型" class="headerlink" title="1） 最小代价型"></a>1） 最小代价型</h3><h4 id="T1："><a href="#T1：" class="headerlink" title="T1："></a>T1：</h4><p><a href="https://www.luogu.com.cn/problem/P1345">P1345 [USACO5.4]奶牛的电信Telecowmunication</a></p><p>这是一道典型的 01 最小代价问题，从入点到出点都是1的代价。</p><p>将每个点拆为入点和出点，之间的代价为1</p><p>每条边的代价为 $+\infty$，即不能割断。</p><p>不贴代码了，自己建图最大流就可以了。</p><h4 id="T2："><a href="#T2：" class="headerlink" title="T2："></a>T2：</h4><p><a href="https://www.luogu.com.cn/problem/P3866">P3866 [TJOI2009]战争游戏</a></p><p>这是一道多代价问题，不只是 1 的代价</p><p>同样要用到拆点法，入点与出点的连边为轰炸该点的炸药数，</p><p>注意，如果是本身是障碍物的话，相当于轰炸为0代价，在网络流中可以直接掠过。</p><p>从敌军位置向起点连边，从边界向汇点连边，就可以了。</p><h3 id="2）-最大收益类"><a href="#2）-最大收益类" class="headerlink" title="2） 最大收益类"></a>2） 最大收益类</h3><p>其实最大收益类都可以转化为最小代价类。</p><p>为什么单独拿出来说呢？因为很多时候，看不出来是最小割。</p><p>看几道题理解一下。</p><h4 id="T1：-1"><a href="#T1：-1" class="headerlink" title="T1："></a>T1：</h4><p><a href="https://www.luogu.com.cn/problem/P2774">P2774 方格取数问题</a></p><p>很多同学看到“最大和”，迫不及待地要用最大流。</p><p>但这道题，如果是最大流的话，会使图的规模增长一个数量级，并且杂乱无章。</p><p>（<del>所以讲一下还是有必要的</del>）</p><p>我们考虑应该不要哪些点。</p><p>回归割的定义，任意一条从 s 到 t 的路径，必有一条是割边。</p><p>我们将有关联的点全部连在一起，再将这些点分别接到源汇点上，会发现，任意一条边，要么左边满流（取其代价），要么右边满流</p><p>进一步观察题目，挖掘性质，我们可以发现，可将原图分为两部，相邻的点在不同部。</p><p>我们就可以发现，再将两部的点分别连到源汇点，就满足了上面的性质！</p><p>这样建图就可以了，用最大流跑。</p><h4 id="T2：-1"><a href="#T2：-1" class="headerlink" title="T2："></a>T2：</h4><p><a href="https://www.luogu.com.cn/problem/P2762">P2762 太空飞行计划问题</a></p><p>输出里直接说到“最大利润”，所以是最大收益的题目。</p><p>我们考虑哪些实验不要，以及需要支付的费用。</p><p>先将每个实验与源点连边，接着与需要的配置连边$+\infty$，然后把配置与汇点连边。</p><p>挖掘性质：任意一条从 s 到 t 的路径，都会经过一个实验和配置。</p><p>要么实验满流（既不选），要么配置满流（即支付该费用）。</p><p>满足原问题的性质。</p><h4 id="T3："><a href="#T3：" class="headerlink" title="T3："></a>T3：</h4><p><a href="https://www.luogu.com.cn/problem/P4177">P4177 [CEOI2008]order</a></p><p>这道题与上道题类似，只不过多了一个租的环节。</p><p>分析上一题，发现相当于是租的费用为 $+\infty$，这道题，改为对应代价即可。</p><p>每一部分，要么不选工作，要么对应边满流（即租），要么买。</p><h4 id="T4："><a href="#T4：" class="headerlink" title="T4："></a>T4：</h4><p><a href="https://www.luogu.com.cn/problem/P3872">P3872 [TJOI2010]电影迷</a></p><p>这道题提到，$-1000 \leq v(x) \leq 1000$，即可能为负。</p><p>我们可以把负点看做是代价，并将联系正负的分别与源汇点连边。</p><p>注意，负点不是收益，而是代价，该点没有满流代表不选该点</p><p>可以发现，要么正的满流（即不看），要么中间断开（即支付不看的代价），要么从负点断开（即支付看他的代价）。</p><p>详细证明参见 <a href="https://www.luogu.com.cn/blog/Feliks-GMYB/solution-p3872">这篇博客</a></p><h4 id="T5："><a href="#T5：" class="headerlink" title="T5："></a>T5：</h4><p><a href="https://www.luogu.com.cn/problem/P4313">P4313 文理分科</a></p><p>这是最能体现最小割通法的题目了。</p><p>按照先前的思路，就会发现牵扯过多，而不好建图。</p><p>这时我们采取的策略是：<br><strong>先将所有的利益加进来，在将不能共存的状态连边（或者一定的费用），将连边的端点分别以一定代价连边源汇点。</strong><br>按照这个思路，几乎可以秒杀该题。</p><p>将所有利益加起来，然后将 $same_art$ 与几个 $science$ 连边，$same_science$ 同理。</p><p>将带 $art$ 的与源点连边，其余的与汇点连边，用总收益减最小割即可。</p><h3 id="3）-总结"><a href="#3）-总结" class="headerlink" title="3） 总结"></a>3） 总结</h3><p>我们可以用最小割解决问题，都用上面的策略建图即可。</p><h2 id="3-解题步骤"><a href="#3-解题步骤" class="headerlink" title="3. 解题步骤"></a>3. 解题步骤</h2><ol><li><p>判断是不是最小割问题。</p></li><li><p>判断是不是最大收益类，如果是，先将收益加起来。</p></li><li><p>如果是最大收益类，就将不能共存的点连接起来。</p></li><li><p>如果是最小代价类，就将两点必须有至少其一的点连接起来。</p></li><li><p>跑最小割即可。</p></li></ol><h4 id="注意：这两类一般只能处理二分图的形式的题，除了一些明显的最小割问题"><a href="#注意：这两类一般只能处理二分图的形式的题，除了一些明显的最小割问题" class="headerlink" title="注意：这两类一般只能处理二分图的形式的题，除了一些明显的最小割问题"></a>注意：这两类一般只能处理二分图的形式的题，除了一些明显的最小割问题</h4><p>没有总结到的，请在评论区提出，我会按时回复。</p><p>希望对你有所帮助。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tarjan 算法</title>
      <link href="/2021/12/26/Tarjan-algorithm/"/>
      <url>/2021/12/26/Tarjan-algorithm/</url>
      
        <content type="html"><![CDATA[<p>比较重要的图论，tg 中考得比较多。</p><span id="more"></span><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><ol><li><p>连通分量：可以互相到达的点集</p></li><li><p>强连通分量：极大的连通分量（即不可扩展的）</p></li><li><p>常见应用：缩点，可将有向图变为有向无环图（ DAG ），无向图变为树 / 森林。</p></li></ol><hr><h2 id="2-求强连通分量（-SCC-）：-DFS-Tarjan"><a href="#2-求强连通分量（-SCC-）：-DFS-Tarjan" class="headerlink" title="2. 求强连通分量（ SCC ）： DFS+Tarjan"></a>2. 求强连通分量（ SCC ）： DFS+Tarjan</h2><p><strong>注意，下面的定义是属于有向图的，无向图等一下再讨论！</strong></p><h3 id="1-DFS-的特殊定义"><a href="#1-DFS-的特殊定义" class="headerlink" title="1) DFS 的特殊定义"></a>1) DFS 的特殊定义</h3><p>边可分为4类：</p><ol><li>树枝边：搜索时所经历的边（树枝边构成树）</li><li>前向边：祖先指向儿子</li><li>后向边：儿子指向祖先</li><li>横叉边：不属于上面3种的边 （ <del>大雾</del> ）</li></ol><img src="/2021/12/26/Tarjan-algorithm/Tarjan1.png" class=""><p>（黑色为树边，蓝色为前向边，红色为橫叉边，绿色为后向边）</p><h3 id="2-哪些边有用？"><a href="#2-哪些边有用？" class="headerlink" title="2) 哪些边有用？"></a>2) 哪些边有用？</h3><ol><li><p>后向边：祖先先到儿子，儿子回到了祖先（一定是）</p></li><li><p>横叉边：点先到另外点，在有横叉边的话可能回到了祖先</p></li></ol><h3 id="3-Tarjan-算法"><a href="#3-Tarjan-算法" class="headerlink" title="3) Tarjan 算法"></a>3) Tarjan 算法</h3><h4 id="a-又是定义（-雾-）"><a href="#a-又是定义（-雾-）" class="headerlink" title="a. 又是定义（ 雾 ）"></a>a. 又是定义（ <del>雾</del> ）</h4><ol><li><p>时间戳（ dfn ）：遍历到 u 的时间点</p></li><li><p>low ：以 u 为根的子树，只走一条边能到达的 dfn 的最小值</p></li><li><p>u 是一个强连通分量 dfn 的最小值，等价于 $dfn(u) = low(u)$</p></li></ol><img src="/2021/12/26/Tarjan-algorithm/Tarjan2.png" class=""><h4 id="b-算法流程"><a href="#b-算法流程" class="headerlink" title="b. 算法流程"></a>b. 算法流程</h4><ol><li><p>保存一个栈，是搜到的点</p></li><li><p>搜索所有相邻的点，如果未搜过，就递归搜索，如果搜过（即不是树枝边），就有 $low(u)=\min (dfn(v),low(u))$</p></li><li><p>如果 $dfn(u) = low(u)$，将栈里的点一一取出，合并为一个 SCC，直到取出自己</p></li><li><p>复杂度 $O(m+n)$</p></li></ol><h4 id="c-证明：略（过于复杂）"><a href="#c-证明：略（过于复杂）" class="headerlink" title="c.证明：略（过于复杂）"></a>c.证明：略（过于复杂）</h4><h2 id="3-后续事务"><a href="#3-后续事务" class="headerlink" title="3. 后续事务"></a>3. 后续事务</h2><h3 id="1-缩点"><a href="#1-缩点" class="headerlink" title="1) 缩点"></a>1) 缩点</h3><p>遍历每一条原图中的边，如果端点不在同一分量中，就将该两个 SCC 连起来</p><h3 id="2）-在-DAG-上拓扑排序"><a href="#2）-在-DAG-上拓扑排序" class="headerlink" title="2） 在 DAG 上拓扑排序"></a>2） 在 DAG 上拓扑排序</h3><p>其实可以不用，因为 SCC 的顺序就是拓扑序的倒序</p><h4 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h4><p>拓扑序的第一个，一定会在搜的时候搜到其他的强连通分量，并在该 SCC 前就已经结束，第一个一定是最后搜到的 SCC</p><h2 id="4-Code"><a href="#4-Code" class="headerlink" title="4. Code"></a>4. Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[x]=low[x]=++tot;</span><br><span class="line">st[++top]=x, ins[x]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">    <span class="keyword">if</span> (!dfn[e[i]])</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">Tarjan</span>(e[i]);</span><br><span class="line">low[x]=<span class="built_in">min</span>(low[x],low[e[i]]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ins[e[i]]) low[x] = <span class="built_in">min</span>(low[x], dfn[e[i]]);</span><br><span class="line"><span class="keyword">if</span> (low[x]!=dfn[x]) <span class="keyword">return</span>;</span><br><span class="line">cnt++;<span class="keyword">int</span> now;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">now=st[top--];</span><br><span class="line">ins[now]=<span class="literal">false</span>;<span class="comment">// 出栈 </span></span><br><span class="line">bel[now]=cnt;</span><br><span class="line">&#125;<span class="keyword">while</span> (now!=x);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suodian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;++x)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (bel[x]!=bel[e[i]]) <span class="built_in">add</span>(h2, bel[x], bel[e[i]]);</span><br><span class="line">n=cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-无向图"><a href="#5-无向图" class="headerlink" title="5. 无向图"></a>5. 无向图</h2><p>既和有向图类似，有和有向图有区别。</p><p>首先，边的分类只有 3 种：树边，前向边，后向边。</p><p>为什么没有横叉边呢？其实原因很简单，首先，横叉边是指不同子树之间的边。试想，如果有横叉边的话，当我们走到先遍历的点 $u$ 时，另一个子树还没有遍历，那 $u$ 一定会走到 $v$，让横叉边变为了树边了。</p><p>注意，这个代码还应该传一个 $fa$,，防止又走回 $fa$ 而导致死循环了。</p><p>代码（找不到了……</p><h2 id="6-点双联通分量与边双连通分量"><a href="#6-点双联通分量与边双连通分量" class="headerlink" title="6. 点双联通分量与边双连通分量"></a>6. 点双联通分量与边双连通分量</h2><p>这两个有区别，一般用于无向图。</p><h3 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h3><ol><li>点双连通分量：不存在割点，也就是任意去掉一个点，原图仍然联通。</li><li>边双连通分量：不存在桥，也就是任意去掉一条边，原图仍然联通。</li></ol><p>还要区分的是，点双连通分量与边双连通分量是互不包含的，这个有些书上可能是讲错了。</p><h3 id="2）判定"><a href="#2）判定" class="headerlink" title="2）判定"></a>2）判定</h3><ol><li>割点：存在一个点 $v$，使得 $dfn(u)\leq low(v)$（dfs 树的根节点需要两个 $v$），那么 $u$ 是割点。</li><li>桥：存在一条边 $e(u,v)$，使得 $dfn(u)&lt;low(v)$，那么 $e(u,v)$ 是桥。</li></ol><p>注意两个的判定区别。</p><h3 id="3）简要证明"><a href="#3）简要证明" class="headerlink" title="3）简要证明"></a>3）简要证明</h3><ol><li>割点：因为 $v$ 所在的子树不可能到达 $u$ 以上的节点了，所以每一个节点向上遍历的话都要经过 $u$，所以 $u$ 删去后会使原图不联通。但如果是根节点的话，没有向上的点了，所以需要多一个 $v$，那么删去根节点后就不联通了。</li><li>桥：$v$ 所在的子树不可能到达 $u$ 及以上的节点了，所以删去 $e(u,v)$ 会使 $v$ 的子树与其他不联通， $e(u,v)$ 就是桥了。</li></ol><img src="/2021/12/26/Tarjan-algorithm/Tarjan3.png" class=""><p>左边的图中，红色的边下面的点 $low(x)=dfn(x)$，$low(x)&lt;dfn(x.fa)$，那么红边就是桥，但 $low(y)=dfn(z)\not&lt;dfn(z)$，所以蓝边 $e(y,z)$ 不是桥。在右边的图中，$x$ 下面的点 $v$ 一定满足 $low(v)\geq dfn(x)$，所以 $x$ 就是割点。而 $y$ 下面的点会有 $low(x)=dfn(root)&lt;dfn(y)$，所以 $y$ 就不是割点。</p><h3 id="4）缩点"><a href="#4）缩点" class="headerlink" title="4）缩点"></a>4）缩点</h3><h4 id="a-边双连通分量"><a href="#a-边双连通分量" class="headerlink" title="a. 边双连通分量"></a>a. 边双连通分量</h4><p>这个要简单一些，所以先讲（？</p><p>根据定义，不存在桥的子图就是边联通图，而极大的边联通图就是边双连通分量。</p><p>（其实和前面的 Tarjan 差不多）<del>（废话，前面的无向图 Tarjan 就是边双连通分量）</del></p><img src="/2021/12/26/Tarjan-algorithm/Tarjan4.png" class=""><h4 id="b-点双连通分量"><a href="#b-点双连通分量" class="headerlink" title="b. 点双连通分量"></a>b. 点双连通分量</h4><p>这个其实要难一些 <del>很多</del></p><p>首先，我们将所有的割点处理出来。</p><p>如果我们得到 $dfn(u)\leq low(v)$，我们就将当前栈内的所有点一直弹出，直到弹出的点为 $u$，将所有弹出的点都加入一个新的点双连通分量，然后还要将 $u$ 入栈。</p><p>如果要缩为一个新图的话，我们还要注意：每一个割点都是一个新图中的点，然后每一个点双连通分量也是新图中的一个点，连接就是割点向有它的点双连通分量连边。原图最后变为了一棵树（森林）。</p><p>缩完点后，就可以树形 DP 了。</p><img src="/2021/12/26/Tarjan-algorithm/Tarjan5.png" class=""><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h1[N], h2[N], e[M], ne[M], w[M], idx;<span class="comment">//h1 是原图，h2 是新图</span></span><br><span class="line"><span class="keyword">int</span> low[N], dfn[N], tot, stk[N], top, cnt;</span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; dcc[N];<span class="comment">//存每一个点双连通分量的原图编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *h, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">low[x] = dfn[x] = ++ tot, stk[++ top] = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == (from ^ <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (!dfn[e[i]])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(e[i], i);</span><br><span class="line"><span class="keyword">if</span> (low[e[i]] &lt;= dfn[x])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> now;cnt ++;</span><br><span class="line"><span class="keyword">while</span> (stk[top] != x)</span><br><span class="line">&#123;</span><br><span class="line">now = stk[top --];</span><br><span class="line">dcc[cnt].<span class="built_in">push_back</span>(now);</span><br><span class="line">&#125;</span><br><span class="line">dcc[cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="built_in">add</span>(h2, x, cnt + n);</span><br><span class="line">&#125;</span><br><span class="line">low[x] = <span class="built_in">min</span>(low[x], low[e[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> low[x] = <span class="built_in">min</span>(low[x], dfn[e[i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-例题"><a href="#7-例题" class="headerlink" title="7. 例题"></a>7. 例题</h2><h3 id="T1：-Luogu-P2341-受欢迎的牛"><a href="#T1：-Luogu-P2341-受欢迎的牛" class="headerlink" title="T1： Luogu P2341 受欢迎的牛"></a>T1： Luogu P2341 受欢迎的牛</h3><p><a href="https://www.luogu.com.cn/problem/P2341">题目传送门</a></p><p>如果是一个 DAG 的话，直接是出度为 0 的点就是答案</p><p>但是，如果有多个点的话，那么哪个点都不是。</p><p>考虑 Tarjan，缩点后出度为 0 的点的大小就是了。</p><p>Code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>,M=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> st[N],top,dfn[N],low[N],bel[N],cnt,tot,dout[N],din[N],n,m,s[N];</span><br><span class="line"><span class="keyword">bool</span> ins[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[x]=low[x]=++tot;</span><br><span class="line">st[++top]=x, ins[x]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">    <span class="keyword">if</span> (!dfn[e[i]])</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">Tarjan</span>(e[i]);</span><br><span class="line">low[x]=<span class="built_in">min</span>(low[x],low[e[i]]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ins[e[i]]) low[x] = <span class="built_in">min</span>(low[x], dfn[e[i]]);</span><br><span class="line"><span class="keyword">if</span> (low[x]!=dfn[x]) <span class="keyword">return</span>;</span><br><span class="line">cnt++;<span class="keyword">int</span> now;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">now=st[top--];</span><br><span class="line">ins[now]=<span class="number">0</span>; </span><br><span class="line">bel[now]=cnt;</span><br><span class="line">s[cnt]++;</span><br><span class="line">&#125;<span class="keyword">while</span> (now!=x);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">add</span>(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">if</span> (!dfn[i]) <span class="built_in">Tarjan</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;++x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (bel[x]!=bel[e[i]])</span><br><span class="line">&#123;</span><br><span class="line">dout[bel[x]]++;</span><br><span class="line">din[bel[e[i]]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!dout[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">b=s[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T2：-AcWing-367-学校网络-Luogu-P2812-校园网络（加强版）"><a href="#T2：-AcWing-367-学校网络-Luogu-P2812-校园网络（加强版）" class="headerlink" title="T2： AcWing 367 学校网络 / Luogu P2812 校园网络（加强版）"></a>T2： AcWing 367 学校网络 / Luogu P2812 校园网络（加强版）</h3><p><a href="https://www.acwing.com/problem/content/369/">题目传送门_AcWing</a></p><p><a href="https://www.luogu.com.cn/problem/P2812">题目传送门_Luogu</a></p><p>对于第一问，缩点后，入度点的个数即为答案（这些点必须得到，得到后，所有也都会得到）</p><p>对于第二问，设入度为0的点有 $P$ 个，出度为0的点有 $Q$ 个，则答案为<br>$$ans=\max (P,Q)$$</p><p>证明有很多有些问题，这篇博客证明了（我也不知道有没有问题 <del>雾</del> ）</p><p><a href="https://blog.csdn.net/jiangshibiao/article/details/21191737">证明</a></p><p>Code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>,M=<span class="number">5e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> st[N],top,dfn[N],low[N],bel[N],cnt,tot,dout[N],din[N],n;</span><br><span class="line"><span class="keyword">bool</span> ins[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[x]=low[x]=++tot;</span><br><span class="line">st[++top]=x, ins[x]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">    <span class="keyword">if</span> (!dfn[e[i]])</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">Tarjan</span>(e[i]);</span><br><span class="line">low[x]=<span class="built_in">min</span>(low[x],low[e[i]]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ins[e[i]]) low[x] = <span class="built_in">min</span>(low[x], dfn[e[i]]);</span><br><span class="line"><span class="keyword">if</span> (low[x]!=dfn[x]) <span class="keyword">return</span>;</span><br><span class="line">cnt++;<span class="keyword">int</span> now;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">now=st[top--];</span><br><span class="line">ins[now]=<span class="number">0</span>; </span><br><span class="line">bel[now]=cnt;</span><br><span class="line">&#125;<span class="keyword">while</span> (now!=x);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (cin&gt;&gt;x,x) <span class="built_in">add</span>(i,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">if</span> (!dfn[i]) <span class="built_in">Tarjan</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;++x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (bel[x]!=bel[e[i]])</span><br><span class="line">&#123;</span><br><span class="line">dout[bel[x]]++;</span><br><span class="line">din[bel[e[i]]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!dout[i]) a++;</span><br><span class="line"><span class="keyword">if</span> (!din[i]) b++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;b&lt;&lt;endl;<span class="comment">//入度为0的点</span></span><br><span class="line"><span class="keyword">if</span> (cnt==<span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="built_in">max</span>(a,b)&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Tarjan </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3768</title>
      <link href="/2021/12/26/P3768/"/>
      <url>/2021/12/26/P3768/</url>
      
        <content type="html"><![CDATA[<p><del>没人写 Dinic ，我就来一篇吧</del></p><span id="more"></span><h3 id="1-题意"><a href="#1-题意" class="headerlink" title="1.题意"></a>1.题意</h3><p>对于每一个行星，要么选该行，要么选该列。</p><p>是不是有点熟悉？</p><h3 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h3><p>没错，他就是二分图最小点覆盖。</p><p>我的算法是将二分图转化为网络流，再跑一遍最小割。</p><p>即将左边的点与 $s$ 连接，右边的点与 $t$ 连接，权值均为1（代价为1）。<br>中间的边，权值 $+\infty$ （这样就不会成为割边了）。</p><p><strong>证明：割与点覆盖一一对应</strong></p><p>对于每一个割，左边与源点如果满流，则选取；右边同理。</p><p>由于是割， $s$ 到 $t$ 不经过满流的点，就无法到达（否则又有了增广路）。</p><p>所以所有的边都被覆盖了，否则 $s$ 可以到 $t$，与割的定义矛盾。</p><p>对于每一个点覆盖，左边与源点连边满流；右边同理。</p><p>这时，由于中间的边都被覆盖了，$s$ 无法到 $t$。 </p><p>所以这就是一个割。</p><p><strong>证毕</strong></p><p>又由最小割最大流定理可得：最小割=最大流。</p><p>那么，直接 Dinic 就可以了。</p><p>不懂网络流的同学，请移步<br><a href="https://mydcwfy.github.io/2021/12/26/Network-flow/#more">我的博客</a> 或百度 <del>逃</del></p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 20000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e8</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx,S,T;</span><br><span class="line"><span class="keyword">int</span> cur[N],q[N],d[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">e[idx]=a,ne[idx]=h[b],w[idx]=<span class="number">0</span>,h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c=<span class="built_in">getchar</span>()));</span><br><span class="line">res=c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(c=<span class="built_in">getchar</span>())) res=(res&lt;&lt;<span class="number">1</span>)+(res&lt;&lt;<span class="number">3</span>)+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">int</span> hh=<span class="number">1</span>,tt=<span class="number">1</span>;</span><br><span class="line">q[<span class="number">1</span>]=S;cur[S]=h[S];d[S]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (hh&lt;=tt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q[hh++];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (!d[e[i]]&amp;&amp;w[i])</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+<span class="number">1</span>;</span><br><span class="line">cur[e[i]]=h[e[i]];</span><br><span class="line"><span class="keyword">if</span> (e[i]==T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[++tt]=e[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findflow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x==T) <span class="keyword">return</span> limit;</span><br><span class="line"><span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=cur[x];~i&amp;&amp;flow&lt;limit;i=ne[i])</span><br><span class="line">&#123;</span><br><span class="line">cur[x]=i;</span><br><span class="line"><span class="keyword">if</span> (d[e[i]]==d[x]+<span class="number">1</span>&amp;&amp;w[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">findflow</span>(e[i],<span class="built_in">min</span>(w[i],limit-flow));</span><br><span class="line"><span class="keyword">if</span> (!t) d[e[i]]=<span class="number">-1</span>;</span><br><span class="line">w[i]-=t,w[i^<span class="number">1</span>]+=t,flow+=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=<span class="number">0</span>,flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">bfs</span>()) <span class="keyword">while</span> (flow=<span class="built_in">findflow</span>(S,INF)) r+=flow;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">S=<span class="number">0</span>,T=<span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">read</span>(a);<span class="built_in">read</span>(b);</span><br><span class="line"><span class="built_in">add</span>(a,b+n,INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">add</span>(S,i,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">add</span>(i+n,T,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">dinic</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4897</title>
      <link href="/2021/12/26/P4897/"/>
      <url>/2021/12/26/P4897/</url>
      
        <content type="html"><![CDATA[<p><strong>看大家都是倍增，我换一个简单点的方法吧。</strong></p><span id="more"></span><p><del>一开始还以为是最小割的模板呢</del></p><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1.题意"></a>1.题意</h2><p><a href="http://luogu.org/problem/P4897">题目传送门</a></p><ol><li>每次询问$u$到$v$的最小割。</li><li>有$Q$个询问，点数、边数分别为$n$、$m$。</li><li>$Q \leq 10^5,n \leq 500,m \leq 1500$。</li></ol><h2 id="2-知识储备"><a href="#2-知识储备" class="headerlink" title="2.知识储备"></a>2.知识储备</h2><p>网络流 + 最大流</p><p>最大流最小割定理</p><p>不会请移步<br><a href="https://mydcwfy.github.io/2021/12/26/Network-flow/#more">我的博客</a> 或者百度</p><h2 id="3-最小割树"><a href="#3-最小割树" class="headerlink" title="3.最小割树"></a>3.最小割树</h2><p>很明显，不可能每次求最小割（复杂度为 $O(Qn^2m)$）。</p><p>我们将一个网络流的图转化为一棵树，其中原图 $u$ 到 $v$ 的最小割即为转化到树上。</p><p>树的一个性质是：删除一条边，树变得不连通。</p><p>那么，我们可以任意选 2 个点 $s$ 与 $t$，跑最小割（即最大流），然后再连一条从 $s$ 到 $t$ 的边。</p><p>又 Dinic 算法最后一次 bfs 相当于求一个最小割，原图就被分为了两部分。</p><p>最后分治就可以了，复杂度为 $O(n^3m)$（Dinic 跑不满的，所以不会超时）。</p><p>按这样建出的树，就是一棵无根树。</p><p>我们可以发现一个有趣的性质：$u$ 到 $v$ 的最小割就是树上从 $u$ 到 $v$ 的所有路径长的最小值。</p><p>可以感性地理解一下（ <del>主要是太菜不会证</del> ）：最小割即为最小的路径长，把 $u$ 到 $v$ 的任意一条路径切断，都是割。</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>每次跑 Dinic 时，都要对全图进行，否则就不是最大流<br>（$u$ 到 $v$ 的最大流就是针对全局的）。</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//node存放要处理的节点，l与r分别是左右端点</span></span><br><span class="line"><span class="keyword">if</span> (l==r) <span class="keyword">return</span> ;</span><br><span class="line">S=node[l],T=node[l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">dinic</span>();</span><br><span class="line">ans[T][S]=ans[S][T]=t;<span class="comment">//or add(S,T,t),add(T,S,t)</span></span><br><span class="line"><span class="keyword">int</span> cnt1=<span class="number">0</span>,cnt2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=l;i&lt;=r;++i)</span><br><span class="line"><span class="keyword">if</span> (d[node[i]]) tmp1[++cnt1]=node[i];</span><br><span class="line"><span class="keyword">else</span> tmp2[++cnt2]=node[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt1;++i) node[i+l<span class="number">-1</span>]=tmp1[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt2;++i) node[cnt1+l+i<span class="number">-1</span>]=tmp2[i];</span><br><span class="line"><span class="built_in">work</span>(l,l+cnt1<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">work</span>(l+cnt1,r);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-处理询问"><a href="#4-处理询问" class="headerlink" title="4.处理询问"></a>4.处理询问</h2><p>由于询问数很多（ $Q \leq 10^5$ ），很多 dalao 选择了树上倍增的做法，复杂度为 $O(Q \log n)$。</p><p>鉴于本人对倍增不太熟练，我换了一种方式。</p><p>观察题目数据范围，发现 $n$ 较小，而 $Q$ 较大，所以使用预处理的方式，先将答案处理好。</p><p>复杂度为 $O(n^2)$。</p><p>我们甚至不用建树（心中有“树”即可），在每一个 work(l,r) 函数中直接统计从 $s$ 所在集合 $S$ 到 $t$ 所在集合 $T$ 的答案。</p><p>当前 $S$ 与 $T$ 集合的连接只有 $s$ 与 $t$（其他的都在集合内部）。</p><p>则 $\forall u \in S,v \in T$，都有：<br>$$ans(u,v)=\min (ans(u,s),ans(s,t),ans(t,v))$$</p><p>同时，由于正向与反向都相同，所以不要忘记处理反向。</p><p>最后每个询问，输出答案即可。</p><p>代码实现时，注意以下几个细节：</p><ol><li><p>每一次最大流时，都要先恢复开始的网络流（即退流）。</p></li><li><p>插入网络流的边时，要双向插入（题目没有指明哪个是起点）。</p></li><li><p>下标从 0 开始到 $n$。</p></li><li><p>每一次最大流时，先保存源点和汇点，防止被覆盖（如果 $s$ 与 $t$ 使用全局变量）（ <del>卡了一个多小时我才发现</del> ）。</p></li></ol><p>其余细节看代码吧。</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">505</span>,M=<span class="number">6005</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">//M要开4倍，因为正反各要2条边</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> cur[N],q[N],d[N],S,T,n,m;</span><br><span class="line"><span class="keyword">int</span> node[N],ans[N][N],tmp1[N],tmp2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">e[idx]=a,ne[idx]=h[b],w[idx]=<span class="number">0</span>,h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">int</span> hh=<span class="number">1</span>,tt=<span class="number">1</span>;</span><br><span class="line">q[<span class="number">1</span>]=S;cur[S]=h[S];d[S]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (hh&lt;=tt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q[hh++];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (!d[e[i]]&amp;&amp;w[i])</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+<span class="number">1</span>;</span><br><span class="line">cur[e[i]]=h[e[i]];</span><br><span class="line"><span class="keyword">if</span> (e[i]==T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[++tt]=e[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findflow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x==T) <span class="keyword">return</span> limit;</span><br><span class="line"><span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=cur[x];~i&amp;&amp;flow&lt;limit;i=ne[i])</span><br><span class="line">&#123;</span><br><span class="line">cur[x]=i;</span><br><span class="line"><span class="keyword">if</span> (d[e[i]]==d[x]+<span class="number">1</span>&amp;&amp;w[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">findflow</span>(e[i],<span class="built_in">min</span>(w[i],limit-flow));</span><br><span class="line"><span class="keyword">if</span> (!t) d[e[i]]=<span class="number">-1</span>;</span><br><span class="line">w[i]-=t,w[i^<span class="number">1</span>]+=t,flow+=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;i+=<span class="number">2</span>)</span><br><span class="line">w[i]=(w[i]+w[i^<span class="number">1</span>]),w[i^<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="comment">//注意退流的方式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">int</span> r=<span class="number">0</span>,flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">bfs</span>()) <span class="keyword">while</span> (flow=<span class="built_in">findflow</span>(S,INF)) r+=flow;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;<span class="comment">//Dinic模板</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l==r) <span class="keyword">return</span> ;</span><br><span class="line">S=node[l],T=node[l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">dinic</span>(),s=node[l],tt=node[l+<span class="number">1</span>];<span class="comment">//将源汇点存下来</span></span><br><span class="line">ans[T][S]=ans[S][T]=t;</span><br><span class="line"><span class="keyword">int</span> cnt1=<span class="number">0</span>,cnt2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=l;i&lt;=r;++i)</span><br><span class="line"><span class="keyword">if</span> (d[node[i]]) tmp1[++cnt1]=node[i];</span><br><span class="line"><span class="keyword">else</span> tmp2[++cnt2]=node[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt1;++i) node[i+l<span class="number">-1</span>]=tmp1[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt2;++i) node[cnt1+l+i<span class="number">-1</span>]=tmp2[i];</span><br><span class="line"><span class="built_in">work</span>(l,l+cnt1<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">work</span>(l+cnt1,r);<span class="comment">//分治</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt1;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt2;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ii=node[i+l<span class="number">-1</span>],jj=node[j+cnt1+l<span class="number">-1</span>];</span><br><span class="line">ans[jj][ii]=ans[ii][jj]=<span class="built_in">min</span>(<span class="built_in">min</span>(ans[ii][s],ans[s][tt]),ans[tt][jj]);</span><br><span class="line">&#125;<span class="comment">//每个点都要处理</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> ans);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line"><span class="built_in">add</span>(x,y,z);<span class="built_in">add</span>(y,x,z);<span class="comment">//双向边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i) node[i]=i;</span><br><span class="line"><span class="built_in">work</span>(<span class="number">0</span>,n);<span class="comment">//下标从0开始</span></span><br><span class="line"><span class="keyword">int</span> que;cin&gt;&gt;que;</span><br><span class="line"><span class="keyword">while</span> (que--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[x][y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流</title>
      <link href="/2021/12/26/Network-flow/"/>
      <url>/2021/12/26/Network-flow/</url>
      
        <content type="html"><![CDATA[<p><strong>update: 2021-4-12 9:58 增加最小割的内容</strong></p><span id="more"></span><p><del>从我P5192的题解摘过来的</del></p><h2 id="1-网络流"><a href="#1-网络流" class="headerlink" title="1. 网络流"></a>1. 网络流</h2><p>通俗的讲，网络流就是一个水系，有源点（水库， S ）和汇点（大海， T ），中间有很多节点，中间的节点不储存流，作为一个中转站。</p><p>每一条边有一个容量（河道宽度），也有一个流量。显然流量小于等于容量。</p><p>如图是一张网络流。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/qfa0af16.png?x-oss-process=image/resize,m_lfit,h_170,w_225" alt="一张网络图"></p><p>已经有流量的图被称为残留网络。</p><p>注意：残留网络中，有反向边，而一般认为原图中没有反向边。<br>反向边的容量是正向边的流量。</p><p>（可以这么认为，反向边是用来退回正向边的流量，而最多就退回原来流过的量）</p><p>刚才那张图的残留网络是如下：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/135e9u9d.png?x-oss-process=image/resize,m_lfit,h_170,w_225" alt="残留网络"></p><p>增广路：沿着容量大于0的边，从 S 到达 T 的路径，</p><p>（这么多已经足够，详细解释请见百度 <del>逃</del> ）</p><h2 id="2-最大流"><a href="#2-最大流" class="headerlink" title="2. 最大流"></a>2. 最大流</h2><p>我们现在想要求从源点到汇点能流的最大值。</p><p>显然，上面的那张图不是最大流。</p><p>最大流应该是这样。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/s9ngtdta.png?x-oss-process=image/resize,m_lfit,h_170,w_225" alt="最大流"></p><h2 id="3-Edmonds-Karp-与-Dinic-——求最大流的算法"><a href="#3-Edmonds-Karp-与-Dinic-——求最大流的算法" class="headerlink" title="3. Edmonds-Karp 与 Dinic ——求最大流的算法"></a>3. Edmonds-Karp 与 Dinic ——求最大流的算法</h2><p>Edmonds-Karp 的主要思路是每次寻找一条增广路。</p><p>原理可以理解为搜索，直到流不过去为止。</p><p>一般能处理$10^3至$10^4的网络规模</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span><span class="comment">// 广搜</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i) vis[i]=<span class="number">0</span>;</span><br><span class="line">d[S]=<span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">vis[S]=<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(S);</span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[e[i]]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (w[i]!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">vis[e[i]]=<span class="number">1</span>;</span><br><span class="line">d[e[i]]=<span class="built_in">min</span>(d[x],w[i]);</span><br><span class="line">pre[e[i]]=i;<span class="comment">//记录前驱</span></span><br><span class="line"><span class="keyword">if</span> (e[i]==T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Edmonds_Karp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">bfs</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> f=d[T];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">w[pre[i]]-=f;</span><br><span class="line">w[pre[i]^<span class="number">1</span>]+=f;<span class="comment">//反向边加上对应流量</span></span><br><span class="line">&#125;</span><br><span class="line">r+=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dinic 是 EK 的优化，主要思想是建立分层图，一次找多个增广路</p><p>一般能处理$10^4$至$10^5$的网络规模</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    q.<span class="built_in">push</span>(S);</span><br><span class="line">    d[S]=<span class="number">0</span>;cur[S]=h[S];<span class="comment">//cur 是指当前到的出边</span></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span> (d[e[i]]==<span class="number">-1</span>&amp;&amp;w[i])</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[t]+<span class="number">1</span>;</span><br><span class="line">cur[e[i]]=h[e[i]];</span><br><span class="line"><span class="keyword">if</span> (e[i]==T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u==T) <span class="keyword">return</span> lim;</span><br><span class="line">    <span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=cur[u];i!=<span class="number">-1</span>&amp;&amp;flow&lt;lim;i=ne[i])</span><br><span class="line">    &#123;<span class="comment">//没有剩余流量就直接退出</span></span><br><span class="line">        cur[u]=i;<span class="comment">// 当前弧优化，下一次从这一条边出发</span></span><br><span class="line">        <span class="keyword">if</span> (d[e[i]]==d[u]+<span class="number">1</span>&amp;&amp;w[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t=<span class="built_in">find</span>(e[i],<span class="built_in">min</span>(w[i],lim-flow));</span><br><span class="line">            <span class="keyword">if</span> (t!=<span class="number">0</span>) d[e[i]]=<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 没有路径，就不再访问，赋值为-1</span></span><br><span class="line">            w[i]-=t,w[i^<span class="number">1</span>]+=t,flow+=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=<span class="number">0</span>,flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>())</span><br><span class="line">        <span class="keyword">while</span> (flow=<span class="built_in">find</span>(S,INF)) r+=flow;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-最小割"><a href="#4-最小割" class="headerlink" title="4. 最小割"></a>4. 最小割</h2><h3 id="1）-定义"><a href="#1）-定义" class="headerlink" title="1） 定义"></a>1） 定义</h3><p>如果沿着剩余容量大于0的边，无法从 s 到 t，那么这个残余网络就被称为割。</p><p>令 s 能搜到的点集合为 S，其余点的集合为 T。</p><p>割的容量定义为<br>$$c=\sum_ {u\in S,v \in T}{c(u,v)}$$</p><p>割的流量定义为<br>$$flow=\sum_ {u\in S,v\in T}{f(u,v)}-<br>\sum_ {u\in T,v\in S}{f(u,v)}$$</p><p>最小割是指容量最小的割。</p><h3 id="2）-最大流最小割定理"><a href="#2）-最大流最小割定理" class="headerlink" title="2） 最大流最小割定理"></a>2） 最大流最小割定理</h3><p>当下面条件满足之一时，均满足：</p><ol><li><p>f 是最大流</p></li><li><p>不存在从 s 到 t 的路径（沿着剩余容量大于0的边）</p></li><li><p>存在一个割，使 $c(S,T)=f(s,t)$</p></li></ol><h4 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h4><p>我们只要证出有1能得到2，有2能得到3，有3能得到1，原命题成立</p><h4 id="a-1推2"><a href="#a-1推2" class="headerlink" title="a.1推2"></a>a.1推2</h4><p>显然，如果2不满足的话，1一定不满足</p><p>他的逆否命题也成立（即原命题）</p><h4 id="b-2推3"><a href="#b-2推3" class="headerlink" title="b.2推3"></a>b.2推3</h4><p>将 s 能到的点作为一个集合，剩余的作为另一个集合</p><p>很明显，现在 S 与 T 的连接一定都是满流，且反向边容量为0</p><p>如果感觉有点绕的话，看一下上面的最大流图理解一下</p><h4 id="c-3推1"><a href="#c-3推1" class="headerlink" title="c.3推1"></a>c.3推1</h4><p>首先，任意一个割，都大于等于最大流。</p><p>其次，满足 3 的割，一定大于等于最小割（<del>废话</del>）。</p><p>然后，满足 3 的流，一定小于等于最大流。</p><p>我们可以得到：$c(S,T) \geq cmin \geq fmax \geq f(s,t)$</p><p>又 $c(S,T)=f(s,t)$</p><p>所以4项都相等。</p><h4 id="证毕。"><a href="#证毕。" class="headerlink" title="证毕。"></a>证毕。</h4><hr><h3 id="你已经掌握了最简单的网络流，切切网络流24题吧！"><a href="#你已经掌握了最简单的网络流，切切网络流24题吧！" class="headerlink" title="你已经掌握了最简单的网络流，切切网络流24题吧！"></a>你已经掌握了最简单的网络流，切切网络流24题吧！</h3><hr><p><del>小心被切</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5192</title>
      <link href="/2021/12/26/P5192/"/>
      <url>/2021/12/26/P5192/</url>
      
        <content type="html"><![CDATA[<p>同步发表于 P5192 题解。</p><span id="more"></span><h2 id="1-知识储备"><a href="#1-知识储备" class="headerlink" title="1.  知识储备"></a>1.  知识储备</h2><p>网络流 + 最大流。</p><p>（如果各位 dalao 已经滚瓜烂熟，请跳过）。</p><h4 id="1-网络流"><a href="#1-网络流" class="headerlink" title="1. 网络流"></a>1. 网络流</h4><p>通俗的讲，网络流就是一个水系，有源点（水库， S ）和汇点（大海， T ），中间有很多节点，中间的节点不储存流，作为一个中转站。</p><p>每一条边有一个容量（河道宽度），也有一个流量。显然流量小于等于容量。</p><p>如图是一张网络流。</p><img src="/2021/12/26/P5192/%E4%B8%80%E5%BC%A0%E5%9B%BE.png" class="" title="一张网络图"><p>已经有流量的图被称为残留网络。</p><p>注意：残留网络中，有反向边，而一般认为原图中没有反向边。<br>反向边的容量是正向边的流量。</p><p>（可以这么认为，反向边是用来退回正向边的流量，而最多就退回原来流过的量）</p><p>刚才那张图的残留网络是如下：</p><img src="/2021/12/26/P5192/%E6%AE%8B%E7%95%99%E7%BD%91%E7%BB%9C.png" class=""><p>增广路：沿着容量大于0的边，从 S 到达 T 的路径，</p><p>（这么多已经足够，详细解释请见百度 <del>逃</del> ）</p><h4 id="2-最大流"><a href="#2-最大流" class="headerlink" title="2. 最大流"></a>2. 最大流</h4><p>我们现在想要求从源点到汇点能流的最大值。</p><p>显然，上面的那张图不是最大流。</p><p>最大流应该是这样。</p><img src="/2021/12/26/P5192/%E6%9C%80%E5%A4%A7%E6%B5%81.png" class=""><h4 id="3-Edmonds-Karp-与-Dinic-——求最大流的算法"><a href="#3-Edmonds-Karp-与-Dinic-——求最大流的算法" class="headerlink" title="3. Edmonds-Karp 与 Dinic ——求最大流的算法"></a>3. Edmonds-Karp 与 Dinic ——求最大流的算法</h4><p>Edmonds-Karp 的主要思路是每次寻找一条增广路。</p><p>原理可以理解为搜索，直到流不过去为止。</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span><span class="comment">// 广搜</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i) vis[i]=<span class="number">0</span>;</span><br><span class="line">d[S]=<span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">vis[S]=<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(S);</span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[e[i]]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (w[i]!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">vis[e[i]]=<span class="number">1</span>;</span><br><span class="line">d[e[i]]=<span class="built_in">min</span>(d[x],w[i]);</span><br><span class="line">pre[e[i]]=i;<span class="comment">//记录前驱</span></span><br><span class="line"><span class="keyword">if</span> (e[i]==T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Edmonds_Karp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">bfs</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> f=d[T];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">w[pre[i]]-=f;</span><br><span class="line">w[pre[i]^<span class="number">1</span>]+=f;<span class="comment">//反向边加上对应流量</span></span><br><span class="line">&#125;</span><br><span class="line">r+=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dinic 是 EK 的优化，主要思想是建立分层图，一次找多个增广路</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    q.<span class="built_in">push</span>(S);</span><br><span class="line">    d[S]=<span class="number">0</span>;cur[S]=h[S];<span class="comment">//cur 是指当前到的出边</span></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span> (d[e[i]]==<span class="number">-1</span>&amp;&amp;w[i])</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[t]+<span class="number">1</span>;</span><br><span class="line">cur[e[i]]=h[e[i]];</span><br><span class="line"><span class="keyword">if</span> (e[i]==T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u==T) <span class="keyword">return</span> lim;</span><br><span class="line">    <span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=cur[u];i!=<span class="number">-1</span>&amp;&amp;flow&lt;lim;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cur[u]=i;<span class="comment">// 当前弧优化，下一次从这一条边出发</span></span><br><span class="line">        <span class="keyword">if</span> (d[e[i]]==d[u]+<span class="number">1</span>&amp;&amp;w[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t=<span class="built_in">find</span>(e[i],<span class="built_in">min</span>(w[i],lim-flow));</span><br><span class="line">            <span class="keyword">if</span> (t!=<span class="number">0</span>) d[e[i]]=<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 没有路径，就不再访问，赋值为-1</span></span><br><span class="line">            w[i]-=t,w[i^<span class="number">1</span>]+=t,flow+=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=<span class="number">0</span>,flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>())</span><br><span class="line">        <span class="keyword">while</span> (flow=<span class="built_in">find</span>(S,INF)) r+=flow;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-无源汇上下界最大流"><a href="#2-无源汇上下界最大流" class="headerlink" title="2. 无源汇上下界最大流"></a>2. 无源汇上下界最大流</h2><p>我们当然希望他不要有上下界，所以要转化成普通的最大流。</p><p>设边 (u,v) 流量为 f(u,v), 那么有<br>$$ cmin(u,v)\le f(u,v) \le cmax(u,v) $$</p><p>可以得到：</p><p>$$ 0 \le f(u,v) \le cmax(u,v) - cmin(u,v) $$</p><p>可以发现，我们直接从 u 连一条 cmax(u,v) - cmin(u,v) 为容量的边即可！</p><p>真的可以了吗？（<del>雾</del>）</p><p>回顾原来的定义，每一个节点都是要不储存流量的，但这样的话，会导致节点 u 存储的一些流量，为</p><p>$$ \sum_{(u,v)\in E}c(u,v)-\sum_{(t,u)\in E}c(t,u)$$</p><p>为了弥补这一缺陷，我们不得不建立一个源点和汇点（其他点无法在流入或流出）</p><p>如果该项大于 0 ，我们就从源点连一条边到该点，否则就从该点流出到汇点（别无选择）</p><p>于是，我们就可以用最大流了。</p><p>还有一个问题，假设从源点不能每一条边都是满流？此时，我们可以发现，如果不是满流，每一个点还是要储存流量，就会导致性质无法满足。</p><p>最后的最大流，就是从源点出发的流加上每一条边原来没有计算的流量。</p><p>（可以先理解，因为每一个流都会从源点流出，不然就会有其他点不流量守恒了）</p><p>Code: 略（<del>主要是不想打</del>）</p><h2 id="3-有源汇上下界最大流"><a href="#3-有源汇上下界最大流" class="headerlink" title="3. 有源汇上下界最大流"></a>3. 有源汇上下界最大流</h2><p>有源汇对于无源汇来说，有一点不同：原来的源点（记为 s ）和汇点（记为 t ）也是不流量守恒的。</p><p>显而易见的方法是，从 t 到 s 连一条 $+\infty$ 的边。</p><p>然后就先从 S 到 T 用 Dinic ，再 s 到 t 用 Dinic 。<br>两次的流量相加，就可以了。（<del>就可以了</del>）</p><p>但真的可以吗？（<del>雾</del>）</p><p>是可以的（<del>不要被我问一次就犹豫了</del>）</p><p>但是我这里需要严谨证明一下。（看不懂可以略过）</p><p><strong>证明</strong></p><p>我们需要证明的是原图中从 s 到 t 的可行流与新图第一次 Dinic 后从 s 到 t 的可行流是一 一对应的。</p><p>首先，原图的可行流与新图中的满流是一一对应的。</p><h4 id="1-原图至新图"><a href="#1-原图至新图" class="headerlink" title="1. 原图至新图"></a>1. 原图至新图</h4><p>假设新图有一个满流 f(S,T) ，对于任意一个原图的可行流，即一个新图的满流，相减后， S 和 T 相关的边，流量都会变成 0 。</p><p>又由于有 c(t,s)=$+\infty$ ，去掉这条边后，就是从 s 到 t 的可行流。</p><h4 id="2-新图至原图"><a href="#2-新图至原图" class="headerlink" title="2. 新图至原图"></a>2. 新图至原图</h4><p>设新图中有一个满流 f(S,T) ，并有任意一个 s 到 t 的可行流  f(s,t).</p><p>那么，f(S,T)+f(s,t) 也一定是一个满流，同时由于 f(s,t) 不经过 S 和 T ，每个点也满足流量守恒。</p><p>所以对任意一个 f(s,t) ，都有一个满流与之对应，也就是有原图的可行流。</p><p><strong>证毕！</strong></p><h2 id="4-回归本题"><a href="#4-回归本题" class="headerlink" title="4.回归本题"></a>4.回归本题</h2><p><strong><del>由标题可以看出</del>，本题是一个模板题。</strong></p><ul><li><p>先建立一个源点。</p></li><li><p>从源点到每个少女，流量为 [gi,$+\infty$)</p></li><li><p>从每个少女到每一天，流量为 [li,ri]</p></li><li><p>从每一天到汇点，流量为 [0,di]</p></li></ul><p>记得清零，以及少女的编号问题。</p><p>最后，献上代码。其它问题看注释，或者私信。</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e4</span>+<span class="number">10</span>,M=<span class="number">4e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll h[N],e[M],ne[M],w[M],A[N],d[N],cur[N],idx,n,m,S,T,q[N],s,t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll a,ll b,ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">e[idx]=a,w[idx]=<span class="number">0</span>,ne[idx]=h[b],h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加每一个有上下界的边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(ll from,ll to,ll least,ll most)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">add</span>(from,to,most-least);</span><br><span class="line">A[from]-=least,A[to]+=least;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">ll hh=<span class="number">1</span>,tt=<span class="number">1</span>;</span><br><span class="line">q[tt]=S;d[S]=<span class="number">1</span>;cur[S]=h[S];</span><br><span class="line"><span class="keyword">while</span> (hh&lt;=tt)</span><br><span class="line">&#123;</span><br><span class="line">ll x=q[hh++];</span><br><span class="line"><span class="keyword">for</span> (ll i=h[x];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (!d[e[i]]&amp;&amp;w[i])</span><br><span class="line">&#123;</span><br><span class="line">d[e[i]]=d[x]+<span class="number">1</span>;</span><br><span class="line">cur[e[i]]=h[e[i]];</span><br><span class="line"><span class="keyword">if</span> (e[i]==T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[++tt]=e[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">ll res=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> ((c=<span class="built_in">getchar</span>())&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;</span><br><span class="line">res=c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span> ((c=<span class="built_in">getchar</span>())&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="string">&#x27;0&#x27;</span>) res=(res&lt;&lt;<span class="number">3</span>)+(res&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> res*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">findflow</span><span class="params">(ll x,ll limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">ll flow=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (x==T) <span class="keyword">return</span> limit;</span><br><span class="line"><span class="keyword">for</span> (ll i=cur[x];i!=<span class="number">-1</span>&amp;&amp;flow&lt;limit;i=ne[i])</span><br><span class="line">&#123;</span><br><span class="line">cur[x]=i;<span class="comment">//当前弧优化</span></span><br><span class="line"><span class="keyword">if</span> ((d[e[i]]==d[x]+<span class="number">1</span>)&amp;&amp;w[i])</span><br><span class="line">&#123;</span><br><span class="line">ll t=<span class="built_in">findflow</span>(e[i],<span class="built_in">min</span>(limit-flow,w[i]));</span><br><span class="line"><span class="keyword">if</span> (!t) d[e[i]]=<span class="number">-1000</span>;</span><br><span class="line">w[i]-=t,w[i^<span class="number">1</span>]+=t,flow+=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dinic 模板</span></span><br><span class="line"><span class="function">ll <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll r=<span class="number">0</span>,flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">bfs</span>())</span><br><span class="line"><span class="keyword">while</span> (flow=<span class="built_in">findflow</span>(S,INF)) r+=flow;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))<span class="comment">//敲黑板</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="built_in">memset</span>(A,<span class="number">0</span>,<span class="keyword">sizeof</span> A);<span class="comment">//A 是指多出来的流量</span></span><br><span class="line">s=<span class="number">0</span>,t=m+n+<span class="number">1</span>;ll tot=<span class="number">0</span>;idx=<span class="number">0</span>;<span class="comment">//原图的源汇点</span></span><br><span class="line"><span class="keyword">for</span> (ll i=<span class="number">1</span>,x;i&lt;=m;++i)</span><br><span class="line">&#123;</span><br><span class="line">x=<span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">addedge</span>(s,i,x,INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (ll i=<span class="number">1</span>,C,D;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">C=<span class="built_in">read</span>();D=<span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">addedge</span>(m+i,t,<span class="number">0</span>,D);</span><br><span class="line"><span class="keyword">for</span> (ll j=<span class="number">1</span>,x,L,R;j&lt;=C;++j)</span><br><span class="line">&#123;</span><br><span class="line">x=<span class="built_in">read</span>(),L=<span class="built_in">read</span>(),R=<span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">addedge</span>(x+<span class="number">1</span>,m+i,L,R);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">S=m+n+<span class="number">2</span>;T=m+n+<span class="number">3</span>;<span class="comment">//新图的源汇点</span></span><br><span class="line"><span class="keyword">for</span> (ll i=<span class="number">0</span>;i&lt;=m+n+<span class="number">1</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (A[i]&gt;<span class="number">0</span>) <span class="built_in">add</span>(S,i,A[i]),tot+=A[i];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A[i]&lt;<span class="number">0</span>) <span class="built_in">add</span>(i,T,-A[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">add</span>(t,s,INF);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dinic</span>()&lt;tot)<span class="comment">//判断是否为满流</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll res=w[idx<span class="number">-1</span>];</span><br><span class="line">w[idx<span class="number">-1</span>]=w[idx<span class="number">-2</span>]=<span class="number">0</span>;</span><br><span class="line">S=s,T=t;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n\n&quot;</span>,res+<span class="built_in">dinic</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分图</title>
      <link href="/2021/12/26/Bipartite-graph/"/>
      <url>/2021/12/26/Bipartite-graph/</url>
      
        <content type="html"><![CDATA[<p>简单的前置知识。</p><span id="more"></span><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>也就是能分成两部分，每部之间没有边。</p><p>二分图在染色法时（每边染色不同，且只有 2 种颜色）不产生矛盾。</p><p>同时，如果不满足染色法，一定不是二分图。</p><p>这个证明其实有点难，感性理解就是了<del>（大雾</del></p><p>因为无法将颜色相同的点放入两部分，因为无论放入哪部分都会导致该部分内有边。</p><p>没有长度为奇数环（染色法没有矛盾）就一定是二分图。</p><p><strong>证明：</strong>因为没有奇数环的图，那么自己如果能走回自己，一定是经过的偶数条边，而这样两次染的色是相同的，所以就不会产生矛盾。</p><h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p><a href="https://www.luogu.com.cn/problem/P1525">关押罪犯 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/259/">关押罪犯 AcWing</a></p><p>这是一道典型的二分图判定题目。</p><p>虽然有其他做法，但今天着重讲二分图。</p><p>我们对这个图的操作明显就是二分图，而答案又是最大的影响最小化，所以<del>根据套路</del>，应该二分。</p><p>二分答案，对于每一个 $mid$，小于等于的不管，大于的加入边集，看会不会发生冲突。</p><p>用染色方法判定，时间复杂度为 $O(n\log\max(a_i))$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx,w[M];</span><br><span class="line"><span class="keyword">int</span> color[N],now,n,m;</span><br><span class="line"><span class="keyword">bool</span> res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!res) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">        <span class="keyword">if</span> (w[i]&gt;now)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (color[x]==color[e[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                res=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (color[e[i]]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                color[e[i]]=-color[x];</span><br><span class="line">                <span class="built_in">dfs</span>(e[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="keyword">sizeof</span> color);</span><br><span class="line">    res=<span class="number">1</span>;now=mid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (color[i]==<span class="number">0</span>) color[i]=<span class="number">1</span>,<span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;<span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);<span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=(<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-求最大匹配–匈牙利算法"><a href="#2-求最大匹配–匈牙利算法" class="headerlink" title="2.求最大匹配–匈牙利算法"></a>2.求最大匹配–匈牙利算法</h3><h4 id="1）-匹配（定义一堆"><a href="#1）-匹配（定义一堆" class="headerlink" title="1） 匹配（定义一堆"></a>1） 匹配（<del>定义一堆</del></h4><p>我们让二分图的一些边作为匹配边，需要满足的条件是：这些边都没有共同的端点。匹配边两边的点是匹配点，反之就是非匹配点。</p><p>最大匹配就是所有匹配中最大的<del>（废话</del>，最大的评级是根据边数（其实根据点数也没有什么，因为点数等于边数的两倍，只是更为常见的定义是用边数。</p><h4 id="2）增广路径"><a href="#2）增广路径" class="headerlink" title="2）增广路径"></a>2）增广路径</h4><p>从非匹配点开始，沿着非匹配边、匹配边、非、匹、非走，最后走到非匹配点，这样的路径就是一条增光路径。</p><h4 id="3）算法核心"><a href="#3）算法核心" class="headerlink" title="3）算法核心"></a>3）算法核心</h4><p>最大匹配等价于没有增广路径。</p><p>必要性易证：如果有，一定可以这条增广路径上的所有边将所有都取反（匹配边变为非匹配，非匹配变为匹配边，就得到更大匹配。</p><p>画个图，其实比较直观。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/lzykgvau.png"></p><p>（蓝色、红色是匹配边，黑色是非匹配边，左边红-黑交替的是增广路径，两端是非匹配点，将红-黑的所有边匹配取反，答案增加 1）</p><p>充分性略过。</p><h4 id="4）Konig-定理"><a href="#4）Konig-定理" class="headerlink" title="4）Konig 定理"></a>4）Konig 定理</h4><p>最小点覆盖 = 最大匹配。</p><p>最小点覆盖是指标记数量最少的点，使得每一条边至少有一个端点被标记。</p><p>证明又一次略。<del>（主要是我太菜</del></p><h4 id="5）算法流程"><a href="#5）算法流程" class="headerlink" title="5）算法流程"></a>5）算法流程</h4><p>首先，枚举每一个点，然后看这个点有没有增广路径，如果有的话，直接取反，答案加 1。</p><p>具体来说，我们举一个实在的例子。</p><p>我们发现，$a$ 现在想要匹配 $b$，但是现在 $b$ 匹配着 $c$，如果我们要让 $a$ 匹配 $b$，那么我们就要给 $c$ 找到一个匹配，不然的话答案不会增加。又发现现在 $a$ 和 $c$ 是同一部分的，这个其实是一个相似的问题，我们对 $c$ 进行递归即可。直到递归到 $m$ 和 $a,c$ 是同一部分的，而且 $m$ 有一个非匹配点 $n$ 与之相连，那么，我们就将 $m$ 的匹配变为 $n$，递归回去，最后 $a$ 匹配 $b$，答案加一。</p><p>时间复杂度为 $O(nm)$，实际和 spfa 等类似，跑得飞快。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//是看 x 能不能重新匹配一个，能就返回 true</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i]])<span class="comment">//vis 在每一次重新 a 开始的时候都要清空，是为了看一下有没有又走回来，就导致死循环了</span></span><br><span class="line">        &#123;</span><br><span class="line">            vis[e[i]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mat[e[i]]==<span class="number">0</span>||<span class="built_in">dfs</span>(mat[e[i]]))</span><br><span class="line">            &#123;</span><br><span class="line">                mat[e[i]]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-最小点覆盖"><a href="#3-最小点覆盖" class="headerlink" title="3. 最小点覆盖"></a>3. 最小点覆盖</h3><p><a href="https://www.acwing.com/problem/content/description/378/">AcWing376 机器任务</a></p><p>可以发现，对于 $a(i)$ 和 $b(i)$，必须有一个被取。</p><p>而我们发现，对于每一个 $i\in[1,n]$，$a(i)$ 只需要重启一次，也就是说，我们对于每一个 $a(i)$，贡献仅为 1。</p><p>可以将 $a(i)-b(i)$ 转化为一条边，变成用最少的点让所有的边都有一个端点有标记，也就是最小点覆盖问题，用 Konig 定理转化为最大匹配，用匈牙利算法就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">250</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> n,m,k,mat[N],ans;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[e[i]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mat[e[i]]==<span class="number">0</span>||<span class="built_in">dfs</span>(mat[e[i]]))</span><br><span class="line">            &#123;</span><br><span class="line">                mat[e[i]]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;n&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(mat,<span class="number">0</span>,<span class="keyword">sizeof</span> mat);</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">int</span> i,a,b;</span><br><span class="line">    <span class="keyword">while</span> (k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;i,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span> (a&gt;=<span class="number">1</span>&amp;&amp;b&gt;=<span class="number">1</span>) <span class="built_in">add</span>(a,b+n),<span class="built_in">add</span>(b+n,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(i)) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    ans=<span class="number">0</span>;idx=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-最大独立集"><a href="#4-最大独立集" class="headerlink" title="4.最大独立集"></a>4.最大独立集</h3><p><a href="https://www.acwing.com/problem/content/380/">AcWing378 骑士放置</a></p><p><a href="https://www.luogu.com.cn/problem/P3355">Luogu P3355 骑士共存问题</a></p><p>对于每一条限制，相当于端点只能取一个。</p><p>也就是一个最大独立集的问题了。</p><p>大概又有一个<del>简单的</del>定理：最大独立集 = 总点数 - 最小点覆盖。</p><p>不会证，只有鸽着了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span><span class="comment">//AcWing 代码，Luogu n = m</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line">PII mat[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">bool</span> v[N][N],vis[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>&#125;,</span><br><span class="line">    dy[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&gt;=<span class="number">1</span>&amp;&amp;y&gt;=<span class="number">1</span>) <span class="keyword">return</span> x&lt;=n&amp;&amp;y&lt;=m;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v[x][y]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">8</span>;++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i=x+dx[k],j=y+dy[k];</span><br><span class="line">        <span class="keyword">if</span> ((!<span class="built_in">check</span>(i,j))||v[i][j]||vis[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[i][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ii=mat[i][j].first,jj=mat[i][j].second;</span><br><span class="line">        <span class="keyword">if</span> (((ii==<span class="number">0</span>)&amp;&amp;(jj==<span class="number">0</span>))||<span class="built_in">dfs</span>(ii,jj))</span><br><span class="line">        &#123;</span><br><span class="line">            mat[i][j]=<span class="built_in">make_pair</span>(x,y);</span><br><span class="line">            <span class="comment">// printf(&quot;%d %d:%d %d\n&quot;,x,y,i,j);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k,a,b;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<span class="keyword">int</span> tmp=k;</span><br><span class="line">    <span class="keyword">while</span> (k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        v[a][b]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i][j]||(i+j)&amp;<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(i,j)) res++;</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;n*m-tmp-res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 二分图 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉回路</title>
      <link href="/2021/12/26/Euler-circuit-and-Eulerian-path/"/>
      <url>/2021/12/26/Euler-circuit-and-Eulerian-path/</url>
      
        <content type="html"><![CDATA[<p>代码简单。</p><span id="more"></span><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>即”一笔画“问题，从一个点出发，能不重复地走过所有边，则称该路径为欧拉路径。</p><p>如果能走回原点，则该路径为欧拉回路。</p><p>注意，点是可以多次经过的，只要不重复走边即可。</p><h3 id="2-定理"><a href="#2-定理" class="headerlink" title="2.定理"></a>2.定理</h3><p>前提是图连通。</p><h4 id="1）无向图"><a href="#1）无向图" class="headerlink" title="1）无向图"></a>1）无向图</h4><p>一个图有欧拉回路的充要条件是：该图的每一个点的度数都为偶数。</p><p>欧拉路径的充要条件是：除了起始点和终点的度数为奇数，其余都为偶数，或者是欧拉回路。</p><p>即：度数为奇数的点只有 0 或 2 个。</p><p>必要性易证：如果原命题不成立，每一次经过一个点，需要消耗 2 个度，则有些点度数为奇数的点进来后就没有出去的边了，就没法构成欧拉路径了。</p><h4 id="2）有向图"><a href="#2）有向图" class="headerlink" title="2）有向图"></a>2）有向图</h4><p>欧拉回路的充要条件是：每一个点的入度和出度都相等。</p><p>欧拉路径的充要条件是：要么是欧拉回路，或者除了起点的出度比入度多一，终点的入度比出度多一，其余的点入度和出度相等。</p><p>必要性和上面的证明类似。</p><h3 id="3-定理充分性的证明"><a href="#3-定理充分性的证明" class="headerlink" title="3.定理充分性的证明"></a>3.定理充分性的证明</h3><p>只要对于每个符合条件的图，只要构造出来即可。</p><p>通过 dfs 实现。</p><p>直接 dfs，但是有一个问题：如果没有找到所有的边怎么办？</p><p>首先，可以明确的是，欧拉路径是又若干个环所组成的。</p><p>那么，我们怎样将所有的边接为一个大环呢？</p><p>我们模拟栈的回溯过程，将第二个环嵌在第一个环中间。</p><img src="/2021/12/26/Euler-circuit-and-Eulerian-path/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E4%BE%8B%E5%9B%BE.png" class=""><p>这个会按照 红-绿 的颜色进行递归的，然后按照这个倒序的话，我们就可以找到这个欧拉回路，也就是这个 红-绿 路径。</p><p>栈的模拟十分简单，回溯的时候直接将这条边入栈，最后倒序输出就可以了。</p><p>但是，这样的时间复杂度是 $O(nm)$（虽然和 spfa 差不多），我们很多时候需要优化，变为严格 $O(n+m)$。</p><p>可以发现，每一次前面遍历过的边，都肯定不会再被用到。</p><p>直接将 $head[x]$ 设为当前边的下一条 $next[i]$。</p><p>Code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4e5</span>+<span class="number">10</span>,M=<span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> din[N],dout[N],ans[M],cnt;</span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i=h[x];~i;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            i=ne[i];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (t==<span class="number">1</span>) vis[i^<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> now;</span><br><span class="line">        <span class="keyword">if</span> (t==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            now=i/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i&amp;<span class="number">1</span>) now=-now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> now=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        i=ne[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line">        ans[++cnt]=now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    cin&gt;&gt;t&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);dout[a]++;din[b]++;</span><br><span class="line">        <span class="keyword">if</span> (t==<span class="number">1</span>) <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">if</span> (din[i]+dout[i]&amp;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">if</span> (din[i]!=dout[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (~h[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i);<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt&lt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=cnt;i;i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 欧拉回路 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manacher</title>
      <link href="/2021/12/22/Manacher-Algorithm/"/>
      <url>/2021/12/22/Manacher-Algorithm/</url>
      
        <content type="html"><![CDATA[<p>其实应用范围并不是很广。主要是预处理比较麻烦，而且很多问题回归原串的话是比较麻烦的。</p><span id="more"></span><h2 id="1-思想"><a href="#1-思想" class="headerlink" title="1. 思想"></a>1. 思想</h2><p>解决最长回文串的问题。</p><p>其实字符串的思想其实是比较类似的，都是将一个 $O(n ^ 2)$ 或者更高的复杂度的一个算法降一个 $n$。</p><p>比如，这里的 Manacher，暴力匹配是 $O(n ^ 2)$，但是我们通过 Manacher，可以优化到 $O(n)$。（但是有二分加 Hash $O(n \log n)$）</p><h2 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2. 算法流程"></a>2. 算法流程</h2><h3 id="1）预处理"><a href="#1）预处理" class="headerlink" title="1）预处理"></a>1）预处理</h3><p>由于 Manacher <del>比较拙劣</del>只能处理长度为奇数的回文串，所以我们需要一些预处理。</p><p>其实很简单，我们直接在每两个字符之间加上另外一个没有出现过的字符，然后回文中心其实就是新加入的字符。</p><p>比如说，$\texttt{abba}$，然后我们变为：$\texttt{a|b|b|a}$，于是回文中心就是中间的 |。</p><p>注意我们可能会一些比较神奇的匹配出现，同时为了防止边界问题，我们在前面再加一个都没有出现过的字符。</p><p>于是就是：$\texttt{+a|b|b|a}$，很明显匹配的时候，我们会匹配到 + 的时候是一定不会在往前匹配的。所以一定不会导越界。</p><p>（代码中加的字符似乎不一样）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readstr</span><span class="params">()</span><span class="comment">//读入该串并转化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    str[++ len] = <span class="string">&#x27;@&#x27;</span>;</span><br><span class="line">    str[++ len] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) &lt; <span class="string">&#x27;a&#x27;</span> || c &gt; <span class="string">&#x27;z&#x27;</span>);</span><br><span class="line">    str[++ len] = c, str[++ len] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">        str[++ len] = c, str[++ len] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）主流程"><a href="#2）主流程" class="headerlink" title="2）主流程"></a>2）主流程</h3><p>定义 $p(i)$ 表示以 $s(i)$ 为中心的最长回文串半径。比如 $\texttt{a|b|a}$，中间 $b$ 的下标是 $3$，那么 $p(3) = 3$，因为半径就是 $\texttt{b|a}$ 的长度。</p><p>首先，我们定义当前匹配的回文串最远可以达到 $r$，贡献这一个最远的是 $mid$，即 $r = \max(i + p(i) - 1)$，且 $r = mid + p(mid) - 1$。</p><p>我们计算 $p(i)$ 的时候，如果 $i &lt; r$，那么就可以得到 $p(i)\geq \min(r - i + 1, p(2 * mid - i))$。为什么呢？</p><p>首先，我们计算 $p(i)$ 的时候，$mid &lt; i$，然后 $2 * mid - i &lt; i$，所以 $p(i)$ 的信息可以由 $p(2 * mid - i)$ 求出来。注意不能越出最长的回文串，不然就可能不是合法的。</p><img src="/2021/12/22/Manacher-Algorithm/Manacher1.png" class=""><p>计算出来之后，我们直接暴力匹配就可以了。可以证明时间复杂度为 $O(n)$。先看代码。然后我们再证明复杂度。</p><p>如果要求原串的最长回文串，我们发现，不管是长度为奇数还是偶数，都是 $p(i) - 1$。看两个例子就可以了：$\texttt{|b|b|}$：$p(i) = 3$；$\texttt{|a|b|a|}$：$p(i) = 4$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> ri = <span class="number">1</span>, mid = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; ri) p[i] = <span class="built_in">min</span>(p[<span class="number">2</span> * mid - i], ri - i);</span><br><span class="line">        <span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (str[i - p[i]] == str[i + p[i]]) p[i] ++;</span><br><span class="line">        <span class="keyword">if</span> (ri &lt; i + p[i]) mid = i, ri = i + p[i];</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, p[i] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-时间复杂度的证明"><a href="#3-时间复杂度的证明" class="headerlink" title="3. 时间复杂度的证明"></a>3. 时间复杂度的证明</h2><p>很明显，时间的主要消耗是在 <code>while (str[i - p[i]] == str[i + p[i]]) p[i] ++;</code>。</p><p>假设 $p(2\times mid - i) &lt; r - i + 1$，说明我们在匹配 $2 \times mid - i$ 的时候已经发现无法再匹配下去了，而这个无法匹配的字符仍然会被回文到 $i$ 附近，说明匹配 $i$ 的时候，同样会遇到这种情况。那么 <code>while</code> 只会执行一次。</p><p>另外的情况，即 $p(2 \times mid - i)\geq r - i + 1$，那么我一直匹配的话，一定会导致 $r$ 跟着增加（因为 $r$ 会被 $i$ 更新）。并且 $r$ 的增加量就是 <code>while</code> 的执行次数。</p><p>很明显，$r$ 向右移动的次数不超过 $O(n)$。于是我们证明了 Manacher 就是 $O(n)$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2021/12/17/Disjoint-set/"/>
      <url>/2021/12/17/Disjoint-set/</url>
      
        <content type="html"><![CDATA[<p>简单的前置知识。</p><span id="more"></span><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1.基本操作"></a>1.基本操作</h3><p>并查集维护的是一种关系，这种关系具有传递性，并且一般具有对称性。</p><p>1）merge: 将两个集合合并</p><p>2）find: 查询代表元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x]==x) <span class="keyword">return</span> p[x];</span><br><span class="line">    <span class="keyword">return</span> p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root_a=<span class="built_in">find</span>(a),root_b=<span class="built_in">find</span>(b);</span><br><span class="line">    p[root_b]=root_a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>易得，并查集是树形结构。</p><h3 id="2-优化"><a href="#2-优化" class="headerlink" title="2.优化"></a>2.优化</h3><p>1）路径压缩：$O(\log(n))$</p><p>2）按秩合并：$O(\log(n))$</p><p>一般来说，只需要用第一个即可。</p><p>由于常数很小，实际用时，可以看做 $O(1)$</p><h3 id="3-扩展"><a href="#3-扩展" class="headerlink" title="3.扩展"></a>3.扩展</h3><p>1）记录集合大小：一般保存到代表元素。</p><p>2）每个点到根节点的距离：绑定到每一个元素。</p><p>比如说 [NOI2001] 食物链</p><p><a href="https://www.luogu.com.cn/problem/P2024">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/242/">题目传送门 AcWing</a></p><p>有两种处理方式：边带权和扩展域。</p><p>我们后面再讲。</p><h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4.例题"></a>4.例题</h3><h4 id="T1：格子游戏"><a href="#T1：格子游戏" class="headerlink" title="T1：格子游戏"></a>T1：格子游戏</h4><p>来自 《信息学奥赛一本通》（但多方都没有找到）</p><p>将连边的两个点合并到一个并查集即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(i,j) (i-1)*n+j</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">205</span>*<span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x]==x) <span class="keyword">return</span> p[x];</span><br><span class="line">    <span class="keyword">return</span> p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root_a=<span class="built_in">find</span>(a),root_b=<span class="built_in">find</span>(b);</span><br><span class="line">    p[root_b]=root_a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*n;++i) p[i]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>,&amp;a,&amp;b,op);</span><br><span class="line">        <span class="keyword">int</span> x=<span class="built_in">get</span>(a,b);</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>) y=<span class="built_in">get</span>(a+<span class="number">1</span>,b);</span><br><span class="line">        <span class="keyword">else</span> y=<span class="built_in">get</span>(a,b+<span class="number">1</span>);</span><br><span class="line">        x=<span class="built_in">find</span>(x);y=<span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x==y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">merge</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;draw&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2：搭配购买"><a href="#T2：搭配购买" class="headerlink" title="T2：搭配购买"></a>T2：搭配购买</h4><p><a href="https://www.luogu.com.cn/problem/P1455">题目传送门 Luogu</a></p><p>注意维护根节点的价钱和价值。</p><p>最后是一个 01 背包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N],v[N],w[N],n,m,f[<span class="built_in"><span class="keyword">int</span></span>(<span class="number">1e7</span>)],tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x]==x) <span class="keyword">return</span> p[x];</span><br><span class="line">    <span class="keyword">return</span> p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) p[i]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,v+i,w+i);</span><br><span class="line">    <span class="keyword">int</span> a,b,x,y;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        x=<span class="built_in">find</span>(a);y=<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (x!=y)</span><br><span class="line">        &#123;</span><br><span class="line">            w[x]+=w[y];</span><br><span class="line">            v[x]+=v[y];</span><br><span class="line">            p[y]=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i]!=i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=tot;j&gt;=v[i];--j)</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[tot]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3：-NOI2015-程序自动分析"><a href="#T3：-NOI2015-程序自动分析" class="headerlink" title="T3：[NOI2015] 程序自动分析"></a>T3：[NOI2015] 程序自动分析</h4><p><a href="https://www.luogu.com.cn/problem/P1955">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/239/">题目传送门 AcWing</a></p><p>考虑由于等于具有传递性，而不等于不具有传递性，所以将相互等于的数维护一个并查集即可。</p><p>数据范围较大，需要离散化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">unordered_map &lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; S;</span><br><span class="line"><span class="keyword">int</span> n,m,p[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,e;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.<span class="built_in">count</span>(x)==<span class="number">0</span>) S[x]=++n;</span><br><span class="line">    <span class="keyword">return</span> S[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==p[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,x,y,e;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        n=<span class="number">0</span>;</span><br><span class="line">        S.<span class="built_in">clear</span>();</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;x,&amp;y,&amp;q[i].e);</span><br><span class="line">            q[i].a=<span class="built_in">get</span>(x),q[i].b=<span class="built_in">get</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) p[i]=i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">            <span class="keyword">if</span> (q[i].e) p[<span class="built_in">find</span>(q[i].a)]=<span class="built_in">find</span>(q[i].b);</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">            <span class="keyword">if</span> (!q[i].e)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">find</span>(q[i].a)==<span class="built_in">find</span>(q[i].b))</span><br><span class="line">                &#123;</span><br><span class="line">                    flag=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="built_in">puts</span>(flag?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T4：-NOI2002-银河英雄传说"><a href="#T4：-NOI2002-银河英雄传说" class="headerlink" title="T4：[NOI2002] 银河英雄传说"></a>T4：[NOI2002] 银河英雄传说</h4><p><a href="https://www.luogu.com.cn/problem/P1955">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/240/">题目传送门 AcWing</a></p><p>如果没有询问距离，怎么办？</p><p>很简单，直接并查集即可。</p><p>可以发现，从 $x$ 到 $y$ 的距离，可以与 $x$,$y$ 到根节点的距离有关。</p><p>每当合并时，将被合并的点加一个前面的 $size[x]$。</p><p>前面讲到，因为是一个树形结构，所以它的子节点要路径压缩时，必定会经过被合并的点，并加上该点的 $d[x]$。</p><p>同时可以得到：<br>$$<br>dis(x,y)=abs(d(x)-d(y))-1<br>$$<br>注意特判 $x=y$ 的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> p[N],n,d[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> rt=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    d[x]+=d[p[x]];</span><br><span class="line">    <span class="keyword">return</span> p[x]=rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i) p[i]=i,s[i]=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">int</span> x=<span class="built_in">find</span>(a),y=<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x==y) <span class="keyword">continue</span>;</span><br><span class="line">            d[x]=s[y];</span><br><span class="line">            s[y]+=s[x];</span><br><span class="line">            p[x]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x!=y) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">max</span>(<span class="built_in">abs</span>(d[a]-d[b])<span class="number">-1</span>,<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T5：奇偶游戏"><a href="#T5：奇偶游戏" class="headerlink" title="T5：奇偶游戏"></a>T5：奇偶游戏</h4><p><a href="https://www.acwing.com/problem/content/description/241/">题目传送门 AcWing</a></p><p>观察到 $N$ 很大，而 $M$ 相对小得多。</p><p>考虑离散化。</p><p>记录前缀和 $s[i]=\sum_{j=1}^{i}a[j]$</p><p>如果 $l-r$ 中有奇数个，等价于 $s(r)$ 与 $s(l-1)$ 奇偶性不同。</p><p>每次将其奇偶性得到，如果出现矛盾，则不行。</p><p>但是，如果没有矛盾，一定可以吗？( <del>雾</del> )</p><p>答案是肯定的。</p><p>直接使 $a[i]=|s[i]-s[i-1]|$ ，就一定满足条件。</p><p>现在，我们要维护有关联的点，作为一个并查集。</p><p>我们先用边带权做一次。</p><p>$d[x]$ 表示 $x$ 到根节点的奇偶性，则 $dis(x,y)=d[x]+d[y]$。</p><p>每当插入一个关系时，我们应该先判断是否合法。</p><p>如果不在一个集合，那么我们连接 $px$ 与 $py$，边权为 $d[px]=d[x]$ ^ $d[y]$ ^ $ans$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">unordered_map &lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; S;</span><br><span class="line"><span class="keyword">int</span> n,m,tot,p[N],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.<span class="built_in">count</span>(x)==<span class="number">0</span>) S[x]=++n;</span><br><span class="line">    <span class="keyword">return</span> S[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x]==x) <span class="keyword">return</span> p[x];</span><br><span class="line">    <span class="keyword">int</span> rt=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    d[x]^=d[p[x]];</span><br><span class="line">    <span class="keyword">return</span> p[x]=rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;tot&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i) p[i]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %s&quot;</span>,&amp;a,&amp;b,op);</span><br><span class="line">        a=<span class="built_in">get</span>(a<span class="number">-1</span>);b=<span class="built_in">get</span>(b);</span><br><span class="line">        <span class="keyword">int</span> x=<span class="built_in">find</span>(a),y=<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x!=y) p[x]=y,d[x]=d[a]^d[b];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[a]^d[b])</span><br><span class="line">                &#123;</span><br><span class="line">                    cout&lt;&lt;i<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x!=y) p[x]=y,d[x]=d[a]^d[b]^<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[a]^d[b]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout&lt;&lt;i<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展域先鸽着。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组</title>
      <link href="/2021/12/17/Binary-indexed-tree/"/>
      <url>/2021/12/17/Binary-indexed-tree/</url>
      
        <content type="html"><![CDATA[<p>简单的前置知识。</p><span id="more"></span><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><h3 id="1-基本功能"><a href="#1-基本功能" class="headerlink" title="1.基本功能"></a>1.基本功能</h3><p>树状数组可以在 $O(\log n)$ 的时间里，完成1.求前缀和或者2.修改某一个数。</p><p>最坏情况下，也只是 $O(m \log n)$ 的复杂度。</p><h3 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2.基本原理"></a>2.基本原理</h3><p>基于二进制拆分思想。</p><p>$\forall x\in N^+, x=2^ {i_k}+2^{i_{k-1}}+…+2^{i_2}+2{i_1}$，</p><p>其中 $i_k\geq i_{k-1} \geq…\geq i_2\geq i_1$。</p><p>于是，我们将整个区间分为 $\log n$ 个区间。</p><p>分别为 $[x-2^{i_1}+1,x]$,$[x-2^{i_2}-2^{i_1}+1,x-2^{i_1}]$ … $[1,2^{i_{k}}]$。</p><p>每次，都可以取出 $2^i$，它是 x 的二进制表示的最后一位 1。</p><p>定义 $\operatorname{lowbit}(r)$ 表示 r 的最后一位 1 所表示的数。</p><p>那么，$\forall x$，第一个区间都可以表示为 $[x-\operatorname{lowbit}(x)+1,x]$</p><p>又发现，每一个 x，只有一个区间，而这个区间又很容易得到。</p><p>那么，让树状数组 $c[x]$ 表示区间$[x-\operatorname{lowbit}(x)+1,x]$</p><p>又二进制拆分最多只有 $\log n$ 位，所以每一个 x 的前缀和都可以拆分为 $\log n$ 个区间。</p><p>举个例子，13 的区间计算如下：</p><ol><li><p>$13=(1101)_2,\operatorname{lowbit}(13)=1:[13,13]$</p></li><li><p>$13-\operatorname{lowbit}(13)=12$</p></li><li><p>$12=(1100)_2,\operatorname{lowbit}(12)=4:[9,12]$</p></li><li><p>$12-\operatorname{lowbit}(12)=8$</p></li><li><p>$8=(1000)_2,\operatorname{lowbit}(8)=8:[1,8]$</p></li><li><p>$8-\operatorname{lowbit}(8)=0$</p></li></ol><p>结束。</p><p>讨论如何单点修改。</p><p>比如，我们需要在 13 加一个数。</p><p>可以发现，14 16 都要加上这个数。</p><p>相当于， $c[x]$ 代表的区间包含该数，那么该点需要修改。</p><p>将树状数组改为树的形式，也就是它的祖先都要修改。</p><p>当 13 加上 $\operatorname{lowbit}(13)$，则从低到高所有连续的 1 都会向前进位，直到碰到一个0。</p><p>这样得到的数，所包含的区间一定包含该数。</p><p>最后，我们还没讨论 $\operatorname{lowbit}(x)$。</p><p>如何计算 $\operatorname{lowbit}(x)$。</p><p>结论：$\operatorname{lowbit}(x)=x$ &amp; $(-x)$</p><p>$x=(…100…0)_2$（前面随意）。</p><p>又 $-x=\sim x+1$，所以所有的 0 都变成 1，接着加 1，所有最后的 1 都进位，直到原来的 1 不会进位，所以 &amp; 后，不会舍去，而其他位都被去掉。</p><h3 id="3-扩展"><a href="#3-扩展" class="headerlink" title="3.扩展"></a>3.扩展</h3><h4 id="1）差分"><a href="#1）差分" class="headerlink" title="1）差分"></a>1）差分</h4><p>支持区间修改和单点查询。</p><p>直接维护当前的差分数组即可（差分就是 $b[i]=a[i]-a[i-1]$ ）</p><h4 id="2）差分加区间和"><a href="#2）差分加区间和" class="headerlink" title="2）差分加区间和"></a>2）差分加区间和</h4><p>同样维护一个差分数组,也就是维护前缀和。</p><p>公式如下：<br>$$<br>ans=\sum_{x=1}^{i}\sum_{j=1}^{x}b[j]<br>$$<br>进一步推导可以得到：<br>$$<br>ans=\sum_{x=1}^{i}\sum_{j=1}^{x}b[j]=\sum_{x=1}^{i}b[x] * (i-x+1)<br>$$</p><p>分离 x 与 i：<br>$$<br>ans=\sum_{x=1}^{i}b[x] * (i+1)-\sum_{x=1}^{i}b[x] * x<br>$$<br>维护 b[x] 的前缀和和 $x * b[x]$ 的前缀和即可。</p><h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4.例题"></a>4.例题</h3><h4 id="T1：楼兰图腾"><a href="#T1：楼兰图腾" class="headerlink" title="T1：楼兰图腾"></a>T1：楼兰图腾</h4><p><a href="https://www.acwing.com/problem/content/description/243/">题目传送门 AcWing</a></p><p>维护当前左端的数，即可。</p><p>先从左向右记录比当前数大的个数和小的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">ll c[N],g[N],l[N];</span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        c[i]+=(ll)r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        res+=c[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        g[i]=<span class="built_in">sum</span>(n)-<span class="built_in">sum</span>(a[i]);</span><br><span class="line">        l[i]=<span class="built_in">sum</span>(a[i]<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span> c);</span><br><span class="line">    ll res1=<span class="number">0</span>,res2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n;i;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        res1+=g[i]*(<span class="built_in">sum</span>(n)-<span class="built_in">sum</span>(a[i]));</span><br><span class="line">        res2+=l[i]*(<span class="built_in">sum</span>(a[i]<span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld&quot;</span>,res1,res2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2：一个简单的整数问题"><a href="#T2：一个简单的整数问题" class="headerlink" title="T2：一个简单的整数问题"></a>T2：一个简单的整数问题</h4><p><a href="https://www.acwing.com/problem/content/248/">题目传送门 AcWing</a></p><p>刚才扩展 1 的模板题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;-x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll c[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        c[i]+=(ll)r;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        res+=c[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,x,y,t,l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="built_in">add</span>(i,x-l);</span><br><span class="line">        l=x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,op,&amp;x);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">sum</span>(x)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;y,&amp;t);</span><br><span class="line">            <span class="built_in">add</span>(y+<span class="number">1</span>,-t);<span class="built_in">add</span>(x,t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3：一个简单的整数问题2"><a href="#T3：一个简单的整数问题2" class="headerlink" title="T3：一个简单的整数问题2"></a>T3：一个简单的整数问题2</h4><p><a href="https://www.acwing.com/problem/content/description/244/">题目传送门 AcWing</a></p><p>扩展 2 的模板题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll c[<span class="number">2</span>][N],a[N],n,sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x,ll d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;x&lt;=n;x+=<span class="built_in">lowbit</span>(x)) c[k][x]+=d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;x;x-=<span class="built_in">lowbit</span>(x)) ans+=(ll)c[k][x];</span><br><span class="line"><span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m,b;ll d;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,a+i),sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">3</span>];<span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;d);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">0</span>,a,d);<span class="built_in">add</span>(<span class="number">0</span>,b+<span class="number">1</span>,-d);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>,a,a*d);<span class="built_in">add</span>(<span class="number">1</span>,b+<span class="number">1</span>,-(b+<span class="number">1</span>)*d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ll ans=sum[b]-sum[a<span class="number">-1</span>];</span><br><span class="line">ans+=(b+<span class="number">1</span>)*<span class="built_in">query</span>(<span class="number">0</span>,b)-<span class="built_in">query</span>(<span class="number">1</span>,b);</span><br><span class="line">ans-=(a)*<span class="built_in">query</span>(<span class="number">0</span>,a<span class="number">-1</span>)-<span class="built_in">query</span>(<span class="number">1</span>,a<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T4：谜一样的牛"><a href="#T4：谜一样的牛" class="headerlink" title="T4：谜一样的牛"></a>T4：谜一样的牛</h4><p><a href="https://www.acwing.com/problem/content/245/">题目传送门 ACWing</a></p><p>在线维护从前往后第 $a[i]+1$ 个1，就是本题答案。</p><p>考虑如何维护。</p><p>首先维护成前缀和。</p><p>一种比较简单的方法就是二分答案。</p><p>时间复杂度为 $O(n \log^2 n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;-x</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[N],n,a[N],ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) c[i]+=r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) ans+=c[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">add</span>(i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n;i;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sum</span>(mid)&gt;=a[i]+<span class="number">1</span>) r=mid;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i]=l;</span><br><span class="line">        <span class="built_in">add</span>(l,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种是倍增算法。</p><p>我们发现，树状数组恰好为我们维护的 2 的整数幂。</p><p>考虑使用倍增，如果当前的和小于需要的结果，那么就加上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;-x</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,L=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[N],n,a[N],ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) c[i]+=r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) ans+=c[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">add</span>(i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n;i;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">0</span>,nowsum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=L;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (now+(<span class="number">1</span>&lt;&lt;j)&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (nowsum+c[now+(<span class="number">1</span>&lt;&lt;j)]&lt;a[i]+<span class="number">1</span>) now+=(<span class="number">1</span>&lt;&lt;j),nowsum+=c[now];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i]=now+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">add</span>(ans[i],<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>算法</th><th>时间</th><th>空间</th></tr></thead><tbody><tr><td>二分答案算法</td><td>267 ms</td><td>2514 KB</td></tr><tr><td>倍增算法</td><td>134 ms</td><td>2008 KB</td></tr></tbody></table><p>实测 AcWing。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/2021/12/17/Segment-Tree/"/>
      <url>/2021/12/17/Segment-Tree/</url>
      
        <content type="html"><![CDATA[<p>非常重要的数据结构</p><span id="more"></span><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h3 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1.基本操作"></a>1.基本操作</h3><p>pushup 和 pushdown</p><p>代码实现，有以下 5 种操作：</p><ol><li><p>$\operatorname{pushup}(u)$</p></li><li><p>$\operatorname{build}(u,l,r)$</p></li><li><p>$\operatorname{modify}(u,x,val)$ or $\operatorname{modify}(l,r,u,val)$（改为某一个值或加上某一个值）</p></li><li><p>$\operatorname{query}(u,l,r)$</p></li><li><p>$\operatorname{pushdown}(u,l,r)$</p></li></ol><h3 id="2-基本构造"><a href="#2-基本构造" class="headerlink" title="2.基本构造"></a>2.基本构造</h3><p>对于每一个节点，都代表一个区间，该节点如果不是叶节点（即区间只有一个数），都会从中间断开，左右的区间的节点。</p><p>大多数情况，一个节点的父节点和子节点分别为 $[x/2]$ 和 $x \times 2$、$x\times 2 + 1$</p><p>可以发现，该树是完全二叉树。</p><p>由于最后一层不满，所以空间开为 $4\times n$。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/m0s5m6cm.png" alt="一颗线段树"></p><h3 id="3-每个操作的具体实现"><a href="#3-每个操作的具体实现" class="headerlink" title="3.每个操作的具体实现"></a>3.每个操作的具体实现</h3><h4 id="1）query"><a href="#1）query" class="headerlink" title="1）query"></a>1）query</h4><p>现在讲 query。</p><p>当遇到 $\operatorname{query}(u,l,r)$ 时，有下列二种情况：</p><p>$[l,r]\subseteq [T_l,T_r]$，直接返回。</p><p>$[l,r]\cap [T_l,T_r] \not= \emptyset$，递归有的区间。</p><p>注意，不可能出现无交集的情况，因为根本不会进入。</p><p>看似简单并且复杂度高，其实复杂度仅为 $O(\log n)$。一般为 $O(4\times \log n)$。</p><p>证明略，请读者自行分类证明。    </p><h4 id="2）-modify"><a href="#2）-modify" class="headerlink" title="2） modify"></a>2） modify</h4><p>先讲单点。</p><p>比较简单，直接观察哪一边包含该点，进入即可。</p><p>再讲区间修改，即 $\operatorname{pushdown}(p,l,r)$。</p><h4 id="3）pushdown"><a href="#3）pushdown" class="headerlink" title="3）pushdown"></a>3）pushdown</h4><p>现在我们要区间修改。</p><p>与该区间有交集的节点最多有 $n$ 个，所以单次复杂度最坏为 $O(n)$。</p><p>所以有了 $lazytag$。</p><p>来自于 query，即完全包含时，就直接返回。</p><p>$lazytag$ 就记录当前对于整个区间的加，然后就不用继续向下递归。</p><p>注意，一般为了防止错误，一般该节点先加，到时候直接加儿子即可。</p><p>通过证明 query 的复杂度，可以发现 pushdown 整个复杂度为 $O(4\log n)$。</p><p>于是，在 query 时，如果需要递归该子区间时，直接将标记下传即可。</p><p>所以，此时就可以不需要记录 $lazytag$ 了。</p><p>以和为例：<br>$$<br>left.add+=p.add,left.sum+=p.add*(r-l+1);<br>$$<br>最后清空当前节点的 $lazytag$ 即可。</p><h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4.例题"></a>4.例题</h3><h4 id="T1：-JSOI2008-最大数"><a href="#T1：-JSOI2008-最大数" class="headerlink" title="T1：[JSOI2008] 最大数"></a>T1：[JSOI2008] 最大数</h4><p><a href="https://www.luogu.com.cn/problem/P1198">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/1277/">题目传送门 ACWing</a></p><p>将动态改为静态。</p><p>先将插入加入序列，每一次真正插入时，就相当于单点修改。</p><p>就变成了模板题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p1 p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p2 p&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,val;</span><br><span class="line">&#125;tr[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p]=(Segment)&#123;l,r,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p1,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(p2,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].val=<span class="built_in">max</span>(tr[p1].val,tr[p2].val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=tr[p].l,r=tr[p].r;</span><br><span class="line">    <span class="keyword">if</span> (l==r) </span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].val=val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=mid) <span class="built_in">modify</span>(p1,x,val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(p2,x,val);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].l&gt;=l&amp;&amp;tr[p].r&lt;=r) <span class="keyword">return</span> tr[p].val;</span><br><span class="line">    <span class="keyword">int</span> mid=tr[p].l+tr[p].r&gt;&gt;<span class="number">1</span>, ans=-INF;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=mid) ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(p1,l,r));</span><br><span class="line">    <span class="keyword">if</span> (r&gt;mid) ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(p2,l,r));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> m,p,last=<span class="number">0</span>,x,n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;p);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,op,&amp;x);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x=(x+last)%p;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,++n,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            last=<span class="built_in">query</span>(<span class="number">1</span>,n-x+<span class="number">1</span>,n);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,last);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="T2-最大子段和"><a href="#T2-最大子段和" class="headerlink" title="T2:最大子段和"></a>T2:最大子段和</h4><p>考虑在一个节点维护哪些信息。</p><p>首先要维护 $tmax$（该区间的最大子段和）。</p><p>考虑怎样从儿子转移到父亲。</p><p>可以发现，有可能跨越两个区间，即儿子的最大前缀和最大后缀。</p><p>易得 $tmax[u]=\max(tmax[l],tmax[r], rmax[l]+lmax[r])$。</p><p>但是我们也要维护 $lmax[u]$ 和 $rmax[u]$。</p><p>易得：$lmax[u]=max(lmax[l],sum[l]+lmax[r])$。</p><p>右边同理。</p><p>也要维护 $sum$。</p><p>至此得到解决。</p><h4 id="T3：最大公约数"><a href="#T3：最大公约数" class="headerlink" title="T3：最大公约数"></a>T3：最大公约数</h4><p><a href="https://www.acwing.com/problem/content/247">题目传送门 AcWing</a></p><p>一共有 2 个操作：区间加和求最大公约数。</p><p>考虑需要存的信息：</p><p>最大公约数。</p><p>但是，由于 $(a,b,c)$ 与 $(a+x,b+x,c+x)$ 没有直接关系，所以不好维护。</p><p>但是，如果只修改一个数，那么就很简单。（直接跟新即可）</p><p>将区间加改为单点加，直接差分即可。</p><p>又由辗转相除法的扩展，可得：</p><p>$(a[1],a[2]…,a[n])=(a[1],a[2]-a[1] … ,a[n]-a[n-1])$</p><p>证明：</p><p>先证 $d=(a[1],a[2],…,a[n])|(a[1],a[2]-a[1],…, a[n]-a[n-1])$</p><p>易得，$d|a[1],d|a[2]…$，所以 $d|a[2]-a[1]$。同理，就可以证明。</p><p>再证$d=(a[1],a[2]-a[1],…, a[n]-a[n-1])|(a[1],a[2],…,a[n])$</p><p>易得，$d|a[1],d|(a[2]-a[1])$，所以 $d|(a[2]-a[1]+a[1])$，同理可证。</p><p>证毕。</p><p>又因为 $\operatorname{gcd}(a,b,…)$ 具有交换性与结合性，所以可以分开求。</p><p>让线段树维护差分后的值，并在每一个节点维护最大公约数。</p><p>对于每一个询问，都要维护原区间第一个点的值，否则会出问题。</p><p>可以使用树状数组维护前缀和，也可以直接和线段树一起维护。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) (x &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) (x &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ll tr[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, ll c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;bt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    ll val;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Gcd</span><span class="params">(ll a, ll b)</span></span>&#123;<span class="keyword">return</span> b ? <span class="built_in">Gcd</span>(b, a % b) : a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].val = <span class="built_in">Gcd</span>(tr[<span class="built_in">l</span>(x)].val, tr[<span class="built_in">r</span>(x)].val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x] = &#123;l, r, a[l]&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">l</span>(x), l, mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">r</span>(x), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pos, ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[x].r &lt; pos) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr[x].l == tr[x].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].val += c;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (tr[x].l + tr[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) <span class="built_in">modify</span>(<span class="built_in">l</span>(x), pos, c);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">r</span>(x), pos, c);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> tr[x].val;</span><br><span class="line">    <span class="keyword">int</span> mid = (tr[x].l + tr[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">l</span>(x), l, r);</span><br><span class="line">    <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">r</span>(x), l, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Gcd</span>(<span class="built_in">query</span>(<span class="built_in">l</span>(x), l, r), <span class="built_in">query</span>(<span class="built_in">r</span>(x), l, r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; -- i) a[i] -= a[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) bt.<span class="built_in">add</span>(i, a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    ll d;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %d %d&quot;</span>, op + <span class="number">1</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">1</span>] == <span class="string">&#x27;Q&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">abs</span>(<span class="built_in">Gcd</span>(bt.<span class="built_in">query</span>(l), <span class="built_in">query</span>(<span class="number">1</span>, l + <span class="number">1</span>, r))));</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, d), <span class="built_in">modify</span>(<span class="number">1</span>, r + <span class="number">1</span>, -d);</span><br><span class="line">            bt.<span class="built_in">add</span>(l, d), bt.<span class="built_in">add</span>(r + <span class="number">1</span>, -d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T4：一个简单的整数问题2-【模板】线段树1"><a href="#T4：一个简单的整数问题2-【模板】线段树1" class="headerlink" title="T4：一个简单的整数问题2/【模板】线段树1"></a>T4：一个简单的整数问题2/【模板】线段树1</h4><p><a href="https://www.luogu.com.cn/problem/P3372">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/244/">题目传送门 AcWing</a></p><p>上一次，我们使用了树状数组解决了本题。</p><p>这次，我们把他当做线段树的模板题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p1 p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p2 p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    ll sum,add;</span><br><span class="line">&#125;tr[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].sum=tr[p1].sum+tr[p2].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node &amp;root=tr[p],&amp;left=tr[p1],&amp;right=tr[p2];</span><br><span class="line">    <span class="keyword">if</span> (root.add==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    left.add+=root.add,right.add+=root.add;</span><br><span class="line">    left.sum+=root.add*(left.r-left.l+<span class="number">1</span>),right.sum+=root.add*(right.r-right.l+<span class="number">1</span>);</span><br><span class="line">    root.add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].l=l,tr[p].r=r;</span><br><span class="line">    <span class="keyword">if</span> (l==r) tr[p].sum=(ll)a[l],tr[p].add=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(p1,l,mid);</span><br><span class="line">        <span class="built_in">build</span>(p2,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].l&gt;=l&amp;&amp;tr[p].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum+=(ll)(tr[p].r-tr[p].l+<span class="number">1</span>)*x;</span><br><span class="line">        tr[p].add+=(ll)x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid=tr[p].l+tr[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=mid) <span class="built_in">modify</span>(p1,l,r,x);</span><br><span class="line">    <span class="keyword">if</span> (r&gt;mid) <span class="built_in">modify</span>(p2,l,r,x);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].l&gt;=l&amp;&amp;tr[p].r&lt;=r) <span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid=tr[p].l+tr[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=mid) sum+=<span class="built_in">query</span>(p1,l,r);</span><br><span class="line">    <span class="keyword">if</span> (r&gt;mid) sum+=<span class="built_in">query</span>(p2,l,r);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">5</span>];<span class="keyword">int</span> l,r;</span><br><span class="line">    ll x;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x),<span class="built_in">modify</span>(<span class="number">1</span>,l,r,x);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,l,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T5-亚特兰蒂斯"><a href="#T5-亚特兰蒂斯" class="headerlink" title="T5:亚特兰蒂斯"></a>T5:亚特兰蒂斯</h4><p><a href="https://www.acwing.com/problem/content/249/">题目传送门 AcWing</a></p><p>这道题，我们讲另外一个线段树的重要应用：<strong>扫描线</strong></p><p>扫描线的实质就是离散化加线段树（ <del>洛谷的标签</del> ）。</p><p>借助了积分的思想（不要被吓到了）。</p><p>将所有的 x 坐标离散化。</p><p>对于每一个相邻的 x 坐标，都有一些被覆盖，而且不是部分覆盖（即 x 坐标是被完全覆盖的，但 y 不一定）。</p><p>假设每个区间在 y 坐标上覆盖的长度为 $h[i]$，则答案为</p><p>$$ans=\sum_{i=1}^{tot}{h[i]*(x[i+1]-x[i])}$$</p><p>考虑如何求 $h[i]$。</p><p>再次利用差分的思想，将整个矩形覆盖就相当于左边的线段所覆盖的 y 坐标加 1，右边的线段覆盖的 y 坐标减 1。</p><p>也就是每一个点被覆盖的次数，如果不为 0，就算上该节    点。</p><p>原题目转化为，怎样计算在同一线段上，被覆盖的长度。</p><p>所以，将纵坐标再维护成线段树。</p><p>又因为是差分思想，所以直接计算前缀和即可吗，每计算一条边就加入当前的线段树。</p><p>维护以下信息：</p><ul><li><p>$cnt$ 记录当前区间的覆盖次数。</p></li><li><p>$len$ 不考虑当前节点的情况下，$cnt&gt;0$ 的区间长度。</p></li></ul><p>再根据它的特殊性质：在 query 的时候，只询问根节点，那么 query 一定不会使用 pushdown。</p><p>如果在 modify 时也不用使用 pushdown，那么就不需要 $lazytag$。</p><p>考虑该问题的特殊性质，对于同一区间，一定会先加一次，在减一次。</p><p>并且当前的节点，无论是多少，只要$x\geq 1$，就不会影响答案。</p><p>如果当前节点减完有为 0，就根据两个儿子的正确信息，就一定能维护当前节点的正确信息（儿子中没有被更改，是正确的）。</p><p>如果是加法，因为只会查询根节点，就不会用到儿子节点，所以无需管 psushdown。</p><p>并且，只要加大于 0 的节点，就不会影响答案。</p><p>如果等于 0 , pushdown 就不会执行。</p><p>这个题目的做法十分特殊，所以特意讲出来。</p><p>但是没有结束（ <del>雾</del> ）。</p><p>记得开头的标签吗？</p><p>我们还应该首先离散化，预处理相邻的距离。</p><p>还有一个细节，就是因为维护的是区间，所以应该是 $x[l]-x[r-1]$。</p><p>上代码（因为没有 $lazytag$，所以代码较短）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(p) (p&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(p) (p&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,l,r;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Seg &amp;e) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&lt;e.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[<span class="number">2</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">double</span> len;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line">vector &lt;<span class="keyword">double</span>&gt; t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].len=t[tr[p].r+<span class="number">1</span>]-t[tr[p].l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].l==tr[p].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    tr[p].len=tr[<span class="built_in">l</span>(p)].len+tr[<span class="built_in">r</span>(p)].len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p]=(Node)&#123;l,r,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">l</span>(p),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">r</span>(p),mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;%d %d %d %d %d\n&quot;,p,tr[p].l,tr[p].r,l,r);</span></span><br><span class="line">    <span class="keyword">if</span> (tr[p].l&gt;=l&amp;&amp;tr[p].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].cnt+=k;</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=tr[p].l+tr[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=mid) <span class="built_in">modify</span>(<span class="built_in">l</span>(p),l,r,k);</span><br><span class="line">    <span class="keyword">if</span> (r&gt;mid) <span class="built_in">modify</span>(<span class="built_in">r</span>(p),l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>(),x)-t.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">clear</span>();<span class="keyword">double</span> a,b,c,d;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf%lf&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Test case #%d\n&quot;</span>,++T);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Total explored area: %.2lf\n\n&quot;</span>,(c-a)*(d-b));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">            seg[j++]=(Seg)&#123;a,b,d,<span class="number">1</span>&#125;;</span><br><span class="line">            seg[j++]=(Seg)&#123;c,b,d,<span class="number">-1</span>&#125;;</span><br><span class="line">            t.<span class="built_in">push_back</span>(b);t.<span class="built_in">push_back</span>(d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>());</span><br><span class="line">        t.<span class="built_in">erase</span>(<span class="built_in">unique</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>()),t.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Test case #%d\n&quot;</span>,++T);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Total explored area: 0.00\n\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,t.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">        <span class="built_in">sort</span>(seg,seg+<span class="number">2</span>*n);</span><br><span class="line">        <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>) ans+=tr[<span class="number">1</span>].len*(seg[i].x-seg[i<span class="number">-1</span>].x);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="built_in">find</span>(seg[i].l),<span class="built_in">find</span>(seg[i].r)<span class="number">-1</span>,seg[i].k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test case #%d\n&quot;</span>,++T);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total explored area: %.2lf\n\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Treap</title>
      <link href="/2021/12/17/Treap/"/>
      <url>/2021/12/17/Treap/</url>
      
        <content type="html"><![CDATA[<p>比较基础的平衡树。</p><span id="more"></span><h2 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>Tree + Heap = Treap</p><p>前置知识：BST + Heap</p><p><a href="https://www.luogu.com.cn/blog/mydcwfy-342891/binary-search-tree">BST 的链接</a></p><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h3><p>由于 BST 的复杂度与高度相关，而 BST 容易退化。（如插入一条链）</p><p>而可以发现，随机数据下，期望高度为 $O(\log n)$。</p><p>Treap 恰好利用了这一点。</p><p>对于每一个节点，都额外赋予一个 $val$，并实时维护一个堆（小根或大根均可）。</p><p>可以发现，只要 $val$ 确定，树的形态就唯一确定（$val$ 都不同）</p><h4 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3. 基本操作"></a>3. 基本操作</h4><h4 id="1）右旋-zig"><a href="#1）右旋-zig" class="headerlink" title="1）右旋 (zig)"></a>1）右旋 (zig)</h4><p>1 和 2 都是交换儿子与父亲的操作，前提是不会影响中序遍历。</p><p>是将左儿子换到父亲的位置。</p><p>先将左儿子换到父亲，将父亲换到右儿子。</p><p>将左儿子的左子树换到父亲的左子树，左儿子的右子树换到右儿子的左子树。</p><p>画个图理解一下。</p><p>看代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zig</span><span class="params">(<span class="keyword">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> q=tr[p].l;</span><br><span class="line">tr[p].l=tr[q].r,tr[q].r=p,p=q;</span><br><span class="line"><span class="built_in">pushup</span>(tr[p].r);<span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）左旋-zag"><a href="#2）左旋-zag" class="headerlink" title="2）左旋 (zag)"></a>2）左旋 (zag)</h4><p>是将右儿子换到父亲为位置。</p><p>先将右儿子换到父亲，将父亲换到左儿子。</p><p>将右儿子的左子树换到左儿子的右子树，父亲的左子树换到左儿子的左子树。</p><p>可以发现，左旋与右旋是互逆操作。</p><p>画个图理解下。</p><p>看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zag</span><span class="params">(<span class="keyword">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> q=tr[p].r;</span><br><span class="line">tr[p].r=tr[q].l,tr[q].l=p,p=q;</span><br><span class="line"><span class="built_in">pushup</span>(tr[p].l);<span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）插入"><a href="#3）插入" class="headerlink" title="3）插入"></a>3）插入</h4><p>首先回溯插入（见 BST），在回溯过程中如果儿子与父亲不满足堆性质，则交换。</p><h4 id="4）删除"><a href="#4）删除" class="headerlink" title="4）删除"></a>4）删除</h4><p>可以发现，左旋和右旋都可以使一个节点高度降低。</p><p>所以将该节点旋转至叶节点，直接删除即可。</p><p>请注意，在维护过程中同时注意堆性质，防止旋反。</p><p>如果是大根堆，就应该将大的 $val$ 旋到父节点。</p><h3 id="3-例题"><a href="#3-例题" class="headerlink" title="3.例题"></a>3.例题</h3><h4 id="T1：普通平衡树"><a href="#T1：普通平衡树" class="headerlink" title="T1：普通平衡树"></a>T1：普通平衡树</h4><p><a href="https://www.luogu.com.cn/problem/P3369">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/255/">题目传送门 AcWing</a></p><p>模板题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">int</span> key,val,s,cnt;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,idx,rt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[p].s=tr[tr[p].l].s+tr[tr[p].r].s+tr[p].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zig</span><span class="params">(<span class="keyword">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> q=tr[p].l;</span><br><span class="line">tr[p].l=tr[q].r,tr[q].r=p,p=q;</span><br><span class="line"><span class="built_in">pushup</span>(tr[p].r);<span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zag</span><span class="params">(<span class="keyword">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> q=tr[p].r;</span><br><span class="line">tr[p].r=tr[q].l,tr[q].l=p,p=q;</span><br><span class="line"><span class="built_in">pushup</span>(tr[p].l);<span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_node</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[++idx].key=key;</span><br><span class="line">tr[idx].val=<span class="built_in">rand</span>();</span><br><span class="line">tr[idx].s=tr[idx].cnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">get_node</span>(-INF),<span class="built_in">get_node</span>(INF);</span><br><span class="line">rt=<span class="number">1</span>,tr[<span class="number">1</span>].r=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p) </span><br><span class="line">&#123;</span><br><span class="line">p=<span class="built_in">get_node</span>(key);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tr[p].key==key) tr[p].cnt++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tr[p].key&gt;key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">insert</span>(tr[p].l,key);</span><br><span class="line"><span class="keyword">if</span> (tr[p].val&lt;tr[tr[p].l].val) <span class="built_in">zig</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">insert</span>(tr[p].r,key);</span><br><span class="line"><span class="keyword">if</span> (tr[tr[p].r].val&gt;tr[p].val) <span class="built_in">zag</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[p].key==key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[p].cnt&gt;<span class="number">1</span>) tr[p].cnt--;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tr[p].l||tr[p].r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!tr[p].r||tr[tr[p].l].val&gt;tr[tr[p].r].val) <span class="built_in">zig</span>(p),<span class="built_in">remove</span>(tr[p].r,key);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">zag</span>(p),<span class="built_in">remove</span>(tr[p].l,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> p=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tr[p].key&lt;key) <span class="built_in">remove</span>(tr[p].r,key);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">remove</span>(tr[p].l,key);</span><br><span class="line"><span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_rank_by_key</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[p].key==key) <span class="keyword">return</span> tr[tr[p].l].s+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[p].key&gt;key) <span class="keyword">return</span> <span class="built_in">get_rank_by_key</span>(tr[p].l,key);</span><br><span class="line"><span class="keyword">return</span> tr[tr[p].l].s+tr[p].cnt+<span class="built_in">get_rank_by_key</span>(tr[p].r,key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_key_by_rank</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> rank)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">if</span> (tr[tr[p].l].s&gt;=rank) <span class="keyword">return</span> <span class="built_in">get_key_by_rank</span>(tr[p].l,rank);</span><br><span class="line"><span class="keyword">if</span> (tr[tr[p].l].s+tr[p].cnt&gt;=rank) <span class="keyword">return</span> tr[p].key;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">get_key_by_rank</span>(tr[p].r,rank-tr[tr[p].l].s-tr[p].cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_prev</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p) <span class="keyword">return</span> -INF;</span><br><span class="line"><span class="keyword">if</span> (tr[p].key&gt;=key) <span class="keyword">return</span> <span class="built_in">get_prev</span>(tr[p].l,key);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(tr[p].key,<span class="built_in">get_prev</span>(tr[p].r,key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_next</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">if</span> (tr[p].key&lt;=key) <span class="keyword">return</span> <span class="built_in">get_next</span>(tr[p].r,key);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">min</span>(tr[p].key,<span class="built_in">get_next</span>(tr[p].l,key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="built_in">build</span>();</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> op,x;</span><br><span class="line"><span class="keyword">while</span> (n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;op,&amp;x);</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (op)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:<span class="built_in">insert</span>(rt,x);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:<span class="built_in">remove</span>(rt,x);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">get_rank_by_key</span>(rt,x)<span class="number">-1</span>);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">get_key_by_rank</span>(rt,x+<span class="number">1</span>));<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">get_prev</span>(rt,x));<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">get_next</span>(rt,x));<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2：-HNOI-2002-营业额统计"><a href="#T2：-HNOI-2002-营业额统计" class="headerlink" title="T2：[HNOI 2002]营业额统计"></a>T2：[HNOI 2002]营业额统计</h4><p><a href="https://www.luogu.com.cn/problem/P2234">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/267/">题目传送门 AcWing</a></p><p>找$min(|a[i]-a[j]|)(1&lt;=j&lt;i)$，直接维护在当前数之前的序列。</p><p>直接维护 Treap 即可。</p><p>但是我用的是 set 乱搞。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; ta;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; ans;</span><br><span class="line">    ta.<span class="built_in">insert</span>(-INF), ta.<span class="built_in">insert</span>(ans), ta.<span class="built_in">insert</span>(INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, x; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (ta.<span class="built_in">find</span>(x) != ta.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">auto</span> iter = ta.<span class="built_in">insert</span>(x).first;</span><br><span class="line">        <span class="keyword">auto</span> ne = iter, pre = iter;</span><br><span class="line">        ne ++, pre --;</span><br><span class="line">        ans += <span class="built_in">min</span>(*ne - *iter, *iter - *pre);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/2021/12/17/Binary-search-tree/"/>
      <url>/2021/12/17/Binary-search-tree/</url>
      
        <content type="html"><![CDATA[<p>简单的前置知识。</p><span id="more"></span><h2 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h2><p>BST 是所有平衡树的基础，请看 Treap 和 Splay 等之前先看本文。</p><h3 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h3><p>一般是递归定义。</p><p>对于根节点，都有它的左子树的数都小于它，右边的数都大于它。</p><p>并且，左右子树也都是二叉查找树。</p><p>它的本质就是动态维护一个有序序列。</p><p>请注意，我们一般认为是不存在重复元素的。</p><p>如果有，在每一个节点上加一个计数器 $cnt$。</p><h3 id="2）基本性质"><a href="#2）基本性质" class="headerlink" title="2）基本性质"></a>2）基本性质</h3><p>首先，我们按照中序遍历后，一定是有序且递增的序列。</p><h3 id="3）支持操作"><a href="#3）支持操作" class="headerlink" title="3）支持操作"></a>3）支持操作</h3><p>前 6 个操作都可以使用 set 解决。</p><h4 id="a-插入"><a href="#a-插入" class="headerlink" title="a. 插入"></a>a. 插入</h4><p>递归当前节点，如果就等于当前节点，那么计数器 $cnt$ 加1；如果比该节点小，则向左子树递归；如果比该节点大，则向有递归。</p><p>直到遇到一个空节点，就插入并结束。</p><h4 id="b-删除"><a href="#b-删除" class="headerlink" title="b. 删除"></a>b. 删除</h4><p>由于常用的平衡树（ Treap,Splay ）都有自己的独特方法且较为简单，所以先不讲。</p><h4 id="c-查找最小值或最大值"><a href="#c-查找最小值或最大值" class="headerlink" title="c. 查找最小值或最大值"></a>c. 查找最小值或最大值</h4><p>直接一直向左 / 右一直寻找，直到为空，返回当前节点。</p><h4 id="d-查找前驱或后继"><a href="#d-查找前驱或后继" class="headerlink" title="d. 查找前驱或后继"></a>d. 查找前驱或后继</h4><p>以前驱为例。</p><p>假设一定有该节点。</p><p>先找到该节点。</p><p>分为两种情况：</p><ol><li>有左子树：先进入，然后找最大值。</li><li>没有左子树：找到最后一次向右递归的点，也是维护比当前值大的最小的点。</li></ol><h4 id="g-求某个值的排名"><a href="#g-求某个值的排名" class="headerlink" title="g. 求某个值的排名"></a>g. 求某个值的排名</h4><h4 id="h-求排名是-k-的值"><a href="#h-求排名是-k-的值" class="headerlink" title="h. 求排名是 k 的值"></a>h. 求排名是 k 的值</h4><p>g.h. 将在 Treap 中讲解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树套树</title>
      <link href="/2021/12/17/%E6%A0%91%E5%A5%97%E6%A0%91/"/>
      <url>/2021/12/17/%E6%A0%91%E5%A5%97%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>本质是一个区间通过线段树划分为 $\log n$ 个区间，每一个区间在分别维护，一般用 $O(\log n)$ 的数据结构，所以时间复杂度为 $O(n\log ^ 2 n)$，空间复杂度为 $O(n\log n)$，使用时注意空间。</p><span id="more"></span><h2 id="树套树"><a href="#树套树" class="headerlink" title="树套树"></a>树套树</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>顾名思义，就是一棵树套着另一棵树。</p><p>例如，对于每一个线段树的节点所维护的区间，都用 Splay 维护成有序序列。</p><p>一般外层是线段树或者树状数组，内层是一个平衡树或者线段树。</p><p>一般内层使用 STL。</p><p>请注意，如果你没有学过以上知识，请看我的其他博客。</p><p>我们通过例题来理解。</p><h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h3><h4 id="T1：树套树-简单版"><a href="#T1：树套树-简单版" class="headerlink" title="T1：树套树-简单版"></a>T1：树套树-简单版</h4><p><a href="https://www.acwing.com/problem/content/2490/">题目传送门 AcWing</a></p><p>假设没有区间的限制，那么我们就可以直接使用 lower_bound 等函数即可（使用 set）。</p><p>如何加上区间的限制呢？</p><p>那么，我们用一个线段树维护区间，并对每一个节点都建立一个 set，存放整个区间的有序序列。</p><p>回顾线段树，相当于是讲一个区间维护成 $\log n$ 个区间。</p><p>对于每一个区间，都返回前驱即可。</p><p>单次复杂度为 $O(\log^2 n)$。</p><p>如果单次修改，我们也像线段树一样，删除在该区间的数，插入新的树即可。</p><p>时间复杂度为 $O(m\log^2n)$，空间复杂度为 $O(n\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(p) (p&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(p) (p&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    multiset &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[N],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p]=(Node)&#123;l,r&#125;;</span><br><span class="line">    tr[p].s.<span class="built_in">clear</span>();</span><br><span class="line">    tr[p].s.<span class="built_in">insert</span>(-INF),tr[p].s.<span class="built_in">insert</span>(INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=l;i&lt;=r;++i) tr[p].s.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">l</span>(p),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">r</span>(p),mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].s.<span class="built_in">erase</span>(tr[p].s.<span class="built_in">find</span>(a[x]));</span><br><span class="line">    tr[p].s.<span class="built_in">insert</span>(val);+</span><br><span class="line">    <span class="keyword">if</span> (tr[p].l==tr[p].r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=tr[p].l+tr[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=mid) <span class="built_in">modify</span>(<span class="built_in">l</span>(p),x,val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="built_in">r</span>(p),x,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].l&gt;=l&amp;&amp;tr[p].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> it=tr[p].s.<span class="built_in">lower_bound</span>(x);</span><br><span class="line">        --it;<span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=tr[p].l+tr[p].r&gt;&gt;<span class="number">1</span>,ans=-INF;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=mid) ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(<span class="built_in">l</span>(p),l,r,x));</span><br><span class="line">    <span class="keyword">if</span> (r&gt;mid) ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(<span class="built_in">r</span>(p),l,r,x));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op,l,r,x,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;l,&amp;x);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,x);</span><br><span class="line">            a[l]=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;l,&amp;r,&amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,l,r,x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2：树套树"><a href="#T2：树套树" class="headerlink" title="T2：树套树"></a>T2：树套树</h4><p><a href="https://www.luogu.com.cn/problem/P3380">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2478/">题目传送门 AcWing</a></p><p>像上道题一样，我们使用树套树，线段树加 BST。</p><p>由于 set 不能维护当前子树的大小，我们就不能使用 STL。</p><p>手写 Splay/Treap 等平衡树，外面套一个线段树。</p><p>代码很长，至少 200 行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(p) (p&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(p) (p&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,INF=<span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,key,val;</span><br><span class="line">    <span class="keyword">int</span> size,cnt;</span><br><span class="line">&#125;tr[<span class="number">20</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> rt;</span><br><span class="line">&#125;seg[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>,pos,a[N],n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_node</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[++tot]=(Node)&#123;<span class="number">0</span>,<span class="number">0</span>,key,<span class="built_in">rand</span>(),<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].size=tr[tr[p].l].size+tr[tr[p].r].size+tr[p].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zig</span><span class="params">(<span class="keyword">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q=tr[p].l;</span><br><span class="line">    tr[p].l=tr[q].r,tr[q].r=p,p=q;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[p].r);<span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zag</span><span class="params">(<span class="keyword">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q=tr[p].r;</span><br><span class="line">    tr[p].r=tr[q].l;tr[q].l=p,p=q;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[p].l);<span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">get_node</span>(-INF),<span class="built_in">get_node</span>(INF);</span><br><span class="line">    tr[tot<span class="number">-1</span>].r=tot,seg[pos].rt=tot<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">pushup</span>(tot<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">    &#123;</span><br><span class="line">        p=<span class="built_in">get_node</span>(key);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key==key)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].key&gt;key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(tr[p].l,key);</span><br><span class="line">        <span class="keyword">if</span> (tr[p].val&lt;tr[tr[p].l].val) <span class="built_in">zig</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(tr[p].r,key);</span><br><span class="line">        <span class="keyword">if</span> (tr[p].val&lt;tr[tr[p].r].val) <span class="built_in">zag</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key==key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[p].cnt&gt;<span class="number">1</span>) tr[p].cnt--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tr[p].l||tr[p].r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!tr[p].r||tr[tr[p].l].val&gt;tr[tr[p].r].val) <span class="built_in">zig</span>(p),<span class="built_in">remove</span>(tr[p].r,key);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">zag</span>(p),<span class="built_in">remove</span>(tr[p].l,key);</span><br><span class="line">                <span class="built_in">pushup</span>(p);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> p=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key&gt;key) <span class="built_in">remove</span>(tr[p].l,key);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">remove</span>(tr[p].r,key);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_rank_by_key</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key==key) <span class="keyword">return</span> tr[tr[p].l].size;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key&gt;key) <span class="keyword">return</span> <span class="built_in">get_rank_by_key</span>(tr[p].l,key);</span><br><span class="line">    <span class="keyword">return</span> tr[tr[p].l].size+tr[p].cnt+<span class="built_in">get_rank_by_key</span>(tr[p].r,key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_key_by_rank</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> rank)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span> (tr[tr[p].l].size&gt;=rank) <span class="keyword">return</span> <span class="built_in">get_key_by_rank</span>(tr[p].l,rank);</span><br><span class="line">    <span class="keyword">if</span> (tr[tr[p].l].size+tr[p].cnt&gt;=rank) <span class="keyword">return</span> tr[p].key;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_key_by_rank</span>(tr[p].r,rank-tr[p].cnt-tr[tr[p].l].size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_prev</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> -INF;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key&gt;=key) <span class="keyword">return</span> <span class="built_in">get_prev</span>(tr[p].l,key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(tr[p].key,<span class="built_in">get_prev</span>(tr[p].r,key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_next</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key&lt;=key) <span class="keyword">return</span> <span class="built_in">get_next</span>(tr[p].r,key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(tr[p].key,<span class="built_in">get_next</span>(tr[p].l,key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上为 Treap 的模板</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_tree</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">build</span>(p);</span><br><span class="line">    seg[p].l=l,seg[p].r=r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=l;i&lt;=r;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(seg[p].rt,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">make_tree</span>(<span class="built_in">l</span>(p),l,mid);</span><br><span class="line">    <span class="built_in">make_tree</span>(<span class="built_in">r</span>(p),mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seg_change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> pos,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">remove</span>(seg[p].rt,a[pos]);</span><br><span class="line">    <span class="built_in">insert</span>(seg[p].rt,k);</span><br><span class="line">    <span class="keyword">if</span> (seg[p].l==seg[p].r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=seg[p].l+seg[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos&lt;=mid) <span class="built_in">seg_change</span>(<span class="built_in">l</span>(p),pos,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">seg_change</span>(<span class="built_in">r</span>(p),pos,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seg_get_prev</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (seg[p].l&gt;=l&amp;&amp;seg[p].r&lt;=r) <span class="keyword">return</span> <span class="built_in">get_prev</span>(seg[p].rt,x);</span><br><span class="line">    <span class="keyword">int</span> mid=seg[p].l+seg[p].r&gt;&gt;<span class="number">1</span>,ans=-INF;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=mid) ans=<span class="built_in">max</span>(ans,<span class="built_in">seg_get_prev</span>(<span class="built_in">l</span>(p),l,r,x));</span><br><span class="line">    <span class="keyword">if</span> (r&gt;mid) ans=<span class="built_in">max</span>(ans,<span class="built_in">seg_get_prev</span>(<span class="built_in">r</span>(p),l,r,x));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seg_get_next</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (seg[p].l&gt;=l&amp;&amp;seg[p].r&lt;=r) <span class="keyword">return</span> <span class="built_in">get_next</span>(seg[p].rt,x);</span><br><span class="line">    <span class="keyword">int</span> mid=seg[p].l+seg[p].r&gt;&gt;<span class="number">1</span>,ans=INF;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=mid) ans=<span class="built_in">min</span>(ans,<span class="built_in">seg_get_next</span>(<span class="built_in">l</span>(p),l,r,x));</span><br><span class="line">    <span class="keyword">if</span> (r&gt;mid) ans=<span class="built_in">min</span>(ans,<span class="built_in">seg_get_next</span>(<span class="built_in">r</span>(p),l,r,x));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seg_get_rank_by_key</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (seg[p].l&gt;=l&amp;&amp;seg[p].r&lt;=r) <span class="keyword">return</span> <span class="built_in">get_rank_by_key</span>(seg[p].rt,key)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=seg[p].l+seg[p].r&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=mid) ans+=<span class="built_in">seg_get_rank_by_key</span>(<span class="built_in">l</span>(p),l,r,key);</span><br><span class="line">    <span class="keyword">if</span> (r&gt;mid) ans+=<span class="built_in">seg_get_rank_by_key</span>(<span class="built_in">r</span>(p),l,r,key);</span><br><span class="line">    <span class="comment">// printf(&quot;%d %d %d key=%d ans=%d\n&quot;,p,seg[p].l,seg[p].r,key,ans);</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上为线段树的模板</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    <span class="built_in">make_tree</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="comment">/*remove(seg[2].rt,2);</span></span><br><span class="line"><span class="comment">    printf(&quot;%d\n&quot;,get_rank_by_key(seg[2].rt,4)-1);*/</span></span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;,seg_get_rank_by_key(1,1,4,INF/2));</span></span><br><span class="line">    <span class="keyword">int</span> op,l,r,pos,x;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;pos,&amp;x);</span><br><span class="line">            <span class="built_in">seg_change</span>(<span class="number">1</span>,pos,x);</span><br><span class="line">            a[pos]=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;l,&amp;r,&amp;x);</span><br><span class="line">            <span class="keyword">if</span> (op==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">seg_get_rank_by_key</span>(<span class="number">1</span>,l,r,x)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (op==<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> lval=-INF,rval=INF,tot=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (lval&lt;rval)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid=(<span class="keyword">long</span> <span class="keyword">long</span>)lval+rval+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;lval&lt;&lt;&#x27; &#x27;&lt;&lt;mid&lt;&lt;&#x27; &#x27;&lt;&lt;rval&lt;&lt;&#x27;\t&#x27;&lt;&lt;seg_get_rank_by_key(1,l,r,mid)&lt;&lt;endl;</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">seg_get_rank_by_key</span>(<span class="number">1</span>,l,r,mid)&gt;=x) rval=mid<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">else</span> lval=mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,lval);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (op==<span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">seg_get_prev</span>(<span class="number">1</span>,l,r,x));</span><br><span class="line">            <span class="keyword">if</span> (op==<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">seg_get_next</span>(<span class="number">1</span>,l,r,x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3：K大数查询"><a href="#T3：K大数查询" class="headerlink" title="T3：K大数查询"></a>T3：K大数查询</h4><p><a href="https://www.luogu.com.cn/problem/P3332">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2308/">题目传送门 AcWing</a></p><p>首先，由于范围过大，我们需要离散化。</p><p>然后，我们要使用树套树，可以完成。但是有其他办法，所以没有写代码。</p><p>到时再贴树套树的做法吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树套树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AC 自动机</title>
      <link href="/2021/12/17/Aho-corasick-automaton/"/>
      <url>/2021/12/17/Aho-corasick-automaton/</url>
      
        <content type="html"><![CDATA[<p>字符串中相对比较难的知识点。</p><span id="more"></span><h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><h3 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1. 前置知识"></a>1. 前置知识</h3><p>Trie &amp; KMP.</p><p><a href="https://mydcwfy.github.io/2021/12/17/KMP-algorithm/#more">KMP位置</a></p><p>但是，没看懂 KMP 不代表看不懂本博客。</p><h3 id="2-解决的问题"><a href="#2-解决的问题" class="headerlink" title="2.解决的问题"></a>2.解决的问题</h3><p>多模问题，即一个字符串与多个模式串相匹配的问题。</p><p>如果不能匹配，找出最大的（模式串前缀）和（字符串的子串）相同。</p><h3 id="3-核心思想"><a href="#3-核心思想" class="headerlink" title="3.核心思想"></a>3.核心思想</h3><h4 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h4><p>在 Trie 上对每一个节点建立 $fail[i]$,是指的是对于所有模式串来说，当前所到节点的字符串的后缀与所有模式串的前缀的最大长度。</p><p>（ <del>令人难懂的定义</del>）</p><p>对比 KMP，我们发现还是有一定的相似性的。</p><p>可以画一个 Trie，自行匹配。</p><h4 id="2）求法"><a href="#2）求法" class="headerlink" title="2）求法"></a>2）求法</h4><p>由于当前的 $fail$ 一定小于整个串的长度，所以我们跳到父节点。</p><p>然后模仿 KMP,一直向前 fail，直到当前的儿子节点与该节点所代表的相同。</p><p>我们搜索时，也和 KMP 相似，如果匹配失败，就一直 fail 直到可以。</p><p>举个例子。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/vdyn9ho3.png"></p><p>首先，根的所有儿子的 $fail$ 都是指向根节点（没有可以和他匹配的了）。</p><p>对于其他节点 $u$，我们首先跳到父亲 $fa$。</p><p>以 $fa$ 为节点的字符串已经处理好了 $fail$，我们一直往上跳 $fail$，$fa$ 的后缀一定是包含当前节点。</p><p>再定义 $c$ 为 $u$ 是 $fa$ 的哪一个儿子。</p><p>如果碰到跳到的 $fail$ 有 $c$ 儿子，那么 $u$ 的 $fail$ 就指向 $c$ 儿子。</p><p>因为，$fa$ 的后缀与 $fail$ 的字符串一定相同。</p><p>所以，$u$ 的后缀一定与 $fail$ 的 $c$ 儿子相同。</p><h4 id="3）一个小小的优化"><a href="#3）一个小小的优化" class="headerlink" title="3）一个小小的优化"></a>3）一个小小的优化</h4><p>Trie 图。</p><p>你可以先看后面的代码。</p><p>假设当前节点的儿子没有的话，我们可以直接指向 $fail[x]$ 的当前的儿子。</p><p>因为向下走的话，前面匹配的仍然匹配。</p><p>虽然一定程度上破坏了 Trie，但常数会小一些。</p><h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4.例题"></a>4.例题</h3><h4 id="T1：AC自动机"><a href="#T1：AC自动机" class="headerlink" title="T1：AC自动机"></a>T1：AC自动机</h4><p><a href="https://www.luogu.com.cn/problem/P3808">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/1284/">题目传送门 AcWing</a></p><p>模板题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,M=<span class="number">5e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tr[N][<span class="number">26</span>],ne[N],tot,cnt[N];</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">char</span> str[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;str[i];++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!tr[u][t]) tr[u][t]=++tot;</span><br><span class="line">        u=tr[u][t];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[u]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">        <span class="keyword">if</span> (tr[<span class="number">0</span>][i]) q[++tt]=tr[<span class="number">0</span>][i];</span><br><span class="line">    <span class="keyword">while</span> (hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q[hh++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h=<span class="number">0</span>;h&lt;<span class="number">26</span>;++h)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> &amp;t=tr[x][h];</span><br><span class="line">            <span class="keyword">if</span> (!t) t=tr[ne[x]][h];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ne[t]=tr[ne[x]][h];</span><br><span class="line">                q[++tt]=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Calcans</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;str[i];++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        j=tr[j][t];</span><br><span class="line">        <span class="keyword">int</span> p=j;</span><br><span class="line">        <span class="keyword">while</span> (p&amp;&amp;~cnt[p])</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=cnt[p];</span><br><span class="line">            cnt[p]=<span class="number">-1</span>;</span><br><span class="line">            p=ne[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">        <span class="built_in">insert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Calcans</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2：-TJOI2013-单词"><a href="#T2：-TJOI2013-单词" class="headerlink" title="T2：[TJOI2013]单词"></a>T2：[TJOI2013]单词</h4><p><a href="https://www.luogu.com.cn/problem/P3966">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/1287/">题目传送门 AcWing</a></p><p>这道题略有不同，需要我们首先统计每一个节点属于那些字符串，然后使用 ne 的转移，就可以统计了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> tr[N][<span class="number">26</span>],ne[N],cnt[N],id[<span class="number">250</span>],tot,q[N],hh,tt=<span class="number">-1</span>,n;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!tr[u][t]) tr[u][t]=++tot;</span><br><span class="line">        u=tr[u][t];</span><br><span class="line">        cnt[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">    id[x]=u;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">        <span class="keyword">if</span> (tr[<span class="number">0</span>][i]) q[++tt]=tr[<span class="number">0</span>][i];</span><br><span class="line">    <span class="keyword">while</span> (hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q[hh++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> &amp;t=tr[x][i];</span><br><span class="line">            <span class="keyword">if</span> (!t) t=tr[ne[x]][i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ne[t]=tr[ne[x]][i];</span><br><span class="line">                q[++tt]=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">        <span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=tt;i&gt;=<span class="number">0</span>;--i) cnt[ne[q[i]]]+=cnt[q[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt[id[i]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> AC 自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP algorithm</title>
      <link href="/2021/12/17/KMP-algorithm/"/>
      <url>/2021/12/17/KMP-algorithm/</url>
      
        <content type="html"><![CDATA[<p>比较简单的前置知识。</p><span id="more"></span><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><h3 id="1-所解决的问题"><a href="#1-所解决的问题" class="headerlink" title="1. 所解决的问题"></a>1. 所解决的问题</h3><p>匹配一个字符串 $s[]$ 与模式字符串 $p[]$，计算有哪些点 $s[]$ 结尾的字符串与模式串（或前缀）完全相同。</p><p>通俗地讲，就是 $s[]$ 每一个起点（或终点）开始的字符串与 $p[]$ 前面相同的长度。</p><p>朴素算法是枚举起点（或终点），发现匹配即可。</p><p>枚举起点，一直匹配直到不相同为止。</p><h3 id="2-优化（核心思想）"><a href="#2-优化（核心思想）" class="headerlink" title="2. 优化（核心思想）"></a>2. 优化（核心思想）</h3><p>定义 $next[i]$ 为以 i 结尾的模式串的前缀与后缀的相同最大长度（非自己）。</p><p>（ <del>大雾</del> ）</p><p>我们仔细想一想这句话，这句话是什么意思？</p><p>自己画个图，可以发现，当与字符串匹配时，如果当前匹配失败的话，我们需要倒退一定距离。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/aqcp4l3g.png"></p><p>为了使之继续匹配（而不是从头开始），我们需要当前的后缀要与原来的前缀相同，就可以继续尝试匹配。</p><p>也就是 (2) 处的后缀和 (1) 处相同。</p><p>但又因为 (1) 是 (2) 的前缀。</p><p>所以，我们要预处理当前的前缀和后缀相同的最大距离。</p><p>这个的最大距离，就是 $next[i]$。</p><p>这是 KMP 的核心，请务必理解。</p><p>怎样求 next 数组呢？</p><p>其实，求 next 数组时，就是自己与自己匹配的过程。</p><p>s[] 和 p[] 的匹配就是寻找 s[i] 的后缀和 p[] 的前缀的匹配的最大距离。</p><p>将 s[] 也换成 p[]，就是自我匹配。</p><p>上代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=len;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j!=<span class="number">0</span>&amp;&amp;p[j+<span class="number">1</span>]!=p[i]) j=ne[j];</span><br><span class="line"><span class="keyword">if</span> (p[j+<span class="number">1</span>]==p[i]) j++;</span><br><span class="line">ne[i]=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要匹配的话，照搬上面的即可，但注意如果匹配的话，要倒退一步，防止重复匹配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j&amp;&amp;s[i]!=p[j+<span class="number">1</span>]) j=ne[j];</span><br><span class="line"><span class="keyword">if</span> (p[j+<span class="number">1</span>]==s[i]) j++;</span><br><span class="line"><span class="keyword">if</span> (j==m) j=ne[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sqrt algorithm</title>
      <link href="/2021/12/17/Sqrt-algorithm/"/>
      <url>/2021/12/17/Sqrt-algorithm/</url>
      
        <content type="html"><![CDATA[<p>优雅的暴力，注意可以在线。</p><span id="more"></span><h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h2><h3 id="1-主要思想"><a href="#1-主要思想" class="headerlink" title="1. 主要思想"></a>1. 主要思想</h3><p>分块其实是一个很好的 “暴力”，在 oi 赛制中性价比很高。</p><p>很好写，且实际得分也不低。</p><p>首先，分块本身就是一种思想。</p><p>我们可以回忆一下这道题：</p><h4 id="T1：线段树1-你能回答这些问题吗2"><a href="#T1：线段树1-你能回答这些问题吗2" class="headerlink" title="T1：线段树1/你能回答这些问题吗2"></a>T1：线段树1/你能回答这些问题吗2</h4><p><a href="https://www.luogu.com.cn/problem/P3372">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/244/">题目传送门 AcWing</a></p><p>前面，我们使用了树状数组和线段树维护了本题。</p><p>现在，我们使用分块。</p><p>分块就是将整个序列分为若干个段（一般为 $\sqrt{n}$），然后每一段维护整段信息。</p><p>比如，我们现在要从 l 到 r 每个数加 d。</p><p>一类是整段直接加，另一类是朴素加。</p><p>整段的个数 $\leq \sqrt{n}$，首尾朴素个数 $\leq \sqrt{n}$。</p><p>询问也类似。</p><p>然后，怎样区间直接加呢？</p><p>其实，我们可以类比于线段树的 lazytag，对于整段维护一个 add，代表整段加了多少。</p><p>同时，我们要询问整段的总和，所以要维护 sum。</p><p>注意，一定要弄清 sum 与 add 的关系。</p><p>我的思想与代码，都是 sum 已经加过了 add，你也可以设为没有加过。</p><p>下面，我们以此题为例，具体分析怎样操作。</p><h3 id="2-操作"><a href="#2-操作" class="headerlink" title="2. 操作"></a>2. 操作</h3><h4 id="1）修改"><a href="#1）修改" class="headerlink" title="1）修改"></a>1）修改</h4><p>首先，维护整段。<br>$$<br>add=add+x,sum=sum+(now.r-now.l+1)\times d<br>$$<br>然后，朴素两边。<br>$$<br>a[i]=a[i]+x,sum[bel[i]]=sum[bel[i]]+d<br>$$<br>单次复杂度为 $O(\sqrt{n})$</p><h4 id="2）查询"><a href="#2）查询" class="headerlink" title="2）查询"></a>2）查询</h4><p>首先，直接加整段。<br>$$<br>ans=ans+sum[i]<br>$$<br>然后，朴素加。<br>$$<br>ans=ans+a[i]+add[bel[i]]<br>$$</p><h3 id="3-例题"><a href="#3-例题" class="headerlink" title="3. 例题"></a>3. 例题</h3><h4 id="T1：线段树1-你能回答这些问题吗2-1"><a href="#T1：线段树1-你能回答这些问题吗2-1" class="headerlink" title="T1：线段树1/你能回答这些问题吗2"></a>T1：线段树1/你能回答这些问题吗2</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(i) (i/len)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">400</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,len;</span><br><span class="line">ll add[M],sum[M],a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get</span>(l)==<span class="built_in">get</span>(r))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=l;i&lt;=r;++i) a[i]+=x,sum[<span class="built_in">get</span>(i)]+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=l,j=r;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">get</span>(i)==<span class="built_in">get</span>(l)) sum[<span class="built_in">get</span>(i)]+=x,a[i]+=x,i++;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">get</span>(j)==<span class="built_in">get</span>(r)) sum[<span class="built_in">get</span>(j)]+=x,a[j]+=x,j--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="built_in">get</span>(i);k&lt;=<span class="built_in">get</span>(j);++k) sum[k]+=len*x,add[k]+=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get</span>(l)==<span class="built_in">get</span>(r))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=l;i&lt;=r;++i) ans+=a[i]+add[<span class="built_in">get</span>(i)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=l,j=r;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">get</span>(i)==<span class="built_in">get</span>(l)) ans+=a[i]+add[<span class="built_in">get</span>(i)],i++;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">get</span>(j)==<span class="built_in">get</span>(r)) ans+=a[j]+add[<span class="built_in">get</span>(j)],j--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="built_in">get</span>(i);k&lt;=<span class="built_in">get</span>(j);++k) ans+=sum[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    len=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,a+i);</span><br><span class="line">        sum[<span class="built_in">get</span>(i)]+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l,r,x;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %d %d&quot;</span>,op,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(l,r));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="built_in">change</span>(l,r,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AcWing,Luogu 实测数据。</p><table><thead><tr><th>算法</th><th>Luogu 时间</th><th>AcWing 时间</th><th>理论复杂度</th><th>空间</th></tr></thead><tbody><tr><td>树状数组</td><td>131 ms</td><td>144 ms</td><td>$O(n\log n)$</td><td>5.71MB</td></tr><tr><td>线段树</td><td>246 ms</td><td>364 ms</td><td>$O(n\log n)$</td><td>7.49MB</td></tr><tr><td>分块</td><td>391 ms</td><td>891 ms</td><td>$O(n\sqrt n)$</td><td>1.34MB</td></tr></tbody></table><h2 id="块状链表"><a href="#块状链表" class="headerlink" title="块状链表"></a>块状链表</h2><h3 id="1-主要思想-1"><a href="#1-主要思想-1" class="headerlink" title="1. 主要思想"></a>1. 主要思想</h3><p>在上一题，我们使用了数组进行分块。</p><p>但是，如果是需要插入的话，我们就不得不换用另外的数据结构——链表。</p><p>加上分块，就有了一个高大上的名字：“块状链表”。</p><p>每两个块间，都有一个双向指针。</p><p>但是，又有不同的是，由于要支持插入，每一段的长度不是固定的。</p><h3 id="2-支持操作"><a href="#2-支持操作" class="headerlink" title="2. 支持操作"></a>2. 支持操作</h3><h4 id="a-插入"><a href="#a-插入" class="headerlink" title="a. 插入"></a>a. 插入</h4><p>首先，我们将要插入的节点所在块分裂开来，然后将插入的序列改为块状链表，插入即可。</p><h4 id="b-删除"><a href="#b-删除" class="headerlink" title="b. 删除"></a>b. 删除</h4><p>首先将前面节点的后面部分删除，然后删除中间完整节点，最后删除后面节点的前面部分。</p><p>删除前面部分时，我们可以将剩下元素直接复制到前面，更新长度即可。</p><h4 id="c-合并"><a href="#c-合并" class="headerlink" title="c. 合并"></a>c. 合并</h4><p>由于不停地分裂，可能导致节点很多而每一段很少，所以需要定期合并。</p><p>直接遍历整个块状链表，若下一个节点可以合并到当前节点，就合并。</p><p>合并结束后，每一个节点长度 $\geq \dfrac{\sqrt{n}}{2}$，总节点 $\leq 2\sqrt{n}$。</p><p>说实话，这可算是十分毒瘤的数据结构了。</p><p>主要是比较少写，而且没有固定的写法。</p><p>加油吧！</p><h3 id="3-例题-1"><a href="#3-例题-1" class="headerlink" title="3. 例题"></a>3. 例题</h3><h4 id="T2：-NOI2004-文本编辑器"><a href="#T2：-NOI2004-文本编辑器" class="headerlink" title="T2：[NOI2004]文本编辑器"></a>T2：[NOI2004]文本编辑器</h4><p><a href="https://www.luogu.com.cn/problem/P4008">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/949/">题目传送门 AcWing</a></p><p>可以用 Splay,也可以使用块状链表。</p><p>调了 2 个多小时后，AC 代码出炉了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2005</span>,M=<span class="number">2005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> s[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> c,l,r;</span><br><span class="line">&#125;p[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">2000005</span>];</span><br><span class="line"><span class="keyword">int</span> q[M],tt,x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[p[k].l].r=p[k].r;</span><br><span class="line">    p[p[k].r].l=p[k].l;</span><br><span class="line">    p[k].l=p[k].r=p[k].c=<span class="number">0</span>;</span><br><span class="line">    q[++tt]=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[k].r=p[x].r,p[p[x].r].l=k;</span><br><span class="line">    p[k].l=x,p[x].r=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prev</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!y)</span><br><span class="line">    &#123;</span><br><span class="line">        x=p[x].l;</span><br><span class="line">        y=p[x].c<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> y--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y!=p[x].c<span class="number">-1</span>) y++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        x=p[x].r;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=p[<span class="number">0</span>].r;</span><br><span class="line">    <span class="keyword">while</span> (k&gt;p[u].c) k-=p[u].c,u=p[u].r;</span><br><span class="line">    x=u,y=k<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y!=p[x].c<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=q[tt--];</span><br><span class="line">        <span class="built_in">add</span>(x,u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=y+<span class="number">1</span>;j&lt;p[x].c;++j) p[u].s[p[u].c++]=p[x].s[j];</span><br><span class="line">        p[x].c=y+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur=x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=q[tt--];</span><br><span class="line">        <span class="built_in">add</span>(cur,u);</span><br><span class="line">        <span class="keyword">while</span> (p[u].c&lt;N&amp;&amp;i&lt;k) p[u].s[p[u].c++]=str[i++];</span><br><span class="line">        cur=u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=p[<span class="number">0</span>].r;k;k=p[k].r)</span><br><span class="line">        <span class="keyword">while</span> (p[k].r&amp;&amp;p[k].c+p[p[k].r].c&lt;N)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=p[k].c,i=<span class="number">0</span>;i&lt;p[p[k].r].c;++i,++j) p[k].s[j]=p[p[k].r].s[i];</span><br><span class="line">            <span class="keyword">if</span> (x==p[k].r) x=k,y+=p[k].c;</span><br><span class="line">            p[k].c+=p[p[k].r].c;</span><br><span class="line">            <span class="built_in">del</span>(p[k].r);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x].c-y<span class="number">-1</span>&gt;=k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=y+<span class="number">1</span>,j=y+k+<span class="number">1</span>;j&lt;p[x].c;++i,++j) p[x].s[i]=p[x].s[j];</span><br><span class="line">        p[x].c-=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        k-=p[x].c-y<span class="number">-1</span>;</span><br><span class="line">        p[x].c=y+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p[x].r&amp;&amp;k&gt;p[p[x].r].c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur=p[x].r;</span><br><span class="line">            k-=p[cur].c;</span><br><span class="line">            <span class="built_in">del</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur=p[x].r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,j=k;j&lt;p[cur].c;++i,++j) p[cur].s[i]=p[cur].s[j];</span><br><span class="line">        p[cur].c-=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x].c-y<span class="number">-1</span>&gt;=k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i) <span class="built_in">putchar</span>(p[x].s[y+i+<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        k-=p[x].c-y<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=y+<span class="number">1</span>;i&lt;p[x].c;++i) <span class="built_in">putchar</span>(p[x].s[i]);</span><br><span class="line">        <span class="keyword">int</span> cur=x;</span><br><span class="line">        <span class="keyword">while</span> (p[cur].r&amp;&amp;k&gt;=p[p[cur].r].c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> r=p[cur].r;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p[r].c;++i) <span class="built_in">putchar</span>(p[r].s[i]);</span><br><span class="line">            k-=p[r].c;</span><br><span class="line">            cur=r;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=p[cur].r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i) <span class="built_in">putchar</span>(p[cur].s[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;AcWing947_1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;myans.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;M;++i) q[++tt]=i;</span><br><span class="line">    <span class="keyword">int</span> n,l;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">10</span>],c;</span><br><span class="line">    str[<span class="number">0</span>]=<span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">move</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op,<span class="string">&quot;Insert&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;l);</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;l)</span><br><span class="line">                <span class="keyword">if</span> ((c=<span class="built_in">getchar</span>())&gt;=<span class="number">32</span>&amp;&amp;c&lt;=<span class="number">126</span>) str[i++]=c;</span><br><span class="line">            <span class="built_in">insert</span>(l);</span><br><span class="line">            <span class="built_in">merge</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op,<span class="string">&quot;Move&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;l);</span><br><span class="line">            <span class="built_in">move</span>(l+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op,<span class="string">&quot;Delete&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;l);</span><br><span class="line">            <span class="built_in">remove</span>(l);</span><br><span class="line">            <span class="built_in">merge</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op,<span class="string">&quot;Get&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;l);</span><br><span class="line">            <span class="built_in">get</span>(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op,<span class="string">&quot;Prev&quot;</span>)==<span class="number">0</span>) <span class="built_in">prev</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op,<span class="string">&quot;Next&quot;</span>)==<span class="number">0</span>) <span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 分块 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫队</title>
      <link href="/2021/12/17/%E8%8E%AB%E9%98%9F/"/>
      <url>/2021/12/17/%E8%8E%AB%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<p>离线的区间统计一类问题的利器。</p><span id="more"></span><h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><h3 id="1-朴素莫队"><a href="#1-朴素莫队" class="headerlink" title="1. 朴素莫队"></a>1. 朴素莫队</h3><p>就是优化暴力，当你不知道怎么做时，就可以考虑莫队了。</p><h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h3><p>我们从例题中学习。</p><h4 id="T1：HH的项链"><a href="#T1：HH的项链" class="headerlink" title="T1：HH的项链"></a>T1：HH的项链</h4><p><a href="https://www.acwing.com/problem/content/2494/">题目传送门 AcWing</a></p><p><a href="https://www.luogu.com.cn/problem/P1972">题目传送门 Luogu</a></p><p>这道题是模板莫队题。</p><p>首先考虑朴素（暴力），就是直接用 Hash 统计出现次数，并且输出即可。</p><p>时间复杂度为 $O(mn+ms)$ （s 表示颜色的总数）。</p><p>当然可以不用扫描整个数组，如果没统计过的话，就 ans 加一。</p><p>时间复杂度为 $O(mn)$。</p><p>继续考虑优化。</p><p>我们还没有充分利用以前的信息。</p><p>比如从 $[i_1\sim j_1]$ 到 $[i_2\sim j_2]$，我们可以使用指针，从 $i_1$ 移动到 $i_2$，并统计，从 $j_1$ 移动到 $j_2$，统计后，在扫描（也可以实时统计）。</p><p>于是现在我们关心的就是 $|i_1-i_2|$ 和 $|j_1-j_2|$，但是最坏情况仍然为 $O(n)$，没有得到优化。</p><p>现在就要搬出我们的大法——莫队算法！</p><p>莫队算法是一种离线算法，它通过对询问进行适当的排序降低复杂度。</p><p>我们既要使左边走的小，又要使右边走的小，要平衡两个距离，</p><p>就是分块算法！</p><p>回忆分块算法，我们要平衡块的长度和块的个数，于是就有了分块。</p><p>所以说，莫队实质就是一种分块。</p><p>排序需要有两个关键字，第一关键字是左端点所在块编号，第二是右端点。</p><p>注意，我们是用左端点分块排序！</p><p>设块的长度为 T，则单次左端点移动的复杂度为 $O(T)$，在同一块中，右端点移动的复杂度为 $O(n)$。</p><p>总时间复杂度为 $O(Tm+\dfrac{n^2}{T})$.</p><p>在 $T=\sqrt{\dfrac{n^2}{m}}$ 时取得最小值，即为 $O(n\sqrt m)$。</p><p>另外，还有一个 <del>玄学</del> 优化，就是奇数块递增排序，偶数块递减排序，就可以使右端点走的距离少一些。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,id;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,len,ans[N],cnt[N],a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(re <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x/len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Query &amp;a,<span class="keyword">const</span> Query &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="built_in">get</span>(a.l),j=<span class="built_in">get</span>(b.l);</span><br><span class="line">    <span class="keyword">if</span> (i!=j) <span class="keyword">return</span> i&lt;j;</span><br><span class="line">    <span class="keyword">return</span> (a.r&lt;b.r)^(i&amp;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(re <span class="keyword">int</span> x,<span class="keyword">int</span> &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cnt[a[x]]) res++;</span><br><span class="line">    cnt[a[x]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(re <span class="keyword">int</span> x,<span class="keyword">int</span> &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt[a[x]]--;</span><br><span class="line">    <span class="keyword">if</span> (!cnt[a[x]]) res--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(re <span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c=<span class="built_in">getchar</span>())&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) ;</span><br><span class="line">    x=c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c=<span class="built_in">getchar</span>())&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    len=<span class="number">1620</span>;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(q[i].l),<span class="built_in">read</span>(q[i].r);</span><br><span class="line">        q[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+m+<span class="number">1</span>,cmp);</span><br><span class="line">    re <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>,l=<span class="number">1</span>,r=<span class="number">0</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (l&gt;q[i].l) <span class="built_in">add</span>(--l,res);</span><br><span class="line">        <span class="keyword">while</span> (l&lt;q[i].l) <span class="built_in">del</span>(l++,res);</span><br><span class="line">        <span class="keyword">while</span> (r&lt;q[i].r) <span class="built_in">add</span>(++r,res);</span><br><span class="line">        <span class="keyword">while</span> (r&gt;q[i].r) <span class="built_in">del</span>(r--,res);</span><br><span class="line">        ans[q[i].id]=res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>洛谷上数据有点强，莫队现在过不了。</p><h3 id="3-带修改的莫队"><a href="#3-带修改的莫队" class="headerlink" title="3. 带修改的莫队"></a>3. 带修改的莫队</h3><p>将一维转化为二维，另一维是时间轴。</p><p>l 到 r 的维护仍然简单，现在我们来讨论当 t 变化时的维护：</p><p>如果是不在该区间内的话，我们就直接不管。</p><p>如果在的话，就直接加。</p><p>但是这里有个问题：怎样修改而不覆盖原来的数？</p><p>有一个比较取巧的方法：经过该操作时，直接将原数组的数与修改的数交换。</p><p>这样以便于我们回来时可以覆盖回来。</p><p>下面一个问题是：怎样排序？</p><p>显而易见的方法是：按三个关键字排序，分别为 l 所在编号，r 所在编号，t。</p><p>t 表示走到了第几次修改操作，设总修改操作为 t.</p><p>设块的大小为 T,则下面三种的复杂度为：</p><p>l:$O(Tm)$,r:$O(Tm+\dfrac{n^2}{T})$,t:$O(\dfrac{n^2t}{T^2})$</p><p>其中，l 单次移动复杂度为 $O(T)$，r 在同一块单次复杂度为 $O(T)$,区间内移动为 $O(n)$，有 $\dfrac{n}{T}$ 个，t 每一小块为 $O(t)$。</p><p>一般 n 和 m 同级别，当 $Tm+\dfrac{n^2}{T}=\dfrac{n^2t}{T}$，即 $Tn=\dfrac{n^2t}{T},T=\sqrt[3]{nt}$，总复杂度最小，为 $O(\sqrt[3]{n^4t})$。</p><h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4. 例题"></a>4. 例题</h3><h4 id="T2：-国家集训队-数颜色-维护队列"><a href="#T2：-国家集训队-数颜色-维护队列" class="headerlink" title="T2：[国家集训队]数颜色 / 维护队列"></a>T2：[国家集训队]数颜色 / 维护队列</h4><p><a href="https://www.luogu.com.cn/problem/P1903">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2523/">题目传送门 AcWing</a></p><p>上面的模板题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1.5e5</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,l,r,t;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Modify</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos,t;</span><br><span class="line">&#125;c[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[N],cnt[M],n,m,cm,qm,len,a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(re <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x/len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Query &amp;a,<span class="keyword">const</span> Query &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> i1=<span class="built_in">get</span>(a.l),i2=<span class="built_in">get</span>(b.l);</span><br><span class="line">    re <span class="keyword">int</span> j1=<span class="built_in">get</span>(a.r),j2=<span class="built_in">get</span>(b.r);</span><br><span class="line">    <span class="keyword">if</span> (i1!=i2) <span class="keyword">return</span> i1&lt;i2;</span><br><span class="line">    <span class="keyword">if</span> (j1!=j2) <span class="keyword">return</span> j1&lt;j2;</span><br><span class="line">    <span class="keyword">return</span> a.t&lt;b.t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(re <span class="keyword">int</span> a,<span class="keyword">int</span> &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cnt[a]) res++;</span><br><span class="line">    cnt[a]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(re <span class="keyword">int</span> a,<span class="keyword">int</span> &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt[a]--;</span><br><span class="line">    <span class="keyword">if</span> (!cnt[a]) res--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(re <span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c=<span class="built_in">getchar</span>())&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) ;</span><br><span class="line">    x=c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c=<span class="built_in">getchar</span>())&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        re <span class="keyword">char</span> op[<span class="number">2</span>];re <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="built_in">read</span>(a);<span class="built_in">read</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>) ++qm,q[qm]=(Query)&#123;qm,a,b,cm&#125;;</span><br><span class="line">        <span class="keyword">else</span> ++cm,c[cm]=(Modify)&#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    len=<span class="built_in">pow</span>((<span class="keyword">double</span>)n*cm,<span class="number">1.0</span>/<span class="number">3.0</span>);<span class="comment">//pow((double)n*n,1.0/3.0)</span></span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+qm+<span class="number">1</span>,cmp);</span><br><span class="line">    re <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> k=<span class="number">1</span>,i=<span class="number">1</span>,j=<span class="number">0</span>,tnow=<span class="number">0</span>;k&lt;=qm;++k)</span><br><span class="line">    &#123;</span><br><span class="line">        re <span class="keyword">int</span> id=q[k].id,l=q[k].l,r=q[k].r,t=q[k].t;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;l) <span class="built_in">add</span>(a[--i],res);</span><br><span class="line">        <span class="keyword">while</span> (i&lt;l) <span class="built_in">del</span>(a[i++],res);</span><br><span class="line">        <span class="keyword">while</span> (j&lt;r) <span class="built_in">add</span>(a[++j],res);</span><br><span class="line">        <span class="keyword">while</span> (j&gt;r) <span class="built_in">del</span>(a[j--],res);</span><br><span class="line">        <span class="keyword">while</span> (tnow&lt;t)</span><br><span class="line">        &#123;</span><br><span class="line">            ++tnow;</span><br><span class="line">            <span class="keyword">if</span> (c[tnow].pos&gt;=i&amp;&amp;c[tnow].pos&lt;=j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">del</span>(a[c[tnow].pos],res);</span><br><span class="line">                <span class="built_in">add</span>(c[tnow].t,res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(a[c[tnow].pos],c[tnow].t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (tnow&gt;t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[tnow].pos&gt;=i&amp;&amp;c[tnow].pos&lt;=j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">del</span>(a[c[tnow].pos],res);</span><br><span class="line">                <span class="built_in">add</span>(c[tnow].t,res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(a[c[tnow].pos],c[tnow].t);</span><br><span class="line">            tnow--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[id]=res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=qm;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-回滚莫队"><a href="#5-回滚莫队" class="headerlink" title="5. 回滚莫队"></a>5. 回滚莫队</h3><p>可以发现，有一些莫队，加入操作很好操作，但是删除却不是，所以我们要使用回滚莫队。</p><p>我们还是以一道题来看：</p><h4 id="T2：-JOI2013-历史研究"><a href="#T2：-JOI2013-历史研究" class="headerlink" title="T2：[JOI2013]历史研究"></a>T2：[JOI2013]历史研究</h4><p><a href="https://www.luogu.com.cn/problem/AT1219">题目传送门 Luogu(AtCoder-RemoteJudge)</a></p><p><a href="https://www.acwing.com/problem/content/2525/">题目传送门 AcWing</a></p><p>这道题要维护重要度的最大值，由于如果删除，不好维护最大值。</p><p>处理当前块的询问。</p><p>如果右端点在该块里，直接暴力即可，复杂度为 $O(\sqrt n)$。</p><p>如果不在的话，维护下一块开始节点开始的 cnt，的由于右端点是递增，走到每一个询问时直接再暴力加入块内的长度暴力即可。</p><p>画个图，其实就是同一块内的每个询问单独处理，块外的一起处理。</p><p>可以看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,l,r;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],n,len,m,cnt[N];</span><br><span class="line">ll ans[N];</span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x/len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Query &amp;a,<span class="keyword">const</span> Query &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="built_in">get</span>(a.l),j=<span class="built_in">get</span>(b.l);</span><br><span class="line">    <span class="keyword">if</span> (i!=j) <span class="keyword">return</span> i&lt;j;</span><br><span class="line">    <span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,ll &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt[a]++;</span><br><span class="line">    res=<span class="built_in">max</span>(res,(ll)nums[a]*cnt[a]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i),nums.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;q[i].l,&amp;q[i].r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) q[i].id=i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i]=<span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),a[i])-nums.<span class="built_in">begin</span>();</span><br><span class="line">    </span><br><span class="line">    len=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+m+<span class="number">1</span>,cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=m;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=x;</span><br><span class="line">        <span class="keyword">while</span> (y&lt;=m&amp;&amp;<span class="built_in">get</span>(q[y].l)==<span class="built_in">get</span>(q[x].l)) y++;</span><br><span class="line">        <span class="keyword">int</span> node=<span class="built_in">get</span>(q[x].l)*len+len<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (x&lt;=m&amp;&amp;q[x].r&lt;=node)</span><br><span class="line">        &#123;</span><br><span class="line">            ll res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=q[x].l;i&lt;=q[x].r;++i) <span class="built_in">add</span>(a[i],res);</span><br><span class="line">            ans[q[x].id]=res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=q[x].l;i&lt;=q[x].r;++i) cnt[a[i]]--;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ll res=<span class="number">0</span>;<span class="keyword">int</span> j=node;</span><br><span class="line">        <span class="keyword">while</span> (x&lt;y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l=node+<span class="number">1</span>,r=q[x].r;</span><br><span class="line">            <span class="keyword">while</span> (j&lt;r) <span class="built_in">add</span>(a[++j],res);</span><br><span class="line">            ll bac=res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=q[x].l;k&lt;=node;++k) <span class="built_in">add</span>(a[k],res);</span><br><span class="line">            ans[q[x].id]=res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=q[x].l;k&lt;=node;++k) cnt[a[k]]--;</span><br><span class="line">            res=bac;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-树上莫队"><a href="#6-树上莫队" class="headerlink" title="6. 树上莫队"></a>6. 树上莫队</h3><h4 id="T3：树上计数2"><a href="#T3：树上计数2" class="headerlink" title="T3：树上计数2"></a>T3：树上计数2</h4><p><a href="https://www.acwing.com/problem/content/2536/">题目传送门 AcWing</a></p><p>和 <a href="https://www.acwing.com/problem/content/2494/">HH 的项链</a> 类似，这也是统计当前不同的个数。</p><p>主要区别是怎样在树上操作？</p><p>这里我们要使用一种序列：欧拉序列。</p><p>欧拉序列实现过程就是先写当前节点，遍历完子树后，写一遍当前序列。</p><p>很明显的性质是：每一个点都写了两遍。</p><p>怎样将树上的序列转化为欧拉序列呢？</p><p>对于每一个节点，我们记录两个：$first[u]$ 表示第一次出现的位置，$last[u]$ 表示最后一次出现的位置。</p><p>现在要找 $(x,y)(first[x]&lt;fisrt[y])$ 的路径，分为以下两种情况：</p><ol><li>$\operatorname{lca}(x,y)=x$ ，则 $[first[x],first[y]]$ 序列中出现一次的点。</li><li>$\operatorname{lca}(x,y)\not=x$，则 $[last[x],first[y]]$ 中出现一次的点加上 $\operatorname{lca}(x,y)$ 就是该点。</li></ol><p>于是，我们就变成的统计在一个序列中，只出现一次的点不同颜色的点的个数。</p><p>在原来的莫队上，我们可以再加一个数组，表示出现了几次。</p><p>还有，不论是 add 还是 del，都是对出现次数异或 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>,L=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,l,r,L;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],n,m,len,fi[N],la[N],top,dep[N];</span><br><span class="line"><span class="keyword">int</span> euler[M],ans[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N],tim[N];</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx,f[N][L+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x/len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Query &amp;a,<span class="keyword">const</span> Query &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="built_in">get</span>(a.l),j=<span class="built_in">get</span>(b.l);</span><br><span class="line">    <span class="keyword">if</span> (i!=j) <span class="keyword">return</span> i&lt;j;</span><br><span class="line">    <span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>]=fa;</span><br><span class="line">    fi[x]=++top;euler[top]=x;</span><br><span class="line">    dep[x]=dep[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=L;++i) f[x][i]=f[f[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">        <span class="keyword">if</span> (!f[e[i]][<span class="number">0</span>]) <span class="built_in">dfs</span>(e[i],x);</span><br><span class="line">    la[x]=++top;euler[top]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x]&lt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=L;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span> (dep[f[x][i]]&gt;=dep[y]) x=f[x][i];</span><br><span class="line">    <span class="keyword">if</span> (x==y) <span class="keyword">return</span> x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=L;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span> (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tim[pos]^=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tim[pos])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cnt[a[pos]]) res++;</span><br><span class="line">        cnt[a[pos]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cnt[a[pos]]--;</span><br><span class="line">        <span class="keyword">if</span> (!cnt[a[pos]]) res--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) nums.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i]=<span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),a[i])-nums.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,a,b;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add_edge</span>(a,b);<span class="built_in">add_edge</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    len=<span class="built_in">sqrt</span>(top);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,a,b;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span> (fi[a]&gt;fi[b]) <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="keyword">int</span> l=<span class="built_in">lca</span>(a,b);</span><br><span class="line">        <span class="keyword">if</span> (l==a) q[i]=(Query)&#123;i,fi[a],fi[b]&#125;;</span><br><span class="line">        <span class="keyword">else</span> q[i]=(Query)&#123;i,la[a],fi[b],l&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(q,q+m,cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>,i=<span class="number">1</span>,j=<span class="number">0</span>,res=<span class="number">0</span>;k&lt;=m;++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l=q[k].l,r=q[k].r,id=q[k].id,p=q[k].L;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;l) <span class="built_in">add</span>(euler[--i],res);</span><br><span class="line">        <span class="keyword">while</span> (i&lt;l) <span class="built_in">add</span>(euler[i++],res);</span><br><span class="line">        <span class="keyword">while</span> (j&lt;r) <span class="built_in">add</span>(euler[++j],res);</span><br><span class="line">        <span class="keyword">while</span> (j&gt;r) <span class="built_in">add</span>(euler[j--],res);</span><br><span class="line">        <span class="keyword">if</span> (p) <span class="built_in">add</span>(p,res);</span><br><span class="line">        ans[id]=res;</span><br><span class="line">        <span class="keyword">if</span> (p) <span class="built_in">add</span>(p,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-二次离线莫队"><a href="#7-二次离线莫队" class="headerlink" title="7. 二次离线莫队"></a>7. 二次离线莫队</h3><h4 id="T4：二次离线莫队"><a href="#T4：二次离线莫队" class="headerlink" title="T4：二次离线莫队"></a>T4：二次离线莫队</h4><p><a href="https://www.luogu.com.cn/problem/P4887">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2537/">题目传送门 AcWing</a></p><p>二次离线，顾名思义，就是一次后再离线一次。</p><p>假设要从 $[L,R]$ 到 $[l,r]$，且 $r&gt;R$。</p><p>我们要将 $[L,R]$ 扩展到 $[L,R+1]$，需要知道 $[L,R]$ 与 R+1 的配对数。</p><p>又可以改为前缀和 $ans{[L,R]}=s[R]-s[L-1]$。</p><p>首先考虑第一种询问。</p><p>其中 $s[R]$ 表示与 R+1 的配对个数，可以改为 $f(R)$。</p><p>可以改写为 $g(x)$，表示前 i 个数与 x 配对的数（注意，i 一直在变化）。</p><p>现在考虑如何计算，可以发现其实就是开始有 k 个 1 的数与当前数进行异或，得到的数就是需要更新的数。</p><p>具体的，如果用 $a_i$ 表示所有是 k 个一的数，x 是当前数，那么 $a_i$^x 就是我们要找的 $b_i$，因为 $b_i$^x=$a_i$。</p><p>现在我们就维护好了 $g(x)$，而且可以一直更新。</p><p>下面，我们考虑维护 $s[L-1]$。</p><p>问题转化为 $[1,L-1]$ 与 $[R+1,r]$ 的配对数。</p><p>进行第二次离线，我们首先将所有的询问存起来。</p><p>观察到 $[1,L-1]$ 只有一个参量，我们考虑枚举该参量并暴力求。</p><p>像上面一样，我们也同时维护 $g(x)$，表示前 i 个数与 x 的配对数。</p><p>该询问的复杂度就是 $O(r-R)$，是区间长度的线性复杂度。总时间复杂度为 $O(n\sqrt n)$。</p><p>至此，得到解决！</p><p>其他的变化，请读者自行推导。</p><p>当然也可以看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=(<span class="number">1</span>&lt;&lt;<span class="number">14</span>)+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N],g[M];</span><br><span class="line"><span class="keyword">int</span> a[N],n,m,k,len;</span><br><span class="line">ll ans[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,l,r;</span><br><span class="line">    ll res;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,l,r,t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector &lt;Range&gt; rg[N];</span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x/len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Query &amp;a,<span class="keyword">const</span> Query &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="built_in">get</span>(a.l),j=<span class="built_in">get</span>(b.l);</span><br><span class="line">    <span class="keyword">if</span> (i!=j) <span class="keyword">return</span> i&lt;j;</span><br><span class="line">    <span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_count</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x)</span><br><span class="line">    &#123;</span><br><span class="line">        res++;</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) q[i].id=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;q[i].l,&amp;q[i].r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;<span class="number">14</span>);++i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get_count</span>(i)==k) nums.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();++j) g[nums[j]^a[i]]++;</span><br><span class="line">        f[i]=g[a[i+<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+m+<span class="number">1</span>,cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,L=<span class="number">1</span>,R=<span class="number">0</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l=q[i].l,r=q[i].r;</span><br><span class="line">        ll &amp;res=q[i].res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (R&gt;r) rg[L<span class="number">-1</span>].<span class="built_in">push_back</span>((Range)&#123;i,r+<span class="number">1</span>,R,<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (R&gt;r) res-=f[--R];</span><br><span class="line">        <span class="keyword">if</span> (R&lt;r) rg[L<span class="number">-1</span>].<span class="built_in">push_back</span>((Range)&#123;i,R+<span class="number">1</span>,r,<span class="number">-1</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (R&lt;r) res+=f[R++];</span><br><span class="line">        <span class="keyword">if</span> (L&gt;l) rg[R].<span class="built_in">push_back</span>((Range)&#123;i,l,L<span class="number">-1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (L&gt;l) res-=f[L<span class="number">-2</span>]+!k,L--;</span><br><span class="line">        <span class="keyword">if</span> (L&lt;l) rg[R].<span class="built_in">push_back</span>((Range)&#123;i,L,l<span class="number">-1</span>,<span class="number">-1</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (L&lt;l) res+=f[L<span class="number">-1</span>]+!k,L++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();++j) g[nums[j]^a[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;rg[i].<span class="built_in">size</span>();++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Range &amp;tmp=rg[i][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x=tmp.l;x&lt;=tmp.r;++x) q[tmp.id].res+=g[a[x]]*tmp.t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;++i) q[i].res+=q[i<span class="number">-1</span>].res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) ans[q[i].id]=q[i].res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 莫队 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树链剖分</title>
      <link href="/2021/12/17/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
      <url>/2021/12/17/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>可以将树上操作转化为区间操作。</p><span id="more"></span><h2 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h2><h3 id="1-主要思想"><a href="#1-主要思想" class="headerlink" title="1. 主要思想"></a>1. 主要思想</h3><p>通过给每一个节点一个重新的编号，使任意一条路径都变为不超过 $\log n$ 个连续区间。</p><p>于是，就可以<strong>将树上操作转化为区间操作</strong>。</p><p>并且是维护每一个点。</p><p>然后，一般使用线段树 or 树状数组实现。</p><h3 id="2-核心"><a href="#2-核心" class="headerlink" title="2. 核心"></a>2. 核心</h3><p>一般来说，使用轻重链剖分。</p><p>将一个节点的儿子分为重儿子与轻儿子。</p><p>重儿子是指儿子所在子树最大的儿子，其余的为轻儿子。</p><p>如果有相同的话，任取一个即可。</p><p>重边就是指节点到重儿子的边。</p><p>重链是指极大的重边组成的路径。特别的，单个节点也可以做一条重链。</p><p>这样操作之后，每一个节点都在一条重链中。</p><p>我们在建立线段树时（即剖分时），要优先遍历重儿子。</p><p>这样就可以保证重链所在的线段树是连续的区间。</p><p>于是，任意一条路径都可以分为 $\log n$ 个区间。</p><p>这里先不证明了，可以自行理解。</p><h3 id="3-具体流程"><a href="#3-具体流程" class="headerlink" title="3. 具体流程"></a>3. 具体流程</h3><h4 id="1）预处理"><a href="#1）预处理" class="headerlink" title="1）预处理"></a>1）预处理</h4><p>首先遍历一遍，记录 size，并计算重儿子。</p><p>第二次，将树上节点按照重儿子优先的次序遍历，并转化到线段树上。</p><h4 id="2）询问-更改"><a href="#2）询问-更改" class="headerlink" title="2）询问/更改"></a>2）询问/更改</h4><p>对于两个节点，如果他们不在同一重链，那么选择 $top$ 深度较大的点向上跳（即到 $x$ 到 $top$ 进行区间修改，在同一重链），直到在同一重链，直接区间修改。</p><p>如果还有不懂的，可以再看一下前面的解释结合后面的代码进行理解。</p><h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4. 例题"></a>4. 例题</h3><h4 id="T1：树链剖分"><a href="#T1：树链剖分" class="headerlink" title="T1：树链剖分"></a>T1：树链剖分</h4><p><a href="https://www.luogu.com.cn/problem/P3384">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2570/">题目传送门 AcWing</a></p><p>模板题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(p) (p&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(p) (p&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> sz[N],dep[N],son[N],f[N],top[N];</span><br><span class="line"><span class="keyword">int</span> id[N],nw[N],cnt,a[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    ll lt,sum;</span><br><span class="line">&#125;tr[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">    e[idx]=a,ne[idx]=h[b],h[b]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa,<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x]=fa;</span><br><span class="line">    vis[x]=<span class="number">1</span>;sz[x]=<span class="number">1</span>;dep[x]=depth; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(e[i],x,depth+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (sz[e[i]]&gt;sz[son[x]]) son[x]=e[i];</span><br><span class="line">            sz[x]+=sz[e[i]];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[x]=++cnt,nw[cnt]=x,top[x]=t;</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x],t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i]==f[x]||e[i]==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(e[i],e[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PreWork</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].sum=tr[<span class="built_in">l</span>(p)].sum+tr[<span class="built_in">r</span>(p)].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].lt==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    Node &amp;rt=tr[p],&amp;le=tr[<span class="built_in">l</span>(p)],&amp;ri=tr[<span class="built_in">r</span>(p)];</span><br><span class="line">    le.sum+=(le.r-le.l+<span class="number">1</span>)*rt.lt;le.lt+=rt.lt;</span><br><span class="line">    ri.sum+=(ri.r-ri.l+<span class="number">1</span>)*rt.lt;ri.lt+=rt.lt;</span><br><span class="line">    rt.lt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p]=(Node)&#123;l,r&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum=a[nw[l]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">l</span>(p),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">r</span>(p),mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].l&gt;=l&amp;&amp;tr[p].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].lt+=x;</span><br><span class="line">        tr[p].sum+=x*(tr[p].r-tr[p].l+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid=tr[p].l+tr[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=mid) <span class="built_in">modify</span>(<span class="built_in">l</span>(p),l,r,x);</span><br><span class="line">    <span class="keyword">if</span> (r&gt;mid) <span class="built_in">modify</span>(<span class="built_in">r</span>(p),l,r,x);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].l&gt;=l&amp;&amp;tr[p].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid=tr[p].l+tr[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=mid) ans+=<span class="built_in">query</span>(<span class="built_in">l</span>(p),l,r);</span><br><span class="line">    <span class="keyword">if</span> (r&gt;mid) ans+=<span class="built_in">query</span>(<span class="built_in">r</span>(p),l,r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SegmentTree</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_path</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u]!=top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,id[top[u]],id[u],x);</span><br><span class="line">        u=f[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>,<span class="built_in">min</span>(id[u],id[v]),<span class="built_in">max</span>(id[u],id[v]),x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_tree</span><span class="params">(<span class="keyword">int</span> u,ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>,id[u],id[u]+sz[u]<span class="number">-1</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query_path</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[u]!=top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">        ans+=<span class="built_in">query</span>(<span class="number">1</span>,id[top[u]],id[u]);</span><br><span class="line">        u=f[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=<span class="built_in">query</span>(<span class="number">1</span>,<span class="built_in">min</span>(id[u],id[v]),<span class="built_in">max</span>(id[u],id[v]));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query_tree</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>,id[u],id[u]+sz[u]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    ll p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %lld&quot;</span>,&amp;n,&amp;m,&amp;r,&amp;p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,a,b;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(r,<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(r,r);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">int</span> op,u,v;</span><br><span class="line">    ll k;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;op,&amp;u);</span><br><span class="line">        <span class="keyword">if</span> (op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %lld&quot;</span>,&amp;v,&amp;k);</span><br><span class="line">            <span class="built_in">update_path</span>(u,v,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;k);</span><br><span class="line">            <span class="built_in">update_tree</span>(u,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query_path</span>(u,v)%p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op==<span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query_tree</span>(u)%p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2：-NOI2015-软件包管理器"><a href="#T2：-NOI2015-软件包管理器" class="headerlink" title="T2：[NOI2015]软件包管理器"></a>T2：[NOI2015]软件包管理器</h4><p><a href="https://www.luogu.com.cn/problem/P2146">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/920/">题目传送门 AcWing</a></p><p>首先，经过冗长的描述，我们可以知道该依赖关系构成一棵树。</p><p>当要卸载一个软件时，就是将该子树的所有节点状态改为 0。</p><p>如果要安装某个节点 x，等价于将根节点到 x 的路径上的节点状态改为 1。</p><p>输出就是所维护线段树的根节点的信息。</p><p>几乎就是模板题了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(p) (p&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(p) (p&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> sz[N],son[N],dep[N],f[N];</span><br><span class="line"><span class="keyword">int</span> id[N],nw[N],cnt,top[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> sum,flag;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _l,<span class="keyword">int</span> _r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        l=_l;r=_r;</span><br><span class="line">        sum=<span class="number">0</span>;flag=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa,<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x]=fa;dep[x]=depth;sz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i]!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(e[i],x,depth+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (sz[e[i]]&gt;sz[son[x]]) son[x]=e[i];</span><br><span class="line">            sz[x]+=sz[e[i]];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[x]=++cnt,nw[cnt]=x,top[x]=t;</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x],t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i]==son[x]||e[i]==f[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(e[i],e[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Prework</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].sum=tr[<span class="built_in">l</span>(p)].sum+tr[<span class="built_in">r</span>(p)].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (~tr[p].flag)</span><br><span class="line">    &#123;</span><br><span class="line">        Node &amp;rt=tr[p],&amp;le=tr[<span class="built_in">l</span>(p)],&amp;ri=tr[<span class="built_in">r</span>(p)];</span><br><span class="line">        le.flag=rt.flag,le.sum=(le.r-le.l+<span class="number">1</span>)*rt.flag;</span><br><span class="line">        ri.flag=rt.flag,ri.sum=(ri.r-ri.l+<span class="number">1</span>)*rt.flag;</span><br><span class="line">        rt.flag=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].<span class="built_in">init</span>(l,r);</span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">l</span>(p),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">r</span>(p),mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].l&gt;=l&amp;&amp;tr[p].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].flag=x;</span><br><span class="line">        tr[p].sum=x*(tr[p].r-tr[p].l+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid=tr[p].l+tr[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=mid) <span class="built_in">modify</span>(<span class="built_in">l</span>(p),l,r,x);</span><br><span class="line">    <span class="keyword">if</span> (r&gt;mid) <span class="built_in">modify</span>(<span class="built_in">r</span>(p),l,r,x);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Segment Tree</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_path</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u]!=top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,id[top[u]],id[u],x);</span><br><span class="line">        u=f[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (id[u]&gt;id[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>,id[u],id[v],x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>,f;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;f);f++;</span><br><span class="line">        <span class="built_in">add</span>(f,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">15</span>];<span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,op,&amp;x);x++;</span><br><span class="line">        <span class="keyword">int</span> last=tr[<span class="number">1</span>].sum;</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">&#x27;u&#x27;</span>) <span class="built_in">modify</span>(<span class="number">1</span>,id[x],id[x]+sz[x]<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify_path</span>(<span class="number">1</span>,x,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">abs</span>(tr[<span class="number">1</span>].sum-last));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树链剖分 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左偏树</title>
      <link href="/2021/12/17/%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
      <url>/2021/12/17/%E5%B7%A6%E5%81%8F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>又叫可合并堆。</p><span id="more"></span><h2 id="左偏树"><a href="#左偏树" class="headerlink" title="左偏树"></a>左偏树</h2><h3 id="1-本质与基本功能"><a href="#1-本质与基本功能" class="headerlink" title="1. 本质与基本功能"></a>1. 本质与基本功能</h3><p>左偏树本质是堆。</p><p>支持功能：</p><ol><li>插入一个数 $O(\log n)$</li><li>求最小值 $O(1)$</li><li>删除最小值 $O(\log n)$</li><li>合并两棵左偏树 $O(\log n)$</li></ol><h3 id="2-维护信息"><a href="#2-维护信息" class="headerlink" title="2. 维护信息"></a>2. 维护信息</h3><ol><li>值 val</li><li>到最近空节点的距离 dis</li></ol><p>左偏树必须满足：$dis(leftchild) \geq dis(rightchild)$</p><p>下面我们证明这样一个性质：<br>$$<br>dis(root)\leq \log n<br>$$<br>这个等价于 $f(k)=2^k-1$，其中 $f(k)$ 表示当根节点的距离为 k 时，包含的最少节点个数。</p><p>可以使用数学归纳法。</p><p>对于 $k=1,f(k)-2^k-1$。</p><p>$f(k)=f(k’)+(2^{k-1}+1)(k’\geq k-1)$，其中 $f (k’)$ 是左子树的最少节点个数。</p><p>可以发现 f 函数是单调递增的，则 $f(k’)\geq f(k-1)=2^{k-1}+1$，带入原式即可。</p><h3 id="3-特殊函数——merge"><a href="#3-特殊函数——merge" class="headerlink" title="3. 特殊函数——merge"></a>3. 特殊函数——merge</h3><p>由于前 3 个操作都比较简单，且是堆的基本操作，所以只讲最后一个。</p><p>$\operatorname{merge}(x,y)$ 直接进入较大 $dis$ 的节点的右子树，直到为空，然后并上去即可。</p><p>注意回溯时要注意维护左偏树。</p><h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4. 例题"></a>4. 例题</h3><h4 id="T1：左偏树（可并堆）"><a href="#T1：左偏树（可并堆）" class="headerlink" title="T1：左偏树（可并堆）"></a>T1：左偏树（可并堆）</h4><p><a href="https://www.luogu.com.cn/problem/P3377">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2716/">题目传送门 AcWing</a></p><p>可以使用并查集来维护数之间的合并关系。</p><p>AcWing 不需讨论已被删除的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,v,p,dis;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) tr[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) tr[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> v(x) tr[x].v</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> p(x) tr[x].p</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> d(x) tr[x].dis</span></span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">v</span>(a)!=<span class="built_in">v</span>(b)) <span class="keyword">return</span> <span class="built_in">v</span>(a)&lt;<span class="built_in">v</span>(b);</span><br><span class="line">    <span class="keyword">return</span> a&lt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(b,a)) <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="built_in">r</span>(a)=<span class="built_in">merge</span>(<span class="built_in">r</span>(a),b);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">d</span>(<span class="built_in">r</span>(a))&gt;<span class="built_in">d</span>(<span class="built_in">l</span>(a))) <span class="built_in">swap</span>(<span class="built_in">r</span>(a),<span class="built_in">l</span>(a));</span><br><span class="line">    <span class="built_in">d</span>(a)=<span class="built_in">d</span>(<span class="built_in">r</span>(a))+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">p</span>(x)!=x) <span class="built_in">p</span>(x)=<span class="built_in">find</span>(<span class="built_in">p</span>(x));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">p</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">v</span>(<span class="number">0</span>)=INF;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t,x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;t,&amp;x);</span><br><span class="line">        <span class="keyword">if</span> (t==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">v</span>(++idx)=x;</span><br><span class="line">            <span class="built_in">d</span>(idx)=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">p</span>(idx)=idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;y);</span><br><span class="line">            x=<span class="built_in">find</span>(x);y=<span class="built_in">find</span>(y);</span><br><span class="line">            <span class="keyword">if</span> (x!=y)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">cmp</span>(y,x)) <span class="built_in">swap</span>(x,y);</span><br><span class="line">                <span class="built_in">p</span>(y)=x;</span><br><span class="line">                <span class="built_in">merge</span>(x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">v</span>(<span class="built_in">find</span>(x)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t==<span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x=<span class="built_in">find</span>(x);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">cmp</span>(<span class="built_in">r</span>(x),<span class="built_in">l</span>(x))) <span class="built_in">swap</span>(<span class="built_in">l</span>(x),<span class="built_in">r</span>(x));</span><br><span class="line">            <span class="built_in">p</span>(x)=<span class="built_in">l</span>(x),<span class="built_in">p</span>(<span class="built_in">l</span>(x))=<span class="built_in">l</span>(x);</span><br><span class="line">            <span class="built_in">merge</span>(<span class="built_in">l</span>(x),<span class="built_in">r</span>(x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 Luogu 不同，处理起来略显麻烦。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,INF=<span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,v,p,dis;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) tr[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) tr[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> v(x) tr[x].v</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> p(x) tr[x].p</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> d(x) tr[x].dis</span></span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">v</span>(a)!=<span class="built_in">v</span>(b)) <span class="keyword">return</span> <span class="built_in">v</span>(a)&lt;<span class="built_in">v</span>(b);</span><br><span class="line">    <span class="keyword">return</span> a&lt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(b,a)) <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="built_in">r</span>(a)=<span class="built_in">merge</span>(<span class="built_in">r</span>(a),b);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">d</span>(<span class="built_in">r</span>(a))&gt;<span class="built_in">d</span>(<span class="built_in">l</span>(a))) <span class="built_in">swap</span>(<span class="built_in">r</span>(a),<span class="built_in">l</span>(a));</span><br><span class="line">    <span class="built_in">d</span>(a)=<span class="built_in">d</span>(<span class="built_in">r</span>(a))+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">p</span>(x)!=x) <span class="built_in">p</span>(x)=<span class="built_in">find</span>(<span class="built_in">p</span>(x));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">p</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,x;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="built_in">v</span>(++idx)=x;</span><br><span class="line">        <span class="built_in">d</span>(idx)=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">p</span>(idx)=idx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">v</span>(<span class="number">0</span>)=INF;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t,x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;t,&amp;x);</span><br><span class="line">        <span class="keyword">if</span> (t==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;y);</span><br><span class="line">            <span class="keyword">if</span> (x!=y&amp;&amp;<span class="built_in">v</span>(x)!=INF&amp;&amp;<span class="built_in">v</span>(y)!=INF)</span><br><span class="line">            &#123;</span><br><span class="line">                x=<span class="built_in">find</span>(x);y=<span class="built_in">find</span>(y);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">cmp</span>(y,x)) <span class="built_in">swap</span>(x,y);</span><br><span class="line">                <span class="built_in">p</span>(y)=x;</span><br><span class="line">                <span class="built_in">merge</span>(x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">v</span>(x)==INF)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">v</span>(<span class="built_in">find</span>(x)));</span><br><span class="line">            x=<span class="built_in">find</span>(x);</span><br><span class="line">            <span class="built_in">v</span>(x)=INF;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">cmp</span>(<span class="built_in">r</span>(x),<span class="built_in">l</span>(x))) <span class="built_in">swap</span>(<span class="built_in">l</span>(x),<span class="built_in">r</span>(x));</span><br><span class="line">            <span class="built_in">p</span>(x)=<span class="built_in">l</span>(x),<span class="built_in">p</span>(<span class="built_in">l</span>(x))=<span class="built_in">l</span>(x);</span><br><span class="line">            <span class="built_in">merge</span>(<span class="built_in">l</span>(x),<span class="built_in">r</span>(x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2：数字序列"><a href="#T2：数字序列" class="headerlink" title="T2：数字序列"></a>T2：数字序列</h4><p><a href="https://www.luogu.com.cn/problem/P4331">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2727/">题目传送门 AcWing</a></p><p>首先，把每个数都减一个 $i$，即 $a[i]\leftarrow a[i]-i,b[i]\leftarrow b[i]-i$。</p><p>所以 $b[1]\leq b[2]\leq…\leq b[n]$。</p><p>计算处理后的答案，答案不变。</p><p>我们假设所有的 $b[i]$ 都相等，那么问题转化为“货仓选址”问题。</p><p>假设可以划为两段，前后各自取自己 $b[i]$ 相同的最小值。</p><p>再设前面一段取最小值时 $b[i]=u$，后一段 $b[i]=v$。</p><p>第一种情况时 $u\leq v$，则直接保留，即是整段的最优解。</p><p>那第二种情况 $u&gt;v$ 怎么办呢？</p><p><strong>证明：答案 $ans$ 是 $a$ 中位数 ，表示新的 $b[i]$。</strong></p><p>假设前一段是 $b[1…n]$，后一段是 $b[n + 1…m]$。</p><p>首先，证明，$b[n]\leq u,b[n+1]\geq v$。</p><p>证明一个：假设 $b[n] &gt; u$，我们可以将 $b[1…n]$ 全部替换为 $u$，很明显前面的答案不会变大，而且留给后面的空间是越大的，答案不会变差。</p><p>那么，我们接着证明 $b[1…n]$ 变成相同的 $b[1] &gt; u$，是不会变差的。</p><p>首先，可以得到 $a[1…n]$ 的中位数 $s$ 一定是 $\leq u$。如果 $s &gt; u$ 的话，我们可以将 $u$ 向上移动，变为 $s$。因为有 $\dfrac{n}{2}$ 个数大于 $s$，那么答案是一定会变小的。</p><p>我们可以将 $b[2…n]$ 都减去一个 $b[2] - b[1]$，那么此时 $b[1] = b[2]$。看到有 $\dfrac n2$ 个数小于 $u$，于是向下移动的话，会导致答案变小。我们对于每一个都这么操作，最后一定会得到 $b[1..n] = b[1]$。</p><p>然后，我们再证明 $b[1]$ 向下移动一定会使答案变小。这个<del>显然。</del></p><p>现在，我们已经得到 $b[n]\leq u,b[n+1]\geq v$，且两段都是一样的。</p><p>接着就是根据中位数，我们可以将他们调整为 $a[1…n + m]$ 的中位数。<del>肯定说的不清楚，只好先鸽着了。</del></p><p>最后直接维护每一段的大小和长度，如果遇到递减，则合并为中位数，就可以了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 左偏树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Extended-BSGS</title>
      <link href="/2021/12/17/Extended-baby-step-giant-step/"/>
      <url>/2021/12/17/Extended-baby-step-giant-step/</url>
      
        <content type="html"><![CDATA[<p>同步发表于 P4195 题解。</p><span id="more"></span><p><strong>Update on 2021-11-01：</strong> 更新了代码，可能会提升阅读效果吧。</p><h2 id="0-前置知识-amp-废话"><a href="#0-前置知识-amp-废话" class="headerlink" title="0. 前置知识 &amp; 废话"></a>0. 前置知识 &amp; 废话</h2><p>逆元。</p><p><a href="https://www.luogu.com.cn/blog/mydcwfy-342891/inverse-element">我的逆元 Blog</a></p><h2 id="1-普通版-BSGS"><a href="#1-普通版-BSGS" class="headerlink" title="1. 普通版 BSGS"></a>1. 普通版 BSGS</h2><p>要求 $\gcd(a,p)=1$。</p><p>其实就是一个分块的思想。</p><p>设 $t=\lceil\sqrt p\rceil$，我们可以将每一个答案 $x=i\times t-m$，其中 $i,m\leq t$。</p><p>$a^{i\cdot t-m}=b\pmod p\Leftrightarrow a^{i\cdot t}=b\times a^{m}\pmod p$。</p><p>我们枚举每一个 $i$，怎么找到右边的呢？</p><p>其实，我们可以先将 $b\times a^m$ 全部用 Hash 存下来。</p><p>这样就可以直接查找了。</p><h2 id="2-扩展版-BSGS"><a href="#2-扩展版-BSGS" class="headerlink" title="2. 扩展版 BSGS"></a>2. 扩展版 BSGS</h2><p>想办法解决问题，我们应该实现 $\gcd(a,p)=1$。</p><p>首先，同余具有一条性质：<br>$$<br>a=b\pmod c (\gcd(a,c)=1)\Leftrightarrow a\times d=b\times d\pmod {c\times d}<br>$$<br>可以感性的理解一下 （<del>主要是不会证</del>）。</p><p>那么，我们就可以执行消除因子。</p><p>每次在两边除以 $d=\gcd(a,p)$。<br>$$<br>a^x=b\pmod p\Rightarrow \dfrac{a}{d}\times a^{x-1}=\dfrac{b}{d}\pmod {\dfrac{p}{d}}<br>$$<br>重复执行该语段，直到 $\gcd(a,p)=1$ 为止。</p><p>将所有的 $\dfrac{a}{d}$ 都乘起来，记为 $tot$。</p><p>假设执行了 $cnt$ 次，则原问题转化为 $tot\times a^{x-cnt}=b\pmod p\Leftrightarrow a^{x-cnt}=b\times tot^{-1}\pmod p$</p><p>注意，这里有一些细节：</p><ol><li>如果 $b$ 不被 $d$ 整除，则直接返回无解。</li><li>答案可能小于 $cnt$，我们必须枚举 $[0,cnt-1]$ 的解，看有没有。</li></ol><p>于是就转化为了普通的 BSGS 了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a, b, Mod;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Gcd</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ExGcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = <span class="built_in">ExGcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * a % Mod;</span><br><span class="line">        a = a * a % Mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ExBSGS</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b %= Mod, a %= Mod;<span class="comment">//注意开始的时候要先模一下。</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span> || Mod == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> g = <span class="number">0</span>;</span><br><span class="line">    ll now = <span class="number">1</span>, t;</span><br><span class="line">    <span class="keyword">while</span> ((t = <span class="built_in">Gcd</span>(a, Mod)) != <span class="number">1</span>)<span class="comment">//消除因子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % t) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        b /= t, Mod /= t, now = now * (a / t) % Mod;</span><br><span class="line">        g ++;</span><br><span class="line">        <span class="keyword">if</span> (now == b) <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> K = <span class="built_in">sqrt</span>(Mod * <span class="number">1.0</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> map&lt;ll, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp.<span class="built_in">clear</span>();</span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="built_in">ExGcd</span>(now, Mod, x, y);<span class="comment">//逆元（因为 p 不一定是质数）</span></span><br><span class="line">    x = (x % Mod + Mod) % Mod;</span><br><span class="line">    now = x * b % Mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        now = now * a % Mod;</span><br><span class="line">        mp[now] = i;<span class="comment">//小块存入 Hash</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll pw = <span class="built_in">qpow</span>(a, K);</span><br><span class="line">    now = pw;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++ i)</span><br><span class="line">    &#123;<span class="comment">//大块直接枚举</span></span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">find</span>(now) != mp.<span class="built_in">end</span>()) <span class="keyword">return</span> i * K - mp[now] + g;</span><br><span class="line">        now = now * pw % Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a, b;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;a, &amp;Mod, &amp;b), a || b || Mod)</span><br><span class="line">    &#123;</span><br><span class="line">        ll res = <span class="built_in">ExBSGS</span>(a, b);</span><br><span class="line">        <span class="keyword">if</span> (~res) cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆元</title>
      <link href="/2021/12/17/Inverse-element/"/>
      <url>/2021/12/17/Inverse-element/</url>
      
        <content type="html"><![CDATA[<p>比较简单的前置知识。</p><span id="more"></span><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>$a*x =1\pmod b$，且 $\gcd(a,b)=1$，则我们称 $x$ 为 $a$ 的逆元，简称 $a^{-1}$。</p><p>然后我们在处理 $d/a\pmod b$，可以转化为 $d * a^{-1}\pmod p$。</p><h2 id="2-求法"><a href="#2-求法" class="headerlink" title="2. 求法"></a>2. 求法</h2><h3 id="1）-扩展欧几里得算法"><a href="#1）-扩展欧几里得算法" class="headerlink" title="1） 扩展欧几里得算法"></a>1） 扩展欧几里得算法</h3><p>可以转化为 $a<em>x+b</em>y=1$，直接扩展欧几里得即可。</p><p>值得注意的是，我们要将 $x$ 变成 $[0,p-1]$ 的数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">ExGCD</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;</span><br><span class="line">ll d;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) x=<span class="number">1</span>,y=<span class="number">0</span>,d=a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">d=<span class="built_in">ExGCD</span>(b,a%b,y,x),y-=a/b*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll p)</span><span class="comment">// 求逆元的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="built_in">ExGCD</span>(a,p,x,y);</span><br><span class="line">    x=(x%p+p)%p;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）线性算法"><a href="#2）线性算法" class="headerlink" title="2）线性算法"></a>2）线性算法</h3><p>首先，$1^{-1}=1$。</p><p>$[\dfrac{p}{i}]*i+r=p\Leftrightarrow [\dfrac{p}{i}]*i+r=0\pmod p$。</p><p>同时乘以 $i^{-1}*r^{-1}$，就可以得到 $[\dfrac{p}{i}]*r^{-1}+i^{-1}=0\pmod p$。</p><p>于是，$i^{-1}=-[\dfrac{p}{i}]*r^{-1}\pmod p$。</p><p>当然，这个也可以计算单个的逆元。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,p;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">    inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) inv[i]=(p-(p/i))*inv[p%i]%p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(inv[i]%p+p)%p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）快速幂"><a href="#3）快速幂" class="headerlink" title="3）快速幂"></a>3）快速幂</h3><p>因为有费马小定理：$a^{p-1}=1\pmod p$，其中 p 为质数。</p><p>所以 $a*a^{p-2}=1\pmod p$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筛质数</title>
      <link href="/2021/12/17/%E7%AD%9B%E8%B4%A8%E6%95%B0/"/>
      <url>/2021/12/17/%E7%AD%9B%E8%B4%A8%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>比较简单的前置知识。</p><span id="more"></span><h2 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h2><h3 id="1-埃氏筛法"><a href="#1-埃氏筛法" class="headerlink" title="1. 埃氏筛法"></a>1. 埃氏筛法</h3><p>比较简单，算法核心就是直接将所有该质数的所有倍数筛掉。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isprime[i]) prime[cnt++]=i;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;=n;j+=i)</span><br><span class="line">        isprime[j]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为 $O(n*(1/2+1/3+…))=O(n \log \log n)$。</p><h3 id="2-线性筛法"><a href="#2-线性筛法" class="headerlink" title="2. 线性筛法"></a>2. 线性筛法</h3><p>先看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isprime[i]) prime[cnt++]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt&amp;&amp;i*prime[j]&lt;=n;++j)</span><br><span class="line">    &#123;</span><br><span class="line">        isprime[i*prime[j]]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以证明，每一个合数都只会被它的最小质因数筛掉。</p><p>时间复杂度为 $O(n)$。</p><h3 id="3-例题"><a href="#3-例题" class="headerlink" title="3. 例题"></a>3. 例题</h3><h4 id="T1：哥德巴赫猜想"><a href="#T1：哥德巴赫猜想" class="headerlink" title="T1：哥德巴赫猜想"></a>T1：哥德巴赫猜想</h4><p><a href="https://www.luogu.com.cn/problem/P1304">题目传送门 Luogu</a></p><p>直接枚举所有质数，看减后的数是不是素数即可。</p><p>代码略。</p><h4 id="T2：Sherlock-and-his-girlfriend"><a href="#T2：Sherlock-and-his-girlfriend" class="headerlink" title="T2：Sherlock and his girlfriend"></a>T2：Sherlock and his girlfriend</h4><p><a href="https://www.luogu.com.cn/problem/CF776B">题目传送门 Luogu(RemoteJudge:Codeforces)</a></p><p>可以发现，该限制条件是质数与合数之间，不可能是质数与质数之间，合数与合数之间。</p><p>所以该图为二分图（按限制条件建边），答案不超过二。</p><p>只要有合数，那么答案必然为 2。</p><p>即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N],cnt;</span><br><span class="line"><span class="keyword">bool</span> isprime[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i) isprime[i]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (isprime[i]) prime[cnt++]=i; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt&amp;&amp;i*prime[j]&lt;N;++j)</span><br><span class="line">&#123;</span><br><span class="line">isprime[i*prime[j]]=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!(i%prime[j])) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">if</span> (n&gt;=<span class="number">3</span>) <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">if</span> (isprime[i+<span class="number">1</span>]) <span class="built_in">printf</span>(<span class="string">&quot;1 &quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;2 &quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3：质数距离"><a href="#T3：质数距离" class="headerlink" title="T3：质数距离"></a>T3：质数距离</h4><p><a href="https://www.acwing.com/problem/content/198/">题目传送门 AcWing</a></p><p>这道题，需要我们去改进该算法。</p><p>因为所有算法都是从 1 开始的，且至少要 $O(n)$。</p><p>仔细分析，我们发现，任何一个数，都有一个质数 $\leq \sqrt n$。</p><p>所以，我们可以先处理出所有 $\leq \sqrt n$ 的质数，然后用这些数去筛 $[L,R]$。</p><p>复杂度为 $O((R-L)\log\log R)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; PLL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50000</span>,T=<span class="number">1e6</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N],cnt;</span><br><span class="line"><span class="keyword">bool</span> isprime[N];</span><br><span class="line"><span class="keyword">bool</span> vis[T];</span><br><span class="line">ll l,r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(isprime,<span class="literal">true</span>,<span class="keyword">sizeof</span> isprime);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isprime[i]) prime[cnt++]=i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt&amp;&amp;prime[j]*i&lt;N;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            isprime[i*prime[j]]=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(i%prime[j])) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;l&gt;&gt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ll p=prime[i],low=(l+p<span class="number">-1</span>)/p,high=r/p;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="built_in">max</span>((ll)<span class="number">2</span>,low);j&lt;=high;++j)</span><br><span class="line">                vis[p*j-l]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll maxn=<span class="number">0</span>,minx=INF;</span><br><span class="line">        PLL maxp,minp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,last=<span class="number">-1</span>;i&lt;=r-l;++i)</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]&amp;&amp;i+l&gt;=<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (~last)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (maxn&lt;i-last) maxn=i-last,maxp=<span class="built_in">mp</span>(last+l,i+l);</span><br><span class="line">                    <span class="keyword">if</span> (minx&gt;i-last) minx=i-last,minp=<span class="built_in">mp</span>(last+l,i+l);</span><br><span class="line">                &#125;</span><br><span class="line">                last=i;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxn==<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;There are no adjacent primes.&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld,%lld are closest, %lld,%lld are most distant.\n&quot;</span></span><br><span class="line">            ,minp.x,minp.y,maxp.x,maxp.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T4：阶乘分解"><a href="#T4：阶乘分解" class="headerlink" title="T4：阶乘分解"></a>T4：阶乘分解</h4><p><a href="https://www.acwing.com/problem/content/199/">题目传送门 AcWing</a></p><p>将所有的质数的次数存下来即可。</p><p>$n!$ 中 $p$ 的次数为 $\dfrac{n}{p}+\dfrac{n}{p^2}+\dfrac{n}{p^3}…$。</p><p>因为如果是 $p^k$ 的倍数，会在 $\dfrac{n}{p},\dfrac{n}{p^2},..\dfrac{n}{p^k}$ 都加过一遍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[N],n,cnt;</span><br><span class="line">ll ti[N];</span><br><span class="line"><span class="keyword">bool</span> isprime[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(isprime,<span class="literal">true</span>,<span class="keyword">sizeof</span> isprime);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (isprime[i]) prime[cnt++]=i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt&amp;&amp;prime[j]*i&lt;N;++j)</span><br><span class="line">&#123;</span><br><span class="line">isprime[i*prime[j]]=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!(i%prime[j])) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> &amp;p=prime[i];</span><br><span class="line">ll tot=p;</span><br><span class="line"><span class="keyword">while</span> (tot&lt;=(ll)n) ti[i]+=(ll)n/tot,tot*=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt&amp;&amp;prime[i]&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,prime[i],ti[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF Round#758</title>
      <link href="/2021/12/15/CF-Round-758/"/>
      <url>/2021/12/15/CF-Round-758/</url>
      
        <content type="html"><![CDATA[<p>比赛记录：ABC Accepted，Scores：1645，Rank #727（似乎有点巧，<code>Fly727</code>，Rating 829 -&gt; 1239。</p><p>改题进度：ABCD Accepted。</p><span id="more"></span><p><a href="https://codeforces.com/contest/1608">比赛位置</a></p><p>本身应该出校吃东西的，但是因为 18:05 要一次难得的 CF 比赛，于是放弃了吃饭。</p><h2 id="赛时"><a href="#赛时" class="headerlink" title="赛时"></a>赛时</h2><p>一开始看 A，发现是签到题，2 min 水完。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到 B，发现有一些神奇的题。</p><p>发现按照波峰波谷直接构造就可以了，但是有些难写，一直到了 45 min，还错了一发，终于过了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(a - b) &gt; <span class="number">1</span>) <span class="built_in">noans</span>();</span><br><span class="line">        <span class="keyword">if</span> (a == b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a + <span class="number">1</span>) * <span class="number">2</span> &gt; n) <span class="built_in">noans</span>();</span><br><span class="line">            <span class="keyword">int</span> st1 = a + <span class="number">2</span>, st2 = a + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n, t = <span class="number">0</span>; t &lt;= a; t ++, j -= <span class="number">2</span>)</span><br><span class="line">                ans[j] = st1 ++, ans[j - <span class="number">1</span>] = st2 --;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - ((a + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>); i ++) ans[i] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n - ((a + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; i &lt;= n; ++ i) ans[i] += n - ((a + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == b + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a * <span class="number">2</span> + <span class="number">1</span> &gt; n) <span class="built_in">noans</span>();</span><br><span class="line">            <span class="keyword">int</span> st1 = a + <span class="number">1</span>, st2 = a + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n, t = <span class="number">0</span>; t &lt;= b; t ++, j -= <span class="number">2</span>)</span><br><span class="line">                ans[j] = st1 --, ans[j - <span class="number">1</span>] = st2 ++;</span><br><span class="line">            ans[n - ((b + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>)] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - (a &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>; i ++) ans[i] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n - (a &lt;&lt; <span class="number">1</span>); i &lt;= n; ++ i) ans[i] += n - (a &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == b - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (b * <span class="number">2</span> + <span class="number">1</span> &gt; n) <span class="built_in">noans</span>();</span><br><span class="line">            <span class="keyword">int</span> st1 = b * <span class="number">2</span> + <span class="number">1</span>, st2 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t = <span class="number">0</span>; t &lt;= a; ++ t, j += <span class="number">2</span>)</span><br><span class="line">                ans[j] = st1 --, ans[j + <span class="number">1</span>] = st2 ++;</span><br><span class="line">            ans[b * <span class="number">2</span> + <span class="number">1</span>] = b + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = (b + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>; i &lt;= n; ++ i) ans[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看到 C 题，感觉是一个二维偏序问题，和 Dyd 讨论了一会，发现可以先排序，后一个向前一个连一条边表示可以战胜，是一个 Tarjan 可以快速搞完，就可以了。但是确实如果是我自己想的话，大概率是想不出来的。</p><p>但是开黑就是好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpa</span><span class="params">(<span class="keyword">const</span> Item &amp;k1, <span class="keyword">const</span> Item &amp;k2)</span></span>&#123;<span class="keyword">return</span> k1.a &lt; k2.a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpb</span><span class="params">(<span class="keyword">const</span> Item &amp;k1, <span class="keyword">const</span> Item &amp;k2)</span></span>&#123;<span class="keyword">return</span> k1.b &lt; k2.b;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++ tot;</span><br><span class="line">    stk[++ top] = x, ins[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> j : g[x])</span><br><span class="line">        <span class="keyword">if</span> (!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ins[j]) low[x] = <span class="built_in">min</span>(low[x], dfn[j]);</span><br><span class="line">    <span class="keyword">if</span> (low[x] != dfn[x]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    cnt ++;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        now = stk[top --];</span><br><span class="line">        bel[now] = cnt;</span><br><span class="line">        scc[cnt].<span class="built_in">push_back</span>(now);</span><br><span class="line">        ins[now] = <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span> (now != x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        tot = cnt = top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) g[i].<span class="built_in">clear</span>(), scc[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) k[i].id = i, dfn[i] = low[i] = <span class="number">0</span>, ins[i] = ok[i] = <span class="literal">false</span>, deg[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k[i].a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k[i].b);</span><br><span class="line">        <span class="built_in">sort</span>(k + <span class="number">1</span>, k + n + <span class="number">1</span>, cmpa);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) g[k[i + <span class="number">1</span>].id].<span class="built_in">push_back</span>(k[i].id);</span><br><span class="line">        <span class="built_in">sort</span>(k + <span class="number">1</span>, k + n + <span class="number">1</span>, cmpb);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) g[k[i + <span class="number">1</span>].id].<span class="built_in">push_back</span>(k[i].id);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j : g[x])</span><br><span class="line">                <span class="keyword">if</span> (bel[j] != bel[x]) deg[bel[j]] ++;</span><br><span class="line">        <span class="keyword">int</span> deg0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= cnt; ++ x) deg0 += !deg[x];</span><br><span class="line">        <span class="keyword">if</span> (deg0 == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= cnt; ++ x)</span><br><span class="line">                <span class="keyword">if</span> (deg[x] == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> j : scc[x]) ok[j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line">            <span class="keyword">if</span> (ok[x]) <span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到 D 题，才 70 min。发现只有两种可能，一种是神仙 DP 题，另一种是构造 + 组合题。</p><p>但是我和 Dyd 想了很久的 DP 还是没有想出来。我们想了很久拆开一个多米诺骨牌，然后重新组合，但是和题目求的东西不一样。</p><p>一直到最后 5 min，我才发现似乎组合是更靠谱的，但是苦于时间过短，没有想出构造的方案。</p><p>赛后 System Tests，还是有些紧张，但幸好没有挂分。</p><p>看到评论，发现一堆人吐槽 Pretests too weak，说 C、D 的题的 Pretests 几乎等于没有。</p><p>然后好多人都是挂了，排名略微靠前。</p><h2 id="赛后"><a href="#赛后" class="headerlink" title="赛后"></a>赛后</h2><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>开始改 D，发现是一个神仙的构造题。</p><p>首先，必须保证 B 的个数一定是 $n$。可以考虑排列组合，是 ${2 * n - b - w \choose n - b}$。注意判断无解。</p><p>如果有 BB 或 WW 的话，一定可以构造：一定 BB 和 WW 的个数是一样的，然后我们可以构造成 <code>BB WW BB WW...</code>，然后如果是 BW 的话，直接丢在 <code>WW BB</code> 中间，否则丢在 <code>BB WW</code> 中间。注意丢进去后还是 <code>WW BW BB</code>，仍然可以继续放 BW，WB 同理。</p><p>那么我们就减去没有 BB WW 的。让每一个都是 WB / BW，统计个数（$0\sim 2$）计入答案。</p><p>但是我们发现还有特例：都是一种颜色的话，是可以满足条件的。判断一下要加上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> cmp)</span></span>&#123;<span class="keyword">return</span> c == <span class="string">&#x27;?&#x27;</span> || c == cmp;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    flag1 = flag2 = <span class="literal">true</span>, ext = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        cntb += op[<span class="number">0</span>] == <span class="string">&#x27;B&#x27;</span>, cntb += op[<span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">        cntw += op[<span class="number">0</span>] == <span class="string">&#x27;W&#x27;</span>, cntw += op[<span class="number">1</span>] == <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">        ext *= ((<span class="built_in">check</span>(op[<span class="number">0</span>], <span class="string">&#x27;B&#x27;</span>) &amp; <span class="built_in">check</span>(op[<span class="number">1</span>], <span class="string">&#x27;W&#x27;</span>)) + (<span class="built_in">check</span>(op[<span class="number">0</span>], <span class="string">&#x27;W&#x27;</span>) &amp; <span class="built_in">check</span>(op[<span class="number">1</span>], <span class="string">&#x27;B&#x27;</span>)));</span><br><span class="line">        ext %= Mod;</span><br><span class="line">        flag1 &amp;= <span class="built_in">check</span>(op[<span class="number">0</span>], <span class="string">&#x27;B&#x27;</span>) &amp; <span class="built_in">check</span>(op[<span class="number">1</span>], <span class="string">&#x27;W&#x27;</span>);</span><br><span class="line">        flag2 &amp;= <span class="built_in">check</span>(op[<span class="number">0</span>], <span class="string">&#x27;W&#x27;</span>) &amp; <span class="built_in">check</span>(op[<span class="number">1</span>], <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cntb &gt; n || cntw &gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; cntb &lt;&lt; &#x27; &#x27; &lt;&lt; cntw &lt;&lt; &#x27; &#x27; &lt;&lt; ext &lt;&lt; endl;</span></span><br><span class="line">    ans = fact[<span class="number">2</span> * n - cntw - cntb] * infact[n - cntb] % Mod * infact[n - cntw] % Mod;</span><br><span class="line">    ans = (ans - ext + flag1 + flag2 + Mod) % Mod;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 做题记录 </tag>
            
            <tag> CF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CSP-S 2021 复习】图论总结</title>
      <link href="/2021/12/15/csp-s-2021-review-graph-summary/"/>
      <url>/2021/12/15/csp-s-2021-review-graph-summary/</url>
      
        <content type="html"><![CDATA[<p>这里总结了一些以前没有写过的知识点（主要是因为知识点比较少，就不专门写了），同时对于考纲内的知识点，会附上一些自己的看法。可能有纰漏，望读者指出。</p><span id="more"></span><h2 id="1-大概内容"><a href="#1-大概内容" class="headerlink" title="1. 大概内容"></a>1. 大概内容</h2><ol><li>最短路</li><li>最小生成树与次小生成树</li><li><a href="/2021/12/26/Euler-circuit-and-Eulerian-path/">欧拉回路</a></li><li><a href="/2021/12/26/Tarjan-algorithm/">Tarjan 与缩点，割点、桥</a></li><li><a href="/2021/12/26/Bipartite-graph/">二分图</a></li><li><a href="/2021/12/26/Difference-constraint/">差分约束</a></li><li>拓扑排序</li><li>最近公共祖先与倍增</li></ol><p>（一时想不起了，提高组考察似乎就这么多……</p><h2 id="2-详细内容"><a href="#2-详细内容" class="headerlink" title="2. 详细内容"></a>2. 详细内容</h2><h3 id="1）最短路"><a href="#1）最短路" class="headerlink" title="1）最短路"></a>1）最短路</h3><p>最短路估计是大家见过最多的图论了，因为这个算法虽然简单，但是变化莫测，难度几乎没有上限，甚至各种高级算法的基础是它（费用流等），还可以和各种题型进行结合，导致难度骤增。</p><p>关于算法，四种，不用多说：Floyd，Dijkstra，Bellman-Ford，SPFA。</p><p>考场上的选择：一般使用 Dijkstra，不要使用 SPFA（因为最坏复杂度太差，而且能被卡死，除非明摆着的 Dijkstra 过不了的时候，还能一些 <del>（满）</del> 分），多源求最短路用 Floyd，特殊情况用 Bellman-Ford。</p><p>前面三种的区分比较明显，因为时间复杂度不同，Dijkstra 是 $O(m\log n)$，SPFA 是 $O(km)$，Floyd 是 $O(n^3)$。</p><p>什么是 Bellman-Ford 的特殊情况呢？</p><p>比如这样一道题。</p><blockquote><p>给定一张有向图，求对于每一个 $k\in[1,n-1]$，求源点 $1$ 到每一个点走不超过 $k$ 条边的最短路。为了了避免输出量极大，对于每一个 $k$，输出所有最短距离的异或和即可。无法到达的点设其最短距离为 $u\times1\times10^{14}$，$u$ 为其编号。$n\leq1000,m\leq5000,w_i\leq10^7$</p></blockquote><p>这个就是一个经典的 Bellman-Ford 算法了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e14</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125;e[M];</span><br><span class="line">ll d[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) d[j][i] = INF;</span><br><span class="line">d[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; ++ k)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line"><span class="keyword">if</span> (d[k][e[i].v] &gt; d[k - <span class="number">1</span>][e[i].u] + e[i].w) d[k][e[i].v] = d[k - <span class="number">1</span>][e[i].u] + e[i].w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，感谢 @<a href="https://www.luogu.com.cn/user/115359">phigy</a> 的建议，加上了最短路 DAG 的问题。</p><p>对于单源最短路来说，有一些边满足 $dis(i)=dis(j)+w(j,i)$，那么 $e(j,i)$ 就会在新图中，这就构成了最短路 DAG。</p><p>从 DAG 的源点开始走，任意走都是最短路——这个是比较特殊的性质。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_DAG</span><span class="params">(<span class="keyword">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Dijkstra</span>(st);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h1[x]; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (d[e[i]] == d[x] + w[i]) <span class="built_in">add</span>(h2, x, e[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这个题就是一个经典的题。</p><blockquote><p>给定一张 $n$ 个点，$m$ 条边的有向图和起点 $S$，求$S$ 到每一个点最短路的路径条数。</p></blockquote><p>这个直接在 DAG 上 bfs 就可以了。</p><p>还有一个：</p><blockquote><p>给定一张 $n$ 个点，$m$ 条边的有向图和起点 $S$、终点 $T$，求 $S$ 到 $T$ 的最短路的必经边（即删除这条边后会导致最短路变大）。</p></blockquote><p>比较难的解法是 <a href="https://www.luogu.com.cn/problem/P5180">支配树</a>，先求出 DAG 后，再求支配点。</p><p>但是一个偷懒的方法是：假设 $e(i,j)$ 满足 $count(S,i)*count(j,T)=count(S,T)$，其中 $count(i,j)$ 表示 $i$ 到 $j$ 的最短路径数。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/cxv9s5fx.png"></p><p>证明也很简单：如果两边的 $count$ 乘积等于总数的话，那么就不会存在其他路径了，也就是必经边了。</p><p>但是有可能爆 <code>long long</code>，所以使用 <code>Hash</code>。</p><h3 id="2）最小生成树-amp-次小生成树"><a href="#2）最小生成树-amp-次小生成树" class="headerlink" title="2）最小生成树 &amp; 次小生成树"></a>2）最小生成树 &amp; 次小生成树</h3><p>最小生成树算法分别有 Kruskal($O(m\log n)/O(n\alpha(n))$)，Prim($O(n^2)$)，区别也很简单，稀疏图用 Kruskal，稠密图（用邻接矩阵存的）用 Prim。</p><p>推荐一个水题：<a href="https://www.luogu.com.cn/problem/P5994">P5994 [PA2014]Kuglarz</a></p><p>使用 Prim，时间复杂度为 $O(n^2)$。</p><p>同时一些题目本身是图，我们需要将其转化为一棵树，使答案可以很好计算。而转化为最小生成树是答案所求，所以我们先最小生成树。</p><p>注意，这里与最短路径 DAG 是有区别的，因为我们要根据不同的题目，具体选择需要的算法。</p><p><del>（这个找不到例题了……</del></p><p>次小生成树（严格）的模板题：<a href="https://www.luogu.com.cn/problem/P4180">P4180 [BJWC2010]严格次小生成树</a></p><p>这个是倍增的好题，我们马上再讲。（？</p><h3 id="3）欧拉回路"><a href="#3）欧拉回路" class="headerlink" title="3）欧拉回路"></a>3）欧拉回路</h3><p>博客讲得差不多了，我们就不啰嗦了，但是要强调的一个是：<strong>注意要先更新 $head$，然后再遍历，否则复杂度会假掉！</strong></p><p>看一下最开始也是一般的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = h[x]; ~i; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">vis[i] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(e[i]);</span><br><span class="line">ans[++ cnt] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i; -- i) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，当我们 <code>dfs(e[i])</code> 的时候，会导致我们当前的这个点的当前这一条边 $i$ 还没有被踢出 <code>head[]</code>，因为有回路导致重新遍历到这个点，可能会导致时间复杂度假掉。</p><p>正确的应该是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = h[x]; ~i;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[i])</span><br><span class="line">&#123;</span><br><span class="line">i = ne[i];</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">vis[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = e[i];</span><br><span class="line">i = ne[i];</span><br><span class="line"><span class="built_in">dfs</span>(j);</span><br><span class="line">ans[++ cnt] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i; -- i) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就避免了这种情况，</p><p>推荐一个题：<a href="https://www.luogu.com.cn/problem/P1127">P1127 词链</a></p><p>如果我们把这道题看作是哈密尔顿回路的话，那肯定就解不出来。</p><p>考虑将词语转化为边，然后将首尾字符变为点，就是欧拉回路了。</p><p>也涉及到了字符串，可能有一点麻烦。</p><h3 id="4）Tarjan-缩点、各种双连通分量"><a href="#4）Tarjan-缩点、各种双连通分量" class="headerlink" title="4）Tarjan 缩点、各种双连通分量"></a>4）Tarjan 缩点、各种双连通分量</h3><p>这个真得不想再写博客了……</p><p>大概我那篇讲的挺清楚 <del>吗？</del></p><h3 id="5）二分图"><a href="#5）二分图" class="headerlink" title="5）二分图"></a>5）二分图</h3><p>这个要注意染色法，最大匹配，Konig 定理，最大独立集几个知识点。</p><p>染色法其实是比较简单的，至少是 NOI 大纲-提高组区 里的。</p><p>但是不代表其他的不考！</p><p>虽然考得比较少，但是不能说不可能。</p><p>匈牙利算法好打，一般不要使用 dinic 等（打错就尴尬了</p><h3 id="6）差分约束"><a href="#6）差分约束" class="headerlink" title="6）差分约束"></a>6）差分约束</h3><p>差分约束似乎不被重视，但是 <a href="https://www.luogu.com.cn/problem/P7515">2021 联合省选 D1T2</a> 就考到了。</p><p>所以，还是要学习。</p><p>一般只能使用 SPFA（完全图除外），因为没法跑 Dijkstra。</p><p>还是要注意：<strong>最小值跑最长路，最大值跑最短路！</strong></p><p>其他没什么说的了。</p><h3 id="7）拓扑排序"><a href="#7）拓扑排序" class="headerlink" title="7）拓扑排序"></a>7）拓扑排序</h3><p>这个比较简单了，只能在 DAG（有向无环图）上使用。</p><p>一般有 DAG DP 问题。</p><h3 id="8）最近公共祖先"><a href="#8）最近公共祖先" class="headerlink" title="8）最近公共祖先"></a>8）最近公共祖先</h3><h4 id="a-暴力"><a href="#a-暴力" class="headerlink" title="a. 暴力"></a>a. 暴力</h4><p>选择深度较大的点向上跳，直到碰到为止。</p><p>时间复杂度为 $O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (x != y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dep[x] &lt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">x = fa[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要用在树的形态会发生改变的时候。</p><h4 id="b-倍增"><a href="#b-倍增" class="headerlink" title="b. 倍增"></a>b. 倍增</h4><p>考虑优化暴力。</p><p>我们可以预处理，对于每一个 $x$，$f[x][i]$ 表示 $x$ 的 $2^i$ 次跳过后走到的节点。</p><p>首先跳到同一深度。</p><p>然后 $i$ 从大向小枚举，如果跳到的位置不同，就可以跳。</p><p>这样的话，一定只剩一步就跳到相同的位置了。</p><p>时间复杂度为 $O(n\log n)-O(\log n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, L = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], e[N &lt;&lt; <span class="number">1</span>], ne[N &lt;&lt; <span class="number">1</span>], idx;</span><br><span class="line"><span class="keyword">int</span> f[N][L + <span class="number">1</span>], dep[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[x][<span class="number">0</span>] = fa, dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= L; ++ i) f[x][i] = f[f[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (e[i] != fa) <span class="built_in">dfs</span>(e[i], x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dep[x] &lt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line"><span class="keyword">if</span> (dep[f[x][i]] &gt;= dep[y]) x = f[x][i];</span><br><span class="line"><span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;<span class="comment">//注意本身就相会的情况</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line"><span class="keyword">if</span> (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];</span><br><span class="line"><span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>大家应该都知道吧</del></p><h4 id="c-Tarjan（跳过"><a href="#c-Tarjan（跳过" class="headerlink" title="c. Tarjan（跳过"></a>c. Tarjan（跳过</h4><h4 id="d-ST-表"><a href="#d-ST-表" class="headerlink" title="d. ST 表"></a>d. ST 表</h4><p>考虑 dfn 序（话说我在网上找了很久，dfn,euler,dfs 序各家说法不一，我也不太清楚</p><p>大致思路是：遍历到一个点的时候加在序列末尾，记当前位置为 $fi(x)$，然后它的一个子树走到另一个子树时，也要将 $x$ 加在序列末尾。</p><p>得到的序列可以证明不会超过 $2\times n-1$。</p><p>然后，我们找 $lca(x,y)$ 时，可以在序列里 $[fi(x), fi(y)]$ 中找到深度最小的点，一定就是答案。</p><p>为什么呢？原因很简单：因为 $[fi(x),fi(y)]$ 之间，一定会有 $lca$ 的出现，因为 $x,y$ 在 $lca$ 的不同子树，遍历不同子树的时候会记下 $lca$。</p><p>很明显，$lca$ 上面的 $fa(lca)$ 是不会在这之间的，因为 $x,y$ 是同一子树。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5tyisg35.png"></p><p>剩下的可以使用 ST 表维护了。</p><p>时间复杂度 $O(n\log n)-O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, L = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], e[N &lt;&lt; <span class="number">1</span>], ne[N &lt;&lt; <span class="number">1</span>], idx;</span><br><span class="line"><span class="keyword">int</span> dep[N], st[N &lt;&lt; <span class="number">1</span>][L], lg[N &lt;&lt; <span class="number">1</span>], tot, fi[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dep_min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> dep[x] &lt; dep[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">st[++ tot][<span class="number">0</span>] = x, dep[x] = dep[fa] + <span class="number">1</span>, fi[x] = tot;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (e[i] != fa) <span class="built_in">dfs</span>(e[i], x), st[++ tot][<span class="number">0</span>] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework_st</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= tot; ++ i) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= tot; ++ j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= tot; ++ i)</span><br><span class="line">st[i][j] = <span class="built_in">dep_min</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (fi[x] &gt; fi[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line"><span class="keyword">int</span> Lg = lg[fi[y] - fi[x] + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dep_min</span>(st[fi[x]][Lg], st[fi[y] - (<span class="number">1</span> &lt;&lt; Lg) + <span class="number">1</span>][Lg]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9）倍增"><a href="#9）倍增" class="headerlink" title="9）倍增"></a>9）倍增</h3><p>这个看似简单，我们拿两道题来看一下（前面的严格次小生成树在这里）。</p><h4 id="T1：严格次小生成树"><a href="#T1：严格次小生成树" class="headerlink" title="T1：严格次小生成树"></a>T1：<a href="https://www.luogu.com.cn/problem/P4180">严格次小生成树</a></h4><p>这个我们慢慢讲。</p><p>首先，我们跑一遍最小生成树，然后我们考虑再加入一条边，然后删除一条边。</p><p>很明显，假设一条边是 $e(u,v)$，我们应该删除 $u,v$ 路径上的一条边。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/yhojk8ky.png"></p><p>黑色的边就是我们可以删除的边，因为只有这些边中的一个被删除，原图仍然是树。</p><p>还可以得到一个结论：$\max_{e\in P(u,v)}(e.w)\leq w(u,v)$。（$P(u,v)$ 是指这条路径）</p><p>这个也显然，因为如果有边大于 $w(u,v)$ 的话，我们可以用 $w(u,v)$ 替换它，就答案更小了。</p><p>回到本题，我们删除哪条边呢？</p><p>明显应该删除 $P(u,v)$ 最大的边啊！（这样答案才最小</p><p>但是，得有一个前提：$\max_{e\in P(u,v)}(e.w)&lt;w(u,v)$，否则就不是严格的了。</p><p>碰上 $=$ 怎么办呢？我们就删除次大边就是了。</p><p>那么，现在我们处理的问题就是怎样找到最大边和严格次大边。</p><p>倍增就可以解决这个问题了。</p><p>$g[x][i][0]$ 表示 $x$ 向上跳 $2^i$ 所经历的边的最大值，$g[x][i][1]$ 为严格次大值。</p><p>回顾 $\text{LCA}(x,y)$ 的算法，我们就可以处理了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span><span class="comment">//预处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=L;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[x][i]=f[f[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        g[<span class="number">0</span>][x][i]=<span class="built_in">max</span>(g[<span class="number">0</span>][f[x][i<span class="number">-1</span>]][i<span class="number">-1</span>],g[<span class="number">0</span>][x][i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (g[<span class="number">0</span>][x][i<span class="number">-1</span>]&lt;g[<span class="number">0</span>][f[x][i<span class="number">-1</span>]][i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            g[<span class="number">1</span>][x][i]=<span class="built_in">max</span>(g[<span class="number">0</span>][x][i<span class="number">-1</span>],g[<span class="number">1</span>][f[x][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (g[<span class="number">0</span>][x][i<span class="number">-1</span>]==g[<span class="number">0</span>][f[x][i<span class="number">-1</span>]][i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            g[<span class="number">1</span>][x][i]=<span class="built_in">max</span>(g[<span class="number">1</span>][x][i<span class="number">-1</span>],g[<span class="number">1</span>][f[x][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            g[<span class="number">1</span>][x][i]=<span class="built_in">max</span>(g[<span class="number">1</span>][x][i<span class="number">-1</span>],g[<span class="number">0</span>][f[x][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> now)</span><span class="comment">//now 是指加入的边，不能与之相同</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[x]&lt;d[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">int</span> ans=-INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=L;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span> (d[f[x][i]]&gt;=d[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[<span class="number">0</span>][x][i]==now) ans=<span class="built_in">max</span>(ans,g[<span class="number">1</span>][x][i]);</span><br><span class="line">            <span class="keyword">else</span> ans=<span class="built_in">max</span>(ans,g[<span class="number">0</span>][x][i]);</span><br><span class="line">            x=f[x][i];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//  cout&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span> (x==y) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=L;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span> (f[x][i]!=f[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[<span class="number">0</span>][x][i]==now) ans=<span class="built_in">max</span>(ans,g[<span class="number">1</span>][x][i]);</span><br><span class="line">            <span class="keyword">else</span> ans=<span class="built_in">max</span>(ans,g[<span class="number">0</span>][x][i]);</span><br><span class="line">            <span class="keyword">if</span> (g[<span class="number">0</span>][y][i]==now) ans=<span class="built_in">max</span>(ans,g[<span class="number">1</span>][y][i]);</span><br><span class="line">            <span class="keyword">else</span> ans=<span class="built_in">max</span>(ans,g[<span class="number">0</span>][y][i]);</span><br><span class="line">            x=f[x][i];y=f[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (g[<span class="number">0</span>][x][i]==now) ans=<span class="built_in">max</span>(ans,g[<span class="number">1</span>][x][i]);</span><br><span class="line">    <span class="keyword">else</span> ans=<span class="built_in">max</span>(ans,g[<span class="number">0</span>][x][i]);</span><br><span class="line">    <span class="keyword">if</span> (g[<span class="number">0</span>][y][i]==now) ans=<span class="built_in">max</span>(ans,g[<span class="number">1</span>][y][i]);</span><br><span class="line">    <span class="keyword">else</span> ans=<span class="built_in">max</span>(ans,g[<span class="number">0</span>][y][i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2：跑路"><a href="#T2：跑路" class="headerlink" title="T2：跑路"></a>T2：<a href="https://www.luogu.com.cn/problem/P1613">跑路</a></h4><p>这个题其实是比较简单的倍增题目。</p><p>因为这里明显在提示 $2^k$，所以我们考虑倍增求一次能达到的点。</p><p>$a[bit][i][j]$ 表示经过 $2^{bit}$ 次边，$i,j$ 是否互达。</p><p>这个可以使用 Floyd，$a[bit][i][j]|=a[bit-1][i][k]\odot a[bit-1][k][j]$。</p><p>对于 $d(i,j)$，$\exists bit\in[0,30],a[bit][i][j]=1$，则 $d(i,j)=1$。</p><p>然后 Floyd 跑就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> bit = <span class="number">0</span>; bit &lt; <span class="number">31</span>; ++ bit)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">                a[bit + <span class="number">1</span>][i][j] |= a[bit][i][k] &amp; a[bit][k][j];</span><br></pre></td></tr></table></figure><h4 id="T3：电阻网络"><a href="#T3：电阻网络" class="headerlink" title="T3：电阻网络"></a>T3：<a href="https://www.luogu.com.cn/problem/P3617">电阻网络</a></h4><p><del>（作为习题了吧</del></p><p>首先是可以分治的，然后对于并联电路，求最早交点。</p><p>可以倍增找交点，有点像 LCA。</p><p>这个不具体讲了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀数组</title>
      <link href="/2021/12/13/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
      <url>/2021/12/13/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>和后缀自动机几乎是字符串最难的两个专题了。</p><p><strong>注意很多题不能相互替代。</strong></p><span id="more"></span><h3 id="1-主要思想"><a href="#1-主要思想" class="headerlink" title="1. 主要思想"></a>1. 主要思想</h3><p>首先，我们一般要依靠两个算法：</p><ol><li>倍增 $O(n\log n)$</li><li>DC3 $O(n)$，常数较大。</li></ol><p>一般使用 $O(n \log n)$ 的倍增算法。</p><p>该算法是针对字符串的，可以在 $O(n\log n)$ 的时间内将所有的后缀全部排序。</p><p>假设下标从 1 开始，其中从 $i$ 开始的后缀被称为第 $i$ 个后缀。显然没有两个 $s[i]$ 是相同的。</p><p>排序后，我们可以得到 $sa[1…n]$ 的数组，代表排名为 $i$ 的是第几个后缀。按照字典序排序。定义 $s[i]$ 为从 $i$ 开始的后缀。注意有时直接使用 $i$ 来代替 $s[i]$，请注意。</p><p>还可以得到 $rk[1…n]$ 代表第 $i$ 个后缀的排名是多少。显然 $sa[rk[i]] = i$。</p><p>还有一个比较重要而常用的数组 $height[n]$，表示 $sa[i]$ 和 $sa[i-1]$ 的<strong>最长公共前缀</strong>。</p><p>请注意<strong>排名为 $i$</strong> 的 $sa[1…n]$ 和 <strong>$s[i]$ 的排名</strong> $rk[1…n]$ 的区别。</p><h3 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2. 实现方法"></a>2. 实现方法</h3><p>首先，我们按第一个字符进行排序，相对位置不变（即如果第一个有相同的，在前面的还在前面）。</p><p>使用倍增。</p><p>假设当前已经处理了前 $k$ 个字符，我们将前 $k$ 个字符当做第一关键字，将接着的 $k$ 个字符当做第二关键字。这样就可以将每一个后缀按照前 $2k$ 个字符进行字典序排序。</p><p><strong>没有的（即长度不满 $2k$）一定比长度 $\geq 2k$ 更小。</strong></p><p>前 $k$ 个字符可以离散化，接着的 $k$ 个字符也可以离散化。</p><p>然后每一次排序就可以使用基数排序（不记得的先去复习一下）。</p><p>如果有两个关键字，可以先按第二关键字排序，再按第一关键字排序。</p><p>这里简单的讲解一下这里使用到的基数排序：</p><ol><li>首先将第一关键字 $x$ 扔入一个桶 $cnt$ 中。</li><li>将桶做一遍前缀和。这时可以发现，$(x,y)$ 这一个元素的最大排名就是 $cnt[x]$。</li><li>然后，按照第二个关键字的逆序，将 $(x,y)$ 的排名赋值 $cnt[x]$。此时还没有枚举到的 $(x,y’)$（即 $x$ 相同，$y’$ 更小）的最大排名变小一位，于是 $cnt[x]\leftarrow cnt[x] - 1$。</li></ol><p>如果还不理解，我们拿一个例子来看。</p><p>假设我们要排序 $(1,3),(2,2),(1,5),(3,7)$。</p><p>首先执行第一步，得到：$cnt[] = {2, 1, 1}$。</p><p>然后，前缀和得到： $cnt[] = {2, 3, 4}$。</p><p>然后按照 $y$ 逆序排序，首先枚举 $(3,7)$，得到 $rk[(3,7)] = 4$，$cnt[3]\leftarrow cnt[3] - 1$。</p><p>同理，然后会枚举 $(1,5)$，于是就是 $rk[(1,5)] = 2$，$cnt[1] = 1$。</p><p>枚举 $(1,3)$，得到 $rk[(1,3)] = cnt[1] = 1$，$cnt[1] = 0$。</p><p>最后枚举 $(2,2)$，略去。</p><p>由于基数排序是稳定排序，我们就没有影响这里的前后顺序。</p><p>我们给出代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_sa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) c[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n;i;i--) sa[c[x[i]]--]=i;<span class="comment">//按照第一个字符排序，其实是 (s[i], i) 排序，使用基数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n-k+<span class="number">1</span>;i&lt;=n;++i) y[++num]=i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">if</span> (sa[i]&gt;k) y[++num]=sa[i]-k;<span class="comment">//y[] 的意思是第二个关键字排名为  i 的后缀是哪一个。但 x[] 却是 i 为后缀在前 k 个排序时的排名</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) c[i]=<span class="number">0</span>;<span class="comment">//等价于 cnt[]，注意清空</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) c[x[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;++i) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n;i;i--) sa[c[x[y[i]]]--]=y[i],y[i]=<span class="number">0</span>;<span class="comment">//注意存的不是 rk[]，而是 sa[]，所以 y[i] 和 cnt[x[y[i]] --] 是不同的。等价与 rk[y[i]] = cnt[x[y[i]] --]</span></span><br><span class="line">        <span class="built_in">swap</span>(x,y);<span class="comment">//由于第二关键字已经完全使用了，我们不再需要，将第一个关键字排序的结果转到临时变量（是按照前 k 个的排序结果）。注意存的是每一后缀的排名。</span></span><br><span class="line">        x[sa[<span class="number">1</span>]]=<span class="number">1</span>,num=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)<span class="comment">//明显比较前 2k 字符的时候，sa[i] 一定不会比 sa[i - 1] 的排名小。所以 num 不减。</span></span><br><span class="line">            <span class="keyword">if</span> (y[sa[i]]==y[sa[i<span class="number">-1</span>]]&amp;&amp;y[sa[i]+k]==y[sa[i<span class="number">-1</span>]+k])</span><br><span class="line">                x[sa[i]]=num;<span class="comment">//如果 sa[i] 和 sa[i - 1] 的排名相等，且 sa[i] + k 和 sa[i - 1] + k 的排名相等，那么说明 sa[i] 和 sa[i - 1] 比较前 2k 字符时都是相等的。</span></span><br><span class="line">            <span class="keyword">else</span> x[sa[i]]=++num;</span><br><span class="line">        <span class="keyword">if</span> (num==n) <span class="keyword">return</span>;</span><br><span class="line">        m=num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再给一个简洁的代码，供参考。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_sa</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> *sa, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c[N], x[N], y[N];</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">126</span>, num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) c[x[i] = str[i]] ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i) sa[c[x[i]] --] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++ i) y[++ num] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; k) y[++ num] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) c[x[i]] ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i) sa[c[x[y[i]]] --] = y[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) y[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">        x[sa[<span class="number">1</span>]] = <span class="number">1</span>, num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (y[sa[i]] == y[sa[i - <span class="number">1</span>]] &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]) x[sa[i]] = num;</span><br><span class="line">            <span class="keyword">else</span> x[sa[i]] = ++ num;</span><br><span class="line">        <span class="keyword">if</span> (num == n) <span class="keyword">return</span>;</span><br><span class="line">        m = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎样求和利用 $height[]$ 呢？</p><p>首先再次明确定义，$height[1…n]$ 表示的是 $sa[i]$ 和 $sa[i - 1]$ 的最长公共前缀。</p><p>我们定义 $lcp(i,j)$ 为 $s[sa[i]]$ 与 $s[sa[j]]$ 的最长公共前缀。</p><p><strong>证明1：</strong>$lcp(i,j)=\min(lcp(i,k),lcp(k,j))[i\leq k \leq j]$。</p><p>首先证明 $\geq$。</p><p>很明显，如果 $lcp(i,k)&gt;lcp(i,j),lcp(k,j)&gt;lcp(i,j)$，那么 $i$ 和 $k$、$k$ 和 $j$ 都有更长的后缀，也就是 $i$ 和 $j$ 有更长的后缀。</p><p>再证明 $\leq$。</p><p>假设 $i$、$j$、$k$ 前 $lcp(i,j)$ 的串为 $A,B,C$。</p><p>很明显，有 $A\leq B\leq C$，又有 $A=C$，则 $A=B=C$。</p><p><strong>证毕</strong>。</p><p>为了方便，我们假设 $h(i)=height[rk[i]]$。就是指 $i$ 的后缀与排序后在 $i$ 前面一个的最长公共前缀。</p><p><strong>证明2：</strong> $h(i)\geq h(i-1)-1$。</p><p>这里假设 $h(i - 1)\geq 1$。如果 $h(i - 1) = 0$，原式显然。</p><p>假设 $i-1$ 的前面一个是第 $k$ 个后缀，那么 $i-1$ 与 $k$ 的最长公共前缀就是 $h(i-1)$。</p><p>都去掉第一个字符，就可以得到 $k + 1$ 与 $i$ 的公共前缀是 $h(i-1)-1$。（因为去掉第一个字符，相当于 $i$ 为后缀的字符串变为了 $i + 1$ 为后缀的字符串。</p><p>因为 $k$ 在 $i-1$ 前面，那么 $k+1$ 在 $i$ 的前面。因为第一个字符是一样的，所以比较 $k$ 和 $i - 1$ 的比较其实是从 $k + 1$ 和 $i$ 的比较得来的。既然 $k$ 比 $i - 1$ 小，那么肯定 $k + 1$ 比 $i$ 小。</p><p>由前面的证明可以得到 $h(i)$ 大于等于 $i$ 与 $k+1$ 的最长公共前缀长度。</p><p>即 $h(i)\geq h(i-1)-1$。</p><p><strong>证毕</strong>。</p><p>有了这个结论，我们在每次求 $height[i]$ 时，就可以使用该结论。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_height</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) rk[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> j=sa[rk[i]<span class="number">-1</span>],k=<span class="built_in">max</span>(<span class="number">0</span>,height[rk[i<span class="number">-1</span>]]<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//j 的位置一定注意，我们不管是什么，都一定求的是 sa[rk[i]] 和 sa[rk[i - 1]] 的最长公共前缀，只是因为证明，我们才使用了 rk[i - 1]</span></span><br><span class="line">        <span class="keyword">while</span> (i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k]) k++;</span><br><span class="line">        height[rk[i]]=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-例题"><a href="#3-例题" class="headerlink" title="3. 例题"></a>3. 例题</h3><h4 id="T1：-NOI2015-品酒大会"><a href="#T1：-NOI2015-品酒大会" class="headerlink" title="T1：[NOI2015]品酒大会"></a>T1：[NOI2015]品酒大会</h4><p><a href="https://www.luogu.com.cn/problem/P2178">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/1006/">题目传送门 AcWing</a></p><p>能很好的体现后缀数组的作用和使用方法。</p><p>在使用后缀数组后，我们将会得到所有后缀的排名 $sa[]$，以及所有后缀与前一名的最大公共前缀 $height[]$。</p><p>首先考虑后缀的最大公共前缀与 $r$ 的关系。</p><p>由 “证明1” 可得，如果 $height[i]&lt;r$，则 $i$ 上面的和下面的不可能 $lcp$ 大于等于 $r$。</p><p>同时我们也可以得到结论：如果将所有分成几段，则段内一定都是 $r$ 相似。</p><p>怎样维护最大值？</p><p>可以维护最大值和次大值，乘起来即可。</p><p>由于有负数，也要维护最小值和次小值。</p><p>由于有些绕，所以得认真打。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">2e18</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> sa[N], n, height[N], fa[N], a[N];</span><br><span class="line"><span class="keyword">int</span> mx1[N], mx2[N], mn1[N], mn2[N], sz[N];</span><br><span class="line">LL cnt, res = -INF;</span><br><span class="line">PLL ans[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; com[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_sa</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> *sa, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c[N], x[N], y[N];</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">126</span>, num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) c[x[i] = str[i]] ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i) sa[c[x[i]] --] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++ i) y[++ num] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; k) y[++ num] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) c[x[i]] ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i) sa[c[x[y[i]]] --] = y[i];</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">        x[sa[<span class="number">1</span>]] = <span class="number">1</span>, num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (y[sa[i]] == y[sa[i - <span class="number">1</span>]] &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]) x[sa[i]] = num;</span><br><span class="line">            <span class="keyword">else</span> x[sa[i]] = ++ num;</span><br><span class="line">        <span class="keyword">if</span> (num == n) <span class="keyword">return</span>;</span><br><span class="line">        m = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_height</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> *sa, <span class="keyword">int</span> *height, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> rk[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i] - <span class="number">1</span>], k = <span class="built_in">max</span>(<span class="number">0</span>, height[rk[i - <span class="number">1</span>]] - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; str[i + k] == str[j + k]) k ++;</span><br><span class="line">        height[rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PLL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : com[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = i, b = i - <span class="number">1</span>;</span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        cnt -= <span class="number">1LL</span> * sz[a] * (sz[a] - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1LL</span> * sz[b] * (sz[b] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mx1[a] &gt; mx1[b]) mx2[a] = <span class="built_in">max</span>(mx2[a], mx1[b]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mx1[a] &lt; mx1[b]) mx2[a] = <span class="built_in">max</span>(mx1[a], mx2[b]), mx1[a] = mx1[b];</span><br><span class="line">        <span class="keyword">else</span> mx2[a] = mx1[a];</span><br><span class="line">        <span class="keyword">if</span> (mn1[a] &lt; mn1[b]) mn2[a] = <span class="built_in">min</span>(mn2[a], mn1[b]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mn1[a] &gt; mn1[b]) mn2[a] = <span class="built_in">min</span>(mn1[a], mn2[b]), mn1[a] = mn1[b];</span><br><span class="line">        <span class="keyword">else</span> mn2[a] = mn1[a];</span><br><span class="line">        sz[a] += sz[b], sz[b] = <span class="number">0</span>;</span><br><span class="line">        fa[b] = a;</span><br><span class="line">        cnt += <span class="number">1LL</span> * sz[a] * (sz[a] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(<span class="number">1LL</span> * mx1[a] * mx2[a], <span class="number">1LL</span> * mn1[a] * mn2[a]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> &#123;cnt, res&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, str + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) fa[i] = i, sz[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">get_sa</span>(str, sa, n), <span class="built_in">get_height</span>(str, sa, height, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) mx1[i] = mn1[i] = a[sa[i]], mx2[i] = <span class="number">-1e9</span>, mn2[i] = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) com[height[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; ~i; -- i) ans[i] = <span class="built_in">solve</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, ans[i].first, ans[i].second);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2：-SDOI2016-生成魔咒"><a href="#T2：-SDOI2016-生成魔咒" class="headerlink" title="T2：[SDOI2016]生成魔咒"></a>T2：[SDOI2016]生成魔咒</h4><p><a href="https://www.luogu.com.cn/problem/P4070">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2574/">题目传送门 AcWing</a></p><p>首先容易得到，所有后缀的所有前缀集合就是所有子串的集合。</p><p><strong>证明3：</strong>在最长公共前缀内的，前面都出现过；在外面的，前面都没有出现过。</p><p>前一条易证。</p><p>如果在外面的某一个前缀在前面出现过，但是没有 $i - 1$ 出现过，$lcp(i,i-1)&lt; lcp(i,k)$，则与已知矛盾。</p><p>至于从后面加，我们可以将序列翻转，最后再翻转输出即可。</p><p>然后，我们删除最后一个字符的时候，直接将它所在的后缀删除就是了，然后将它的下面的 $height$ 维护为 $\min(height[now], height[nxt])$，可以 $O(1)$ 维护。总个数也可以 $O(1)$ 维护。</p><p>此外，此题还有 $O(n)$ 的在线做法，<del>可能</del>会在 SAM 中讲解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> str[N];</span><br><span class="line"><span class="keyword">int</span> sa[N], n, m, height[N], rk[N];</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dis;</span><br><span class="line">LL ans[N], res;</span><br><span class="line"><span class="keyword">int</span> d[N], u[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_sa</span><span class="params">(<span class="keyword">int</span> *str, <span class="keyword">int</span> *sa, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c[N], x[N], y[N];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) c[x[i] = str[i]] ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i) sa[c[x[i]] --] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; ++ i) y[++ num] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; k) y[++ num] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) c[x[i]] ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i) sa[c[x[y[i]]] --] = y[i];</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">        x[sa[<span class="number">1</span>]] = <span class="number">1</span>, num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (y[sa[i]] == y[sa[i - <span class="number">1</span>]] &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]) x[sa[i]] = num;</span><br><span class="line">            <span class="keyword">else</span> x[sa[i]] = ++ num;</span><br><span class="line">        <span class="keyword">if</span> (num == n) <span class="keyword">return</span>;</span><br><span class="line">        m = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_height</span><span class="params">(<span class="keyword">int</span> *str, <span class="keyword">int</span> *sa, <span class="keyword">int</span> *height, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i] - <span class="number">1</span>], k = <span class="built_in">max</span>(<span class="number">0</span>, height[rk[i - <span class="number">1</span>]] - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; str[i + k] == str[j + k]) k ++;</span><br><span class="line">        height[rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discrete</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dis.<span class="built_in">count</span>(x) == <span class="number">0</span>) dis[x] = ++ m;</span><br><span class="line">    <span class="keyword">return</span> dis[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;str[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) str[i] = <span class="built_in">discrete</span>(str[i]);</span><br><span class="line">    <span class="built_in">reverse</span>(str + <span class="number">1</span>, str + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">get_sa</span>(str, sa, n), <span class="built_in">get_height</span>(str, sa, height, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) res += n - sa[i] + <span class="number">1</span> - height[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) u[i] = i - <span class="number">1</span>, d[i] = i + <span class="number">1</span>;</span><br><span class="line">    u[n + <span class="number">1</span>] = n, d[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[i] = res;</span><br><span class="line">        <span class="keyword">int</span> x = rk[i], y = d[x];</span><br><span class="line">        res -= n - sa[x] + <span class="number">1</span> - height[x] + n - sa[y] + <span class="number">1</span> - height[y];</span><br><span class="line">        height[y] = <span class="built_in">min</span>(height[y], height[x]);</span><br><span class="line">        res += n - sa[y] + <span class="number">1</span> - height[y];</span><br><span class="line">        u[d[x]] = u[x], d[u[x]] = d[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 后缀数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点分治和点分树</title>
      <link href="/2021/12/13/%E7%82%B9%E5%88%86%E6%B2%BB%E5%92%8C%E7%82%B9%E5%88%86%E6%A0%91/"/>
      <url>/2021/12/13/%E7%82%B9%E5%88%86%E6%B2%BB%E5%92%8C%E7%82%B9%E5%88%86%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>将来自数组的分治搬到树上。</p><span id="more"></span><h3 id="1-主要思想"><a href="#1-主要思想" class="headerlink" title="1. 主要思想"></a>1. 主要思想</h3><p>树上分治分为点分治和边分治。</p><p>边分治主要因为时间复杂度容易被卡为 $O(n)$，而点分治可以保证时间复杂度为 $O(\log n)$。</p><p>所以边分治不太常用，而点分治相对常用。</p><p>点分树是点分治的动态问题。</p><h3 id="2-主要方法"><a href="#2-主要方法" class="headerlink" title="2. 主要方法"></a>2. 主要方法</h3><p>以下面一个例题为例：</p><h4 id="T1：【模板】点分治"><a href="#T1：【模板】点分治" class="headerlink" title="T1：【模板】点分治"></a>T1：【模板】点分治</h4><p><a href="https://www.luogu.com.cn/problem/P3806">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/254/">题目传送门 AcWing</a></p><p>其实，点分治就是取一个点，然后分治为几棵子树。</p><p>关键是如何统计不同子树间的信息。</p><p>首先，将所有点到根节点全部存下来。</p><p>为了处理，我们可以先将所有的排序，然后使用双指针即可。</p><p>要统计不同子树间的，我们可以先将所有的情况减去不符合条件的情况即可。</p><p>注意，因为要递归，我们希望层数尽量少。</p><p>所以，我们选择树的重心，这样不会超过 $\log n$ 层。</p><p>时间复杂度为 $O(n\log^2 n)$。</p><p>由于时间都卡得很紧，需要一定优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R register</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>,Maxn=<span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N],e[<span class="number">2</span>*N],ne[<span class="number">2</span>*N],w[<span class="number">2</span>*N],idx=<span class="number">1</span>,s[N],rt,mx=<span class="number">1e7</span>,son[N],sizetot,st[N];</span><br><span class="line"><span class="keyword">int</span> n,m,k,top;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(R <span class="keyword">int</span> a,R <span class="keyword">int</span> b,R <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[++idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">findroot</span><span class="params">(R <span class="keyword">int</span> x,R <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line">s[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (R <span class="keyword">int</span> i=h[x];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (e[i]==fa||vis[e[i]]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">findroot</span>(e[i],x);</span><br><span class="line">s[x]+=s[e[i]];</span><br><span class="line">son[x]=<span class="built_in">max</span>(son[x],s[e[i]]);</span><br><span class="line">&#125;</span><br><span class="line">son[x]=<span class="built_in">max</span>(son[x],sizetot-s[x]);</span><br><span class="line"><span class="keyword">if</span> (son[x]&lt;mx) mx=son[x],rt=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(R <span class="keyword">int</span> x,R <span class="keyword">int</span> fa,R <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">st[++top]=d;</span><br><span class="line"><span class="keyword">for</span> (R <span class="keyword">int</span> i=h[x];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[e[i]]||e[i]==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">query</span>(e[i],x,d+w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(R <span class="keyword">int</span> x,R <span class="keyword">int</span> d,R <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">top=<span class="number">0</span>;<span class="built_in">query</span>(x,<span class="number">0</span>,d);</span><br><span class="line"><span class="built_in">sort</span>(st+<span class="number">1</span>,st+top+<span class="number">1</span>);</span><br><span class="line">R <span class="keyword">int</span> j=top;</span><br><span class="line">ll now=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (R <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j&amp;&amp;st[j]+st[i]&gt;k) j--;</span><br><span class="line">    now+=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;++i)</span><br><span class="line">    <span class="keyword">if</span> (st[i]*<span class="number">2</span>&lt;=k) now--;</span><br><span class="line">now/=<span class="number">2</span>;</span><br><span class="line">ans+=now*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(R <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k==<span class="number">1000</span>) cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">vis[x]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">solve</span>(x,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (R <span class="keyword">int</span> i=h[x];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[e[i]]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">solve</span>(e[i],w[i],<span class="number">-1</span>);</span><br><span class="line">mx=<span class="number">1e7</span>,rt=<span class="number">0</span>,sizetot=s[e[i]];</span><br><span class="line"><span class="built_in">findroot</span>(e[i],x);</span><br><span class="line"><span class="built_in">dfs</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k),n||k)</span><br><span class="line">&#123;</span><br><span class="line">    ans=<span class="number">0</span>;idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (R <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) son[i]=<span class="number">0</span>,vis[i]=<span class="number">0</span>,h[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (R <span class="keyword">int</span> i=<span class="number">1</span>,x,y,c;i&lt;n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;c),x++,y++,<span class="built_in">add</span>(x,y,c),<span class="built_in">add</span>(y,x,c);</span><br><span class="line"></span><br><span class="line">    mx=<span class="number">1e7</span>,rt=<span class="number">0</span>,sizetot=n;</span><br><span class="line">    <span class="built_in">findroot</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="built_in">dfs</span>(rt);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>,M=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> p[N],q[N],n,m;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> ans[N],que[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_size</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (e[i]!=fa) res+=<span class="built_in">get_size</span>(e[i],x);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_zx</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa,<span class="keyword">int</span> tot,<span class="keyword">int</span> &amp;zx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">1</span>,mx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[e[i]]||e[i]==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">get_zx</span>(e[i],x,tot,zx);</span><br><span class="line">sum+=t;mx=<span class="built_in">max</span>(mx,t);</span><br><span class="line">&#125;</span><br><span class="line">mx=<span class="built_in">max</span>(mx,tot-sum);</span><br><span class="line"><span class="keyword">if</span> (mx&lt;=tot/<span class="number">2</span>) zx=x;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa,<span class="keyword">int</span> d,<span class="keyword">int</span> &amp;tot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span> (vis[x]) <span class="keyword">return</span>;</span><br><span class="line">q[tot++]=d;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span> (e[i]!=fa) <span class="built_in">query</span>(e[i],x,d+w[i],tot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> tot,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(a,a+tot);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=m;++l)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> &amp;k=que[l],res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=tot<span class="number">-1</span>,j=<span class="number">0</span>;~i;--i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j&lt;tot&amp;&amp;a[j]+a[i]&lt;k) j++;</span><br><span class="line"><span class="keyword">if</span> (a[j]+a[i]&gt;k) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span> (j&lt;tot&amp;&amp;a[j]+a[i]==k)</span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">if</span> (j==i+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">res++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans[l]+=res*f/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[x]) <span class="keyword">return</span> ;</span><br><span class="line"><span class="built_in">get_zx</span>(x,<span class="number">-1</span>,<span class="built_in">get_size</span>(x,<span class="number">-1</span>),x);</span><br><span class="line">vis[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">query</span>(e[i],<span class="number">-1</span>,w[i],tot);</span><br><span class="line"><span class="built_in">solve</span>(q,tot,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tot;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=m;++l)</span><br><span class="line"><span class="keyword">if</span> (que[l]==q[j]) ans[l]++;</span><br><span class="line">p[cnt++]=q[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">solve</span>(p,cnt,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i]) <span class="built_in">calc</span>(e[i]);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);idx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y,c;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;x,&amp;y,&amp;c);</span><br><span class="line"><span class="built_in">add</span>(x,y,c);<span class="built_in">add</span>(y,x,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;que[i]);</span><br><span class="line"><span class="built_in">calc</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">puts</span>(ans[i]?<span class="string">&quot;AYE&quot;</span>:<span class="string">&quot;NAY&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-例题"><a href="#3-例题" class="headerlink" title="3. 例题"></a>3. 例题</h3><h4 id="T2：权值"><a href="#T2：权值" class="headerlink" title="T2：权值"></a>T2：权值</h4><p><a href="https://www.acwing.com/problem/content/266/">题目传送门 AcWing</a></p><p>其实和上面的类似，我们可以分为一个一个的子树。</p><p>在同一棵子树中，可以递归处理，我们需要考虑的就是不同子树之间的距离。</p><p>可以直接处理每一个节点到根节点的距离，存在一个桶中。</p><p>其中，桶中存的是每一个对应距离，最小经过的边。</p><p>这样就可以了。</p><p>注意，我们无需每次清空桶，只需每一次将用过的点的操作撤销即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,M=<span class="number">4e5</span>+<span class="number">20</span>,Maxn=<span class="number">1e7</span>+<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> f[Maxn],n,m,ans=INF;</span><br><span class="line">PII p[N],q[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_size</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        res+=<span class="built_in">get_size</span>(e[i],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_zx</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa,<span class="keyword">int</span> tot,<span class="keyword">int</span> &amp;zx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">1</span>,mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="built_in">get_zx</span>(e[i],x,tot,zx);</span><br><span class="line">        sum+=t;mx=<span class="built_in">max</span>(mx,t);</span><br><span class="line">    &#125;</span><br><span class="line">    mx=<span class="built_in">max</span>(mx,tot-sum);</span><br><span class="line">    <span class="keyword">if</span> (mx&lt;=tot/<span class="number">2</span>) zx=x;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa,<span class="keyword">int</span> d,<span class="keyword">int</span> now,<span class="keyword">int</span> &amp;tot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]||d&gt;m) <span class="keyword">return</span> ;</span><br><span class="line">    q[tot++]=<span class="built_in">mp</span>(d,now);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i]!=fa) <span class="built_in">query</span>(e[i],x,d+w[i],now+<span class="number">1</span>,tot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">get_zx</span>(x,<span class="number">-1</span>,<span class="built_in">get_size</span>(x,<span class="number">-1</span>),x);</span><br><span class="line">    vis[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">query</span>(e[i],x,w[i],<span class="number">1</span>,tot);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;tot;++l)</span><br><span class="line">        &#123;</span><br><span class="line">            PII &amp;tmp=q[l];</span><br><span class="line">            <span class="keyword">if</span> (tmp.fi==m) ans=<span class="built_in">min</span>(ans,tmp.se);</span><br><span class="line">            <span class="keyword">else</span> ans=<span class="built_in">min</span>(ans,tmp.se+f[m-tmp.fi]);</span><br><span class="line">            p[cnt++]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;tot;++l) f[q[l].fi]=<span class="built_in">min</span>(f[q[l].fi],q[l].se);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;++i) f[p[i].fi]=INF;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i]) <span class="built_in">calc</span>(e[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y,c;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;x,&amp;y,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(x,y,c);<span class="built_in">add</span>(y,x,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">calc</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans!=INF) cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-点分树"><a href="#4-点分树" class="headerlink" title="4. 点分树"></a>4. 点分树</h3><p>还是来看一下例题：</p><h4 id="T3：开店"><a href="#T3：开店" class="headerlink" title="T3：开店"></a>T3：开店</h4><p><a href="https://www.luogu.com.cn/problem/P3241">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2228/">题目传送门 AcWing</a></p><p>点分树所处理的题目没有更改树的形态，而是有很多的在线询问，需要我们回答距离问题。</p><p>还是考虑递归。</p><p>首先，假设 u 在一个子树，如果当前处理的节点在 u 所在的子树内，那么我们可以递归。</p><p>如果在不同节点，我们就可以通过归并的方法来解决。</p><p>由于没有更改，我们可以先预处理重心来划分。</p><p>可以将重心连接起来，我们发现又是一棵树。</p><p>这也是“点分树”的命名来源。</p><p>然后，我们应该如何计算所有点到 u 的距离和呢？</p><p>有两种情况：</p><p><strong>1：</strong> 与兄弟子树（即 u 不是重心）。</p><p>首先，我们可以将答案分为两部分：u 到重心的距离乘以个数，再加上兄弟子树到重心的总距离。</p><p>我们可以将所有节点的年龄以及到重心的距离按年龄排序，直接二分即可，就可以求第一个了。</p><p>对于第二个，我们可以预处理前缀和。</p><p><strong>2：</strong> 与所有子树（即 u 是重心）。</p><p>其实和上面一种情况比较相似，我们直接对于每一个子树，按上面的求就是了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">150010</span>,M=<span class="number">300010</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> a[N],n,q,atot;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">ll res;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Father</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> zx,now;</span><br><span class="line">    ll d;</span><br><span class="line">&#125;;</span><br><span class="line">vector &lt;Father&gt; f[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Son</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;ll d;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Son &amp;t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&lt;t.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector &lt;Son&gt; s[N][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_size</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i]!=fa) res+=<span class="built_in">get_size</span>(e[i],x);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_zx</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa,<span class="keyword">int</span> tot,<span class="keyword">int</span> &amp;zx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">1</span>,maxn=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="built_in">get_zx</span>(e[i],x,tot,zx);</span><br><span class="line">        maxn=<span class="built_in">max</span>(maxn,t);sum+=t;</span><br><span class="line">    &#125;</span><br><span class="line">    maxn=<span class="built_in">max</span>(maxn,tot-sum);</span><br><span class="line">    <span class="keyword">if</span> (maxn&lt;=tot/<span class="number">2</span>) zx=x;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_son_tree</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa,ll d,<span class="keyword">int</span> zx,<span class="keyword">int</span> k,vector&lt;Son&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="keyword">return</span>;</span><br><span class="line">    f[x].<span class="built_in">push_back</span>((Father)&#123;zx,k,d&#125;);</span><br><span class="line">    p.<span class="built_in">push_back</span>((Son)&#123;a[x],d&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i]!=fa) <span class="built_in">get_son_tree</span>(e[i],x,d+w[i],zx,k,p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">get_zx</span>(x,<span class="number">-1</span>,<span class="built_in">get_size</span>(x,<span class="number">-1</span>),x);</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x],now=<span class="number">0</span>;~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[e[i]]) <span class="keyword">continue</span>;</span><br><span class="line">        vector&lt;Son&gt; &amp;p=s[x][now];</span><br><span class="line">        <span class="built_in">get_son_tree</span>(e[i],x,w[i],x,now,p);</span><br><span class="line">        p.<span class="built_in">push_back</span>((Son)&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        p.<span class="built_in">push_back</span>((Son)&#123;INF,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;p.<span class="built_in">size</span>();++i) p[i].d+=p[i<span class="number">-1</span>].d;</span><br><span class="line">        now++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i]) <span class="built_in">calc</span>(e[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;f[x].<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Father &amp;tmp=f[x][i];</span><br><span class="line">        <span class="keyword">if</span> (a[tmp.zx]&gt;=l&amp;&amp;a[tmp.zx]&lt;=r) res+=tmp.d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> now=<span class="number">0</span>;now&lt;<span class="number">3</span>;++now)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;Son&gt; &amp;p=s[tmp.zx][now];</span><br><span class="line">            <span class="keyword">if</span> (now==tmp.now||p.<span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> tl=<span class="built_in">lower_bound</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),(Son)&#123;l,<span class="number">0</span>&#125;)-p.<span class="built_in">begin</span>(),</span><br><span class="line">                tr=<span class="built_in">lower_bound</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),(Son)&#123;r+<span class="number">1</span>,<span class="number">0</span>&#125;)-p.<span class="built_in">begin</span>();</span><br><span class="line">            res+=(tr-tl)*tmp.d+p[tr<span class="number">-1</span>].d-p[tl<span class="number">-1</span>].d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> now=<span class="number">0</span>;now&lt;<span class="number">3</span>;++now)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;Son&gt; &amp;p=s[x][now];</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> tl=<span class="built_in">lower_bound</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),(Son)&#123;l,<span class="number">0</span>&#125;)-p.<span class="built_in">begin</span>(),</span><br><span class="line">            tr=<span class="built_in">lower_bound</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),(Son)&#123;r+<span class="number">1</span>,<span class="number">0</span>&#125;)-p.<span class="built_in">begin</span>();</span><br><span class="line">        res+=p[tr<span class="number">-1</span>].d-p[tl<span class="number">-1</span>].d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q&gt;&gt;atot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y,c;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;x,&amp;y,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(x,y,c);<span class="built_in">add</span>(y,x,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">calc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x,l,r;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;x,&amp;l,&amp;r);</span><br><span class="line">        l=(l+res)%atot;r=(r+res)%atot;</span><br><span class="line">        <span class="keyword">if</span> (l&gt;r) <span class="built_in">swap</span>(l,r);</span><br><span class="line">        <span class="built_in">query</span>(x,l,r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 分治 </tag>
            
            <tag> 点分治和点分树 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国剩余定理</title>
      <link href="/2021/12/13/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
      <url>/2021/12/13/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>注意公式。</p><span id="more"></span><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><h3 id="0-前置知识"><a href="#0-前置知识" class="headerlink" title="0. 前置知识"></a>0. 前置知识</h3><p>逆元。</p><p><a href="https://www.luogu.com.cn/blog/mydcwfy-342891/inverse-element">我的逆元 Blog</a></p><h3 id="1-处理的问题"><a href="#1-处理的问题" class="headerlink" title="1. 处理的问题"></a>1. 处理的问题</h3><p>$m_1,m_2,..,m_n$ 两两互质。</p><p>求 $x\in \text{Z}$，使：</p><p>$$<br>\begin{array}{ll}<br>x=a_1\pmod {m_1}\\<br>x=a_2\pmod {m_2}\\<br>…\\<br>x=a_n\pmod {m_n}<br>\end{array}<br>$$</p><h3 id="2-解决的方法"><a href="#2-解决的方法" class="headerlink" title="2. 解决的方法"></a>2. 解决的方法</h3><p>设 $M=m_1m_2…m_n$。</p><p>令 $M_i=\dfrac{M}{m_i},t_i=M_i^{-1}\pmod {m_i}$。</p><p>那么，$x=\sum_{i=1}^{n} {a_i * t_i * M_i}$。</p><p>证明略。（背就行了 <del>逃</del>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n,m[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exGCD</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b)</span><br><span class="line">&#123;</span><br><span class="line">x=<span class="number">1</span>;y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exGCD</span>(b,a%b,y,x);</span><br><span class="line">y-=a/b*x;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m[i],&amp;b[i]);</span><br><span class="line">ll M=<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) M*=m[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">ll Mi=M/m[i],ti,x;</span><br><span class="line"><span class="built_in">exGCD</span>(Mi,m[i],ti,x);</span><br><span class="line">res+=b[i]*Mi*ti;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(res%M+M)%M);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学基础杂论</title>
      <link href="/2021/12/13/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%9D%82%E8%AE%BA/"/>
      <url>/2021/12/13/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%9D%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>本人由于以前看过一些书，对一些知识有一定的了解，所以这里只讲自己不懂的知识和例题。</p><p>对于基础的算法，可能也会有简略的讲解。</p><span id="more"></span><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>有以下内容：</p><ol><li>筛质数</li><li>同余（扩欧）</li><li>中国剩余定理</li><li>矩阵乘法（快速幂）</li><li>组合计数（加乘原理，Lucas，Catalan）</li></ol><h2 id="1-筛质数"><a href="#1-筛质数" class="headerlink" title="1. 筛质数"></a>1. 筛质数</h2><p>以前写过，就放在这里了。</p><p><a href="https://www.luogu.com.cn/blog/mydcwfy-342891/prime-election">我的筛质数的 Blog</a></p><h2 id="2-同余"><a href="#2-同余" class="headerlink" title="2. 同余"></a>2. 同余</h2><p>解决形如 $ax\equiv 1\pmod b$ 或 $ax+by=1$ 不定方程的算法，为扩展欧几里得算法。</p><p>利用欧几里得算法，我们就可以计算不同的状态之间的转移。</p><p>具体直接看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">ExGCD</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;</span><br><span class="line">ll d;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) x=<span class="number">1</span>,y=<span class="number">0</span>,d=a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">d=<span class="built_in">ExGCD</span>(b,a%b,y,x),y-=a/b*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T1：青蛙的约会"><a href="#T1：青蛙的约会" class="headerlink" title="T1：青蛙的约会"></a>T1：青蛙的约会</h3><p><a href="https://www.luogu.com.cn/problem/P1516">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/224/">题目传送门 AcWing</a></p><p>模板题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExGCD</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y,ll &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b)</span><br><span class="line">&#123;</span><br><span class="line">x=<span class="number">1</span>,y=<span class="number">0</span>;d=a;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ExGCD</span>(b,a%b,y,x,d);</span><br><span class="line">y-=a/b*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll x,y,m,n,l;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;m,&amp;n,&amp;l);</span><br><span class="line">ll a=x-y,b=n-m;</span><br><span class="line">ll d,t;<span class="built_in">ExGCD</span>(b,l,x,y,d);</span><br><span class="line"><span class="keyword">if</span> (a%d) <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">x*=a/d;</span><br><span class="line">ll t=<span class="built_in">abs</span>(l/d);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(x%t+t)%t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T2：最幸运的数字"><a href="#T2：最幸运的数字" class="headerlink" title="T2：最幸运的数字"></a>T2：最幸运的数字</h3><p><a href="https://www.acwing.com/problem/content/204/">题目传送门 AcWing</a></p><p>首先，$x$ 个 8 可以表示为 $\dfrac89*(10^x-1)$，那么 $L|\dfrac89*(10^x-1)|\Leftrightarrow \dfrac{9L}d|\dfrac8d(10^x-1)$，其中 $\gcd(8,L)=d$。</p><p>又 $\dfrac8d$ 与左边互质，所以无需该数。</p><p>于是，我们令 $c=\dfrac{9L}d$，则变为 $10^x\equiv1\pmod c$。</p><p>首先，如果 $\gcd(10,c)\not=1$，那么原方程无解（因为左边一定是 $c$  的倍数，而右边不是）。</p><p>又知道 $10^{\varphi(c)}\equiv1\pmod c$，于是 $\varphi(c)$ 满足答案。</p><p>那么，怎样求一个最小的呢？</p><p><strong>证明：</strong> 最小的 $x$ 一定是 $\varphi(c)$ 的约数。</p><p>（以下模的方程省略 $\pmod c$）</p><p>使用反证法。</p><p>假设 $x\not|\varphi(c)$，那么可以写为 $\varphi(c)=qx+r$，其中 $0&lt;r&lt;x$。</p><p>首先，由于 $10^x\equiv1$，则 $10^{qx}\equiv1$。</p><p>又 $10^{\varphi(c)}\equiv1$，即 $10^{qx+r}\equiv1$。</p><p>所以，$10^r\equiv1$，与 $x$ 的最小性矛盾。</p><p>故原命题成立。</p><p><strong>证毕</strong>。</p><p>回到本题，只需我们枚举约数即可。</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll l;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qmul</span><span class="params">(ll a,ll b,ll p)</span><span class="comment">//快速乘（可能爆 long long） </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b&amp;<span class="number">1</span>) res+=a,res%=p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;a+=a;a%=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b,ll p)</span><span class="comment">//快速幂 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b&amp;<span class="number">1</span>) res=<span class="built_in">qmul</span>(res,a,p);</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;a=<span class="built_in">qmul</span>(a,a,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get_phi</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=n;</span><br><span class="line">    <span class="keyword">for</span> (ll i=<span class="number">2</span>;i&lt;=n/i;++i)</span><br><span class="line">        <span class="keyword">if</span> (n%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (n%i==<span class="number">0</span>) n/=i;</span><br><span class="line">            res=res/i*(i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n&gt;<span class="number">1</span>) res=res/n*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;l))&amp;&amp;l)</span><br><span class="line">    &#123;</span><br><span class="line">        ll d=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l%(d*<span class="number">2</span>)==<span class="number">0</span>&amp;&amp;d*<span class="number">2</span>&lt;=<span class="number">8</span>) d*=<span class="number">2</span>;</span><br><span class="line">        ll n=<span class="number">9</span>*l/d;</span><br><span class="line">        ll phi=<span class="built_in">get_phi</span>(n);</span><br><span class="line">        ll res=(<span class="number">1ll</span>&lt;&lt;<span class="number">60</span>);</span><br><span class="line">        <span class="keyword">for</span> (ll i=<span class="number">1</span>;i&lt;=phi/i&amp;&amp;i&lt;=res;++i)</span><br><span class="line">            <span class="keyword">if</span> (phi%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">qpow</span>(<span class="number">10</span>,i,n)==<span class="number">1</span>) res=<span class="built_in">min</span>(res,i);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">qpow</span>(<span class="number">10</span>,phi/i,n)==<span class="number">1</span>) res=<span class="built_in">min</span>(res,phi/i);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (res==(<span class="number">1ll</span>&lt;&lt;<span class="number">60</span>)) res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %lld\n&quot;</span>,++t,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="3-中国剩余定理"><a href="#3-中国剩余定理" class="headerlink" title="3. 中国剩余定理"></a>3. 中国剩余定理</h2><p>巧了，我以前也写过。</p><p><a href="https://www.luogu.com.cn/blog/mydcwfy-342891/chinese-remainder-theorem">我的中国剩余定理 Blog</a></p><h2 id="4-矩阵乘法"><a href="#4-矩阵乘法" class="headerlink" title="4. 矩阵乘法"></a>4. 矩阵乘法</h2><p>不想讲，主要是定义对于 OI 毫无用处。</p><p>自己去百度吧 <del>（逃）</del>。</p><p>只放一个代码。</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">202</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF=<span class="number">1e16</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ll a[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">(<span class="keyword">int</span> _n,<span class="keyword">int</span> _m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n=_n,m=_m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j) a[i][j]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> *(<span class="keyword">const</span> Matrix &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">        Matrix c;</span><br><span class="line">        <span class="keyword">if</span> (m!=b.n) <span class="keyword">return</span> c;</span><br><span class="line">        c.<span class="built_in">clean</span>(n,b.m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c.n;++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c.m;++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;++k) c.a[i][j]+=a[i][k]*b.a[k][j],c.a[i][j]%=Mod;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;F0;</span><br><span class="line"></span><br><span class="line">Matrix <span class="keyword">operator</span> ^(Matrix a,ll n)</span><br><span class="line">&#123;</span><br><span class="line">    Matrix ans=a;n--;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&amp;<span class="number">1</span>) ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>在 OI 中，主要使用快速幂优化。</p><p>也就是上面的最后一个重载运算符。</p><h3 id="T1：-HNOI2008-GT考试"><a href="#T1：-HNOI2008-GT考试" class="headerlink" title="T1：[HNOI2008]GT考试"></a>T1：[HNOI2008]GT考试</h3><p><a href="https://www.luogu.com.cn/problem/P3193">题目传送门 Luogu</a></p><p><a href="https://loj.ac/p/10224">题目传送门 LOJ</a></p><p>可以利用矩阵快速幂优化。</p><h2 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h2><p>如果你小学（？）学过的话，就会觉得不太难。</p><p>方面特别多，我们一个一个看（以例题看）。</p><h3 id="T1：牡牛和牝牛"><a href="#T1：牡牛和牝牛" class="headerlink" title="T1：牡牛和牝牛"></a>T1：牡牛和牝牛</h3><p><a href="https://loj.ac/p/10230">题目传送门 LOJ</a></p><p>这个是一种组合计数。</p><p>用 $f(i)$ 表示所有以 $1$ 结尾的长度为 $i$ 的字符串的数量。</p><p>那么，我们可以得到：<br>$$<br>f(i)=\sum_{j=0}^{i-k-1}f(j)<br>$$<br>答案为：<br>$$<br>ans=\sum_{i=0}^{n}f(i)<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,Mod=<span class="number">5000011</span>;</span><br><span class="line">ll s[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">s[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">f[i]=s[<span class="built_in">max</span>(i-k<span class="number">-1</span>,<span class="number">0</span>)];</span><br><span class="line">s[i]=s[i<span class="number">-1</span>]+f[i];s[i]%=Mod;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;s[n]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T2：车的放置"><a href="#T2：车的放置" class="headerlink" title="T2：车的放置"></a>T2：车的放置</h3><p><a href="https://www.luogu.com.cn/problem/P1350">题目传送门 Luogu</a></p><p><a href="https://loj.ac/p/10232">题目传送门 LOJ</a></p><p>可以使用化整为零的思想。</p><p>分情况讨论，并将所有的答案加起来。</p><p>首先，我们考虑矩形求答案。</p><p>假设长为 $n$，宽为 $m$，那么，答案为：<br>$$<br>ans=\binom mk*P_n^k<br>$$<br>回归本题，枚举上面放 $i$ 个车，下面放 $k-i$ 个车。</p><p>注意，我们要首先计算上面的，因为上面的对下面的影响是固定的，而下面对上面的影响可能变化。</p><p>所以，答案为：<br>$$<br>ans=\sum_{i=1}^{k}{\binom bi<em>P_a^i</em>\binom d{k-i}*P_ {a+c-i}^{k-i}}<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2010</span>,Mod=<span class="number">1e5</span>+<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a,b,c,d,k;</span><br><span class="line">ll f[N],inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (b&amp;<span class="number">1</span>) res*=a,res%=Mod;</span><br><span class="line">a*=a;a%=Mod;b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[<span class="number">0</span>]=inv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">f[<span class="number">1</span>]=inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) f[i]=f[i<span class="number">-1</span>]*i%Mod,inv[i]=<span class="built_in">qpow</span>(f[i],Mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m&gt;n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> f[n]*inv[n-m]%Mod*inv[m]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">P</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m&gt;n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> f[n]*inv[n-m]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;k;</span><br><span class="line"><span class="built_in">init</span>(N<span class="number">-1</span>);</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;++i)</span><br><span class="line">res+=<span class="built_in">C</span>(b,i)*<span class="built_in">P</span>(a,i)%Mod*<span class="built_in">C</span>(d,k-i)%Mod*<span class="built_in">P</span>(a+c-i,k-i)%Mod,res%=Mod;</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T3：数三角形"><a href="#T3：数三角形" class="headerlink" title="T3：数三角形"></a>T3：数三角形</h3><p><a href="https://www.luogu.com.cn/problem/P3166">题目传送门 Luogu</a></p><p><a href="https://loj.ac/p/2240">题目传送门 LOJ</a></p><p>我们可以使用容斥原理的思想。</p><p>首先，总方案为 $\binom {m*n}3$。</p><p>减去的就是三点共线的情况。</p><p>首先，水平的和竖直的情况共有 $n\binom m3+m\binom n3$。</p><p>然后，我们考虑斜率不为 0 的情况。</p><p>首先，对于每一个斜率小于 0 的情况，都可以转化为大于 0 的情况。</p><p>按照左下角的位置，划分为 $n*m$ 种情况。</p><p>对于每一个点 $(i,j)$ 再按照右上角的位置划分为 $(n-i)*(m-j)$ 种情况。</p><p>怎样求在上面的点的数量呢？</p><p>假设第二次选出的点为 $(x,y)$。</p><p>可以发现，就是 $\gcd(x-i,y-j)-1$ 种情况。</p><h3 id="T4：序列统计"><a href="#T4：序列统计" class="headerlink" title="T4：序列统计"></a>T4：序列统计</h3><p><a href="https://loj.ac/p/10235">题目传送门 LOJ</a></p><p>首先，我们可以映射为 $[0,R-L]$ 的序列。</p><p>然后使用差分思想，设 $x_i=a_i-a_{i-1}$，那么原问题转化为 $x_1+x_2+…+x_k\leq R-L,x_i\geq 0$，其中 $k$ 为长度。</p><p>那么，令 $y_i=x_i+1$，那么变为 $y_1+y_2+…+y_k\leq R-L+k$。</p><p>假设 $y_{k+1}$ 为 $R-L+k+1-(y_1+y_2+…+y_k)$，则 $y_{k+1}\geq 1$，那么原式变为 $y_1+y_2+…+y_{k+1}=R-L+k+1$。</p><p>利用隔板法，就可以得到答案 $\binom {R-L+k}k$。</p><p>于是，总答案就为：<br>$$<br>ans=\sum_{k=1}^{N}{\binom {R-L+k}k}=\sum_{k=1}^{N}{\binom {R-L+k}{R-L}}<br>$$<br>又因为 $\binom ab=\binom{a-1}b+\binom{a-1}{b-1}$，于是：<br>$$<br>ans=\binom{R-L+1}{R-L+1}+\sum_{k=1}^{N}{\binom {R-L+k}{R-L}}-1<br>$$<br>利用公式，就可以得到：<br>$$<br>ans=\binom{R-L+N+1}{R-L+1}-1<br>$$<br>注意，这里一定要看懂，可能有些绕！</p><p>接下来，因为 $R,L,N\leq10^9$，所以要使用 Lucas。</p><p><strong>Lucas 定理</strong>。</p><p>这个大概背代码就可以了。</p><p>核心就是 $\binom nm\equiv\binom{n%p}{m%p}* \binom{n/p}{m/p}\pmod p$，其中 $p$ 为质数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&amp;<span class="number">1</span>) ans*=a,ans%=p;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a*=a;a%=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>,tmp=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>,i=a;j&lt;=b;--i,++j) ans*=i,ans%=p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=b;++i) tmp*=i,tmp%=p;</span><br><span class="line">    <span class="keyword">return</span> ans*<span class="built_in">qpow</span>(tmp,p<span class="number">-2</span>,p)%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lucas</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lucas</span>(n/p,m/p,p)*<span class="built_in">cm</span>(n%p,m%p,p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以了！</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">1e6</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> n,l,r;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (b&amp;<span class="number">1</span>) res*=a,res%=Mod;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">a*=a;a%=Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll ans=<span class="number">1</span>,fac=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) fac*=i,fac%=Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=n-m+<span class="number">1</span>;i&lt;=n;++i) ans*=i,ans%=Mod;</span><br><span class="line"><span class="keyword">return</span> ans*<span class="built_in">qpow</span>(fac,Mod<span class="number">-2</span>)%Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Lucas</span><span class="params">(ll n,ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n&lt;Mod&amp;&amp;m&lt;Mod) <span class="keyword">return</span> <span class="built_in">C</span>(n,m);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Lucas</span>(n/Mod,m/Mod)*<span class="built_in">C</span>(n%Mod,m%Mod)%Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;l,&amp;r);</span><br><span class="line">ll res=<span class="built_in">Lucas</span>(r-l+n+<span class="number">1</span>,r-l+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res?res<span class="number">-1</span>:Mod<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="T5：网络"><a href="#T5：网络" class="headerlink" title="T5：网络"></a>T5：网络</h3><p><a href="https://loj.ac/p/10238">题目传送门 LOJ</a></p><p>Catalan。</p><p>假设我们从 (0,0) 走到 (n,n)，其中横坐标必须大于等于纵坐标，请问答案有多少种。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ohufdrpi.png"></p><p>首先，总数即为 $\binom {2n} {n}$，因为我们要在 $2n$ 次里选出  $n$ 个向上。</p><p>利用容斥原理，我们发现 $ans=\binom {2n} n$ 再减去不合法的即可。</p><p>如果不合法，那么我们一定有一个 2 点，在红线上。</p><p>将 2 到 3 的路径沿红线翻转，那么，就得到一个 3‘ 点。</p><p>同理，我们可以将每一个到 3’ 点沿红线翻转到 3 点。</p><p>到 3’ 的方法有 $\binom{2n}{n+1}$ 种。</p><p>答案即为 $ans=\binom{2n}{n}-\binom{2n}{n+1}$。</p><p>回到本题，又有了一些变化。</p><p>我们可以使用类似的映射方式。</p><p>$n\not=m$，需要我们更改一下。</p><p>首先，将 $(n,m)$ 整体下移一格，得到 $(n,m-1)$，同时将红线向下平移一格，再关于红线对称，得到 $(m-1,n)$，再上移一格，最后得到 $(m-1,n+1)$。</p><p>所以，不合法的方案数即为 $\binom{m+n}{m-1}$。</p><p>答案即为 $ans=\binom{m+n}m-\binom{m+n}{m-1}$。</p><p>注意，本题答案很大，需要高精。</p><p>（写了一天）</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//支持正整数的加减乘除乘方，位数小于 40000</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">num</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ll a[N];</span><br><span class="line">    <span class="keyword">const</span> ll B = <span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; ++i)</span><br><span class="line">            a[i + <span class="number">1</span>] += a[i] / B, a[i] %= B;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (a[a[<span class="number">0</span>] + <span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">            a[<span class="number">0</span>]++, a[a[<span class="number">0</span>] + <span class="number">1</span>] += a[a[<span class="number">0</span>]] / B, a[a[<span class="number">0</span>]] %= B;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((!a[a[<span class="number">0</span>]]) &amp;&amp; a[<span class="number">0</span>] &gt; <span class="number">1</span>)</span><br><span class="line">            a[<span class="number">0</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">1</span>] = x % B;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (x &gt;= B)</span><br><span class="line">            a[++a[<span class="number">0</span>]] = x / B, x /= B;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> num <span class="keyword">operator</span> =(<span class="keyword">const</span> num &amp;b) &#123;</span><br><span class="line">        <span class="built_in">init</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= b.a[<span class="number">0</span>]; ++i)</span><br><span class="line">            a[i] = b.a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> num &amp;b)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] != b.a[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; ++i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] != b.a[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> num &amp;b)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] != b.a[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b.a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; ++i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] != b.a[i])</span><br><span class="line">                <span class="keyword">return</span> a[i] &lt; b.a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;=(<span class="keyword">const</span> num &amp;b)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] != b.a[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b.a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; ++i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] != b.a[i])</span><br><span class="line">                <span class="keyword">return</span> a[i] &lt; b.a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;(<span class="keyword">const</span> num &amp;b)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] != b.a[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b.a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; ++i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] != b.a[i])</span><br><span class="line">                <span class="keyword">return</span> a[i] &gt; b.a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;=(<span class="keyword">const</span> num &amp;b)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] != b.a[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b.a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; ++i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] != b.a[i])</span><br><span class="line">                <span class="keyword">return</span> a[i] &gt; b.a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> num <span class="keyword">operator</span> +(<span class="keyword">const</span> num &amp;b)<span class="keyword">const</span> &#123;</span><br><span class="line">        num ans;</span><br><span class="line">        ans.<span class="built_in">init</span>(<span class="number">0</span>);</span><br><span class="line">        ans.a[<span class="number">0</span>] = <span class="built_in">max</span>(a[<span class="number">0</span>], b.a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ans.a[<span class="number">0</span>]; ++i)</span><br><span class="line">            ans.a[i] = a[i] + b.a[i];</span><br><span class="line"></span><br><span class="line">        ans.<span class="built_in">adjust</span>();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> num <span class="keyword">operator</span> -(<span class="keyword">const</span> num &amp;x)<span class="keyword">const</span> &#123;</span><br><span class="line">        num ans;</span><br><span class="line">        ans.<span class="built_in">init</span>(<span class="number">0</span>);</span><br><span class="line">        ans.a[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">        num b = x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; ++i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; b.a[i])</span><br><span class="line">                ans.a[i] += a[i] - b.a[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.a[i] += a[i] + B - b.a[i], ans.a[i + <span class="number">1</span>]--;</span><br><span class="line"></span><br><span class="line">        ans.<span class="built_in">adjust</span>();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> num <span class="keyword">operator</span> *(<span class="keyword">const</span> num &amp;b)<span class="keyword">const</span> &#123;</span><br><span class="line">        num ans;</span><br><span class="line">        ans.<span class="built_in">init</span>(<span class="number">0</span>);</span><br><span class="line">        ans.a[<span class="number">0</span>] = a[<span class="number">0</span>] + b.a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b.a[<span class="number">0</span>]; ++j)</span><br><span class="line">                ans.a[i + j - <span class="number">1</span>] += a[i] * b.a[j];</span><br><span class="line"></span><br><span class="line">            ans.<span class="built_in">adjust</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> num <span class="keyword">operator</span> *(<span class="keyword">const</span> <span class="keyword">int</span> &amp;b)<span class="keyword">const</span> &#123;</span><br><span class="line">        num ans=*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; ++i)</span><br><span class="line">            t+=a[i]*b,ans.a[i]=t%B,t/=B;</span><br><span class="line">        <span class="keyword">while</span> (t) ans.a[++ans.a[<span class="number">0</span>]]=t%B,t/=B;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> num <span class="keyword">operator</span> /(<span class="keyword">const</span> <span class="keyword">int</span> &amp;b)<span class="keyword">const</span> &#123;</span><br><span class="line">        num ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= a[<span class="number">0</span>]; ++i)</span><br><span class="line">            ans.a[i] = a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a[<span class="number">0</span>]; i; --i)</span><br><span class="line">            <span class="comment">/*ans.a[i-1]+=a[i]%b*B,ans.a[i]/=b;*/</span></span><br><span class="line">            y = B * y + ans.a[i], ans.a[i] = y / b, y %= b;</span><br><span class="line"></span><br><span class="line">        ans.<span class="built_in">adjust</span>();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> num <span class="keyword">operator</span> ^(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">            num ans;</span><br><span class="line">            ans.<span class="built_in">init</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        num ans, now;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= a[<span class="number">0</span>]; ++i)</span><br><span class="line">            now.a[i] = ans.a[i] = a[i];</span><br><span class="line"></span><br><span class="line">        ll b = x - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">                ans = ans * now;</span><br><span class="line"></span><br><span class="line">            now = now * now;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; a[a[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a[<span class="number">0</span>] - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>, a[i] / <span class="number">1000</span>, a[i] / <span class="number">100</span> % <span class="number">10</span>, a[i] / <span class="number">10</span> % <span class="number">10</span>, a[i] % <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">            prime[cnt++] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; i * prime[j] &lt; N; ++j) &#123;</span><br><span class="line">            st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!(i % prime[j]))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(ll n, ll p)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">        ans += n / p, n /= p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">num <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    num ans;</span><br><span class="line">    ans.<span class="built_in">init</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = prime[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p &gt; n)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        ll tmp=<span class="number">1</span>;</span><br><span class="line">        ll t=<span class="built_in">get</span>(n, p) - <span class="built_in">get</span>(m, p) - <span class="built_in">get</span>(n - m, p);</span><br><span class="line">        <span class="comment">/*if (p==2) printf(&quot;%d %d %d %d %d %d\n&quot;,get(n,p),get(m,p),get(n-m,p),n,m,n-m);</span></span><br><span class="line"><span class="comment">        printf(&quot;%d %d\n&quot;,p,t);*/</span></span><br><span class="line">        <span class="keyword">while</span> (t--) ans=ans*p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// puts(&quot;success&quot;);</span></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    num res = <span class="built_in">C</span>(n + m, m);</span><br><span class="line">    res=res-<span class="built_in">C</span>(n + m, n+<span class="number">1</span>);</span><br><span class="line">    res.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="T6：-HNOI2009-有趣的数列"><a href="#T6：-HNOI2009-有趣的数列" class="headerlink" title="T6：[HNOI2009]有趣的数列"></a>T6：[HNOI2009]有趣的数列</h3><p><a href="https://www.luogu.com.cn/problem/P3200">题目传送门 Luogu</a></p><p><a href="https://loj.ac/p/10239">题目传送门 LOJ</a></p><p>其实本题还是一个 Catalan。</p><p>怎样证明呢？</p><p>可以发现，</p><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><h3 id="T1：球形空间生成器"><a href="#T1：球形空间生成器" class="headerlink" title="T1：球形空间生成器"></a>T1：球形空间生成器</h3><p><a href="https://www.luogu.com.cn/problem/P4035">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/209/">题目传送门 AcWing</a></p><p>根据球的性质，可以得到：<br>$$<br>\begin{cases}<br>(a_{1,1}-x_1)^2+(a_{1,2}-x_2)^2+…+(a_{1,n}-x_n)^2=R^2\\<br>(a_{2,1}-x_1)^2+(a_{2,2}-x_2)^2+…+(a_{2,n}-x_n)^2=R^2\\<br>…\\<br>(a_{n+1,1}-x_1)^2+(a_{n+1,2}-x_2)^2+…+(a_{n+1,n}-x_n)^2=R^2<br>\end{cases}<br>$$<br>是一个二次方程，其实不好解。</p><p>但是，我们可以相减，就可以把二次消掉了。</p><p>有些麻烦，<del>懒得写公式了</del>。</p><h3 id="T2：开关问题"><a href="#T2：开关问题" class="headerlink" title="T2：开关问题"></a>T2：开关问题</h3><p><a href="https://www.acwing.com/problem/content/210/">题目传送门 AcWing</a></p><p>本题是异或高斯消元法。</p><p>首先，发现：每一个开关最多开一次。</p><p>可以得到：影响该开关的所有开关的异或和再异或上初始的状态为终状态。</p><p>看代码就可以了。</p><h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><h3 id="T1：Devu-和鲜花"><a href="#T1：Devu-和鲜花" class="headerlink" title="T1：Devu 和鲜花"></a>T1：Devu 和鲜花</h3><p><a href="https://www.luogu.com.cn/problem/CF451E">题目传送门 Luogu(RemoteJudge:Codeforces)</a></p><p><a href="https://www.acwing.com/problem/content/216/">题目传送门 AcWing</a></p><p>首先，考虑每个盒子花有无限个。</p><p>那么，$x_1+x_2..+x_N=M(x_i\geq0)$，隔版法即可。</p><p>答案为 $\binom{N+M-1}{N-1}$。</p><p>然后考虑容斥原理。</p><p>首先，我们计算不满足第一个盒子的情况。</p><p>假设不满足第 $i$ 个盒子的情况为 $S_i$</p><p>利用容斥，我们可以得到<br>$$<br>ans=\binom{M+N-1}{M-1}-\sum_{i=1}^{n}|S_i|+ \sum_{i=1}^{n}\sum_{j=i+1}^n|S_i\cup S_j|-…<br>$$<br>可以将每一个理解为 $2^n$ 的二进制，每一位代表是否不满足该条件。</p><p>奇减偶加，就可以了。</p><h2 id="Mobius-函数"><a href="#Mobius-函数" class="headerlink" title="Mobius 函数"></a>Mobius 函数</h2><p><del>（前面我开始没学懂）</del></p><p>定义 $\mu(x)$ 为莫比乌斯函数为：<br>$$<br>\begin{array}{ll}<br>0(d_i&gt;1)\\<br>-1(k\equiv1\pmod2)\\<br>1(k\equiv0\pmod2)<br>\end{array}<br>$$<br>其中，$x=p_1^{d_1}*p_2^{d_2}…*p_k^{d_k}$，$p_i$ 为质数。</p><h3 id="1-求法"><a href="#1-求法" class="headerlink" title="1. 求法"></a>1. 求法</h3><p>在线性筛上改进。</p><ol><li>如果是质数，那么 $\mu(x)=-1$。</li><li>如果 $i\equiv0\pmod{prime[j]}$，那么说明有一个质数的次数超过 1，那么 $\mu(x)=0$</li><li>否则，多了一个质数 $\mu(x)=-\mu(i)$。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) prime[cnt++]=i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt&amp;&amp;prime[j]*i&lt;N;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(i%prime[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                mu[prime[j]*i]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> mu[prime[j]*i]=-mu[i];</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h3><h4 id="T1：ZAP-queries-破译密码"><a href="#T1：ZAP-queries-破译密码" class="headerlink" title="T1：ZAP-queries/破译密码"></a>T1：ZAP-queries/破译密码</h4><p><a href="https://www.luogu.com.cn/problem/P3455">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/217/">题目传送门 AcWing</a></p><p>首先，我们令 $f(x)$ 为满足 $\gcd(a,b)=x$ 的个数。</p><p>再定义 $F(X)$ 为 $x|\gcd(a,b)$ 的个数。</p><p>那么，根据莫比乌斯反演，可以得到：<br>$$<br>F(x)=\sum_{x|k}f(k)=\lfloor\dfrac{a}{x}\rfloor\lfloor\dfrac{b}{x}\rfloor\<br>f(x)=\sum_{x|k}\mu(\dfrac{k}{x})F(d)<br>$$<br>线性筛可以求出 $\mu(x)$，于是 $O(n)$ 就可以求出了。</p><p>但是，本题有多组数据，还需要我们进一步优化。</p><p>我们发现，有一些相邻的 $F(d)$ 是相同的。</p><p><del>通过打表发现</del>，每一段的最大值为 $n/(n/d)$，答案都为 $F(d)$。</p><p>就可以了。</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N],cnt;</span><br><span class="line"><span class="keyword">int</span> mu[N],g[N],sum[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) mu[i]=<span class="number">-1</span>,prime[cnt++]=i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt&amp;&amp;i*prime[j]&lt;N;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(i%prime[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                mu[i*prime[j]]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i*prime[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt;++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i*prime[j]&lt;N;++i)</span><br><span class="line">            g[i*prime[j]]+=mu[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i) sum[i]=sum[i<span class="number">-1</span>]+g[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> t,n,m;cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">if</span> (n&gt;m) <span class="built_in">swap</span>(n,m);</span><br><span class="line">        ll res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r=<span class="built_in">min</span>(n,<span class="built_in">min</span>(n/(n/l),m/(m/l)));</span><br><span class="line">            res+=(sum[r]-sum[l<span class="number">-1</span>])*(ll)(n/l)*(m/l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h2><p>来看一个简单的例题：</p><h4 id="T1：绿豆蛙的归宿"><a href="#T1：绿豆蛙的归宿" class="headerlink" title="T1：绿豆蛙的归宿"></a>T1：绿豆蛙的归宿</h4><p><a href="https://www.luogu.com.cn/problem/P4316">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/219/">题目传送门 AcWing</a></p><p>期望其实就是一个加权平均值。</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> dout[N];</span><br><span class="line"><span class="keyword">double</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x]&gt;=<span class="number">0</span>) <span class="keyword">return</span> f[x];</span><br><span class="line">    f[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">        f[x]+=(<span class="built_in">dfs</span>(e[i])+w[i])/dout[x];</span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">int</span> n,m,a,b,c;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);dout[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,<span class="built_in">dfs</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="T2：扑克牌"><a href="#T2：扑克牌" class="headerlink" title="T2：扑克牌"></a>T2：扑克牌</h3><p><a href="https://www.acwing.com/problem/content/220/">题目传送门 AcWing</a></p><p>记录 $f(a,b,c,d,x,y)$，前四个表示四种花牌的个数，后两个表示大小王分别放入的花色。</p><p>特别地，$x=4$ 表示大王未进入，$y=4$ 表示小王未进入。</p><p>直接递推即可。</p><details><summary>详细代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> INF=<span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> f[N][N][N][N][<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> ta,tb,tc,td;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a&lt;ta) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (b&lt;tb) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (c&lt;tc) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (d&lt;td) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> na=a+(x==<span class="number">0</span>)+(y==<span class="number">0</span>),</span><br><span class="line">        nb=b+(x==<span class="number">1</span>)+(y==<span class="number">1</span>),</span><br><span class="line">        nc=c+(x==<span class="number">2</span>)+(y==<span class="number">2</span>),</span><br><span class="line">        nd=d+(x==<span class="number">3</span>)+(y==<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">double</span> &amp;v=f[a][b][c][d][x][y];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(na,nb,nc,nd,x,y)) <span class="keyword">return</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[a][b][c][d][x][y]&gt;=<span class="number">0</span>) <span class="keyword">return</span> f[a][b][c][d][x][y];</span><br><span class="line">    <span class="keyword">int</span> sum=a+b+c+d+(x!=<span class="number">4</span>)+(y!=<span class="number">4</span>);</span><br><span class="line">    sum=<span class="number">54</span>-sum;</span><br><span class="line">    <span class="keyword">if</span> (sum&lt;=<span class="number">0</span>) <span class="keyword">return</span> v=INF;</span><br><span class="line">    v=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a&lt;<span class="number">13</span>) v+=(<span class="number">13.0</span>-a)/sum*<span class="built_in">dp</span>(a+<span class="number">1</span>,b,c,d,x,y);</span><br><span class="line">    <span class="keyword">if</span> (b&lt;<span class="number">13</span>) v+=(<span class="number">13.0</span>-b)/sum*<span class="built_in">dp</span>(a,b+<span class="number">1</span>,c,d,x,y);</span><br><span class="line">    <span class="keyword">if</span> (c&lt;<span class="number">13</span>) v+=(<span class="number">13.0</span>-c)/sum*<span class="built_in">dp</span>(a,b,c+<span class="number">1</span>,d,x,y);</span><br><span class="line">    <span class="keyword">if</span> (d&lt;<span class="number">13</span>) v+=(<span class="number">13.0</span>-d)/sum*<span class="built_in">dp</span>(a,b,c,d+<span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> t=INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i) t=<span class="built_in">min</span>(t,<span class="built_in">dp</span>(a,b,c,d,i,y));</span><br><span class="line">        v+=<span class="number">1.0</span>/sum*t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y==<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> t=INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i) t=<span class="built_in">min</span>(t,<span class="built_in">dp</span>(a,b,c,d,x,i));</span><br><span class="line">        v+=<span class="number">1.0</span>/sum*t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;ta&gt;&gt;tb&gt;&gt;tc&gt;&gt;td;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">4</span>][<span class="number">4</span>]&gt;INF/<span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;-1.000&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>,f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">4</span>][<span class="number">4</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3755</title>
      <link href="/2021/12/13/P3755/"/>
      <url>/2021/12/13/P3755/</url>
      
        <content type="html"><![CDATA[<p>同步发表于 P3755 题解。</p><span id="more"></span><h2 id="0-前置知识-amp-废话"><a href="#0-前置知识-amp-废话" class="headerlink" title="0. 前置知识 &amp; 废话"></a>0. 前置知识 &amp; 废话</h2><p>本蒟蒻最近学习 CDQ 分治，看到该题，虽然想起了扫描线等方法，但为了训练 CDQ 分治，还是自然写一篇题解。</p><p>本文是使用的三维偏序，如果不懂的话，可以A <a href="https://www.luogu.com.cn/problem/P3810">这道题</a>，想更多了解 CDQ 分治的，<del>一波广告</del> <a href="https://www.luogu.com.cn/blog/mydcwfy-342891/cdq-fen-zhi">我的 Blog</a>。</p><h2 id="1-关于-CDQ-分治"><a href="#1-关于-CDQ-分治" class="headerlink" title="1. 关于 CDQ 分治"></a>1. 关于 CDQ 分治</h2><p>CDQ 分治是一个离线分治算法，用于解决三维的问题。</p><p>它是在解决二维的基础上，再套一个树状数组来维护时间的先后顺序，复杂度比同类的二维问题多 $\log n$。</p><p>相信你 A 了模板题，会对这算法有更深的理解。</p><h2 id="2-关于本题"><a href="#2-关于本题" class="headerlink" title="2. 关于本题"></a>2. 关于本题</h2><ol><li>有 $n$ 个先给出的点，每一个点有一个权值，在给出 $m$ 个矩形边框，给出两个点 $(x_1,y_1),(x_2,y_2)$，求围住的点的总权值。</li><li>$n\leq 10^5,m\leq 10^5,-2^{31}\leq x_1,x_2,y_1,y_2\leq 2^{31}$。</li></ol><p>虽然近乎于一道模板题，直接扫描线，但是我们还是可以使用一下 CDQ 分治。</p><p>CDQ 分治的关键就在于构造一个三维偏序问题。</p><p>注意，有的题解使用的是二维偏序问题，我这里为了更加与模板吻合，构造了第三维，使用标准的三维偏序。</p><p>首先，我们可以将其转化为一个二维前缀和的问题，即 $ans=\operatorname{sum}(x_2,y_2)-\operatorname{sum}(x_1-1,y_2)-\operatorname{sum}(x_2,y_1-1)+\operatorname {sum}(x_1-1,y_1-1)$（就是一个容斥原理）。</p><p>于是，问题就是求<br>$$<br>\operatorname{sum}(x_t,y_t)=\sum_{x\leq x_t,y\leq y_t}{a[x][y]}<br>$$<br>第一和第二维很简单，直接是 $x$ 和 $y$。</p><p>怎样求第三维呢？</p><p>可以发现，我们要构造为 $z&lt;z_t$，又因为 CDQ 分治是离线，询问和答案在一起。</p><p>于是，我们可以用一个 $z$ 来标记是询问还是原来的点。</p><p>我们要加答案的是原来的点，而不是询问，所以我们将原来的点记为 0，询问记为 1。</p><p>那么，我们现在求的是：<br>$$<br>\operatorname{sum}(x_t,y_t,z_t)=\sum_{x\leq x_t,y\leq y_t,z&lt;z_t}{a[x][y]}<br>$$<br>于是就是一个标准的偏序问题了！</p><h2 id="3-关于-Code"><a href="#3-关于-Code" class="headerlink" title="3. 关于 Code"></a>3. 关于 Code</h2><ol><li>我们需要使用 long long，因为很可能炸 int。</li><li>实际使用 $z$ 的时候，我们其实不需完全使用原来的三维偏序，其实可以将 $z=0$ 时加入总和即可。</li></ol><p>然后就是愉快的上代码时间了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c,id,f,p;</span><br><span class="line">    ll sum;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp;t)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a!=t.a) <span class="keyword">return</span> a&lt;t.a;</span><br><span class="line">        <span class="keyword">if</span> (b!=t.b) <span class="keyword">return</span> b&lt;t.b;</span><br><span class="line">        <span class="keyword">return</span> c&lt;t.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;k[N],tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(l,mid);<span class="built_in">merge_sort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> j=l,i=mid+<span class="number">1</span>,h=<span class="number">0</span>;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=mid&amp;&amp;i&lt;=r)<span class="comment">//k[j].c 为 0 时就加上</span></span><br><span class="line">        <span class="keyword">if</span> (k[j].b&lt;=k[i].b) sum+=(!k[j].c)*k[j].p,tmp[h++]=k[j++];</span><br><span class="line">        <span class="keyword">else</span> k[i].sum+=sum,tmp[h++]=k[i++];</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=mid) tmp[h++]=k[j++];</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=r) k[i].sum+=sum,tmp[h++]=k[i++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=l,t=<span class="number">0</span>;t&lt;h;++t,++i) k[i]=tmp[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,a,b,c;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        k[i]=(Node)&#123;a,b,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,c,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tot=n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,a,b,c,d;i&lt;m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">        k[tot++]=(Node)&#123;a<span class="number">-1</span>,b<span class="number">-1</span>,<span class="number">1</span>,i,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        k[tot++]=(Node)&#123;a<span class="number">-1</span>,d,<span class="number">1</span>,i,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        k[tot++]=(Node)&#123;c,d,<span class="number">1</span>,i,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        k[tot++]=(Node)&#123;c,b<span class="number">-1</span>,<span class="number">1</span>,i,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(k,k+tot);</span><br><span class="line">    <span class="built_in">merge_sort</span>(<span class="number">0</span>,tot<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;++i)</span><br><span class="line">        <span class="keyword">if</span> (k[i].c) ans[k[i].id]+=k[i].sum*k[i].f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 分治 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> CDQ 分治 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDQ 分治</title>
      <link href="/2021/12/13/CDQ-%E5%88%86%E6%B2%BB/"/>
      <url>/2021/12/13/CDQ-%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<p>同样可以使用二维树状数组。</p><span id="more"></span><h2 id="CDQ-分治"><a href="#CDQ-分治" class="headerlink" title="CDQ 分治"></a>CDQ 分治</h2><p>首先我们看一下模板题：</p><p><a href="https://www.luogu.com.cn/problem/P3810">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2817/">题目传送门 AcWing</a></p><h3 id="1-主要思想"><a href="#1-主要思想" class="headerlink" title="1. 主要思想"></a>1. 主要思想</h3><p>我们一维一维地扩展。</p><h4 id="1）一维"><a href="#1）一维" class="headerlink" title="1）一维"></a>1）一维</h4><p>首先，我们考虑只有一维的。</p><p>直接排序即可。</p><h4 id="2）二维"><a href="#2）二维" class="headerlink" title="2）二维"></a>2）二维</h4><p>然后，我们考虑有二维的。</p><p>首先，我们按双关键字排序，然后从前往后一个一个枚举，在 $i$ 前面才可能会有答案。</p><p>也就是说，一定有 $a[j]\leq a<a href="j%3Ci">i</a>$。</p><p>怎样考虑优化呢？</p><p>我们可以先对 $b[]$ 进行离散化，然后再利用树状数组就可以解决了。</p><p>时间复杂度为 $O(n\log n)$。</p><p>另外，我们可以使用分治。</p><p>假设 $j$ 对 $i$ 满足条件，有三种情况：</p><ol><li>同时在左边。</li><li>同时在右边。</li><li>$j$ 在左边，$i$ 在右边。</li></ol><p>对于前两种情况，我们可以进行递归。</p><p>左边的 $a$ 一定小于等于右边的 $a$，于是我们就可以只考虑 $b$。</p><p>考虑与求逆序对类似的算法。</p><p>首先，我们按 $a$ 进行排序，然后归并计算答案时按 $b$ 进行排序。</p><p>对于每一个区间，我们按 $b$ 进行归并排序，在右边的 $i$ 使用双指针算法就可以计算了。</p><p>由于本身就是一个归并排序的过程，我们无需整个排序，只需归并即可。</p><p>时间复杂度为 $O(n\log n)$。</p><h4 id="3）三维"><a href="#3）三维" class="headerlink" title="3）三维"></a>3）三维</h4><p>即本题。</p><p>首先，我们按照三关键字排序。</p><p>那么，$j$ 只有在 $i$ 的左边，才可能对 $i$ 满足条件。</p><p>还是按照二维的分治算法，我们可以二分区间。</p><p>当 $j$ 在左，$i$ 在右时，我们可以对于每一个区间按 $b$ 进行归并排序。</p><p>对于每一个 $i$，我们可以二分找到最后一个小于等于 $b_i$ 的 $j$，在利用二维的树状数组算法，我们就可以找到 $j$ 之前小于等于 $c_i$ 的值。</p><p>每一层都是 $O(n\log n)$，其中枚举每一个为 $O(n)$，二分和树状数组为 $O(\log n)$，在有 $\log n$ 层，总复杂度为 $O(n\log^2 n)$。</p><h4 id="4）注意事项"><a href="#4）注意事项" class="headerlink" title="4）注意事项"></a>4）注意事项</h4><p>我们不得不处理两个数据完全相同的情况，因为枚举 $i$，它后面的相同的就不会枚举到，所以要去重。</p><h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h3><h4 id="T1：模板题"><a href="#T1：模板题" class="headerlink" title="T1：模板题"></a>T1：模板题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c,sz,res;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp;t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a!=t.a) <span class="keyword">return</span> a&lt;t.a;</span><br><span class="line">        <span class="keyword">if</span> (b!=t.b) <span class="keyword">return</span> b&lt;t.b;</span><br><span class="line">        <span class="keyword">return</span> c&lt;t.c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> Node &amp;t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a==t.a&amp;&amp;b==t.b&amp;&amp;c==t.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;k[N],tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tr[M],ans[N],n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=x;i&lt;M;i+=<span class="built_in">lowbit</span>(i)) tr[i]+=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) res+=tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(l,mid);<span class="built_in">merge_sort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> j=l,i=mid+<span class="number">1</span>,h=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=mid&amp;&amp;i&lt;=r)</span><br><span class="line">        <span class="keyword">if</span> (k[j].b&lt;=k[i].b) <span class="built_in">add</span>(k[j].c,k[j].sz),tmp[h++]=k[j++];</span><br><span class="line">        <span class="keyword">else</span> k[i].res+=<span class="built_in">ask</span>(k[i].c),tmp[h++]=k[i++];</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=mid) <span class="built_in">add</span>(k[j].c,k[j].sz),tmp[h++]=k[j++];</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=r) k[i].res+=<span class="built_in">ask</span>(k[i].c),tmp[h++]=k[i++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=l;i&lt;=mid;++i) <span class="built_in">add</span>(k[i].c,-k[i].sz);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> now=<span class="number">0</span>,i=l;now&lt;h;++i,++now) k[i]=tmp[now];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,a,b,c;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        k[i]=(Node)&#123;a,b,c,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(k,k+n);</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span> (k[now<span class="number">-1</span>]==k[i]) k[now<span class="number">-1</span>].sz++;</span><br><span class="line">        <span class="keyword">else</span> k[now++]=k[i];</span><br><span class="line">    <span class="built_in">merge_sort</span>(<span class="number">0</span>,now<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;now;++i)</span><br><span class="line">        ans[k[i].res+k[i].sz<span class="number">-1</span>]+=k[i].sz;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2：-CQOI2017-老C的任务"><a href="#T2：-CQOI2017-老C的任务" class="headerlink" title="T2：[CQOI2017]老C的任务"></a>T2：[CQOI2017]老C的任务</h4><p><a href="https://www.luogu.com.cn/problem/P3755">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2849/">题目传送门 AcWing</a></p><p>首先，我们可以转化为二维前缀和，问题就转化为了 $x\leq x_{now},y\leq y_{now}$ 的所有 $p$ 之和。</p><p>如果是在线，可能就会超时，我们使用离线算法。</p><p>将查询的点记为 $1$，原来的点记为 0。</p><p>那么，我们就相当于 $x\leq x_{now},y\leq y_{now}, z&lt; z_{now}$ 的点。</p><p>由于 $z$ 只有 0 和 1，直接无需树状数组，复杂度 $O(n\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c,id,f,p;</span><br><span class="line">    ll sum;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp;t)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a!=t.a) <span class="keyword">return</span> a&lt;t.a;</span><br><span class="line">        <span class="keyword">if</span> (b!=t.b) <span class="keyword">return</span> b&lt;t.b;</span><br><span class="line">        <span class="keyword">return</span> c&lt;t.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;k[N],tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(l,mid);<span class="built_in">merge_sort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> j=l,i=mid+<span class="number">1</span>,h=<span class="number">0</span>;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=mid&amp;&amp;i&lt;=r)</span><br><span class="line">        <span class="keyword">if</span> (k[j].b&lt;=k[i].b) sum+=(!k[j].c)*k[j].p,tmp[h++]=k[j++];</span><br><span class="line">        <span class="keyword">else</span> k[i].sum+=sum,tmp[h++]=k[i++];</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=mid) tmp[h++]=k[j++];</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=r) k[i].sum+=sum,tmp[h++]=k[i++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=l,t=<span class="number">0</span>;t&lt;h;++t,++i) k[i]=tmp[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,a,b,c;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        k[i]=(Node)&#123;a,b,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,c,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tot=n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,a,b,c,d;i&lt;m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">        k[tot++]=(Node)&#123;a<span class="number">-1</span>,b<span class="number">-1</span>,<span class="number">1</span>,i,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        k[tot++]=(Node)&#123;a<span class="number">-1</span>,d,<span class="number">1</span>,i,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        k[tot++]=(Node)&#123;c,d,<span class="number">1</span>,i,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        k[tot++]=(Node)&#123;c,b<span class="number">-1</span>,<span class="number">1</span>,i,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(k,k+tot);</span><br><span class="line">    <span class="built_in">merge_sort</span>(<span class="number">0</span>,tot<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;++i)</span><br><span class="line">        <span class="keyword">if</span> (k[i].c) ans[k[i].id]+=k[i].sum*k[i].f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3：-CQOI2011-动态逆序对"><a href="#T3：-CQOI2011-动态逆序对" class="headerlink" title="T3：[CQOI2011]动态逆序对"></a>T3：[CQOI2011]动态逆序对</h4><p><a href="https://www.luogu.com.cn/problem/P3157">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2821/">题目传送门 AcWing</a></p><p>其实，使用 CDQ 分治，我们可以构造三维，其中，第三维可以表示时间戳。</p><p>例如本题，我们可以用第三维表示被删除的时间。</p><p>如果有未被删除的数，把时间戳设为大于总删除数即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分治 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> CDQ 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>仙人掌</title>
      <link href="/2021/12/13/%E4%BB%99%E4%BA%BA%E6%8E%8C/"/>
      <url>/2021/12/13/%E4%BB%99%E4%BA%BA%E6%8E%8C/</url>
      
        <content type="html"><![CDATA[<p>同步发表于 P5236 题解。</p><span id="more"></span><h2 id="0-前置知识"><a href="#0-前置知识" class="headerlink" title="0. 前置知识"></a>0. 前置知识</h2><p>本蒟蒻也是最近学习这个 <del>巨毒瘤</del> 的算法，好多地方也是一头雾水，仔细想了几个晚自习后，有些恍然大悟，于是写了这篇题解。</p><p>需要的东西：Tarjan（似乎没有具体的模板）。</p><p>就是一个求边强连通分量的算法，一会我们要利用它并改进为我们所用。</p><p>还有一颗看完我的博客的心~~</p><h2 id="1-圆方树"><a href="#1-圆方树" class="headerlink" title="1. 圆方树"></a>1. 圆方树</h2><p>其实，圆方树就是将环的作用转化为一棵树的作用，使原来的图变为了新图，许多性质没有变化，但处理树会简单许多。</p><p>以例题为例：<a href="https://www.luogu.com.cn/problem/P5236">题目传送门</a></p><p>想一想，怎样将环变为树的样子？</p><p>回归定义的一个特殊性质：</p><blockquote><p>任意一条边至多只出现在一条简单回路的无向连通图称为仙人掌。</p></blockquote><p>翻译成人话（？），就是原图由一些边不相交的环和另外的边构成。</p><p>首先，可以想到的是，将一个环缩为一个点，将整个图缩为一棵树（因为无向图中只有树和环两种形状，没有第三种，又因为没有环套环（边重合），所以一定变为一棵树）。</p><p>但是，环内的边和点间的距离就没法统计了。</p><p>我们假设任意一个点为根，那么一定会有一个点距离根节点最近。</p><p>来看一个图（ <del>盗的例题的图</del> ）</p><p><img src="https://cdn.luogu.com.cn/upload/pic/52854.png"></p><p>假设七号点为根，那么，对于 “1-2-3-4” 的环，三号点距离根节点最近。</p><p>我们设最近的点具有 “A” 性质。</p><p>下面，我们证明一个东西：环内的点到根节点一定经过环内具有 “A” 性质的点。</p><p>显然，如果不经过该点的话，就不可能达到根节点。</p><p>那么，如果在树中，该点如果想向上走的话，必须经过该环的 “A” 节点。</p><p>我们就可以考虑将这种关系转化为树的节点之间的关系。</p><p>环内的节点通向 “A” 节点只可能有两条路径：顺时针和逆时针。</p><p>又由于对于每一个点，长的一条路肯定用不上，那么我们只需要存到 “A” 节点的最短距离即可。</p><p>那么，原图很大程度上就等价于新图了。</p><p>但是，对于一些题来说，我们需要判断原来的边还是环中的边变换过来的。</p><p>那么，我们可以使用 “圆方树”。</p><p>假设原来的点叫做圆点，新建的点叫做方点。</p><p>对于环内的节点，我们可以新建一个方点，向 “A” 的点连接一条权值为 0 的边，在从新点到其他点连接原来应有的权值。</p><p>现在，我们判断是不是原来的边，只需判断是不是有新建的点即可。</p><p>举个例子，上面的仙人掌建为圆方树（7 号是根节点）是：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/lhd1whrx.png"></p><h2 id="2-Tarjan-算法及变形"><a href="#2-Tarjan-算法及变形" class="headerlink" title="2. Tarjan 算法及变形"></a>2. Tarjan 算法及变形</h2><p>我们刚才讨论的范围，是在能求简单环的基础上，现在，我们的问题是，如何才能找到所有的简单环？</p><p>可能大家都会想到，直接用 Tarjan 算法，就可以去求了。</p><p>但是，有一个问题：Tarjan 求的是边双联通分量，即去掉任意一条边后，原图仍然联通，那么，原图的 “123456”6 个点，满足该要求，但他们并不属于同一个简单环，怎么办呢？</p><p>于是，需要我们改进该算法。</p><p>首先，我们回顾一下原算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来自本人缩点模板题</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[x]=low[x]=++tot;</span><br><span class="line">st[++top]=x, ins[x]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">    <span class="keyword">if</span> (!dfn[e[i]])</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">Tarjan</span>(e[i]);</span><br><span class="line">low[x]=<span class="built_in">min</span>(low[x],low[e[i]]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ins[e[i]]) low[x] = <span class="built_in">min</span>(low[x], dfn[e[i]]);</span><br><span class="line"><span class="keyword">if</span> (low[x]!=dfn[x]) <span class="keyword">return</span>;</span><br><span class="line">cnt++;<span class="keyword">int</span> now;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">now=st[top--];</span><br><span class="line">ins[now]=<span class="number">0</span>; </span><br><span class="line">bel[now]=cnt;</span><br><span class="line">&#125;<span class="keyword">while</span> (now!=x);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原算法中，只要还在栈中，我们都将所有归为一个边双联通分量。</p><p>但是，现在，如果我们还遇到这种情况的话，就应该一个一个的处理为一个一个的简单环，而不是揉在一起。</p><p>所以，当我们遇到 $low[e[i]]&lt;dfn[x]$ 的时候，我们直接倒回去，就可以倒推出一整个环的情况了。</p><p>请注意，此时 $x$ 也为其中的点。</p><p>具体来说，我们遇到这种情况时，直接 $\operatorname{build-round-square}(x,e[i],w)$，表示从 $e[i]$ 倒推，直到 $x$ 为 “A” 点，其中 $(x,e[i])$ 的权值为 $w$。</p><p>具体来说，我们遇到了这样的情况：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/vuo9hei8.png"></p><p><del>（好像少标了一条边的权值）</del></p><p>我们知道，Tarjan 算法建了一棵搜索树，在树上进行计算。</p><p>如图，黑边就是搜索树的边，而红边就是非树边。</p><p>肉眼可见，有两个环。</p><p>对于每个节点，我们维护他在搜索树中的父亲，还有到父亲的距离。</p><p>如果相连的节点在他的下面（即不是父亲），并且他的父亲不是该节点，说明有另外一条路径（树边）可达他的儿子，我们就可以 $\operatorname{build-round-square}(x,e[i],w)$ 了。</p><p>举个例子，搜索完 1 节点后，我们找连接点，找到 5 号点，发现满足上面的性质，于是就 $\operatorname{build-round-square}(1,5,2)$ 即可以了。</p><p>如果你还感到费解，请看前面的例图，加以理解。</p><p>如果你对传参有不理解，看一下代码就知道了。</p><p>于是，我们就可以得到这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> h[],<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_round_square</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=y;i!=x;i=fa[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        s[i]=sum;</span><br><span class="line">        sum+=fw[i];</span><br><span class="line">    &#125;</span><br><span class="line">    stot[x]=s[x]=sum;</span><br><span class="line">    <span class="built_in">add</span>(h2,x,++square_node,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=y;i!=x;i=fa[i])</span><br><span class="line">    &#123;</span><br><span class="line">        stot[i]=sum;</span><br><span class="line">        <span class="built_in">add</span>(h2,square_node,i,<span class="built_in">min</span>(s[i],stot[i]-s[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h1[x],j;~i;i=ne[i])</span><br><span class="line">        <span class="keyword">if</span> (!dfn[j=e[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            fa[j]=x,fw[j]=w[i];</span><br><span class="line">            <span class="built_in">tarjan</span>(j,i);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[j]);</span><br><span class="line">            <span class="keyword">if</span> (low[j]&gt;dfn[x]) <span class="built_in">add</span>(h2,x,j,w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i!=(from^<span class="number">1</span>)) low[x]=<span class="built_in">min</span>(low[x],dfn[e[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h1[x],j;~i;i=ne[i])</span><br><span class="line">        <span class="keyword">if</span> (dfn[j=e[i]]&gt;dfn[x]&amp;&amp;fa[j]!=x)</span><br><span class="line">            <span class="built_in">build_round_square</span>(x,j,w[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-回归本题"><a href="#3-回归本题" class="headerlink" title="3. 回归本题"></a>3. 回归本题</h2><h4 id="1）题意"><a href="#1）题意" class="headerlink" title="1）题意"></a>1）题意</h4><ol><li>给定一个仙人掌图，有 $Q$ 次询问，询问 $u$ 和 $v$ 之间的最短路。</li><li>$n,q\leq10^4,m\leq2*10^4,w\leq10^5$。</li></ol><h4 id="2）具体算法"><a href="#2）具体算法" class="headerlink" title="2）具体算法"></a>2）具体算法</h4><p>前面的东西是总体的仙人掌转圆方树的算法，对于不同的题来说，肯定也会有一些细节不同。</p><p>当然，仙人掌的题的大概思路是：</p><ol><li>将仙人掌转化为圆方树。</li><li>结合其他树的算法（树链剖分，点分治等），将本题树的写法写好。</li><li>分情况，看是圆点还是方点，进行算法调整。</li></ol><p>本题也是如此。</p><p>考虑树上怎么做。</p><p>很明显，使用倍增算法，将一个节点的 $2^k$ 次祖先存储下来。</p><p>再利用前缀和的思想，答案即为：$ans=d[a]+d[b]-2d[lca]$。</p><p>现在，我们考虑分类讨论。</p><p>首先，假设 $lca$ 是圆点，直接按上面求即可（因为会在原来的点相会）。</p><p>假设 $lca$ 是方点呢？</p><p>这说明，当到了 $lca$ 的前一层时，两个点是在同一个环上。</p><p>对于每一个节点，可以存储一个前缀和 $s[]$，即从 “A” 性质的点按同一个方向（指一个环中是同一个方向）走到该点的距离。</p><p>特别地，”A” 性质的点记为环的总权值。</p><p>现在我们可以将环间的路径表示为（$x,y$ 分别表示 $a,b$ 环里的节点）：$d=\min(|s[x]-s[y]|,stot[x]-|tot - |s[x] - s[y]||)$。</p><p>现在我们就可以完美的解决了。</p><h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h2><p>还会有一些细节从代码中呈现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>,M=<span class="number">1e5</span>+<span class="number">10</span>,L=<span class="number">14</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h1[N],h2[N],e[M],ne[M],w[M],idx,square_node;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">h1,h2分别表示原图和新图的节点的头指针</span></span><br><span class="line"><span class="comment">square_node表示新建的点 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],tot;<span class="comment">//Tarjan 算法 </span></span><br><span class="line"><span class="keyword">int</span> stot[N],s[N],fa[N],fw[N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">stot表示所在环的总权值</span></span><br><span class="line"><span class="comment">s是前缀和 </span></span><br><span class="line"><span class="comment">fa即为搜索树中的父亲</span></span><br><span class="line"><span class="comment">fw表示到父亲的距离 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> f[N][L+<span class="number">1</span>],depth[N],dis[N];<span class="comment">//倍增算法 </span></span><br><span class="line"><span class="keyword">int</span> n,m,q,A,B;<span class="comment">//A,B表示走到同一个环中的节点 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> h[],<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_round_square</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=y;i!=x;i=fa[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        s[i]=sum;</span><br><span class="line">        sum+=fw[i];</span><br><span class="line">    &#125;</span><br><span class="line">    stot[x]=s[x]=sum;<span class="comment">//注意s[x]要赋值为总权值 </span></span><br><span class="line">    <span class="built_in">add</span>(h2,x,++square_node,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=y;i!=x;i=fa[i])</span><br><span class="line">    &#123;</span><br><span class="line">        stot[i]=sum;</span><br><span class="line">        <span class="built_in">add</span>(h2,square_node,i,<span class="built_in">min</span>(s[i],stot[i]-s[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h1[x],j;~i;i=ne[i])</span><br><span class="line">        <span class="keyword">if</span> (!dfn[j=e[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            fa[j]=x,fw[j]=w[i];</span><br><span class="line">            <span class="built_in">tarjan</span>(j,i);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[j]);</span><br><span class="line">            <span class="keyword">if</span> (low[j]&gt;dfn[x]) <span class="built_in">add</span>(h2,x,j,w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i!=(from^<span class="number">1</span>)) low[x]=<span class="built_in">min</span>(low[x],dfn[e[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h1[x],j;~i;i=ne[i])</span><br><span class="line">        <span class="keyword">if</span> (dfn[j=e[i]]&gt;dfn[x]&amp;&amp;fa[j]!=x)<span class="comment">//Tarjan算法改进 </span></span><br><span class="line">            <span class="built_in">build_round_square</span>(x,j,w[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span><span class="comment">//倍增算法预处理 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    depth[x]=depth[fa]+<span class="number">1</span>;</span><br><span class="line">    f[x][<span class="number">0</span>]=fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=L;++i) f[x][i]=f[f[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h2[x];~i;i=ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i]!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[e[i]]=dis[x]+w[i];</span><br><span class="line">            <span class="built_in">dfs</span>(e[i],x);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[a]&lt;depth[b]) <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=L;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span> (depth[f[a][i]]&gt;=depth[b]) a=f[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a==b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=L;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span> (f[a][i]!=f[b][i]) a=f[a][i],b=f[b][i];</span><br><span class="line">    A=a,B=b;</span><br><span class="line">    <span class="keyword">return</span> f[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h1,<span class="number">-1</span>,<span class="keyword">sizeof</span> h1);</span><br><span class="line">    <span class="built_in">memset</span>(h2,<span class="number">-1</span>,<span class="keyword">sizeof</span> h2);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(h1,a,b,c);<span class="built_in">add</span>(h1,b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    square_node=n;</span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">int</span> lca=<span class="built_in">LCA</span>(a,b);</span><br><span class="line">        <span class="keyword">if</span> (lca&lt;=n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[a]+dis[b]<span class="number">-2</span>*dis[lca]);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> res=dis[a]-dis[A]+dis[b]-dis[B];</span><br><span class="line">            res+=<span class="built_in">min</span>(<span class="built_in">abs</span>(s[A]-s[B]),stot[A]-<span class="built_in">abs</span>(s[A]-s[B]));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小表示法</title>
      <link href="/2021/12/13/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
      <url>/2021/12/13/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>似乎比较简单的算法。</p><span id="more"></span><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>一般是对于字符串而定义的。</p><p>我们定义<strong>循环</strong>是指不断将第一个字符放到最后。</p><p>显然，经过循环之后，一共会产生 $n$ 个字符串（$n$ 为字符串长度）。</p><p>其中最小的就是最小表示法。</p><p>暴力是 $O(n^2)$，我们可以通过该算法得到 $O(n)$ 的时间复杂度。</p><h2 id="2-思想"><a href="#2-思想" class="headerlink" title="2. 思想"></a>2. 思想</h2><p>首先，这个相当于是一个环。</p><p>考虑<strong>破环为链</strong>，复制一倍接在后面，那么 $1\sim n$ 开始的长度为 $n$ 的字符串就是我们要找的。</p><p>我们最开始定义两个指针（差不多是双指针算法）：$i=1,j=2$。</p><p>直接暴力比较 $i$ 和 $j$ 开头的字符串的大小。</p><p>假设最后遇到了 $s_{i+k}&gt;s_{j+k}$，那么以 $i$ 开头的一定不是最小表示法。</p><p>同时，我们可以发现，$[i+1,i+k]$ 任意开头的，仍然不是最小表示法。</p><p>明显的，我们找到 $[j+1,j+k]$，可以发现，对应的 $i$ 开头的，一定比对应的 $j$ 开头的更大。</p><p>这时，我们可以直接将 $i$ 跳到 $i+k+1$。</p><p>可以发现，时间复杂度和 $i,j$ 移动的长度是同级的，而显然，$i,j$ 的移动都是 $O(n)$ 的，所以时间复杂度为 $O(n)$。</p><p>但是，我们可能会遇到几个问题：</p><ol><li>一直到 $k=n$ 的时候，都没有遇到 $s_{i+k}\not=s_{j+k}$：说明我们已经找到了更小的循环节，也就是已经遍历完了（后面都一样了）</li><li>$i\leftarrow i+k+1$ 后，$i=j$：$i\leftarrow i+1$，使两串错开。</li></ol><p>就结束了。似乎也没有什么例题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) str[i + n] = str[i];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">1</span>, k;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n &amp;&amp; j &lt;= n)</span><br><span class="line">&#123;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (k &lt; n &amp;&amp; str[i + k] == str[j + k]) k ++;</span><br><span class="line"><span class="keyword">if</span> (k == n) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (str[i + k] &lt; str[j + k]) j += k + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> i += k + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i == j) i ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="built_in">min</span>(i, j);</span><br><span class="line"><span class="keyword">for</span> (k = ans; k &lt;= ans + n - <span class="number">1</span>; ++ k) cout &lt;&lt; str[k] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟退火</title>
      <link href="/2021/12/13/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"/>
      <url>/2021/12/13/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/</url>
      
        <content type="html"><![CDATA[<p><strong>骗分大法好！</strong></p><span id="more"></span><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>一种神仙的随机算法，在你找不到 DP 的方法时可以使用<del>来骗分</del>。比如我在 NOIP 考场上 T3 就骗了 96 pts（虽然差一点就想到了 DP 正解）。</p><h2 id="2-思想"><a href="#2-思想" class="headerlink" title="2. 思想"></a>2. 思想</h2><p>首先，它本身是在一个很大的 $x$ 取值范围寻找函数的最优解（注意函数不一定是单峰或单调）。</p><p>下面默认寻找最小值。</p><p>算法就是我们找到一个初值，然后一直随机跳，找到最优解。</p><p>再定义一个温度 $t$，可以表示随机的范围。比如当前的区间就是 $[x_0-dt,x_0+dt]$，其中 $d$ 是常数。</p><p>$t$ 会不断衰减，定义一个衰减系数，每一次 $t$ 都会乘上衰减系数，一般很靠近 1。</p><p>假设我们当前是 $x_0$，随机到的点是 $x$，再假设 $f(x)-f(x_0)=\Delta$。</p><ol><li>$\Delta&lt;0$，则 $x_0$ 不优，我们直接跳到 $x$ 即可。</li><li>$\Delta\geq0$，则 $x$ 不优。注意函数可能不止一个峰值，所以有可能 $x$ 的位置更靠近最小值，我们就需要有一定的概率跳过去。$t$ 越小，概率越小，$\Delta$ 越大，概率越小。</li></ol><p>对于第二种情况，这个概率各家都不同，一般来看，可以使用 $e^{-\Delta kt}$ 的概率。其中 $k$ 是常数，需要自己定义。</p><p>很明显，$0&lt;e^{-\Delta kt}&lt;1$。</p><p>好，上面是理论，下面才是重点。（骗分嘛，怎么好怎么来）</p><h2 id="3-实践与经验"><a href="#3-实践与经验" class="headerlink" title="3. 实践与经验"></a>3. 实践与经验</h2><p>诚然，一次的答案确实可能是局部的最优解而不是全局的。</p><p>于是，我们就多做几次，每一次都这么走，那么肯定走到全局的最优解的概率是越大的。</p><p>那么，我们可以得到第一个结论：<strong>时间越多，答案的正确性越大。</strong></p><p>还有很多的题目，是无法控制步长的（甚至连函数都不算），我们经过实验，可以发现：<strong>衰减系数越大，答案的正确性越大。</strong></p><p>然后，<strong>尽可能的推出一些性质（比如贪心构造，即使可能正确性有误），尽量的靠近最优解</strong>。这样的正确性比较高。（比如 NOIP T3）</p><p>下面给出一个简单的模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = INF, now;</span><br><span class="line"><span class="keyword">double</span> k = ;<span class="comment">//自定义参数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> t = <span class="number">1e7</span>; t &gt; <span class="number">1e-7</span>; t *= <span class="number">0.999997</span>)<span class="comment">//衰减参数</span></span><br><span class="line">&#123;<span class="comment">//先生成新解 cur</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">clock</span>() / CLOCKS_PER_SEC &gt; <span class="number">0.9</span>) <span class="keyword">return</span> ans;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="built_in">get_ans</span>();</span><br><span class="line"><span class="keyword">if</span> (cur &lt; now || <span class="built_in">exp</span>(- (cur - now) * t * k) &lt; <span class="built_in">rand</span>() / RAND_MAX) now = cur;<span class="comment">//比较两解，如果大的话有一定概率跳过去</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-例题"><a href="#4-例题" class="headerlink" title="4. 例题"></a>4. 例题</h2><h4 id="T1：-NOIP2021-T3-方差"><a href="#T1：-NOIP2021-T3-方差" class="headerlink" title="T1：[NOIP2021 T3]方差"></a>T1：[NOIP2021 T3]方差</h4><p><a href="https://www.luogu.com.cn/problem/P7962">题目传送门 Luogu</a></p><p>注意至少要推出差分的性质，得分会至少有 50-70 pts。</p><p>给出考场的 96 pts 代码，Luogu 民间数据 88 pts。（去掉了 <code>freopen</code>，中文注释是后来加的）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], n, b[N], tmp[N], pre[N], suf[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) flag = <span class="number">1</span>;</span><br><span class="line">    x = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> ...<span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x, T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x), <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get_S</span><span class="params">()</span><span class="comment">//得到方差</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) a[i] = a[i - <span class="number">1</span>] + tmp[i - <span class="number">1</span>];</span><br><span class="line">    ll sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        sum1 += a[i], sum2 += a[i] * a[i];</span><br><span class="line">    <span class="keyword">return</span> sum2 * n - sum1 * sum1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*void solve_to_right(int l, int r)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    // for (int times = 1; times &lt;= r - l + 1; ++ times)</span></span><br><span class="line"><span class="comment">        for (int i = l; i &lt;= r; ++ i)</span></span><br><span class="line"><span class="comment">            a[i] = min(a[i], a[i - 1] + a[i + 1] - a[i]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void solve_to_left(int l, int r)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    // for (int times = 1; times &lt;= r - l + 1; ++ times)</span></span><br><span class="line"><span class="comment">        for (int i = r; i &gt;= l; -- i)</span></span><br><span class="line"><span class="comment">            a[i] = max(a[i], a[i - 1] + a[i + 1] - a[i]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void solve(int l, int r)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    if (r - l + 1 &lt;= 2) return;</span></span><br><span class="line"><span class="comment">    if (r - l + 1 == 3)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if (a[l] - a[1] &gt; a[n] - a[r]) a[l + 1] = min(a[l + 1], a[l] + a[r] - a[l + 1]);</span></span><br><span class="line"><span class="comment">        else a[l + 1] = max(a[l + 1], a[l] + a[r] - a[l + 1]);</span></span><br><span class="line"><span class="comment">        return;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    if (a[l] - a[1] &gt;= a[n] - a[r]) solve_to_right(l + 1, r - 1), solve_to_left(l + 1, r - 2);</span></span><br><span class="line"><span class="comment">    else solve_to_left(l + 1, r - 1), solve_to_right(l + 2, r - 1);</span></span><br><span class="line"><span class="comment">    solve(l + 1, r - 1);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> t = <span class="number">1e9</span>; t &gt; <span class="number">1e-7</span>; t *= <span class="number">0.9999997</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line">        ll now = <span class="built_in">get_S</span>(), nw;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">rand</span>() % (n - <span class="number">1</span>) + <span class="number">1</span>, j = <span class="built_in">rand</span>() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">1.0</span> * <span class="built_in">clock</span>() / CLOCKS_PER_SEC) &gt; <span class="number">0.9</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp[i] == tmp[j]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">swap</span>(tmp[i], tmp[j]);</span><br><span class="line">        nw = <span class="built_in">get_S</span>();</span><br><span class="line">        <span class="comment">// printf(&quot;%lld %lld\n&quot;, now, nw);</span></span><br><span class="line">        <span class="keyword">if</span> (nw &gt; now)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">exp</span>(-(<span class="number">1.0</span> * nw - now) / now * t) * RAND_MAX &lt; <span class="built_in">rand</span>()) <span class="built_in">swap</span>(tmp[i], tmp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;variance.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;variance.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="number">2206704740U</span>);</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) b[i] = a[i + <span class="number">1</span>] - a[i];</span><br><span class="line">    <span class="built_in">sort</span>(b + <span class="number">1</span>, b + n);</span><br><span class="line">    <span class="built_in">reverse</span>(b + <span class="number">1</span>, b + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = n - <span class="number">1</span>, tot = <span class="number">0</span>; i &lt;= j;)</span><br><span class="line">    &#123;<span class="comment">//构造贪心，随意构造，可以不管</span></span><br><span class="line">        <span class="keyword">if</span> (pre[i - <span class="number">1</span>] &lt;= suf[j + <span class="number">1</span>]) tmp[i] = b[++ tot], pre[i] = pre[i - <span class="number">1</span>] + tmp[i], i ++;</span><br><span class="line">        <span class="keyword">else</span> tmp[j] = b[++ tot], suf[j] = suf[j + <span class="number">1</span>] + tmp[j], j --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sa</span>();</span><br><span class="line">    <span class="comment">// solve(1, n);</span></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt; n; ++ i) cout &lt;&lt; tmp[i] &lt;&lt; &quot; \n&quot;[i == n - 1];</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">get_S</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 模拟退火 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>舞蹈链（DLX）</title>
      <link href="/2021/12/13/%E8%88%9E%E8%B9%88%E9%93%BE%EF%BC%88DLX%EF%BC%89/"/>
      <url>/2021/12/13/%E8%88%9E%E8%B9%88%E9%93%BE%EF%BC%88DLX%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>题型有两种：精确覆盖与重复覆盖。</p><span id="more"></span><h2 id="Dancing-Links"><a href="#Dancing-Links" class="headerlink" title="Dancing Links"></a>Dancing Links</h2><h3 id="1-废话"><a href="#1-废话" class="headerlink" title="1. 废话"></a>1. 废话</h3><p>首先，它有几个名字：DLX,Dancing Links,十字链表，舞蹈链。</p><p>然后，它是一种数据结构。</p><p>精确覆盖是指每一列恰好有一个 1。</p><p>重复覆盖是指每一列至少有一个 1。</p><p>它解决的问题，一般矩阵规模较大，但 1 的个数较少。</p><p>可以通过题目来理解。</p><p><a href="https://www.luogu.com.cn/problem/P4929">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/1069/">题目传送门 AcWing</a></p><h3 id="2-精确覆盖问题"><a href="#2-精确覆盖问题" class="headerlink" title="2. 精确覆盖问题"></a>2. 精确覆盖问题</h3><h4 id="1）如何存储矩阵"><a href="#1）如何存储矩阵" class="headerlink" title="1）如何存储矩阵"></a>1）如何存储矩阵</h4><p>使用十字链表。</p><p>对于每一个 1，都建立一个节点。</p><h4 id="2）初始化"><a href="#2）初始化" class="headerlink" title="2）初始化"></a>2）初始化</h4><p>每一个节点的上下左右都连向该方向的最近链表。（如果没有，就循环找）。</p><p>实际使用时，可以按照一行一行的处理。</p><p>同时，对于最前面，我们建立一个哨兵，全为 1。</p><p>上面的操作就是初始化。</p><h4 id="3）插入一行"><a href="#3）插入一行" class="headerlink" title="3）插入一行"></a>3）插入一行</h4><p>建立当前行的前面和后面，插入时，直接选择即可。</p><p>这里有些难理解，我们结合代码讲。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;hh,<span class="keyword">int</span> &amp;tt,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">l</span>(idx)=hh,<span class="built_in">r</span>(idx)=tt,<span class="built_in">r</span>(hh)=idx,<span class="built_in">l</span>(tt)=idx;</span><br><span class="line">    <span class="built_in">d</span>(idx)=<span class="built_in">d</span>(y),<span class="built_in">u</span>(idx)=y,<span class="built_in">u</span>(<span class="built_in">d</span>(y))=idx,<span class="built_in">d</span>(y)=idx;</span><br><span class="line">    <span class="built_in">col</span>(idx)=y;<span class="built_in">row</span>(idx)=x;</span><br><span class="line">    tt=idx++;s[y]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> hh=idx,tt=idx;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span> (x) <span class="built_in">add</span>(hh,tt,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//in main()</span></span><br></pre></td></tr></table></figure><p>最开始时，第一个点的右边和左边都是当前本身，所以初始时都是 idx,更新时直接将 tt 赋值为 idx，就串成了一个循环链表。</p><h4 id="4）搜索"><a href="#4）搜索" class="headerlink" title="4）搜索"></a>4）搜索</h4><p>在 dfs 的过程中，从未选择的行中任意选择一行，搜索一行。</p><p>剪枝：</p><ol><li>比较明显，直接选择包含 1 最少的一列选择一行。</li><li>在选择一列后，将该列删除。</li><li>在选择一行后，将该行包含 1 的列全部删除。</li></ol><p>这里，我们发现，需要 2 个函数：删除一列和恢复一列。</p><h4 id="5）删除一列"><a href="#5）删除一列" class="headerlink" title="5）删除一列"></a>5）删除一列</h4><p>对于哨兵，可以直接删除。</p><p>但是，由于要满足”精确覆盖“，我们要将包含该列的行全部删掉。</p><h4 id="6）恢复一列"><a href="#6）恢复一列" class="headerlink" title="6）恢复一列"></a>6）恢复一列</h4><h4 id="7）Code"><a href="#7）Code" class="headerlink" title="7）Code"></a>7）Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLX</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,u,d;</span><br><span class="line">    <span class="keyword">int</span> row,col;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(i) a[i].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(i) a[i].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> u(i) a[i].u</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> d(i) a[i].d</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> row(i) a[i].row</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> col(i) a[i].col</span></span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"><span class="keyword">int</span> ans[N],top;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">l</span>(i)=i<span class="number">-1</span>;<span class="built_in">r</span>(i)=i+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">u</span>(i)=<span class="built_in">d</span>(i)=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">l</span>(<span class="number">0</span>)=m;<span class="built_in">r</span>(m)=<span class="number">0</span>;</span><br><span class="line">    idx=m+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;hh,<span class="keyword">int</span> &amp;tt,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">l</span>(idx)=hh,<span class="built_in">r</span>(idx)=tt,<span class="built_in">r</span>(hh)=idx,<span class="built_in">l</span>(tt)=idx;</span><br><span class="line">    <span class="built_in">d</span>(idx)=<span class="built_in">d</span>(y),<span class="built_in">u</span>(idx)=y,<span class="built_in">u</span>(<span class="built_in">d</span>(y))=idx,<span class="built_in">d</span>(y)=idx;</span><br><span class="line">    <span class="built_in">col</span>(idx)=y;<span class="built_in">row</span>(idx)=x;</span><br><span class="line">    tt=idx++;s[y]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">r</span>(<span class="built_in">l</span>(p))=<span class="built_in">r</span>(p),<span class="built_in">l</span>(<span class="built_in">r</span>(p))=<span class="built_in">l</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="built_in">d</span>(p);i!=p;i=<span class="built_in">d</span>(i))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="built_in">r</span>(i);j!=i;j=<span class="built_in">r</span>(j))</span><br><span class="line">        &#123;</span><br><span class="line">            s[<span class="built_in">col</span>(j)]--;</span><br><span class="line">            <span class="built_in">u</span>(<span class="built_in">d</span>(j))=<span class="built_in">u</span>(j),<span class="built_in">d</span>(<span class="built_in">u</span>(j))=<span class="built_in">d</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="built_in">u</span>(p);i!=p;i=<span class="built_in">u</span>(i))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="built_in">l</span>(i);j!=i;j=<span class="built_in">l</span>(j))</span><br><span class="line">        &#123;</span><br><span class="line">            s[<span class="built_in">col</span>(j)]++;</span><br><span class="line">            <span class="built_in">u</span>(<span class="built_in">d</span>(j))=j,<span class="built_in">d</span>(<span class="built_in">u</span>(j))=j;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">r</span>(<span class="built_in">l</span>(p))=p,<span class="built_in">l</span>(<span class="built_in">r</span>(p))=p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">r</span>(<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="built_in">r</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="built_in">r</span>(<span class="number">0</span>);i;i=<span class="built_in">r</span>(i))</span><br><span class="line">        <span class="keyword">if</span> (s[i]&lt;=s[p]) p=i;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">remove</span>(p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="built_in">d</span>(p);i!=p;i=<span class="built_in">d</span>(i))</span><br><span class="line">    &#123;</span><br><span class="line">        ans[++top]=<span class="built_in">row</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="built_in">r</span>(i);j!=i;j=<span class="built_in">r</span>(j)) <span class="built_in">remove</span>(<span class="built_in">col</span>(j));</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="built_in">l</span>(i);j!=i;j=<span class="built_in">l</span>(j)) <span class="built_in">resume</span>(<span class="built_in">col</span>(j));</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">resume</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> hh=idx,tt=idx;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span> (x) <span class="built_in">add</span>(hh,tt,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No Solution!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-例题"><a href="#3-例题" class="headerlink" title="3. 例题"></a>3. 例题</h3><p>做 Dancing Links 的题，做法如下：</p><ol><li>首先将题目的选择设为行。</li><li>然后将题目的限制设为列。</li><li>使用模板。</li></ol><h4 id="T1：数独2"><a href="#T1：数独2" class="headerlink" title="T1：数独2"></a>T1：数独2</h4><p><a href="https://www.acwing.com/problem/content/171/">题目传送门 AcWing</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLX</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, u, d, row, col;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Option</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> row, col, k;</span><br><span class="line">&#125;opt[N];</span><br><span class="line"><span class="keyword">int</span> n, m = <span class="number">1024</span>, sz[<span class="number">1025</span>], idx, ans[N], top;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = &#123;i - <span class="number">1</span>, i + <span class="number">1</span>, i, i, <span class="number">0</span>, i&#125;;</span><br><span class="line">        sz[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">0</span>].l = m, a[<span class="number">0</span>].r = <span class="number">1</span>, a[m].r = <span class="number">0</span>, idx = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;hh, <span class="keyword">int</span> &amp;tt, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[idx] = &#123;hh, tt, y, a[y].d, x, y&#125;;</span><br><span class="line">    a[a[y].d].u = idx, a[y].d = idx;</span><br><span class="line">    a[hh].r = a[tt].l = idx;</span><br><span class="line">    sz[y] ++, tt = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x * <span class="number">16</span> + y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[a[p].r].l = a[p].l, a[a[p].l].r = a[p].r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a[p].d; i != p; i = a[i].d)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i].r; j != i; j = a[j].r)</span><br><span class="line">        &#123;</span><br><span class="line">            sz[a[j].col] --;</span><br><span class="line">            a[a[j].d].u = a[j].u, a[a[j].u].d = a[j].d;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a[p].u; i != p; i = a[i].u)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i].l; j != i; j = a[j].l)</span><br><span class="line">        &#123;</span><br><span class="line">            sz[a[j].col] ++;</span><br><span class="line">            a[a[j].d].u = a[a[j].u].d = j;</span><br><span class="line">        &#125;</span><br><span class="line">    a[a[p].l].r = a[a[p].r].l = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a[<span class="number">0</span>].r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> p = a[<span class="number">0</span>].r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a[p].r; i; i = a[i].r)</span><br><span class="line">        <span class="keyword">if</span> (sz[i] &lt; sz[p]) p = i;</span><br><span class="line">    <span class="built_in">remove</span>(p);</span><br><span class="line">    top ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a[p].d; i != p; i = a[i].d)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[top] = a[i].row;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i].r; j != i; j = a[j].r) <span class="built_in">remove</span>(a[j].col);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i].l; j != i; j = a[j].l) <span class="built_in">resume</span>(a[j].col);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">resume</span>(p);</span><br><span class="line">    top --;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[<span class="number">1</span>] + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t) cout &lt;&lt; endl;</span><br><span class="line">        n = top = <span class="number">0</span>, <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">16</span>; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">16</span>; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">16</span>; ++ j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x, y;</span><br><span class="line">                <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;-&#x27;</span>) x = <span class="number">0</span>, y = <span class="number">15</span>;</span><br><span class="line">                <span class="keyword">else</span> x = y = s[i][j] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = x; k &lt;= y; ++ k)</span><br><span class="line">                &#123;</span><br><span class="line">                    opt[++ n] = &#123;i, j, k&#125;;</span><br><span class="line">                    <span class="keyword">int</span> hh = idx, tt = idx;</span><br><span class="line">                    <span class="built_in">add</span>(hh, tt, n, <span class="number">256</span> * <span class="number">0</span> + <span class="built_in">get</span>(i - <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">add</span>(hh, tt, n, <span class="number">256</span> * <span class="number">1</span> + <span class="built_in">get</span>(i - <span class="number">1</span>, k) + <span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">add</span>(hh, tt, n, <span class="number">256</span> * <span class="number">2</span> + <span class="built_in">get</span>(j - <span class="number">1</span>, k) + <span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">add</span>(hh, tt, n, <span class="number">256</span> * <span class="number">3</span> + <span class="built_in">get</span>((i - <span class="number">1</span>) / <span class="number">4</span> * <span class="number">4</span> + (j - <span class="number">1</span>) / <span class="number">4</span>, k) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">dfs</span>();</span><br><span class="line">        <span class="comment">// cout &lt;&lt; dfs() &lt;&lt; &#x27; &#x27; &lt;&lt; top &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= top; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;op = opt[ans[i]];</span><br><span class="line">            s[op.row][op.col] = op.k + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">16</span>; ++ i) cout &lt;&lt; s[i] + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        t = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2：-NOI2005-智慧珠游戏"><a href="#T2：-NOI2005-智慧珠游戏" class="headerlink" title="T2：[NOI2005]智慧珠游戏"></a>T2：[NOI2005]智慧珠游戏</h4><p><a href="https://www.luogu.com.cn/problem/P4205">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/958/">题目传送门 AcWing</a></p><p>将每一种摆法的旋转、平移的所有方法，都做成一个行，然后将每一个格子、每一种方法都做成列。</p><p>代码比较繁琐，但是思路不太难。</p><h3 id="4-重复覆盖问题"><a href="#4-重复覆盖问题" class="headerlink" title="4. 重复覆盖问题"></a>4. 重复覆盖问题</h3><p><a href="https://www.acwing.com/problem/content/2715/">题目传送门 AcWing</a></p><p>与精确覆盖问题对比。</p><p>重复覆盖问题的规模较小，而精确覆盖问题的规模较大。</p><p>重复覆盖问题的答案较小，而精确覆盖问题的 1 个数较小。</p><p>为什么答案要求要比较小呢？</p><p>因为使用了 IDA* （迭代加深）。</p><p>算法流程如下：</p><ol><li><p>选择一个行数最少的列</p></li><li><p>枚举当前列是 1 的行。</p></li><li><p>枚举当前行，递归。</p></li></ol><p>对比精确覆盖问题，我们发现有不同。</p><p>于是，这个就会慢很多。</p><p>我们又有一个武器：IDA*。</p><p>加上这样一个句： <code>if (k+h()&gt;depth) return false;</code></p><p>这样，我们应该考虑怎样构造 <code>h()</code>。</p><p>请注意，我们要保证 $h()\leq ans$。</p><p>遍历所有未被覆盖的列，选择当前列的所有行，但是计数只记一行。</p><p>这样，我们其实选择了更多，所以答案不可能更大。</p><p>上代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=(<span class="keyword">int</span>)<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLX</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,u,d,row,col;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(i) a[i].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(i) a[i].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> u(i) a[i].u</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> d(i) a[i].d</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> col(i) a[i].col</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> row(i) a[i].row</span></span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> idx,n,m,s[<span class="number">105</span>],ans[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">bool</span> st[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">l</span>(i)=i<span class="number">-1</span>,<span class="built_in">r</span>(i)=i+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">col</span>(i)=<span class="built_in">u</span>(i)=<span class="built_in">d</span>(i)=i;</span><br><span class="line">        s[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">l</span>(<span class="number">0</span>)=m,<span class="built_in">r</span>(m)=<span class="number">0</span>;</span><br><span class="line">    idx=m+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;hh,<span class="keyword">int</span> &amp;tt,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[idx]=(DLX)&#123;hh,tt,y,<span class="built_in">d</span>(y),x,y&#125;;</span><br><span class="line">    <span class="built_in">u</span>(<span class="built_in">d</span>(y))=idx;<span class="built_in">d</span>(y)=idx;s[y]++;</span><br><span class="line">    <span class="built_in">l</span>(tt)=<span class="built_in">r</span>(hh)=idx;</span><br><span class="line"></span><br><span class="line">    tt=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="built_in">d</span>(p);i!=p;i=<span class="built_in">d</span>(i))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">l</span>(<span class="built_in">r</span>(i))=<span class="built_in">l</span>(i),<span class="built_in">r</span>(<span class="built_in">l</span>(i))=<span class="built_in">r</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="built_in">u</span>(p);i!=p;i=<span class="built_in">u</span>(i))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">l</span>(<span class="built_in">r</span>(i))=<span class="built_in">r</span>(<span class="built_in">l</span>(i))=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">h</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="built_in">r</span>(<span class="number">0</span>);i;i=<span class="built_in">r</span>(i))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        st[i]=<span class="literal">true</span>;res++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="built_in">d</span>(i);j!=i;j=<span class="built_in">d</span>(j))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="built_in">r</span>(j);k!=j;k=<span class="built_in">r</span>(k)) st[<span class="built_in">col</span>(k)]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k+<span class="built_in">h</span>()&gt;depth) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">r</span>(<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="built_in">r</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="built_in">r</span>(<span class="number">0</span>);i;i=<span class="built_in">r</span>(i))</span><br><span class="line">        <span class="keyword">if</span> (s[i]&lt;s[p]) p=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="built_in">d</span>(p);i!=p;i=<span class="built_in">d</span>(i))</span><br><span class="line">    &#123;</span><br><span class="line">        ans[k]=<span class="built_in">row</span>(i);</span><br><span class="line">        <span class="built_in">remove</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="built_in">r</span>(i);j!=i;j=<span class="built_in">r</span>(j)) <span class="built_in">remove</span>(j);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(k+<span class="number">1</span>,depth)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="built_in">l</span>(i);j!=i;j=<span class="built_in">l</span>(j)) <span class="built_in">resume</span>(j);</span><br><span class="line">        <span class="built_in">resume</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,hh=idx,tt=idx;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span> (x) <span class="built_in">add</span>(hh,tt,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">dfs</span>(<span class="number">0</span>,depth)) depth++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,depth);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;depth;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-例题"><a href="#5-例题" class="headerlink" title="5. 例题"></a>5. 例题</h3><h4 id="T1：破坏正方形"><a href="#T1：破坏正方形" class="headerlink" title="T1：破坏正方形"></a>T1：破坏正方形</h4><p><a href="https://www.luogu.com.cn/problem/UVA1603">题目传送门 Luogu(RemoteJudge:UVA)</a></p><p><a href="https://www.acwing.com/problem/content/184/">题目传送门 AcWing</a></p><p> 可以将火柴看做行，将正方形看做列，其实就是一个重复覆盖问题了。</p><p>具体实现时，注意正方形的计算，可能会有些繁琐，需要你认真找规律。</p><p>代码略。</p><h4 id="T2：雷达"><a href="#T2：雷达" class="headerlink" title="T2：雷达"></a>T2：雷达</h4><p><a href="https://www.acwing.com/problem/content/2726/">题目传送门 AcWing</a></p><p>首先，我们发现，答案具有单调性，即小的可以，那么更大的半径一定可以。</p><p>二分到一个答案时，我们将雷达设为行，将城市设为列，如果一行一列为一时，代表该雷达可以覆盖该城市。</p><p>剩下就是一个重复覆盖的模板了。</p><p><strong>注意卡常！</strong></p><p>注意 <code>h()</code> 的时候不要清空，而是每一次使用一个新的编号，这样就可以避免清空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLX</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, d, l, r, row, col;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> u(x) a[x].u</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> d(x) a[x].d</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) a[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) a[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> col(x) a[x].col</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> row(x) a[x].row</span></span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="keyword">int</span> idx, s[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">1005</span>], stcnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    idx = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="built_in">l</span>(i) = i - <span class="number">1</span>, <span class="built_in">r</span>(i) = i + <span class="number">1</span>, s[i] = <span class="number">0</span>, <span class="built_in">u</span>(i) = <span class="built_in">d</span>(i) = <span class="built_in">col</span>(i) = i;</span><br><span class="line">    <span class="built_in">r</span>(n) = <span class="number">0</span>, <span class="built_in">l</span>(<span class="number">0</span>) = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;hh, <span class="keyword">int</span> &amp;tt, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[idx] = &#123;y, <span class="built_in">d</span>(y), hh, tt, x, y&#125;;</span><br><span class="line">    <span class="built_in">r</span>(hh) = <span class="built_in">l</span>(tt) = <span class="built_in">u</span>(<span class="built_in">d</span>(y)) = idx;</span><br><span class="line">    <span class="built_in">d</span>(y) = idx, s[y] ++, tt = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">d</span>(p); i != p; i = <span class="built_in">d</span>(i))</span><br><span class="line">        <span class="built_in">l</span>(<span class="built_in">r</span>(i)) = <span class="built_in">l</span>(i), <span class="built_in">r</span>(<span class="built_in">l</span>(i)) = <span class="built_in">r</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">u</span>(p); i != p; i = <span class="built_in">u</span>(i))</span><br><span class="line">        <span class="built_in">l</span>(<span class="built_in">r</span>(i)) = <span class="built_in">r</span>(<span class="built_in">l</span>(i)) = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">h</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    ++ stcnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="built_in">r</span>(<span class="number">0</span>); p; p = <span class="built_in">r</span>(p))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[<span class="built_in">col</span>(p)] == stcnt) <span class="keyword">continue</span>;</span><br><span class="line">        st[<span class="built_in">col</span>(p)] = stcnt, res ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">d</span>(p); i != p; i = <span class="built_in">d</span>(i))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">r</span>(i); j != i; j = <span class="built_in">r</span>(j)) st[<span class="built_in">col</span>(j)] = stcnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k + <span class="built_in">h</span>() &gt; lim) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">r</span>(<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="built_in">r</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">r</span>(<span class="number">0</span>); i; i = <span class="built_in">r</span>(i))</span><br><span class="line">        <span class="keyword">if</span> (s[i] &lt; s[p]) p = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">d</span>(p); i != p; i = <span class="built_in">d</span>(i))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">remove</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">r</span>(i); j != i; j = <span class="built_in">r</span>(j)) <span class="built_in">remove</span>(j);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(k + <span class="number">1</span>, lim)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">l</span>(i); j != i; j = <span class="built_in">l</span>(j)) <span class="built_in">resume</span>(j);</span><br><span class="line">        <span class="built_in">resume</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dist2</span><span class="params">(<span class="keyword">const</span> Item &amp;a, <span class="keyword">const</span> Item &amp;b)</span></span>&#123;<span class="keyword">return</span> (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st), stcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> hh = idx, tt = idx;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1.0</span> * <span class="built_in">dist2</span>(p[i], p[j + m]) &lt;= mid * mid) <span class="built_in">add</span>(hh, tt, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (depth &lt;= k &amp;&amp; !<span class="built_in">dfs</span>(<span class="number">0</span>, depth)) depth ++;</span><br><span class="line">    <span class="keyword">return</span> depth &lt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;p[i + m].x, &amp;p[i + m].y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">        <span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">1500</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r - <span class="number">1e-9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">solve</span>(mid)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态压缩 DP</title>
      <link href="/2021/12/13/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9-DP/"/>
      <url>/2021/12/13/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9-DP/</url>
      
        <content type="html"><![CDATA[<p>分为两种：基于连通性的 DP（棋盘式）和集合式（表示一个元素是否在集合内）。</p><span id="more"></span><h2 id="状态压缩-DP"><a href="#状态压缩-DP" class="headerlink" title="状态压缩 DP"></a>状态压缩 DP</h2><h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h3><h4 id="T1：蒙德里安的梦想"><a href="#T1：蒙德里安的梦想" class="headerlink" title="T1：蒙德里安的梦想"></a>T1：蒙德里安的梦想</h4><p><a href="https://www.acwing.com/problem/content/293/">题目传送门 AcWing</a></p><h4 id="T2：最短-Hamilton-路径"><a href="#T2：最短-Hamilton-路径" class="headerlink" title="T2：最短 Hamilton 路径"></a>T2：最短 Hamilton 路径</h4><p><a href="https://www.acwing.com/problem/content/description/93/">题目传送门 AcWing</a></p><p>上面两个题都比较简单，这里不再做详细的讲解。</p><h4 id="T3：骑士"><a href="#T3：骑士" class="headerlink" title="T3：骑士"></a>T3：骑士</h4><p><a href="https://loj.ac/p/10170">题目传送门 LOJ</a></p><p>观察到，第 $i$ 行的放置情况和 $i-1$ 相关。</p><p>所以，我们可以考虑将第 $i-1$ 行的情况存储下来，对于每一个 $i-1$ 的情况，都剋容易地求出 $i$ 行的情况，就可以转移了。</p><p>首先考虑，怎样存储当前行的状态。</p><p>观察到 $n$ 很小，于是我们可以将 $n$ 个 01 按位压缩为一个二进制数。</p><p>具体地，如果 $j$ 位为 1，则第 $j$ 个摆放了国王。</p><p>回到本题，还要考虑放了几个国王，于是还要存储，可以表示为 $f[i,j,sta]$ 表示处理到第 $i$ 行，摆放了 $j$ 个国王，且第 $i$ 行状态为 $sta$ 的总种类数。</p><p>再考虑转移，我们首先要保证当前行本身是合法的。</p><p>其次，我们要保证 $i$ 行与 $i-1$ 行是合法的。</p><p>时间复杂度为 $O(2^n\times n\times k)$，实际远远达不到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">12</span>,K=N*N,S=(<span class="number">1</span>&lt;&lt;N);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[N][K][S];</span><br><span class="line"><span class="keyword">bool</span> st[S];</span><br><span class="line"><span class="keyword">int</span> num[S];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> bit=<span class="number">0</span>;bit&lt;<span class="number">12</span>;++bit)</span><br><span class="line">        <span class="keyword">if</span> ((s&gt;&gt;bit&amp;<span class="number">1</span>)&amp;(s&gt;&gt;bit+<span class="number">1</span>&amp;<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;++s)</span><br><span class="line">    &#123;</span><br><span class="line">        st[s]=<span class="built_in">check</span>(s);</span><br><span class="line">        <span class="keyword">if</span> (st[s])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=s;</span><br><span class="line">            <span class="keyword">while</span> (tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                num[s]++;</span><br><span class="line">                tmp-=(tmp&amp;-tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;++s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[s]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ls=<span class="number">0</span>;ls&lt;(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;++ls)</span><br><span class="line">                <span class="keyword">if</span> (st[ls]&amp;&amp;!(s&amp;(ls&lt;&lt;<span class="number">1</span>))&amp;&amp;!(s&amp;ls)&amp;&amp;!((s&lt;&lt;<span class="number">1</span>)&amp;ls))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j=num[s];j&lt;=k;++j) f[i][j][s]+=f[i<span class="number">-1</span>][j-num[s]][ls];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;++s) res+=f[n][k][s];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T4：玉米田"><a href="#T4：玉米田" class="headerlink" title="T4：玉米田"></a>T4：玉米田</h4><p><a href="https://www.acwing.com/problem/content/329/">题目传送门 AcWing</a></p><p>是上一题的变式与扩展。其实差不多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;algorithm&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">14</span>,S=(<span class="number">1</span>&lt;&lt;N);</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">1e8</span>;</span><br><span class="line">ll f[N][S];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">bool</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="keyword">if</span> ((!a[l][i])&amp;(s&gt;&gt;i<span class="number">-1</span>&amp;<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m<span class="number">-1</span>;++i)</span><br><span class="line">        <span class="keyword">if</span> ((s&gt;&gt;i&amp;<span class="number">1</span>)&amp;(s&gt;&gt;i+<span class="number">1</span>&amp;<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;(<span class="number">1</span>&lt;&lt;m);++s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">valid</span>(i,s)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ls=<span class="number">0</span>;ls&lt;(<span class="number">1</span>&lt;&lt;m);++ls)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">valid</span>(i<span class="number">-1</span>,ls)&amp;&amp;!(s&amp;ls))</span><br><span class="line">                    f[i][s]+=f[i<span class="number">-1</span>][ls];</span><br><span class="line">        &#125;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;(<span class="number">1</span>&lt;&lt;m);++s) res=(res+f[n][s])%Mod;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T5：-NOI2001-炮兵阵地"><a href="#T5：-NOI2001-炮兵阵地" class="headerlink" title="T5：[NOI2001]炮兵阵地"></a>T5：[NOI2001]炮兵阵地</h4><p><a href="https://www.luogu.com.cn/problem/P2704">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/294/">题目传送门 AcWing</a></p><p>本题和上面的题比较类似，但是还是有一些区别：</p><ol><li>射程变为了 2 格。</li><li>是求最大放置数。</li></ol><p>一个很明显的想法就是维护上面 2 行的信息。</p><p>使用 $f[i,j,k]$ 表示处理到第 $i$ 行，且第 $i$ 行状态是 $j$，第 $i-1$ 行的状态是 $k$。</p><p>状态之间转移时，我们可以根据第 $i-2$ 行来计算。</p><p>又有了第 $i-1$ 行的状态，我们就可以计算了。</p><p>但是，时间复杂度为 $O(2^{3m}\times n)$，已经超出了时间限制。</p><p> 于是，我们可以先将合法的情况先存下来，再进行计算。</p><p>另外，空间 $O(2^{2m}\times n)$，可能超过空间限制，我们使用滚动数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">101</span>,S=<span class="number">1</span>&lt;&lt;<span class="number">10</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][S][S];</span><br><span class="line"><span class="keyword">int</span> v[N],n,m;</span><br><span class="line"><span class="keyword">int</span> cnt[S];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        <span class="keyword">if</span> ((s&gt;&gt;i&amp;<span class="number">1</span>)+(s&gt;&gt;i+<span class="number">1</span>&amp;<span class="number">1</span>)+(s&gt;&gt;i+<span class="number">2</span>&amp;<span class="number">1</span>)&gt;=<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s)</span><br><span class="line">    &#123;</span><br><span class="line">        res++;</span><br><span class="line">        s-=(s&amp;-s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">14</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j) v[i]|=(op[j]!=<span class="string">&#x27;P&#x27;</span>)&lt;&lt;j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;(<span class="number">1</span>&lt;&lt;m);++s)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">valid</span>(s))</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push_back</span>(s);</span><br><span class="line">            cnt[st.<span class="built_in">size</span>()<span class="number">-1</span>]=<span class="built_in">num</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i0=<span class="number">0</span>;i0&lt;st.<span class="built_in">size</span>();++i0)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i1=<span class="number">0</span>;i1&lt;st.<span class="built_in">size</span>();++i1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> &amp;s0=st[i0],&amp;s1=st[i1];</span><br><span class="line">                <span class="keyword">if</span> ((s0&amp;v[i])|(s1&amp;v[i<span class="number">-1</span>])|(s0&amp;s1)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i2=<span class="number">0</span>;i2&lt;st.<span class="built_in">size</span>();++i2)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> &amp;s2=st[i2];</span><br><span class="line">                    <span class="keyword">if</span> ((s2&amp;v[i<span class="number">-2</span>])|(s0&amp;s2)|(s1&amp;s2)) <span class="keyword">continue</span>;</span><br><span class="line">                    f[i&amp;<span class="number">1</span>][i0][i1]=<span class="built_in">max</span>(f[i<span class="number">-1</span>&amp;<span class="number">1</span>][i1][i2]+cnt[i0],f[i&amp;<span class="number">1</span>][i0][i1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;st.<span class="built_in">size</span>();++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;st.<span class="built_in">size</span>();++j)</span><br><span class="line">            res=<span class="built_in">max</span>(res,f[n&amp;<span class="number">1</span>][i][j]);</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T6：-NOIP2016-愤怒的小鸟"><a href="#T6：-NOIP2016-愤怒的小鸟" class="headerlink" title="T6：[NOIP2016]愤怒的小鸟"></a>T6：[NOIP2016]愤怒的小鸟</h4><p><a href="https://www.luogu.com.cn/problem/P2831">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/526/">题目传送门 AcWing</a></p><p>前面讲的都是棋盘型的状态压缩 DP，现在我们开始讲集合型。</p><p>首先，函数为 $y=ax^2+bx(a&lt;0,b&gt;0)$ 只要确定了两个点，就可以求出抛物线。</p><p>观察到 $n\leq18$，所以我们可以首先将 $\dfrac{n(n-1)}{2}$ 个抛物线以及经过的点预处理出来。</p><p>然后，本题就转化为了重复覆盖问题。</p><p>可以使用 Dancing Links 求解，也可以使用状态压缩 DP 求解。</p><p><a href="http://localhost:4000/2021/12/13/%E8%88%9E%E8%B9%88%E9%93%BE%EF%BC%88DLX%EF%BC%89/#more">我的 Dancing Links Blog</a></p><p>这里讲一下状态压缩 DP。</p><p>首先，我们考虑 DFS.</p><p>在此基础上，我们将其改为一个记忆化搜索，用一个二进制数来表示各个元素是否在集合里。</p><p>于是就可以 DP（记忆化搜索）了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">19</span>, S = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) + <span class="number">10</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> f[S];</span><br><span class="line"><span class="keyword">int</span> n, tmp, tot;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;p[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> sta;</span><br><span class="line">&#125;l[N * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">F</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">const</span> Line &amp;bd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x * bd.a + x * bd.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">OnLine</span><span class="params">(<span class="keyword">const</span> Point &amp;pg, <span class="keyword">const</span> Line &amp;bd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">F</span>(pg.x, bd) - pg.y) &lt; eps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Line <span class="title">calc</span><span class="params">(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> X1 = p1.x, X2 = p2.x, Y1 = p1.y, Y2 = p2.y;</span><br><span class="line">    Line res;</span><br><span class="line">    res.a = (Y2 * X1 - Y1 * X2) / (X1 * X2 * (X2 - X1));</span><br><span class="line">    res.b = (Y1 - X1 * X1 * res.a) / X1;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (<span class="number">1</span> &lt;&lt; n); ++ i) f[i] = INF;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; tmp;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) l[++ tot].sta = (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++ j)</span><br><span class="line">            &#123;</span><br><span class="line">                l[++ tot] = <span class="built_in">calc</span>(p[i], p[j]);</span><br><span class="line">                Line &amp;now = l[tot];</span><br><span class="line">                <span class="keyword">if</span> (now.a &gt; -eps)</span><br><span class="line">                &#123;</span><br><span class="line">                    tot --;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++ k)</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">OnLine</span>(p[k], now)) now.sta |= <span class="number">1</span> &lt;&lt; k;</span><br><span class="line">            &#125;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); ++ j)</span><br><span class="line">                f[j | l[i].sta] = <span class="built_in">min</span>(f[j | l[i].sta], f[j] + <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 状态压缩 </tag>
            
            <tag> DP 及其优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间 DP</title>
      <link href="/2021/12/13/%E5%8C%BA%E9%97%B4-DP/"/>
      <url>/2021/12/13/%E5%8C%BA%E9%97%B4-DP/</url>
      
        <content type="html"><![CDATA[<p>比较灵活的一种 DP，复杂度比较高。</p><span id="more"></span><h2 id="区间-DP"><a href="#区间-DP" class="headerlink" title="区间 DP"></a>区间 DP</h2><h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h3><ol><li>环形 DP 转线性 DP</li><li>记录方案数</li><li>区间 DP + 高精度</li><li>二维区间 DP</li></ol><h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h3><h4 id="T1：-NOI1995-石子合并"><a href="#T1：-NOI1995-石子合并" class="headerlink" title="T1：[NOI1995] 石子合并"></a>T1：[NOI1995] 石子合并</h4><p><a href="https://www.luogu.com.cn/problem/P1880">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/284/">题目传送门 AcWing</a></p><p>是一个模板题，大致思路是 $f[i][j]= \max(f[i][k]+f[k+1][j])+a[l][r](i\leq k&lt;j)$。</p><p>时间复杂度 $O(n^3)$。</p><p>不详细讲了。</p><h4 id="T2：环形石子合并"><a href="#T2：环形石子合并" class="headerlink" title="T2：环形石子合并"></a>T2：环形石子合并</h4><p><a href="https://acwing.com/problem/content/1070/">题目传送门 AcWing</a></p><p>和上一题其实没有大区别，只是可以首尾合并。</p><p>现在怎么办呢？</p><p>首先，我们可以发现，合并完后，一定会有相邻的两个点是没有合并的。</p><p>于是，我们可以枚举相邻的两个点，从中间断开，就可以转换成链了。</p><p>但是，这个的复杂度为 $O(n\times n^3=n^4)$，会超时。</p><p>怎么优化呢？</p><p>我们将整个的环断开，复制一倍在末尾。</p><p>按链来计算，我们再枚举起点，$f[i][i+n-1]$ 即为答案。</p><h4 id="T3：-NOIP2006-能量项链"><a href="#T3：-NOIP2006-能量项链" class="headerlink" title="T3：[NOIP2006] 能量项链"></a>T3：[NOIP2006] 能量项链</h4><p><a href="https://www.luogu.com.cn/problem/P1063">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/322/">题目传送门 AcWing</a></p><p>可能很多同学都会想到贪心，但是是有问题的。</p><p>其实还是一个区间 DP，和上一题没有大区别。</p><p>考虑边界问题，有一些不同。</p><p>$f[i][j]=\max(f[i][k]+f[k][j]+a[i]*a[k]*a[j])i&lt;k&lt;j$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],f[N][N],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i+n]=a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;=<span class="number">2</span>*n;++len)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n-len+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (len==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;j;++k)</span><br><span class="line">                f[i][j]=<span class="built_in">max</span>(f[i][j],f[i][k]+f[k][j]+a[i]*a[k]*a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) res=<span class="built_in">max</span>(res,f[i][i+n]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T4：凸多边形的划分"><a href="#T4：凸多边形的划分" class="headerlink" title="T4：凸多边形的划分"></a>T4：凸多边形的划分</h4><p><a href="https://loj.ac/p/10149">题目传送门 LOJ</a></p><p>看似无从下手。</p><p>现在，我们先考虑对于一条边，我们必须找到一个点来使这条边构成一个三角形。</p><p>枚举这个点，我们发现可以将整个图转化为三个部分，于是就划分为了三个子问题。</p><p>于是，我们就可以区间 DP 了！</p><p>具体来说，我们选取 $[L,R]$ 这条边，然后枚举对应的点，然后划分为 $[L,i],[i,R],(L,i,R)$ 三部分。</p><p>最后要注意的是，答案很大，需要使用该精度。</p><h4 id="T5：-NOIP2003-加分二叉树"><a href="#T5：-NOIP2003-加分二叉树" class="headerlink" title="T5：[NOIP2003] 加分二叉树"></a>T5：[NOIP2003] 加分二叉树</h4><p><a href="https://www.acwing.com/problem/content/481/">题目传送门 AcWing</a></p><p><a href="https://www.luogu.com.cn/problem/P1040">题目传送门 Luogu</a></p><p>题目本身不难，但是我们要学习区间 DP 的思想。</p><p>我们发现，在中序遍历中，左子树一定会根节点的左边，右子树一定在根节点的右边。</p><p>于是，我们可以枚举当前的根节点，然后就可以划分为几个了。</p><p>$f[i,j]=\max(f[i][k-1]\times f[k+1][j]+a[k])(i&lt;k&lt;j)$。</p><p>同时，我们要记录答案的来源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">35</span>;</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="keyword">int</span> n,g[N][N],a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,g[l][r]);</span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l!=g[l][r]) <span class="built_in">print</span>(l,g[l][r]<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (r!=g[l][r]) <span class="built_in">print</span>(g[l][r]+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;=n;++len)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=n-len+<span class="number">1</span>;++l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">            ll &amp;val=f[l][r];</span><br><span class="line">            <span class="keyword">if</span> (l==r)</span><br><span class="line">            &#123;</span><br><span class="line">                val=a[l];</span><br><span class="line">                g[l][r]=l;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f[l+<span class="number">1</span>][r]+a[l]&gt;=f[l][r<span class="number">-1</span>]+a[r])</span><br><span class="line">            &#123;</span><br><span class="line">                val=f[l+<span class="number">1</span>][r]+a[l];</span><br><span class="line">                g[l][r]=l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                val=f[l][r<span class="number">-1</span>]+a[r];</span><br><span class="line">                g[l][r]=r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=l+<span class="number">1</span>;k&lt;r;++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (val&lt;f[l][k<span class="number">-1</span>]*f[k+<span class="number">1</span>][r]+a[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    val=f[l][k<span class="number">-1</span>]*f[k+<span class="number">1</span>][r]+a[k];</span><br><span class="line">                    g[l][r]=k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[<span class="number">1</span>][n]);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T6：-NOI1999-棋盘分割"><a href="#T6：-NOI1999-棋盘分割" class="headerlink" title="T6：[NOI1999] 棋盘分割"></a>T6：[NOI1999] 棋盘分割</h4><p><a href="https://www.luogu.com.cn/problem/P5752">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/323/">题目传送门 AcWing</a></p><p>首先一阵推导：<br>$$<br>ans^2=\dfrac{\sum_{i=1}^{n}(x_i -\overline x)}{n}\ =\dfrac1n(\sum_{i=1}^n(x_i^2-2x_i\overline x+\overline x^2))<br>$$</p><p>$$<br>=\dfrac1n(\sum_{i=1}^nx_i^2-2\overline x\sum_{i=1}^nx_i+n \overline x^2)<br>$$</p><p>$$<br>=\dfrac {\sum_{i=1}^nx_i^2}n-\overline x^2<br>$$</p><p>于是，我们就是要使  $\sum_{i=1}^nx_i^2$ 最小。</p><p>首先，分为横切和纵切。</p><p>然后，我们还要看是哪一边继续切割，就递归统计答案。</p><p>对于另一边，我们可以使用二维前缀和快速计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) (x*x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20</span>,M=<span class="number">9</span>,INF=<span class="number">0x3f3f3f3f</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">8</span>,k;</span><br><span class="line"><span class="keyword">int</span> s[M][M];</span><br><span class="line"><span class="keyword">double</span> f[M][M][M][M][N],X;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_matrix</span><span class="params">(<span class="keyword">int</span> xa,<span class="keyword">int</span> ya,<span class="keyword">int</span> xb,<span class="keyword">int</span> yb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> t=(<span class="keyword">double</span>)s[xb][yb]-s[xa<span class="number">-1</span>][yb]-s[xb][ya<span class="number">-1</span>]+s[xa<span class="number">-1</span>][ya<span class="number">-1</span>]-X;</span><br><span class="line">    <span class="keyword">return</span> t*t/k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> xa,<span class="keyword">int</span> ya,<span class="keyword">int</span> xb,<span class="keyword">int</span> yb,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> &amp;v=f[xa][ya][xb][yb][k];</span><br><span class="line">    <span class="keyword">if</span> (v&gt;=<span class="number">0</span>) <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">if</span> (k==<span class="number">1</span>) <span class="keyword">return</span> v=(<span class="built_in">get_matrix</span>(xa,ya,xb,yb));</span><br><span class="line">    v=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=xa;i&lt;xb;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        v=<span class="built_in">min</span>(v,(<span class="built_in">get_matrix</span>(xa,ya,i,yb))+<span class="built_in">dp</span>(i+<span class="number">1</span>,ya,xb,yb,k<span class="number">-1</span>));</span><br><span class="line">        v=<span class="built_in">min</span>(v,(<span class="built_in">get_matrix</span>(i+<span class="number">1</span>,ya,xb,yb))+<span class="built_in">dp</span>(xa,ya,i,yb,k<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=ya;i&lt;yb;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        v=<span class="built_in">min</span>(v,(<span class="built_in">get_matrix</span>(xa,ya,xb,i))+<span class="built_in">dp</span>(xa,i+<span class="number">1</span>,xb,yb,k<span class="number">-1</span>));</span><br><span class="line">        v=<span class="built_in">min</span>(v,(<span class="built_in">get_matrix</span>(xa,i+<span class="number">1</span>,xb,yb))+<span class="built_in">dp</span>(xa,ya,xb,i,k<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;%d %d %d %d %d:%d\n&quot;,xa,ya,xb,yb,k,v);</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i][j]);</span><br><span class="line">            s[i][j]-=s[i<span class="number">-1</span>][j<span class="number">-1</span>]-s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    X=(<span class="keyword">double</span>)s[n][n]/k;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="comment">// printf(&quot;%.3lf\n&quot;,(double)dp(1,1,n,n,k));</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>,<span class="built_in">sqrt</span>(<span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">1</span>,n,n,k)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DP 及其优化 </tag>
            
            <tag> 区间 DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树形 DP</title>
      <link href="/2021/12/13/%E6%A0%91%E5%BD%A2-DP/"/>
      <url>/2021/12/13/%E6%A0%91%E5%BD%A2-DP/</url>
      
        <content type="html"><![CDATA[<p>题型多而杂，我们通过学习例题的方式看一下。</p><span id="more"></span><h4 id="T1：树的直径"><a href="#T1：树的直径" class="headerlink" title="T1：树的直径"></a>T1：树的直径</h4><p>考虑树形 DP。</p><p>对于每一个子树，我们都可以求出在该子树的最长路径。</p><p>对于根节点，他的所有儿子都会有一个向下的最大路径。</p><p>然后，我们维护这些路径的最大值和次大值，就可以求出经过该点且在该点里的最大路径。</p><h4 id="T2：树的中心"><a href="#T2：树的中心" class="headerlink" title="T2：树的中心"></a>T2：树的中心</h4><p>直接考虑怎样求从一个点出发走到的最远距离。</p><p>对于一个点，他向下走的最大距离是很好求的，直接模仿上一题。</p><p>接下来，我们考虑向上走。</p><p>首先，走到父亲节点时，他有两种选择：继续向上走或者向下走。</p><p>向上走的部分就可以递归了，但是向下走有问题：如果向下的最大距离是经过当前点怎么办？</p><p>我们再维护一个次大值，向下的最大路径如果经过当前点的话，就给次大值。</p><h4 id="T3：数字变换"><a href="#T3：数字变换" class="headerlink" title="T3：数字变换"></a>T3：数字变换</h4><p><a href="https://loj.ac/p/10155">题目传送门 LOJ</a></p><p>将问题抽象为一颗树的形式：假设较小的数是较大的数的父亲。</p><p>那么，每一个数，一定只有一个父亲，且一定不会形成一个环。</p><p>所以，按小到大的顺序建好树后，就可以直接求树的直径了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>,M=<span class="number">1e5</span>+<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> sum[N],d[N],ans,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[x]&gt;=<span class="number">0</span>) <span class="keyword">return</span> d[x];</span><br><span class="line">    <span class="keyword">int</span> &amp;d1=d[x],d2=-INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="built_in">dfs</span>(e[i])+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (t&gt;=d1) d2=d1,d1=t;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t&gt;d2) d2=t;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,d1+d2);</span><br><span class="line">    <span class="comment">// printf(&quot;%d %d %d\n&quot;,x,d1,d2);</span></span><br><span class="line">    <span class="keyword">if</span> (d1&lt;<span class="number">0</span>) d1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> d1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0xcf</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n/i;++j) sum[i*j]+=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (sum[i]&lt;i) <span class="built_in">add</span>(sum[i],i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (d[i]&lt;<span class="number">0</span>) <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T4：二叉苹果树"><a href="#T4：二叉苹果树" class="headerlink" title="T4：二叉苹果树"></a>T4：二叉苹果树</h4><p><a href="https://loj.ac/p/10153">题目传送门 LOJ</a></p><p>这个是一个比较简单的树形（有依赖的）背包问题。</p><p>考虑计算一个节点。</p><p>对于他的所有儿子来说，都相当于是一个分组的物品。</p><p>直接分组背包即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">150</span>,M=<span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> n,k,f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(e[i],x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=k;j;--j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">0</span>;l+<span class="number">1</span>&lt;=j;++l)</span><br><span class="line">                f[x][j]=<span class="built_in">max</span>(f[x][j],f[x][j-l<span class="number">-1</span>]+f[e[i]][l]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y,c;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;x,&amp;y,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(x,y,c);<span class="built_in">add</span>(y,x,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;f[<span class="number">1</span>][k]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T5：战略游戏"><a href="#T5：战略游戏" class="headerlink" title="T5：战略游戏"></a>T5：战略游戏</h4><p><a href="https://loj.ac/p/10156">题目传送门 LOJ</a></p><p>记录 $f[i,0]$ 为 $i$ 节点不放士兵的最小代价，$f[i,1]$ 为 $i$ 节点放士兵的最小代价。</p><p>那么，就可以得到：<br>$$<br>f[i,1]=\sum_{(i,j)\in E}{\min (f[j,0],f[j,1])}<br>$$</p><p>$$<br>f[i,0]=\sum_{(i,j)\in E}{f[j,1]}<br>$$</p><p>就可以计算了。</p><p>（话说我尝试了一下新型的码风）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1505</span>, M = <span class="number">2</span> * N;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> n, f[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(e[i]);</span><br><span class="line">        f[x][<span class="number">0</span>] += f[e[i]][<span class="number">1</span>];</span><br><span class="line">        f[x][<span class="number">1</span>] += <span class="built_in">min</span>(f[e[i]][<span class="number">0</span>], f[e[i]][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b, id, tot;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;id, &amp;tot);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (tot -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b);</span><br><span class="line">            <span class="built_in">add</span>(id, b);</span><br><span class="line">            st[b] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> rt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (st[rt]) rt ++ ;</span><br><span class="line">    <span class="built_in">dfs</span>(rt);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">min</span>(f[rt][<span class="number">1</span>], f[rt][<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T6：皇宫看守"><a href="#T6：皇宫看守" class="headerlink" title="T6：皇宫看守"></a>T6：皇宫看守</h4><p><a href="https://loj.ac/p/10157">题目传送门 LOJ</a></p><p>这个题大概要使用到状态自动机模型<del>（但是我没写）</del></p><p>其实也不难，就是不同的状态之间的转化。</p><p>设 $0$ 状态为儿子节点看守本节点， $1$ 状态为本节点看守，$2$ 状态为父亲节点看守。</p><p>每一个节点的三种状态，都可以通过儿子节点算出来。</p><p>具体请读者自行实现，或者看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1505</span>, M = <span class="number">2</span> * N;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">3</span>], v[N], n;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x][<span class="number">1</span>] = v[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(e[i]);</span><br><span class="line">        f[x][<span class="number">1</span>] += <span class="built_in">min</span>(<span class="built_in">min</span>(f[e[i]][<span class="number">1</span>], f[e[i]][<span class="number">2</span>]), f[e[i]][<span class="number">0</span>]);</span><br><span class="line">        f[x][<span class="number">2</span>] += <span class="built_in">min</span>(f[e[i]][<span class="number">1</span>], f[e[i]][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">        tot += <span class="built_in">min</span>(f[e[i]][<span class="number">1</span>], f[e[i]][<span class="number">0</span>]);</span><br><span class="line">    f[x][<span class="number">0</span>] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">        f[x][<span class="number">0</span>] = <span class="built_in">min</span>(f[x][<span class="number">0</span>], tot - <span class="built_in">min</span>(f[e[i]][<span class="number">1</span>], f[e[i]][<span class="number">0</span>]) + f[e[i]][<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// printf(&quot;%d %d %d %d\n&quot;, x, f[x][0], f[x][1], f[x][2]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id, b, tot;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;id);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;v[id], &amp;tot);</span><br><span class="line">        <span class="keyword">while</span> (tot -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b);</span><br><span class="line">            <span class="built_in">add</span>(id, b);</span><br><span class="line">            st[b] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (st[rt]) rt ++ ;</span><br><span class="line">    <span class="built_in">dfs</span>(rt);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">min</span>(f[rt][<span class="number">0</span>],f[rt][<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树形 DP </tag>
            
            <tag> DP 及其优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数位 DP</title>
      <link href="/2021/12/13/%E6%95%B0%E4%BD%8D-DP/"/>
      <url>/2021/12/13/%E6%95%B0%E4%BD%8D-DP/</url>
      
        <content type="html"><![CDATA[<p>比较套路的一种 DP。</p><span id="more"></span><h2 id="数位-DP"><a href="#数位-DP" class="headerlink" title="数位 DP"></a>数位 DP</h2><h3 id="1-通用思路"><a href="#1-通用思路" class="headerlink" title="1. 通用思路"></a>1. 通用思路</h3><h4 id="1）通用问法"><a href="#1）通用问法" class="headerlink" title="1）通用问法"></a>1）通用问法</h4><ol><li>首先，题目会让你求一个区间中满足一个条件的数。</li><li>该条件可以被拆分为逐数位考虑的方法。</li></ol><h4 id="2）通用解法"><a href="#2）通用解法" class="headerlink" title="2）通用解法"></a>2）通用解法</h4><ol><li>$[L,R]\Rightarrow[1,R]-[1,L-1]$</li><li>考虑填入第 $i$ 位时，可以分为 $[0,a_{i}-1]$ 和 $a_i$ 两种情况，其中 $a_i$ 表示限制数目第 $i$ 位的数字。</li></ol><h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h3><h4 id="T1：度的数量"><a href="#T1：度的数量" class="headerlink" title="T1：度的数量"></a>T1：度的数量</h4><p><a href="https://www.acwing.com/problem/content/1083/">题目传送门 AcWing</a></p><p>按上面的做法来分析，如果选 $0$，那么答案为 $\binom{n-1}k$，如果选 $1$ 且 $a_i\not=1$，那么答案为 $\binom{n-1}{k-1}$。</p><p>如果 $a_i=1$，那么就填上 1，递归即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> K, B, l, r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++ i )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++ j )</span><br><span class="line">            <span class="keyword">if</span> (!j) f[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> f[i][j] = f[i - <span class="number">1</span>][j] + f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> maxn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!maxn) <span class="keyword">return</span> !K;</span><br><span class="line"></span><br><span class="line">    vector &lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">int</span> tmp = maxn;</span><br><span class="line">    <span class="keyword">while</span> (tmp) nums.<span class="built_in">push_back</span>(tmp % B), tmp /= B;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> &amp;x = nums[i];</span><br><span class="line">        <span class="keyword">if</span> (x)</span><br><span class="line">        &#123;</span><br><span class="line">            res += f[i][K - last];</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (K &gt;= last + <span class="number">1</span>) res += f[i][K - last - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                last ++ ;</span><br><span class="line">                <span class="keyword">if</span> (last &gt; K) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!i &amp;&amp; last == K) res ++ ; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r &gt;&gt; K &gt;&gt; B;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">dp</span>(r) - <span class="built_in">dp</span>(l - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2：-SCOI2009-Windy-数"><a href="#T2：-SCOI2009-Windy-数" class="headerlink" title="T2：[SCOI2009] Windy 数"></a>T2：[SCOI2009] Windy 数</h4><p><a href="https://www.luogu.com.cn/problem/P2657">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/1085/">题目传送门 AcWing</a></p><p><a href="https://loj.ac/p/10165">题目传送门 LOJ</a></p><p>本题同样是数位 DP 的经典题目。</p><p>仍然从高到低枚举每一位，分为 $[0,a_i-1]$ 和 $a_i$ 两种情况。</p><p>首先，我们发现，当前的位既不能超过 $a_i$，又必须与 $a_{i+1}$ 差值至少为 2。</p><p>枚举当前位即可，后面的位就与当前数无关，就可以预处理了。</p><p>具体来说，我们预处理 $f[i,j]$ 为位数为 $i$，且最高位为 $j$ 的总数。</p><p>这个显然不难，一个简单的递推即可。</p><p>但是，本题还有一个问题：不含前导零怎么处理？</p><p>首先，我们将和当前限制的数的相同位数的算出来（即第一位至少为 1，后面可以为 0），然后再将低于当前限制位数算出来，很明显我们已经预处理了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++ j ) f[<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++ i )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++ j )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">9</span>; ++ k )</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(k - j) &gt;= <span class="number">2</span>) f[i][j] += f[i - <span class="number">1</span>][k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vector &lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    nums.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">while</span> (n) nums.<span class="built_in">push_back</span>(n % <span class="number">10</span>), n /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, last = <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> &amp;x = nums[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i == nums.<span class="built_in">size</span>() - <span class="number">1</span>; j &lt; x; ++ j )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(j - last) &gt;= <span class="number">2</span>) res += f[i + <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(x - last) &gt;= <span class="number">2</span>) last = x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (!i) res ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;, res);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; -- i )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; ++ j ) res += f[i + <span class="number">1</span>][j];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dp</span>(r) - <span class="built_in">dp</span>(l - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3：数字游戏"><a href="#T3：数字游戏" class="headerlink" title="T3：数字游戏"></a>T3：数字游戏</h4><p><a href="https://loj.ac/p/10166">题目传送门 LOJ</a></p><p>可以发现，所有数位 DP 的题目其实差不多。</p><p>直接预处理 $i$ 位数，最高位是 $j$，且模 $n$ 是 $k$ 的总个数。</p><p>然后和上题差不多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line">ll f[<span class="number">12</span>][<span class="number">10</span>][N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Mod</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (s % n + n) % n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++ i) f[<span class="number">1</span>][i][i % n] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">12</span>; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++ k)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= <span class="number">9</span>; ++l)</span><br><span class="line">                    f[i][j][k] += f[i - <span class="number">1</span>][l][<span class="built_in">Mod</span>(k - j)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    vector &lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">while</span> (x) nums.<span class="built_in">push_back</span>(x % <span class="number">10</span>), x /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> &amp;x = nums[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x; ++ j)</span><br><span class="line">            res += f[i + <span class="number">1</span>][j][<span class="built_in">Mod</span>(-last)];</span><br><span class="line">        last = <span class="built_in">Mod</span>(last + x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!i &amp;&amp; !last) res ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b &gt;&gt; n) <span class="built_in">init</span>(), <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">dp</span>(b) - <span class="built_in">dp</span>(a - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下几个题作为练习的题目，不再做讲解，有疑问的同学可以看代码。</p><h4 id="T4：不要-62"><a href="#T4：不要-62" class="headerlink" title="T4：不要 62"></a>T4：不要 62</h4><p><a href="https://loj.ac/p/10167">题目传送门 LOJ</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++ i) f[<span class="number">1</span>][i] = i != <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">9</span>; ++ k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">4</span> || k == <span class="number">4</span> || (j == <span class="number">6</span> &amp;&amp; k == <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                f[i][j] += f[i - <span class="number">1</span>][k];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    vector &lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">while</span> (n) nums.<span class="built_in">push_back</span>(n % <span class="number">10</span>), n /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> &amp;x = nums[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x; ++ j)</span><br><span class="line">            <span class="keyword">if</span> ((j != <span class="number">2</span> || last != <span class="number">6</span>) &amp;&amp; (j != <span class="number">4</span>))</span><br><span class="line">                res += f[i + <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">if</span> ((last == <span class="number">6</span> &amp;&amp; x == <span class="number">2</span>) || (x == <span class="number">4</span>)) <span class="keyword">break</span>;</span><br><span class="line">        last = x;</span><br><span class="line">        <span class="keyword">if</span> (!i) res ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b, a || b) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dp</span>(b) - <span class="built_in">dp</span>(a - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T5：恨-7-不成妻"><a href="#T5：恨-7-不成妻" class="headerlink" title="T5：恨 7 不成妻"></a>T5：恨 7 不成妻</h4><p><a href="https://loj.ac/p/10168">题目传送门 LOJ</a></p><p>维护 $s0,s1,s2$ 分别表示所有的 0 次方（及个数），1 次方（和），2 次方。</p><p>比较难写，特别注意是模什么。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod(x, y) ((x) % (y) + (y)) % (y)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll s0, s1, s2;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s0 = <span class="built_in">mod</span>(s0, Mod);</span><br><span class="line">        s1 = <span class="built_in">mod</span>(s1, Mod);</span><br><span class="line">        s2 = <span class="built_in">mod</span>(s2, Mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node f[N][<span class="number">10</span>][<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line">ll p7[N], pm[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(Node &amp;v1, <span class="keyword">const</span> Node &amp;v2, <span class="keyword">int</span> j, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v1.s0 = (v1.s0 + v2.s0) % Mod;</span><br><span class="line">    v1.s1 = ((v1.s1 + v2.s1) % Mod + v2.s0 * p % Mod * (ll)j % Mod) % Mod;</span><br><span class="line">    v1.s2 = (v1.s2 + v2.s2</span><br><span class="line">            +<span class="number">2ll</span> * p % Mod * v2.s1 % Mod * (ll)j % Mod</span><br><span class="line">            +((ll)j * p % Mod) * ((ll)j * p % Mod) % Mod * v2.s0 % Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    p7[<span class="number">0</span>] = pm[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) p7[i] = (p7[i - <span class="number">1</span>] * <span class="number">10ll</span>) % <span class="number">7ll</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) pm[i] = (pm[i - <span class="number">1</span>] * <span class="number">10ll</span>) % Mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        Node &amp;v1 = f[<span class="number">1</span>][i][i % <span class="number">7</span>][i % <span class="number">7</span>];</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">7</span>) <span class="keyword">continue</span>;</span><br><span class="line">        v1.s0 ++, v1.s1 += i, v1.s2 += i * i;</span><br><span class="line">    &#125;</span><br><span class="line">    ll p = <span class="number">10ll</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++ i, p *= <span class="number">10ll</span>, p %= Mod)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">7</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">9</span>; ++ k)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">7</span>; ++ x)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">7</span>; ++ y)</span><br><span class="line">                    <span class="keyword">if</span> (k != <span class="number">7</span>) <span class="built_in">merge</span>(f[i][j][x][y],</span><br><span class="line">                     f[i - <span class="number">1</span>][k][<span class="built_in">mod</span>(x - j, <span class="number">7ll</span>)][<span class="built_in">mod</span>(y - p7[i - <span class="number">1</span>] * j, <span class="number">7ll</span>)], j, p);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll s0 = <span class="number">0</span>, s1 = <span class="number">0</span>, s2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">7</span>; ++ k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">7</span>; ++ l)</span><br><span class="line">            <span class="keyword">if</span> (k != x &amp;&amp; l != y)</span><br><span class="line">            &#123;</span><br><span class="line">                Node &amp;v = f[i][j][k][l];</span><br><span class="line">                s0 = (s0 + v.s0) % Mod;</span><br><span class="line">                s1 = (s1 + v.s1) % Mod;</span><br><span class="line">                s2 = (s2 + v.s2) % Mod;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> (Node)&#123;s0, s1, s2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dp</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ll tmp = n;n %= Mod;</span><br><span class="line">    vector &lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">while</span> (tmp) nums.<span class="built_in">push_back</span>(tmp % <span class="number">10</span>), tmp /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    ll last0 = <span class="number">0</span>, last1 = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> &amp;x = nums[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">7</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="built_in">mod</span>(-last0, <span class="number">7</span>), b = <span class="built_in">mod</span>(-(last1 % <span class="number">7</span>) * p7[i + <span class="number">1</span>], <span class="number">7</span>);</span><br><span class="line">            Node v = <span class="built_in">calc</span>(i + <span class="number">1</span>, j, a, b);</span><br><span class="line">            res = (res + (last1 % Mod) * (last1 % Mod) % Mod * pm[i + <span class="number">1</span>] % Mod * pm[i + <span class="number">1</span>] % Mod * v.s0 % Mod</span><br><span class="line">            + <span class="number">2</span> * (last1 % Mod) % Mod * pm[i + <span class="number">1</span>] % Mod * v.s1 % Mod + v.s2) % Mod;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">7</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        last1 = last1 * <span class="number">10</span> + x;last0 += x;</span><br><span class="line">        <span class="keyword">if</span> (!i &amp;&amp; last1 % <span class="number">7</span> &amp;&amp; last0 % <span class="number">7</span>) res = (res + n * n % Mod) % Mod;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;L10168.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;myans.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    ll t, l, r;cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">mod</span>(<span class="built_in">dp</span>(r) - <span class="built_in">dp</span>(l - <span class="number">1</span>), Mod) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DP 及其优化 </tag>
            
            <tag> 数位 DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斜率优化 DP</title>
      <link href="/2021/12/13/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96-DP/"/>
      <url>/2021/12/13/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96-DP/</url>
      
        <content type="html"><![CDATA[<p>DP 优化。</p><span id="more"></span><h2 id="斜率优化-DP"><a href="#斜率优化-DP" class="headerlink" title="斜率优化 DP"></a>斜率优化 DP</h2><h3 id="1-主要思想"><a href="#1-主要思想" class="headerlink" title="1. 主要思想"></a>1. 主要思想</h3><p>斜率优化和单调队列、倍增、数据结构优化差不多，都是为了优化算法瓶颈的复杂度。</p><h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h3><h4 id="T1：任务安排"><a href="#T1：任务安排" class="headerlink" title="T1：任务安排"></a>T1：任务安排</h4><p><a href="https://www.luogu.com.cn/problem/P2365">例题1：(Luogu)</a></p><p><a href="https://acwing.com/problem/content/302/">例题1：(AcWing)</a></p><p>这题是斜率优化模板题的前身。</p><p>首先，我们发现启动一次，会对后面的所有都有影响。</p><p>所以，我们可以首先将该费用提前计算，为后面所有的费用乘上启动时间。</p><p>于是，我们较为简单地写出状态转移：<br>$$<br>f[i]=\min(f[j]+S*(sumc[n]-sumc[j])+ (sumc[i]-sumc[j])*sumt[i])<br>$$</p><p>就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, sumt[N], sumc[N], f[N], S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;sumt[i], &amp;sumc[i]);</span><br><span class="line">        sumt[i] += sumt[i - <span class="number">1</span>];</span><br><span class="line">        sumc[i] += sumc[i - <span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++ j)</span><br><span class="line">            f[i] = <span class="built_in">min</span>(f[i], f[j] + S * (sumc[n] - sumc[j]) + sumt[i] * (sumc[i] - sumc[j]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h4><p><a href="https://loj.ac/p/10185">题目传送门 LOJ</a></p><p>这个就是斜率优化最经典的题目了。</p><p>我们来看一下：<br>$$<br>f[i]=\min(f[j]+S*(sumc[n]-sumc[j])+ (sumc[i]-sumc[j])*sumt[i])<br>$$<br>在求 $f[i]$ 的时候，可以认为 $i$ 相关的是常量，与 $j$ 相关的是变量。</p><p>所以，“参变分离”，可得：<br>$$<br>f[i]=f[j]-(S+sumt[i])<em>sumc[j]+S</em> sumc[n]+sumc[i]*sumt[i]<br>$$<br>将 $f[j]$ 看作 $y$，$sumc[j]$ 为 $x$，那么原式可以为：<br>$$<br>f[j]=(S+sumt[i])*sumc[j]+f[i]-sumt[i]<em>sumc[i]-S</em>sumt[n]<br>$$<br>那么，每一个决策都可以看作一个点，为 $(f[j],sumc[j])$。</p><p>我们现在想要 $f[i]$ 最小，即截距要最小。</p><p>然后，对于同一个 $i$ 来说，斜率是不变的。</p><p>那么，我们让斜率为 $S+sumt[i]$ 的一条直线一直向上移，当碰到第一个点时，就是最优决策了。</p><p>所以，对于每一个 $i$ 来说，都是这样来计算即可。</p><p>根据<strong>动态规划的优化根本原则</strong>，就是<strong>及时删除不需要的决策</strong>。</p><p>那些是不需要的决策呢？</p><p>首先，将所有点按横坐标排序（本题就是递增的）。</p><p>然后，将相邻两个点的<strong>斜率</strong>算出来。</p><p>注意，这里的斜率和上面的不同，定义是有区别的，务必分清！</p><p>以示区分，我在这里用<strong>横纵比</strong>表示这里的斜率（名字不好，凑合着用一下吧）</p><p>然后，如果相邻的纵横比是递减的，那么中间的点一定不会用到。</p><p>这个得到的图形就是凸包。</p><p>这里是难点，请务必理解。</p><p>画个图。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/m4afde28.png"></p><p>然后，我们在凸包中找答案。</p><p>可以证明，答案一定是满足这样性质的点：他与前面点的横纵比小于斜率，与后面的点的纵横比大于斜率。</p><p>如果不理解的话，看一下上面的图就可以了。</p><p>于是，我们只要维护一个凸包即可，用平衡树维护即可，复杂度为 $O(n\log n)$。</p><p>其实，这也是 Graham 算法。</p><p>这个就是斜率优化的精髓。</p><p>然后，我们回归本题。</p><p>因为插入的点的横坐标一定是递增的，所以我们一定可以将点向后插入，就不需要平衡树了。</p><p>同时，因为本题查询的斜率也一定是递增的，所以如果有小于当前斜率的横纵比，直接就删除该点即可，就是上面被绿色叉掉的点。</p><p>在本题中，可以做到 $O(n)$，其他题可以优化到 $O(n\log n)$。</p><p>所有的题目，使用斜率优化时，都要弄清状态转移方程的 $y,x,k$ 再做。</p><p>代码不太长，但是细节有点多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line">ll f[N], sumt[N], sumc[N];</span><br><span class="line"><span class="keyword">int</span> n, q[N], S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;S);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;sumt[i], &amp;sumc[i]);</span><br><span class="line">        sumt[i] += sumt[i - <span class="number">1</span>];</span><br><span class="line">        sumc[i] += sumc[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//f[j] = f[i] + (sumt[i] + S) * sumc[j] - sumc[n] * S - sumt[i] * sumc[i]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt; tt &amp;&amp; (f[q[hh + <span class="number">1</span>]] - f[q[hh]]) &lt;= (sumt[i] + S) * (sumc[q[hh + <span class="number">1</span>]] - sumc[q[hh]]))</span><br><span class="line">            hh ++;</span><br><span class="line">        f[i] = f[q[hh]] - (sumt[i] + S) * sumc[q[hh]] + sumc[n] * S + sumt[i] * sumc[i];</span><br><span class="line">        <span class="keyword">while</span> (hh &lt; tt &amp;&amp; (f[q[tt]] - f[q[tt - <span class="number">1</span>]]) * (sumc[i] - sumc[q[tt]]) &lt;= </span><br><span class="line">        (f[i] - f[q[tt]]) * (sumc[q[tt]] - sumc[q[tt - <span class="number">1</span>]])) tt --;</span><br><span class="line">        q[++ tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[n]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h4><p><a href="https://www.luogu.com.cn/problem/P5785">题目传送门 Luogu</a></p><p><a href="https://loj.ac/p/10186">题目传送门 LOJ</a></p><p>这个就是刚才的题的加强版。</p><p>$T&lt;0$，会发生什么呢？</p><p>看到上面的分析，我们发现就是斜率就不再具有单调性。</p><p>所以，我们不能删除横纵比小于当前斜率的点，于是就必须二分查找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line">ll sumt[N], sumc[N], f[N];</span><br><span class="line"><span class="keyword">int</span> S, q[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;sumt[i], &amp;sumc[i]);</span><br><span class="line">        sumt[i] += sumt[i - <span class="number">1</span>];</span><br><span class="line">        sumc[i] += sumc[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = hh, r = tt;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ((f[q[mid + <span class="number">1</span>]] - f[q[mid]]) &gt;= (sumt[i] + S) * (sumc[q[mid + <span class="number">1</span>]] - sumc[q[mid]]))</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = q[r];</span><br><span class="line">        f[i] = f[j] - (sumt[i] + S) * sumc[j] + S * sumc[n] + sumc[i] * sumt[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (hh &lt; tt &amp;&amp; (f[q[tt]] - f[q[tt - <span class="number">1</span>]]) * (sumc[i] - sumc[q[tt]]) &gt;=</span><br><span class="line">        (f[i] - f[q[tt]]) * (sumc[q[tt]] - sumc[q[tt - <span class="number">1</span>]])) tt --;</span><br><span class="line">        q[++ tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[n]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T4：运输小猫"><a href="#T4：运输小猫" class="headerlink" title="T4：运输小猫"></a>T4：运输小猫</h4><p><a href="https://www.acwing.com/problem/content/305/">题目传送门 AcWing</a></p><p>首先，我们求 $d_{1,i}$，即一个前缀和。</p><p>然后，假设 $S$ 为饲养员出发的时间。</p><p>那么，就可以得到 $S+d_i\geq t_i$，即 $S\geq t_i-d_i$。</p><p>令 $a_i=t_i-d_i$，那么每只小猫要求饲养员的出发时间的最大值。</p><p>再按照 $a_i$ 排序，于是就可以排成序列。</p><p>于是就转化为了一个较为经典的 DP 了。</p><p>设 $f[i,j]$ 为接走前 $i$ 只小猫用了 $j$ 个饲养员所需的最小等待时间。</p><p>用前缀和 $s_i$ 表示 $\sum_{j=1}^{i}a[i]$。</p><p>那么就可以得到：<br>$$<br>f[i,j]=\min(f[k,j-1]+a[i]*(i-k)-(s[i]-s[k]))<br>$$<br>接着，可以改写为：<br>$$<br>f[k,j-1]+s[k]=a[i]*k+f[i,j]-a[i]*i+s[i]<br>$$<br>就是一个斜率优化了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, P = <span class="number">110</span>;</span><br><span class="line">ll d[N], a[N], f[P][N], s[N];</span><br><span class="line"><span class="keyword">int</span> n, m, p, q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d[i]);</span><br><span class="line">        d[i] += d[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, id; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;id, &amp;a[i]);</span><br><span class="line">        a[i] -= d[id];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= p; ++ j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) f[j][i] = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">        q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (hh &lt; tt &amp;&amp; (f[j - <span class="number">1</span>][q[hh + <span class="number">1</span>]] + s[q[hh + <span class="number">1</span>]] - f[j - <span class="number">1</span>][q[hh]] - s[q[hh]])</span><br><span class="line">            &lt;= a[i] * (q[hh + <span class="number">1</span>] - q[hh]))</span><br><span class="line">                hh ++;</span><br><span class="line">            f[j][i] = f[j - <span class="number">1</span>][q[hh]] + a[i] * (i - q[hh]) - s[i] + s[q[hh]];</span><br><span class="line">            <span class="keyword">while</span> (hh &lt; tt &amp;&amp; (f[j - <span class="number">1</span>][q[tt]] + s[q[tt]] - f[j - <span class="number">1</span>][q[tt - <span class="number">1</span>]] - s[q[tt - <span class="number">1</span>]]) * (i - q[tt])</span><br><span class="line">            &gt;= (f[j - <span class="number">1</span>][i] + s[i] - f[j - <span class="number">1</span>][q[tt]] - s[q[tt]]) * (q[tt] - q[tt - <span class="number">1</span>]))</span><br><span class="line">                tt --;</span><br><span class="line">            q[++ tt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll res = <span class="number">1ll</span> &lt;&lt; <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++ i) res = <span class="built_in">min</span>(res, f[i][m]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DP 及其优化 </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>群论和 Pólya 定理</title>
      <link href="/2021/12/13/%E7%BE%A4%E8%AE%BA%E5%92%8C-Polya-%E5%AE%9A%E7%90%86/"/>
      <url>/2021/12/13/%E7%BE%A4%E8%AE%BA%E5%92%8C-Polya-%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>本章节不再讲述非常难的群论基础，仅作为学习 Pólya 的工具，基本不涉及证明。</p><span id="more"></span><h2 id="群论和-Polya-定理"><a href="#群论和-Polya-定理" class="headerlink" title="群论和 Pólya 定理"></a>群论和 Pólya 定理</h2><h3 id="1-群论基础"><a href="#1-群论基础" class="headerlink" title="1. 群论基础"></a>1. 群论基础</h3><h4 id="1）置换"><a href="#1）置换" class="headerlink" title="1）置换"></a>1）置换</h4><p>其实就是一个函数，或者是映射。</p><p>我们首先有一个 $1\sim n$ 的排列，然后我们将顺序打乱，然后前后的变化就是一个置换。</p><p>写为标准的格式，就是<br>$$<br>\binom{1\ 2\ 3…\ n}{a_1\ a_2…\ a_n}<br>$$</p><h4 id="2）循环置换"><a href="#2）循环置换" class="headerlink" title="2）循环置换"></a>2）循环置换</h4><p>就是将一个置换循环（？）。</p><p>具体来说，就是 1 变 2，2 变 3，…，$n-1$ 变 $n$，$n$ 变 1。</p><p>这样大概理解了吧。</p><p>我们将其投射到图上，会发现每一个置换可以看作一张图中沿有向图的方向行走一个。</p><p>循环置换中，就是 1 连 2，2 连 3，这样，就会构成一个环。</p><p>每一个置换都是有几个环构成的。</p><h4 id="3）置换群"><a href="#3）置换群" class="headerlink" title="3）置换群"></a>3）置换群</h4><p>就是所有置换的集合。</p><p>注意，他的子集也可以是置换群。</p><h3 id="2-Burnside-引理"><a href="#2-Burnside-引理" class="headerlink" title="2. Burnside 引理"></a>2. Burnside 引理</h3><p>求解的问题是某类本质不同的方案数。</p><p>本质相同比如：翻转、旋转能重合的。</p><p><strong>引理：不同方案数就是每个置换的不动点的平均值。</strong></p><p>首先，这里的置换就是从一个方案转换到另一种方案的过程。</p><p>这里可能有一些抽象，后面结合例题一起来看。</p><p>比如，我们看一个简单的例子。</p><blockquote><p>给定一串珠子，给它染上 3 种颜色，求本质不同的方案数。</p></blockquote><p>置换过后，如果该方案是没有变化的，那么就称该方案在该置换下是不动点。</p><p>我们对于每一个置换，都求一下不动点的个数，最后求一下平均值，就是本质不同的方案数。</p><h3 id="3-Polya-定理"><a href="#3-Polya-定理" class="headerlink" title="3. Pólya 定理"></a>3. Pólya 定理</h3><p>刚才的 Burnside 引理，还需要求不动点。</p><p>首先，我们将这个置换拆成多个循环。</p><p>然后，对于每一个循环，我们只要染上同一种颜色，就是不动点。</p><p>所以，不动点个数就为 $c^k$，其中 $c$ 表示颜色，$k$ 表示循环数。</p><p>这样，我们只需要求每一个置换的循环数，就可以求出不动点了。</p><h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4. 例题"></a>4. 例题</h3><h4 id="T1：串珠子-【模板】Polya-定理"><a href="#T1：串珠子-【模板】Polya-定理" class="headerlink" title="T1：串珠子/【模板】Pólya 定理"></a>T1：串珠子/【模板】Pólya 定理</h4><p><a href="https://www.luogu.com.cn/problem/P4980">题目传送门 Luogu</a></p><p>第一种：旋转。</p><p>可以旋转 0 格，1 格，……，$n-1$ 格。</p><p>那么，$k$ 格之后，$x$ 会转到 $x+k$ 的位置。</p><p>设 $d=\gcd(n,k)$，那么转 $\dfrac{n}{d}$ 次后就会产生重叠，所以循环节长度就为 $\dfrac{n}{d}$。</p><p>于是，画个图就可以理解，一共有 $d$ 个循环节。</p><p>所以，不动点就为 $m^{\gcd(n,k)}$。</p><p>第二种：翻转。</p><p>首先，我们要分类。</p><p>如果 $n\equiv1\pmod2$，于是对称轴一定穿过每个点。</p><p>就有 $n$ 种情况，每一种情况的循环个数为 $1+\dfrac{n-1}{2}=\dfrac{n+1}{2}$。</p><p>如果 $n\equiv0\pmod2$，于是对称轴可能是穿过每个点，或者是穿过两个点的中间。</p><p>如果对称轴穿过一个点，就是 $2+\dfrac{n-2}{2}=\dfrac{n}{2}+1$。</p><p>如果对称轴穿过中间，就是 $\dfrac{n}{2}$。</p><p>至此，我们就将所有不动点的情况全部计算了出来。</p><p>（这是 Luogu 的代码，还要出来一下 后面的公式推导）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Gcd</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res *= a, res %= Mod;</span><br><span class="line">        a *= a;a %= Mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_phi</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / i; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, n;cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / i; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = (ans + <span class="built_in">qpow</span>(n, i) * <span class="built_in">get_phi</span>(n / i) % Mod) % Mod;</span><br><span class="line">                <span class="keyword">if</span> (i * i != n) ans = (ans + <span class="built_in">qpow</span>(n, n / i) * <span class="built_in">get_phi</span>(i) % Mod) % Mod;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans * <span class="built_in">qpow</span>(n, Mod - <span class="number">2</span>) % Mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2：魔法手链"><a href="#T2：魔法手链" class="headerlink" title="T2：魔法手链"></a>T2：魔法手链</h4><p><a href="https://www.acwing.com/problem/content/3137/">题目传送门 AcWing</a></p><p>这道题，我们不能使用 Pólya 定理，因为 Pólya 不能满足这些限制。</p><p>于是，我们使用 Burnside 引理。</p><p>怎样找不动点呢？</p><p>首先，我们考虑 $k$ 旋转之后得到的置换。</p><p>然后，对于每一个点，我们都有每 $d=\gcd(n,k)$ 都是当前点可能达到的。</p><p>于是，我们如果要不动点的话，这每 $d$ 个点出现一次的点一定都要相等。</p><p>纵观全局，这个循环是 $\dfrac{n}{d}$ 长度的。</p><p>于是，就是 $d$ 个互不相同的循环。</p><p>问题就变为了 $0\sim d-1$ 的颜色将会被复制 $\dfrac{n}{d}$ 次使得填满该环。</p><p>于是，我们只需要关注这个小段即可，而且他首尾相连。</p><p>也就是长度为 $d$ 的环染色数量就是不动点的数量。</p><p>这样，我们可以考虑 DP 了。</p><p>首先，我们初始化，首先定义 $d$ 的颜色，枚举即可。</p><p>然后，我们直接暴力枚举每一种颜色和前面的颜色，只要可以放在一起就累计答案。</p><p>最后，取 $d$ 的颜色的累计答案，就可以了。</p><p>但是，本题 $n\leq10^9$，无法通过。</p><p>所以，我们可以预处理长度为 $1\sim n$ 的环的答案。</p><p>这个就是一个简单的矩阵快速幂优化 DP 了。</p><p>但是，本体中，我们还不能枚举 $k$。</p><p>观察到 $k$ 的答案仅与 $d$ 的取值相关。</p><p>所以，我们枚举 $d|n$，然后找到 $k=k’*d$ 使得 $k’$ 与 $\dfrac nd$ 互质。</p><p>这不就是 $\varphi(\dfrac nd)$ 吗！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">11</span>, Mod = <span class="number">9973</span>;</span><br><span class="line"><span class="keyword">int</span> M;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a[N][N], n, m;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">(<span class="keyword">int</span> _n, <span class="keyword">int</span> _m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        n = _n, m = _m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> Matrix <span class="keyword">operator</span> *(<span class="keyword">const</span> Matrix &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">        Matrix c;c.<span class="built_in">clean</span>(n, b.m);</span><br><span class="line">        <span class="keyword">if</span> (m != b.n) <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b.m; ++ j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++ k)</span><br><span class="line">                    c.a[i][j] = (c.a[i][j] + a[i][k] * b.a[k][j]) % Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> Matrix <span class="keyword">operator</span> ^(<span class="keyword">int</span> x)<span class="keyword">const</span>&#123;</span><br><span class="line">        Matrix res, tmp = *<span class="keyword">this</span>;res.<span class="built_in">clean</span>(n, m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) res.a[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &amp; <span class="number">1</span>) res = res * tmp;</span><br><span class="line">            x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            tmp = tmp * tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;F0, ed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_phi</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / i; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">1</span>) ans = ans / n  *(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * a % Mod;</span><br><span class="line">        a = a * a % Mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">qpow</span>(x, Mod - <span class="number">2</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ed = F0 ^ x;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++ i) sum += ed.a[i][i], sum %= Mod;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, n, k;cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; M &gt;&gt; k;</span><br><span class="line">        F0.<span class="built_in">clean</span>(M, M);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++ j) F0.a[i][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            F0.a[x][y] = F0.a[y][x] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / i; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res = (res + <span class="built_in">calc</span>(i) * (<span class="built_in">get_phi</span>(n / i) % Mod) % Mod) % Mod;</span><br><span class="line">                <span class="keyword">if</span> (i == n / i) <span class="keyword">continue</span>;</span><br><span class="line">                res = (res + <span class="built_in">calc</span>(n / i) * (<span class="built_in">get_phi</span>(i) % Mod) % Mod) % Mod;</span><br><span class="line">            &#125;</span><br><span class="line">        cout &lt;&lt; <span class="function">res * <span class="title">inv</span><span class="params">(n)</span> % Mod &lt;&lt; endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> Polya 定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀自动机（SAM）总结</title>
      <link href="/2021/12/13/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88SAM%EF%BC%89%E6%80%BB%E7%BB%93/"/>
      <url>/2021/12/13/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88SAM%EF%BC%89%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>自认为写得还行。</p><span id="more"></span><h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h3><p>本文不比前面的学习笔记 <a href="https://www.luogu.com.cn/blog/mydcwfy-342891/suffix-automation">后缀自动机笔记</a>，这篇文章大概能保证你能理解。</p><p>本文同样不会给出证明，但是会亲近读者，尽可能让读者看懂。</p><p>图片建议新标签页打开看一下。因为用的是 Luogu，github 上会挂。</p><h3 id="1-职能"><a href="#1-职能" class="headerlink" title="1. 职能"></a>1. 职能</h3><p>这个就是一个可以快速查找一个字符串的子串，1 号点是根节点，走 1 号点可以走到所有的子串。</p><p>预处理和寻找都是线性 $O(n)$ 的。</p><h3 id="2-前置知识"><a href="#2-前置知识" class="headerlink" title="2. 前置知识"></a>2. 前置知识</h3><p>$\text{endpos}$ 的一些基本定义和性质。</p><p>顾名思义，$\text{endpos}$ 对于字符串中的一个子串而定义，是指所有出现的地方的最后一个字符的位置。</p><p>（可能有些绕，看一下下面的解释</p><p>首先，我们定义，$\text{endpos}$ 相同的作为一个等价类，可以看做同一个状态，对应在 SAM 中是同一个结点。</p><p>比如，我们还是来看一个实例 $\texttt{abcbc}$：</p><ul><li>${\texttt{abcbc},\texttt{bcbc},\texttt{cbc} }$ 的 $\text{endpos}$ 都是 ${5}$。</li><li>${\texttt{bc},\texttt{c} }$ 的 $\text{endpos}$ 都是 ${3,5}$。</li></ul><p>当然没有列举完，读者可以自己推一下（？</p><p>可以发现，$\text{endpos}$ 有一个性质，就是如果 $\text{endpos}$ 相同的，一定是长度递减的字符串。</p><p>还是看上面的实例：</p><ul><li>${\texttt{abcbc},\texttt{bcbc},\texttt{cbc} }$ 是长度递减的字符串，且后面一个是前面一个的后缀。</li><li>${\texttt{bc},\texttt{c} }$ 是长度递减的字符串，且后面一个是前面一个的后缀。</li></ul><p>现在，大概理解了 $\text{endpos}$ 的基本性质了吧。</p><h3 id="3-SAM-的构造"><a href="#3-SAM-的构造" class="headerlink" title="3. SAM 的构造"></a>3. SAM 的构造</h3><p>这里我们先贴代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len, fa;</span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">26</span>];</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">1</span>, tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = last;<span class="keyword">int</span> np = ++ tot;</span><br><span class="line">f[tot] = <span class="number">1</span>;</span><br><span class="line">tr[np].len = tr[p].len + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; !tr[p].ch[c]; p = tr[p].fa) tr[p].ch[c] = np;</span><br><span class="line">last = tot;</span><br><span class="line"><span class="keyword">if</span> (!p) tr[np].fa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> q = tr[p].ch[c];</span><br><span class="line"><span class="keyword">if</span> (tr[q].len == tr[p].len + <span class="number">1</span>) tr[np].fa = q;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nq = ++ tot;</span><br><span class="line">tr[nq] = tr[q], tr[nq].len = tr[p].len + <span class="number">1</span>;</span><br><span class="line">tr[q].fa = tr[np].fa = nq;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; tr[p].ch[c] == q; p = tr[p].fa) tr[p].ch[c] = nq;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数调用的时候，直接 <code>for (int i = 1; str[i]; ++ i) extend(str[i] - &#39;a&#39;);</code> （这里假设只有小写字母）。</p><p><del>可以先背代码，再看下面的讲解</del>。</p><p>下面一点一点的讲解：</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len, fa;</span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">26</span>];</span><br><span class="line">&#125;tr[N];</span><br></pre></td></tr></table></figure><p>说明一下每一个变量的含义：</p><p><code>tr[N]</code>：前面所讲的 $\text{endpos}$ 相同的子串将会被放入同一个结点，也就是说这些子串遍历时会走到这个结点停止。</p><p><code>ch[26]</code>：指所有的结点的转移。</p><p><code>len</code>：指所有的子串的最大长度。</p><p><code>fa</code>：可以看做 <code>fail</code>，也就是匹配失败的时候会走到哪个结点（现在大概用不到，有点像 KMP）。</p><p><strong>性质</strong>：$fa$ 指向的结点的最长长度就是当前结点所代表的子串的最短长度减 1。</p><p>还是拿 $\texttt{abcbc}$ 来说：</p><p>${\texttt{abcbc},\texttt{bcbc},\texttt{cbc} }$ 的最短长度是 3，那么这个结点的 $fa$ 是 $\texttt{bc}$ 所在的结点， 长度为 2。</p><p>这里有一些重要，请务必理解。（其实认真读一下上面的定义就可以了）</p><p>然后，还有一个<strong>重要的性质</strong>：如果当前所代表的最长子串是 $s$，那么按照 $fa$ 一直跳的话，所有遍历到的结点所代表的子串一定都是 $s$ 的后缀，且 $s$ 的后缀一定都被遍历到。</p><p>拿 ${\texttt{abcbc},\texttt{bcbc},\texttt{cbc} }$ 为例：这个结点的 $fa$ 会指向 $\texttt{bc}$ 所在的结点，然后 ${\texttt{bc},\texttt{c}}$ 是一个结点，然后 $fa$ 是 $\varnothing$。可以发现，整个遍历到的是 ${\texttt{abcbc,bcbc,cbc,bc,c},\varnothing }$，恰好是 $\texttt{abcbc}$ 的后缀的所有。 </p><hr><p><code>last = tot = 1</code>：这里表示开始已经有了一个节点，我们定义最开始结点的 $fa$ 是 0，长度也是 0。</p><hr><p><code>int p = last, np = ++ tot; ...; last = tot; </code>：$p$ 表示前面的结点，$np$ 表示当前的结点，处理完当前结点的时候要将 $last$ 更新。</p><hr><p><code>for (; p &amp;&amp; !tr[p].ch[c]; p = tr[p].fa) tr[p].ch[c] = np;</code></p><p>根据刚才的性质：</p><blockquote><p>如果当前所代表的最长子串是 $s$，那么按照 $fa$ 一直跳的话，所有遍历到的结点所代表的子串一定都是 $s$ 的后缀，且 $s$ 的后缀一定都被遍历到。</p></blockquote><p>有了这个结论的话，这里就比较简单了：直接一直按照 $fa$ 跳，将所有的结点都加上当前字符 $c$。</p><p>为什么要加上 <code>!tr[p].ch[c]</code> 呢？</p><p>因为如果出现了相同的字符，我们就有可能出现 $\text{endpos}$ 不是当前结点的，我们要特殊处理。</p><p>这个稍微有点复杂，现在可以理解为有原来的指向了，如果再赋值就会导致一些被覆盖，我们等一下再讲。</p><hr><p><code>if (!p) tr[np].fa = 1;</code>：这个说明程序退出循环是因为 $p=0$，所以说明 $last$ 结点所代表的最长子串，也就是原串（每一次扩展时 $last$ 都赋值给了最新的那个，也就是最长的那个），原串的所有后缀都加了当前字符 $c$，然后到了 $np$ 这个结点。</p><p>所以，$np$ 所代表的子串的长度一定从 $1$ 到最长长度。</p><p>比如，原来的串是 $\texttt{abc}$，加上了 $\texttt{d}$，那么 $\texttt{abc},\texttt{bc},\texttt{c},\varnothing$ 都会加上 $d$ 这个字符。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/u717hbc3.png"></p><p>（黑色边代表 $ch[]$，绿色边代表 $fa$）</p><p>前面没有理解可以看一下这个图。</p><p>那么，$np$ 的 $fa$ 就是长度为 $0$ 的串在的结点，也就是 $1$。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q = tr[p].ch[c];</span><br><span class="line"><span class="keyword">if</span> (tr[q].len == tr[p].len + <span class="number">1</span>) tr[np].fa = q;</span><br></pre></td></tr></table></figure><p>这里就有些难理解了，我们首先填一下前面的坑。</p><p>因为 $p$ 既可以转移到 $q$，也可以转移到 $np$，那么可以得到结论：$p$ 转移的 $ch[c]$ 有两个出现。</p><p>这里我们用一下前面的例子，在前面的基础 $\texttt{ab}$ 加上 $\texttt{b}$。</p><p>当循环到 $p=1$ 的时候，我们发现已经有了 $b$ 的转移边，这意味着 $\varnothing+\texttt{b}$ 已经出现了一次，这里又一次出现了，也就是说，$\text{endpos}$ 结果是不同于 $q$ 本身的 $\text{endpos}$ 了，所以要特殊处理。</p><p>这里明显是遇上了也有 $c$ 转移的。</p><p>我们首先记录下 $ch[c]$ 的位置 $q$。</p><p>首先，为什么 <code>tr[q].len = tr[p].len + 1</code> 与 <code>tr[q].len != tr[p].len + 1</code> 是不同的呢？</p><p>画一个图。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/eolba4ep.png"></p><p>根据前面所讲，$\texttt{b}$ 的 $\text{endpos}$ 是 ${2,3}$，不同于原来 3 号结点的 $\text{endpos}$。</p><p>但是，这里判断的 <code>tr[q].len = tr[p].len + 1</code> 是什么意思呢？</p><p>前面讲到，$len$ 的意思是一个结点所代表的子串的最长长度。</p><p>如果 <code>tr[q].len == tr[p].len + 1</code> 的话，那么这里只有长度为 $tr[q].len$ 的一个子串！</p><p>所以我们可以直接将这个结点的 $\text{endpos}$ 改为新的子串。</p><p>比如说，前面的 $q=3$ 的 $\text{endpos}$ 为 2，但是又添加了 $b$ 这个字符，我们就将 $q=3$ 的 $\text{endpos}$ 直接改为 ${2,3}$ 就可以了。</p><p>很明显，3 号结点所代表的子串仍然是 ${\texttt{ab},\texttt{b}}$，然后 $np=4$ 所代表的子串是 ${\texttt{abb}}$，比较明显，4 的 $fa$ 是 3。</p><hr><p>（你以为完了？还多着呢</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nq = ++ tot;</span><br><span class="line">tr[nq] = tr[q], tr[nq].len = tr[p].len + <span class="number">1</span>;</span><br><span class="line">tr[q].fa = tr[np].fa = nq;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; tr[p].ch[c] == q; p = tr[p].fa) tr[p].ch[c] = nq;</span><br></pre></td></tr></table></figure><p>这里是前面情况的相反情况，也就是 <code>tr[q].len != tr[p].len + 1</code>。</p><p>那么，我们这里就需要将 $q$ 结点拆为两个结点。</p><p>其中一个仍然是 $q$，另一个是 $nq$，也就是新建结点。</p><p>我们再画一个图，建的是 $\texttt{abcb}$ 的后缀自动机。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/hib4zlyo.png"></p><p><code>tr[nq] = tr[q]</code>：这一个比较简单，因为就是复制过来即可。</p><p><code>tr[nq].len = tr[p].len + 1</code>：这里是指将 $q$ 的长度为 $tr[p].len+1$ 的子串。</p><p><code>tr[q].fa = tr[np].fa = nq</code>：首先，我们从例子中学习。</p><p>很明显，$q$ 的最短子串是 $\texttt{ab}$，也就是长度减 1 的就是 $\texttt{b}$，同理，$np$ 的最短子串是 $\texttt{cb}$，长度减 1 也是 $\texttt{b}$。</p><p>再从证明入手。</p><p>前面说到，$nq$ 这个结点是从 $q$ 这个结点分离出来的，且是最短的子串被分离了的。</p><p>所以，$q$ 的 $fa$ 就应该是 $q$，这个显然 <del>（显然大法）</del>。</p><p>然后，因为 $np$ 本来应该也是有 $nq$ 这个结点所代表的子串的。</p><p>那么，我们也可以说 $nq$ 是从 $np$ 分离出来的。</p><p>所以，这一句显然。</p><hr><p><code>for (; p &amp;&amp; tr[p].ch[c] == q; p = tr[p].fa) tr[p].ch[c] = nq;</code></p><p> 这里是指，既然 $p$ 这个结点所代表的最长子串都是重复了的，那么 $p$ 的所有 $fa$（前提是原来是 $tr[p].ch[c] == q$）都应该有 $ch[c]$ 指到 $nq$ 这个结点。</p><p>看一下上面的例子。</p><p>$p$ 所代表的是 $\varnothing$，它接上 $\texttt{b}$ 也应该属于 $nq$，所以 $tr[p].ch[‘b’-‘a’]=nq$。</p><p>$p$ 的 $fa$ 是 0，所以结束。</p><hr><h3 id="4-SAM-时空复杂度的理解与简要证明"><a href="#4-SAM-时空复杂度的理解与简要证明" class="headerlink" title="4. SAM 时空复杂度的理解与简要证明"></a>4. SAM 时空复杂度的理解与简要证明</h3><p>这里，只说明 $tot\leq 2\operatorname{strlen}(s) - 1$。</p><p>很明显，每一次最多只会多 2 个结点。</p><p>查询也是线性，不用多说。</p><hr><h3 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h3><p>如果你还没有理解的话，<del>请喷作者</del>并发再评论。</p><p>希望能帮助到你。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 后缀数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀自动机（SAM）</title>
      <link href="/2021/12/13/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88SAM%EF%BC%89/"/>
      <url>/2021/12/13/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88SAM%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>写得比较差，建议看另一篇。</p><span id="more"></span><h2 id="后缀自动机-SAM"><a href="#后缀自动机-SAM" class="headerlink" title="后缀自动机(SAM)"></a>后缀自动机(SAM)</h2><h3 id="1-主要思想"><a href="#1-主要思想" class="headerlink" title="1. 主要思想"></a>1. 主要思想</h3><p>可以类比于 Trie，但它是一个有向无环图。</p><p>可以用来存储一个串的所有子串。</p><h3 id="2-性质"><a href="#2-性质" class="headerlink" title="2. 性质"></a>2. 性质</h3><p>从起点出发，从普通边，可以得到所有子串。</p><p>同时，所有边和点的数量在 $O(n)$ 级别。</p><p>终点就是包含后缀的点，同时每一个点对应的是不止一个子串。</p><p>但所有每一个点对应的子串满足：按长度降序排序后，我们发现每一个串都是前面一个串的后缀。</p><p>还有一种边：$Link/Father$。</p><p>这种边构成一棵树。</p><p>将一个点所对应的最短的子串的首字母去掉，得到的子串所对应的节点，再由原来节点指向这个节点。</p><p>首先定义 $endpos(s)$ 为子串 s 在原串所有出现的位置（尾字母）下标集合。</p><p>如果有两个子串的 $endpos$ 相同，则我们可以将其看为一个等价类。</p><p>SAM 的状态与所有的等价类一一对应。</p><p><strong>证明1</strong>：如果 $|s1|\leq|s2|$，则 $s1$ 是 $s2$ 的后缀当且仅当 $endpos(s1) \supseteq endpos(s2)$。</p><p>$s1$ 不是 $s2$ 的后缀当且仅当 $endpos(s1)\cap endpos(s2)= \varnothing$。</p><p>这两个易证。</p><p><strong>证明2：</strong>两个不同子串的 $endpos$ 要么包含要么无交集。</p><p>易得，如果不为交集，那么必有一个 $pos$ 使两个都满足，则必有一个是另一个的子集。</p><p><strong>证明3：</strong> 对于每一个等价类 $st$，最长的子串为 $longest$，最短的为 $shortest$，若 $shortest\leq |s|\leq longest$，则 $s$ 也是属于该等价类。</p><h3 id="3-构造方法"><a href="#3-构造方法" class="headerlink" title="3. 构造方法"></a>3. 构造方法</h3><p>本人能力不够，也是云里雾里，只能帮到这了（ <del>逃</del> ）。</p><p>自己去理解吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len,fa;</span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">26</span>];</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line">ll f[N],ans;</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],ne[N],idx,last=<span class="number">1</span>,tot=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=last;<span class="keyword">int</span> np=++tot;</span><br><span class="line">    f[tot]=<span class="number">1</span>;</span><br><span class="line">    tr[np].len=tr[p].len+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;p&amp;&amp;!tr[p].ch[c];p=tr[p].fa) tr[p].ch[c]=np;</span><br><span class="line">    last=tot;</span><br><span class="line">    <span class="keyword">if</span> (!p) tr[np].fa=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q=tr[p].ch[c];</span><br><span class="line">        <span class="keyword">if</span> (tr[q].len==tr[p].len+<span class="number">1</span>) tr[np].fa=q;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> nq=++tot;</span><br><span class="line">            tr[nq]=tr[q],tr[nq].len=tr[p].len+<span class="number">1</span>;</span><br><span class="line">            tr[q].fa=tr[np].fa=nq;</span><br><span class="line">            <span class="keyword">for</span> (;p&amp;&amp;tr[p].ch[c]==q;p=tr[p].fa) tr[p].ch[c]=nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(e[i]);f[x]+=f[e[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f[x]&gt;<span class="number">1</span>) ans=<span class="built_in">max</span>(ans,f[x]*tr[x].len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;str[i];++i) <span class="built_in">extend</span>(str[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=tot;++i) <span class="built_in">add</span>(tr[i].fa,i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4. 例题"></a>4. 例题</h3><h4 id="T1：玄武密码"><a href="#T1：玄武密码" class="headerlink" title="T1：玄武密码"></a>T1：玄武密码</h4><p><a href="https://www.luogu.com.cn/problem/P5231">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/1285/">题目传送门 AcWing</a></p><p>比模板还要裸。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e7</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa,len;</span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">4</span>];</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="keyword">int</span> last=<span class="number">1</span>,tot=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=last,np=last=++tot;</span><br><span class="line">    tr[np].len=tr[p].len+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;p&amp;&amp;!tr[p].ch[c];p=tr[p].fa) tr[p].ch[c]=np;</span><br><span class="line">    <span class="keyword">if</span> (!p) tr[np].fa=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q=tr[p].ch[c];</span><br><span class="line">        <span class="keyword">if</span> (tr[q].len==tr[p].len+<span class="number">1</span>) tr[np].fa=q;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> nq=++tot;</span><br><span class="line">            tr[nq]=tr[q],tr[nq].len=tr[p].len+<span class="number">1</span>;</span><br><span class="line">            tr[q].fa=tr[np].fa=nq;</span><br><span class="line">            <span class="keyword">for</span> (;p&amp;&amp;tr[p].ch[c]==q;p=tr[p].fa) tr[p].ch[c]=nq; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>:<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">1</span>,i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;str[i]&amp;&amp;tr[p].ch[<span class="built_in">get</span>(str[i])];++i) p=tr[p].ch[<span class="built_in">get</span>(str[i])];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">extend</span>(<span class="built_in">get</span>(str[i]));</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">        <span class="built_in">dfs</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2：最长公共子串"><a href="#T2：最长公共子串" class="headerlink" title="T2：最长公共子串"></a>T2：最长公共子串</h4><p><a href="https://www.acwing.com/problem/content/2813/">题目传送门 AcWing</a></p><p><a href="https://loj.ac/p/171">题目传送门 LOJ</a></p><p>将第一个建后缀自动机，和后面的进行比较即可。</p><p>注意要标记回传，否则更新可能不及时。</p><p>注意其中的最大最小：</p><ol><li>每一次走到一个节点时，应该和当前的取最大值。</li><li>不同的字符串之间，一个节点的值应取最小值。</li><li>最后得出答案时，应该把不同的节点所保存的值取最大输出。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len,fa;</span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">26</span>];</span><br><span class="line">&#125;tr[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">int</span> last=<span class="number">1</span>,tot=<span class="number">1</span>,now[N],ans[N];</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=last,np=last=++tot;</span><br><span class="line">    tr[np].len=tr[p].len+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;p&amp;&amp;!tr[p].ch[c];p=tr[p].fa) tr[p].ch[c]=np;</span><br><span class="line">    <span class="keyword">if</span> (!p) tr[np].fa=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q=tr[p].ch[c];</span><br><span class="line">        <span class="keyword">if</span> (tr[q].len==tr[p].len+<span class="number">1</span>) tr[np].fa=q;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> nq=++tot;</span><br><span class="line">            tr[nq]=tr[q],tr[nq].len=tr[p].len+<span class="number">1</span>;</span><br><span class="line">            tr[q].fa=tr[np].fa=nq;</span><br><span class="line">            <span class="keyword">for</span> (;p&amp;&amp;tr[p].ch[c]==q;p=tr[p].fa) tr[p].ch[c]=nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h[x];~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">tree</span>(e[i]);</span><br><span class="line">        now[x]=<span class="built_in">max</span>(now[x],now[e[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,p=<span class="number">1</span>,t=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(now,<span class="number">0</span>,<span class="keyword">sizeof</span> now);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;str[i];++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (p&gt;<span class="number">1</span>&amp;&amp;!tr[p].ch[c]) p=tr[p].fa,t=tr[p].len; </span><br><span class="line">        <span class="keyword">if</span> (tr[p].ch[c]) p=tr[p].ch[c],t++;</span><br><span class="line">        now[p]=<span class="built_in">max</span>(now[p],t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">tree</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;++i) ans[i]=<span class="built_in">min</span>(ans[i],now[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;n--;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;str[i];++i) <span class="built_in">extend</span>(str[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;++i) ans[i]=tr[i].len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=tot;++i) <span class="built_in">add</span>(tr[i].fa,i);</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">        <span class="built_in">calc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> finalres=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;++i) finalres=<span class="built_in">max</span>(finalres,ans[i]);</span><br><span class="line">    cout&lt;&lt;finalres&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 后缀数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫比乌斯反演</title>
      <link href="/2021/12/12/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
      <url>/2021/12/12/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
      
        <content type="html"><![CDATA[<p>容斥原理的升级版。</p><span id="more"></span><h2 id="1-莫比乌斯函数的定义与主要思想"><a href="#1-莫比乌斯函数的定义与主要思想" class="headerlink" title="1. 莫比乌斯函数的定义与主要思想"></a>1. 莫比乌斯函数的定义与主要思想</h2><p>$\mu(x)$ 来表示莫比乌斯函数。</p><p>其实就是容斥原理的升级版。</p><p>定义为：（假设 $x=p1^{a1}p2^{a2}…pk^{ak}$）</p><ol><li>$\exists i, ai\geq2,\mu(x)=0$</li><li>$\forall i,ai=1,\mu(x)=(-1)^k$</li></ol><p>顺便讲一下积性函数：</p><p>如果 $\gcd(i,j)=1,f(i*j)=f(i)*f(j)$，那么 $f$ 就是积性函数。</p><p>$\mu(x)$ 就是一个积性函数。</p><p>原因很简单：</p><ol><li>如果有 $\mu(i)=0$ 或 $\mu(j)=0$，那么 $i * j$ 一定有一个质因数的次数 $\geq2$，所以 $\mu(i*j)=0$</li><li>如果没有，设 $i$ 的质因数个数（即上面的 $k$）为 $x$，$j$ 为 $y$，又因为 $\gcd(i,j)=1$，所以没有相同的质因数，所以 $i * j$ 的质因数个数为 $x+y$，且没有次数 $&gt;1$ 的。所以 $\mu(i * j)=(-1)^{x+y}$。</li></ol><p>那么，我们就可以在线性筛的时候求出 $\mu(x)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (!st[i]) mu[i]=<span class="number">-1</span>,prime[cnt++]=i;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt&amp;&amp;i*prime[j]&lt;N;++j)</span><br><span class="line">       &#123;</span><br><span class="line">           st[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span> (!(i%prime[j]))</span><br><span class="line">           &#123;</span><br><span class="line">               mu[i*prime[j]]=<span class="number">0</span>;<span class="comment">//break1</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           mu[i*prime[j]]=-mu[i];<span class="comment">//break2</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这就是一个简单的线性筛模板了。</p><p><code>break1</code>：这时，$i * prime[j]$ 的 $prime[j]$ 的次数一定大于 1，所以 $\mu(i*prime[j])$ 为 0。</p><p><code>break2</code>：这是，可以使用积性函数的性质 $\mu(i * prime[j])=\mu(i) * \mu(prime[j])$。</p><h2 id="2-函数的一些性质"><a href="#2-函数的一些性质" class="headerlink" title="2. 函数的一些性质"></a>2. 函数的一些性质</h2><h3 id="一）"><a href="#一）" class="headerlink" title="一）"></a>一）</h3><p>定义 $smu(n)=\sum_{d|n}\mu(d)$，那么可以得到：</p><ol><li>$n=1\Rightarrow smu(n)=1$</li><li>$n\not=1,smu(n)=0$</li></ol><p>简要的证明一下（前置知识：二项式定理）：</p><p>$n=1$ 的情况略过。</p><p>假设 $n&gt;1$，那么 $k\geq1$（前面的 $k$，即质因数个数）</p><p>首先，如果 $\forall i,0\leq bi\leq ai$，那么 $x=p1^{b1}p2^{b2}…pk^{bk}$ 一定是 $n$ 的因数。</p><p>如果 $\exists bi&gt;1$，那么 $\mu(x)=0$。</p><p>所以，我们只需要考虑 $0\leq bi\leq1$ 的情况。</p><p>假设有 $t$ 个 1，则 $\mu(x)=(-1)^t$。（不懂的回去看一下前面的定义）</p><p>对于每一个 $t$，其实都有 $C_k^t$ 种情况（就是 $k$ 个中选取 $t$ 个，就是组合数了）</p><p>那么，$smu(n)=C_k^0(-1)^0+C_k^1(-1)^1+…+C_k^{k-1}(-1)^{k-1}+C_k^k(-1)^k$。</p><p>又由二项式定义得到：$(a+b)^k=C_k^0a^0b^k+C_k^1a^1b^{k-1}+…+C_k^ka^kb_0$。</p><p>用 $-1$ 代替 $a$，$1$ 代替 $b$，我们发现， 右边就是 $smu(n)$，左边就是 $(-1+1)^k=0$！</p><p>得证。</p><h2 id="3-莫比乌斯反演"><a href="#3-莫比乌斯反演" class="headerlink" title="3. 莫比乌斯反演"></a>3. 莫比乌斯反演</h2><p>直接扔式子。<br>$$<br>F(n)=\sum_{d|n}f(d)\Rightarrow f(n)=\sum_{d|n}\mu(d)*F(\dfrac{n}{d})<br>$$<br>这个是比较常见的式子。</p><p>简要的证明一下：<br>$$<br>\sum_{d|n}\mu(d)F(\dfrac{n}{d})=\sum_{d|n}\mu(d)\sum_{x|\frac{n}{d}}f(x)<br>$$<br>上面的式子就是我们根据所给条件从右边开始的。</p><p>现在，我们要做一件事情：将 $d$ 和 $x$ 交换一下！</p><p>先给出结论：<br>$$<br>\sum_{d|n}\mu(d)\sum_{x|\frac{n}{d}}f(x)=\sum_{x|n}f(x)\sum_{d|\frac{n}{x}}\mu(d)<br>$$<br>为什么是对的呢？</p><p>这里，我们假设一下：首先有一个 $d$，然后我们枚举了 $\dfrac{n}{d}$ 的因数 $x$，然后我们将 $\mu(d)f(x)$ 加入了答案。</p><p>$x|\dfrac{n}{d}\Leftrightarrow xd|n$，那么，$xd|n\Leftrightarrow d|\dfrac{n}{x}$。</p><p>所以，我们枚举每一个 $x$，其实和枚举每一个 $d$ 其实是一样的，因为每个枚举到的 $(x,d)$ 在先枚举 $d$ 的时候都会枚举到！</p><p>那么，原式变为了：<br>$$<br>\sum_{x|n}f(x)\sum_{d|\frac{n}{x}}\mu(d)<br>$$<br>观察右边的 $\displaystyle \sum_{d|\frac{n}{x}}\mu(d)$，和上面我们得到的式子 $smu(n)$ 其实是一样的！</p><p>所以，只有在 $\dfrac{n}{x}=1$，即 $x=n$ 时后面才为 1，其余为 0。</p><p>那么，原式得证。</p><p><del>你以为就结束了吗？</del></p><p>还有一个式子：<br>$$<br>F(n)=\sum_{n|d}f(d)\Rightarrow f(n)=\sum_{n|d}\mu(\dfrac{d}{n})F(d)<br>$$<br>和上面的式子略微不同，但本质一样。</p><p>还是一波操作（中间步骤的推导留给读者 <del>逃</del>）：<br>$$<br>\sum_{n|d}\mu(\dfrac{n}{d})F(d)=\sum_{n|d}\mu(\dfrac{d}{n})\sum_{d|x}f(x)<br>$$<br>设 $t=\dfrac{d}{n}$，$y=\dfrac{x}{d}$，则：<br>$$<br>\sum_{t=1}\mu(t)\sum_{y=1}f(t * y * n)<br>$$<br>那么，我们在枚举 $t$ 再枚举 $y$ 的时候，统计答案为 $\mu(t) * f(t * y * n)$，我们也可以先枚举 $t * y$，在枚举 $t$，其实相当于枚举了 $t,y$。</p><p>所以，一波操作（设 $z=t * y$）：<br>$$<br>\sum_{z=1}f(z * n)\sum_{t|z}\mu(t)<br>$$<br>所以又看到后面的式子，实在是熟悉不过了。</p><p>于是 $z=1$ 时右边为 $1$。</p><p>所以就是 $f(n)$ 了。</p><h2 id="3-例题"><a href="#3-例题" class="headerlink" title="3. 例题"></a>3. 例题</h2><h4 id="T1：-HAOI-2011-Problem-b"><a href="#T1：-HAOI-2011-Problem-b" class="headerlink" title="T1：[HAOI 2011]Problem b"></a>T1：[HAOI 2011]Problem b</h4><p><a href="https://www.luogu.com.cn/problem/P2522">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2704/">题目传送门 AcWing</a></p><p>首先，看到 $x\in[a,b],y\in[c,d]$，可以想到二维前缀和（还是差分，记不清楚了 qwq</p><p>所以，假设 $F(a,b)$ 表示 $x\in[1,a],y\in[1,b]$ 满足 $\gcd(x,y)=k$ 的个数，可以得到：<br>$$<br>ans=F(b,d)-F(a-1,d)-F(b,c-1)+F(a-1,b-1)<br>$$<br>然后开始正题，求 $F(a,b)$。</p><p>又是一波操作：<br>$$<br>F(a,b)=\sum_{x=1}^{\frac{a}{k}}\sum_{y=1}^{\frac{b}{k}}[\gcd(x,y)=1]<br>$$<br>首先，$[\gcd(x,y)=1]$ 表示 $\gcd(x,y)=1$ 取值为 $1$，否则为 $0$。</p><p>那么，设 $m=\dfrac{a}{k},n=\dfrac{b}{k}$，于是就是：<br>$$<br>F(a,b)=\sum_{x=1}^m\sum_{y=1}^n[\gcd(x,y)=1]<br>$$<br>定义 $f(d)$ 为 $\sum_{x=1}^m\sum_{y=1}^n[\gcd(x,y)=d]$，$g(d)=\sum_{x=1}^m\sum_{y=1}^n[d|\gcd(x,y)]$。</p><p>所以 $F(a,b)=f(1)$，$g(x)=\lfloor\dfrac{m}{x}\rfloor\lfloor\dfrac{n}{x}\rfloor$。（直接取 $x$ 的倍数就是了</p><p>还有一个：<br>$$<br>g(x)=\sum_{x|d}f(d)<br>$$<br>意义很简单：$\gcd(a1,a2)$ 可以等于 $x,2x,…$，就是这个式子的意思。</p><p>根据套路：<br>$$<br>f(x)=\sum_{x|d}\mu(\dfrac{d}{x})g(d)<br>$$<br>所以，$f(1)=\sum_{d=1}^n\mu(d)g(d)$</p><p>直接求的话，大概也是能过的。</p><p>还有一些优化，比如整除分块，就是 $g(d)$ 相同的可以一起计算。</p><p>如果当前的值为 $a$，那么当前值为 $\dfrac{n}{a}$，那么最大的 $x$ 满足 $\dfrac{n}{x}=\dfrac{n}{a}$ 为 $x=\dfrac{n}{\frac{n}{a}}$。（证明略复杂，跳过</p><p>加入 $m$ 的话，满足 $\dfrac{n}{a}*\dfrac{m}{a}=\dfrac{n}{x}*\dfrac{n}{x}$ 的最大 $x$ 为 $\min(\dfrac{n}{\frac{n}{a}},\dfrac {m}{\frac{m}{a}})$。</p><p>时间复杂度：$O(\sqrt{n})$。</p><p>放个代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a/=k,b/=k;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">min</span>(a,b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r=<span class="built_in">min</span>(n,<span class="built_in">min</span>(a/(a/l),b/(b/l)));</span><br><span class="line">        res+=(sum[r]-sum[l<span class="number">-1</span>])*(ll)(a/l)*(b/l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2：-SDOI-2015-约数个数和"><a href="#T2：-SDOI-2015-约数个数和" class="headerlink" title="T2：[SDOI 2015]约数个数和"></a>T2：[SDOI 2015]约数个数和</h4><p><a href="https://www.luogu.com.cn/problem/P3327">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/1360/">题目传送门 AcWing</a></p><p><strong>前方高能！</strong></p><p>首先，得到结论：<br>$$<br>d(i*j)=\sum_{x|i}\sum_{y|j}[\gcd(x,y)=1]<br>$$<br>简要证明：</p><p>假设对于每一个质因数 $p$，$i$ 的次数为 $a$，$j$ 的次数为 $b$。</p><p>对于左边，显然 $p$ 的存在可以使答案乘上 $a+b+1$（可以选择 $0\sim a+b$ 次方）。</p><p>对于右边，可以有以下的方法：</p><ol><li>都选择 $0$ 次，贡献为 $1$。</li><li>如果 $i$ 选择 $0$ 次，那么 $j$ 可以选择 $1\sim b$，贡献为 $b$。</li><li>如果 $j$ 选择 $0$ 次，那么 $i$ 可以选择 $1\sim a$，贡献为 $a$。</li></ol><p>综上，$p$ 的存在使得答案乘上了 $a+b+1$。</p><p>既然对于每一个 $p$，左右相乘的数是相等的。</p><p>得证。</p><p>接下来，一波操作：<br>$$<br>ans=\sum_{i=1}^N\sum_{j=1}^M\sum_{x|i}\sum_{y|j}[\gcd(x,y)=1]<br>$$<br>根据上面的结论得到的。<br>$$<br>=\sum_{x=1}^N\sum_{y=1}^M[\gcd(x,y)=1]\lfloor\dfrac{N}{x}\rfloor\lfloor\dfrac{M}{y}\rfloor<br>$$<br>直接提出 $x,y$，枚举 $i,j$ 贡献其实就是 $\lfloor\dfrac{N}{x}\rfloor\lfloor\dfrac{M}{y}\rfloor$。</p><p>令 $f(d)=\sum_{x=1}^N\sum_{y=1}^M[\gcd(x,y)=1]\lfloor\dfrac{N}{x}\rfloor\lfloor\dfrac{M}{y}\rfloor,F(d)=\sum_{x=1} ^N\sum_{y=1}^M[d|\gcd(x,y)]\lfloor\dfrac{N}{x}\rfloor\lfloor\dfrac{M}{y}\rfloor$。</p><p>还可以根据套路推 $F$ 得到：<br>$$<br>F(d)=\sum_{k=1}^{\frac{N}{d}}\sum_{l=1}^{\frac{M}{d}}\lfloor\dfrac{N}{dk} \rfloor\lfloor\dfrac{M}{dl}\rfloor<br>$$<br>接着令 $N1=\dfrac{N}{d},M1=\dfrac{M}{d}$，则：<br>$$<br>F(d)=\sum_{k=1}^{N1}\sum_{l=1}^{M1}\lfloor\dfrac{N1}{k}\rfloor\lfloor\dfrac{M1}{l}\rfloor<br>$$<br>$g(n)=\sum_{k=1}^{N}\lfloor\dfrac{N}{k}\rfloor$ 是可以预处理的。对于每一个 $g(n)$，直接整除分块，复杂度 $O(n\sqrt{n})$。</p><p>可以得到：$F(d)=g(\dfrac{N}{d})g(\dfrac{M}{d})$</p><p>莫比乌斯的反演套路大都如此：构造出 $f,F$，引入 $\mu$ 来简化运算，$f(1)$ 一般为所求，$\mu$ 一般要预处理。</p><p>接着：<br>$$<br>ans=f(1)=\sum_{d=1}\mu(d)F(d)<br>$$<br>可以 $O(n)$ 求，但还不够优秀。</p><p>带入 $g$，即得：<br>$$<br>ans=\sum_{d=1}\mu(d)g(\dfrac{N}{d})g(\dfrac{M}{d})<br>$$<br>发现可以整除分块，单次复杂度为 $O(\sqrt{n})$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line">ll g[N];</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt, mu[N], n, m, s[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = N - <span class="number">1</span>;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) prime[cnt ++] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; prime[j] * i &lt;= n; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[i] = s[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= n; ++ d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= d; l = r + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r = d / (d / l);</span><br><span class="line">            g[d] += (r - l + <span class="number">1</span>) * (d / l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r = <span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">            ans += (s[r] - s[l - <span class="number">1</span>]) * g[n / l] * g[m / l];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面给出几道题目与得到的公式，就不展开了。</p><h4 id="T3：P3312-SDOI2014-数表"><a href="#T3：P3312-SDOI2014-数表" class="headerlink" title="T3：P3312 [SDOI2014]数表"></a>T3：P3312 [SDOI2014]数表</h4><p><a href="https://www.luogu.com.cn/problem/P3312">题目传送门 Luogu</a><br>$$<br>\sum_{T=1}^n[\dfrac{n}{T}][\dfrac{m}{T}]\sum_{d|T}[g(d)\leq a]\mu(\dfrac{T}{d})d<br>$$</p><p>$g(d)$ 表示 $d$ 的约数和。</p><h4 id="T4：P3704-SDOI2017-数字表格"><a href="#T4：P3704-SDOI2017-数字表格" class="headerlink" title="T4：P3704 [SDOI2017]数字表格"></a>T4：P3704 [SDOI2017]数字表格</h4><p><a href="https://www.luogu.com.cn/problem/P3704">题目传送门 Luogu</a><br>$$<br>\prod_{T=1}^n(\prod_{d|t}f(d)^{\mu(\frac{T}{d})})^{^{\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor}}<br>$$</p><h4 id="T5：P3768-简单的数学题"><a href="#T5：P3768-简单的数学题" class="headerlink" title="T5：P3768 简单的数学题"></a>T5：P3768 简单的数学题</h4><p><a href="https://www.luogu.com.cn/problem/P3768">题目传送门 Luogu</a><br>$$<br>\begin{aligned}\\ans &amp; =<br>\sum_{T=1}^nsum(\dfrac{n}{T})^2\times T^2\sum_{d|T}d\times\mu(\dfrac{T}{d})<br>\\ &amp; =\sum_{T=1}^n\sum(\dfrac{n}{T})^2\times T^2\varphi(T)<br>\end{aligned}<br>$$<br>后面使用杜教筛等。</p><p>化简为：<br>$$<br>\begin{aligned}<br>S(n) &amp;=\sum_{T=1}^nT^2\varphi(T) \\ &amp;=\sum_{i=1}^ni^3-\sum_{i=1}^ni^2S(\dfrac{n}{i})<br>\end{aligned}<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line">ll Mod, sphi[N], n, inv2, inv6;</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt, phi[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line">map &lt;ll, ll&gt; Sphi;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) prime[cnt ++] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; i * prime[j] &lt; N; ++ j)</span><br><span class="line">&#123;</span><br><span class="line">st[i * prime[j]] = <span class="number">1</span>, phi[i * prime[j]] = phi[i] * phi[prime[j]];</span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) sphi[i] = (sphi[i - <span class="number">1</span>] + phi[i] * (ll)i % Mod * i % Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * a % Mod;</span><br><span class="line">a = a * a % Mod;</span><br><span class="line">k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">sum1</span><span class="params">(ll n)</span></span>&#123;<span class="keyword">return</span> (n % Mod) * ((n + <span class="number">1</span>) % Mod) % Mod * inv2 % Mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">sum2</span><span class="params">(ll n)</span></span>&#123;<span class="keyword">return</span> (n % Mod) * ((n + <span class="number">1</span>) % Mod) % Mod * ((<span class="number">2</span> * n + <span class="number">1</span>) % Mod) % Mod * inv6 % Mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">sum3</span><span class="params">(ll n)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sum1</span>(n) * <span class="built_in">sum1</span>(n) % Mod;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get_sphi</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; N) <span class="keyword">return</span> sphi[n];</span><br><span class="line"><span class="keyword">if</span> (Sphi.<span class="built_in">find</span>(n) != Sphi.<span class="built_in">end</span>()) <span class="keyword">return</span> Sphi[n];</span><br><span class="line">ll ans = <span class="built_in">sum3</span>(n);</span><br><span class="line"><span class="keyword">for</span> (ll l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">ans = (-(<span class="built_in">sum2</span>(r) - <span class="built_in">sum2</span>(l - <span class="number">1</span>)) * <span class="built_in">get_sphi</span>(n / l) % Mod + ans + Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Sphi[n] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; Mod &gt;&gt; n;</span><br><span class="line">inv2 = <span class="built_in">qpow</span>(<span class="number">2</span>, Mod - <span class="number">2</span>), inv6 = <span class="built_in">qpow</span>(<span class="number">6</span>, Mod - <span class="number">2</span>);</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (ll l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = n / (n / l);</span><br><span class="line">res = (res + <span class="built_in">sum1</span>(n / l) * <span class="built_in">sum1</span>(n / l) % Mod</span><br><span class="line">        * ((<span class="built_in">get_sphi</span>(r) - <span class="built_in">get_sphi</span>(l - <span class="number">1</span>) + Mod) % Mod) % Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Splay</title>
      <link href="/2021/12/12/Splay/"/>
      <url>/2021/12/12/Splay/</url>
      
        <content type="html"><![CDATA[<p>比较重要的基础数据结构。</p><span id="more"></span><h2 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h2><p>前置知识：平衡二叉树，Treap / 左旋右旋操作。</p><h3 id="1基本原理"><a href="#1基本原理" class="headerlink" title="1基本原理"></a>1基本原理</h3><p>每操作一次，均将该节点旋至树根。</p><h3 id="2-核心操作"><a href="#2-核心操作" class="headerlink" title="2.核心操作"></a>2.核心操作</h3><p>即 Splay 操作.。</p><p>定义 $splay(x,k)$ 为将点 x 旋转至 k 的下面。</p><p>特别的，$splay(x,0)$ 定义为将 x 旋转至根。</p><p>有四种情况，两种分类。</p><p>注意，转 x 的意思就是将 x 转到父节点。</p><p>假设 z 是 y 的父亲，y 是 x 的父亲。</p><p>第一种：成一条链的形状。</p><p>先转 y，再转 x。</p><p>第二种：成折线的形状。</p><p>转两次 x。</p><p>一般来说，k 的取值一般只有是 0 或根。</p><h3 id="3-支持操作"><a href="#3-支持操作" class="headerlink" title="3.支持操作"></a>3.支持操作</h3><h4 id="1）插入"><a href="#1）插入" class="headerlink" title="1）插入"></a>1）插入</h4><p>第一种，就是将 x 直接插入。</p><p>第二种，将一个序列插到 y 的后面。</p><p>主要讲第二种。</p><p>首先，将 y 的后继 z。</p><p>然后，执行 $splay(y,0)$。</p><p>接着，执行 $splay(z,y)$。</p><p>现在，由于 z 是 y 的后继，所以 z 一定没有左子树（否则就不是后继）。</p><p>直接先将插入序列构造成二叉树，接在 z 左子树即可。</p><h4 id="2）删除"><a href="#2）删除" class="headerlink" title="2）删除"></a>2）删除</h4><p>直接讲删除 $[L,R]$。</p><p>先将执行 $splay(L-1,0)$，然后 $splay(R+1,L-1)$。</p><p>此时，$[L,R]$，一定全部在 R+1 的左子树，直接断开来连接即可。</p><h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4.例题"></a>4.例题</h3><h4 id="T1：Splay-文艺平衡树"><a href="#T1：Splay-文艺平衡树" class="headerlink" title="T1：Splay/文艺平衡树"></a>T1：Splay/文艺平衡树</h4><p><a href="https://www.acwing.com/problem/content/2439/">题目传送门 AcWing</a></p><p><a href="https://www.luogu.com.cn/problem/P3391">题目传送门 Luogu</a></p><p>要维护以下信息：</p><ol><li>$size$</li><li>$flag/lazytag$：表示是否会翻转。</li></ol><p>需要维护。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,rt,idx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> s[<span class="number">2</span>],size,p,v;</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _v,<span class="keyword">int</span> _p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">v=_v;p=_p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[p].size=t[t[p].s[<span class="number">0</span>]].size+t[t[p].s[<span class="number">1</span>]].size+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!t[p].flag) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">swap</span>(t[p].s[<span class="number">0</span>],t[p].s[<span class="number">1</span>]);</span><br><span class="line">t[t[p].s[<span class="number">0</span>]].flag^=<span class="number">1</span>;</span><br><span class="line">t[t[p].s[<span class="number">1</span>]].flag^=<span class="number">1</span>;</span><br><span class="line">t[p].flag=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">int</span> y=t[x].p,z=t[y].p,k=(t[y].s[<span class="number">1</span>]==x);</span><br><span class="line">t[z].s[y==t[z].s[<span class="number">1</span>]]=x,t[x].p=z;</span><br><span class="line">t[y].s[k]=t[x].s[k^<span class="number">1</span>],t[t[x].s[k^<span class="number">1</span>]].p=y;</span><br><span class="line">t[x].s[k^<span class="number">1</span>]=y,t[y].p=x;</span><br><span class="line"><span class="built_in">pushup</span>(y);<span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">while</span> (t[x].p!=k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">int</span> y=t[x].p,z=t[y].p;</span><br><span class="line"><span class="keyword">if</span> (z!=k)</span><br><span class="line"><span class="keyword">if</span> ((x==t[y].s[<span class="number">1</span>])^(y==t[z].s[<span class="number">1</span>])) <span class="built_in">rotate</span>(x);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">rotate</span>(y);</span><br><span class="line"><span class="built_in">rotate</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k==<span class="number">0</span>) rt=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;v&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">int</span> u=rt,p=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (u) p=u,u=t[u].s[t[u].v&lt;v];</span><br><span class="line"><span class="keyword">int</span> now=++idx;</span><br><span class="line"><span class="keyword">if</span> (p) t[p].s[v&gt;t[p].v]=now;</span><br><span class="line">t[now].<span class="built_in">init</span>(v,p);</span><br><span class="line"><span class="built_in">splay</span>(now,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_k</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u=rt;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pushdown</span>(u);</span><br><span class="line"><span class="keyword">if</span> (t[t[u].s[<span class="number">0</span>]].size&gt;=k) u=t[u].s[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (t[t[u].s[<span class="number">0</span>]].size==k<span class="number">-1</span>) <span class="keyword">return</span> u;</span><br><span class="line"><span class="keyword">else</span> k-=t[t[u].s[<span class="number">0</span>]].size+<span class="number">1</span>,u=t[u].s[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">pushdown</span>(u);</span><br><span class="line"><span class="keyword">if</span> (t[u].s[<span class="number">0</span>]) <span class="built_in">output</span>(t[u].s[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>&lt;=t[u].v&amp;&amp;t[u].v&lt;=n) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t[u].v);</span><br><span class="line"><span class="keyword">if</span> (t[u].s[<span class="number">1</span>]) <span class="built_in">output</span>(t[u].s[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;++i) <span class="built_in">insert</span>(i);</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">l=<span class="built_in">get_k</span>(l),r=<span class="built_in">get_k</span>(r+<span class="number">2</span>);</span><br><span class="line"><span class="built_in">splay</span>(l,<span class="number">0</span>);<span class="built_in">splay</span>(r,l);</span><br><span class="line">t[t[r].s[<span class="number">0</span>]].flag^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">output</span>(rt);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2：-NOI2004-郁闷的出纳员"><a href="#T2：-NOI2004-郁闷的出纳员" class="headerlink" title="T2：[NOI2004] 郁闷的出纳员"></a>T2：[NOI2004] 郁闷的出纳员</h4><p><a href="https://www.luogu.com.cn/problem/P1486">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/952/">题目传送门 AcWing</a></p><p>还是接近于模板，但是要处理一下整个修改。</p><p>我们可以记录一个 $delta$，记录整个的偏移量。</p><p>差不多就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">2</span>],p;</span><br><span class="line">    <span class="keyword">int</span> val,size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _val,<span class="keyword">int</span> _p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        val=_val;p=_p;</span><br><span class="line">        size=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,rt,m,tot,delta;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].size=tr[tr[p].s[<span class="number">0</span>]].size+tr[tr[p].s[<span class="number">1</span>]].size+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=tr[x].p,z=tr[y].p;</span><br><span class="line">    <span class="keyword">int</span> k=tr[y].s[<span class="number">1</span>]==x;</span><br><span class="line">    tr[x].p=z,tr[z].s[y==tr[z].s[<span class="number">1</span>]]=x;</span><br><span class="line">    tr[tr[x].s[k^<span class="number">1</span>]].p=y,tr[y].s[k]=tr[x].s[k^<span class="number">1</span>];</span><br><span class="line">    tr[y].p=x,tr[x].s[k^<span class="number">1</span>]=y;</span><br><span class="line">    <span class="built_in">pushup</span>(y);<span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (tr[x].p!=k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=tr[x].p,z=tr[y].p;</span><br><span class="line">        <span class="keyword">if</span> (z!=k)</span><br><span class="line">            <span class="keyword">if</span> ((y==tr[z].s[<span class="number">1</span>])^(tr[y].s[<span class="number">1</span>]==x)) <span class="built_in">rotate</span>(x);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">rotate</span>(y);</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!k) rt=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=rt,res;</span><br><span class="line">    <span class="keyword">while</span> (u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[u].val&gt;=val) res=u,u=tr[u].s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> u=tr[u].s[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_k</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=rt,tmp=k;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[tr[u].s[<span class="number">0</span>]].size&gt;=k) u=tr[u].s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tr[tr[u].s[<span class="number">0</span>]].size+<span class="number">1</span>==k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> tr[u].val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> k-=tr[tr[u].s[<span class="number">0</span>]].size+<span class="number">1</span>,u=tr[u].s[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=rt,p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (u) p=u,u=tr[u].s[val&gt;tr[u].val];</span><br><span class="line">    u=++tot;</span><br><span class="line">    <span class="keyword">if</span> (p) tr[p].s[val&gt;tr[p].val]=u;</span><br><span class="line">    tr[u].<span class="built_in">init</span>(val,p);</span><br><span class="line">    <span class="built_in">splay</span>(u,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> L=<span class="built_in">insert</span>(-INF),R=<span class="built_in">insert</span>(INF),cnt=<span class="number">0</span>,x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>,op,&amp;x);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x&gt;=m) x-=delta,<span class="built_in">insert</span>(x),cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>) delta+=x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            delta-=x;</span><br><span class="line">            R=<span class="built_in">get</span>(m-delta);</span><br><span class="line">            <span class="built_in">splay</span>(R,<span class="number">0</span>);<span class="built_in">splay</span>(L,R);</span><br><span class="line">            tr[L].s[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">pushup</span>(L);<span class="built_in">pushup</span>(R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tr[rt].size<span class="number">-2</span>&lt;x) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">get_k</span>(tr[rt].size-x)+delta);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt-(tr[rt].size<span class="number">-2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3：-HNOI2012-永无乡"><a href="#T3：-HNOI2012-永无乡" class="headerlink" title="T3：[HNOI2012] 永无乡"></a>T3：[HNOI2012] 永无乡</h4><p><a href="https://www.luogu.com.cn/problem/P3224">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/1065/">题目传送门 AcWing</a></p><p>主要是如何维护哪些点在同一个集合。</p><p>首先要使用并查集，同时使用启发式合并。</p><p>顾名思义，启发式合并就是将小的合并到大的上面。</p><p>没什么说的了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">2</span>], p;</span><br><span class="line">    <span class="keyword">int</span> key, id;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _key, <span class="keyword">int</span> _id, <span class="keyword">int</span> _p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        key=_key;</span><br><span class="line">        id=_id;</span><br><span class="line">        p=_p;</span><br><span class="line">        size=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr[N];</span><br><span class="line"><span class="keyword">int</span> n, tot, rt[N], fa[N], m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].size = tr[tr[p].s[<span class="number">0</span>]].size + tr[tr[p].s[<span class="number">1</span>]].size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = tr[x].p, z = tr[y].p;</span><br><span class="line">    <span class="keyword">int</span> k = tr[y].s[<span class="number">1</span>] == x;</span><br><span class="line">    tr[x].p=z,tr[z].s[y==tr[z].s[<span class="number">1</span>]]=x;</span><br><span class="line">    tr[tr[x].s[k^<span class="number">1</span>]].p=y,tr[y].s[k]=tr[x].s[k^<span class="number">1</span>];</span><br><span class="line">    tr[y].p = x, tr[x].s[k^<span class="number">1</span>] = y;</span><br><span class="line">    <span class="built_in">pushup</span>(y);<span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (tr[x].p != k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = tr[x].p, z = tr[y].p;</span><br><span class="line">        <span class="keyword">if</span> (z != k)</span><br><span class="line">            <span class="keyword">if</span> ((tr[z].s[<span class="number">1</span>] == y) ^ (tr[y].s[<span class="number">1</span>] == x)) <span class="built_in">rotate</span>(x);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">rotate</span>(y);</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!k) rt[b] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_k</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = rt[b];</span><br><span class="line">    <span class="keyword">while</span> (u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[tr[u].s[<span class="number">0</span>]].size &gt;= k)</span><br><span class="line">            u = tr[u].s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tr[tr[u].s[<span class="number">0</span>]].size == k - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> tr[u].id;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            k -= tr[tr[u].s[<span class="number">0</span>]].size + <span class="number">1</span>, u = tr[u].s[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> id, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = rt[b], p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (u)</span><br><span class="line">        p = u, u = tr[u].s[key &gt; tr[u].key];</span><br><span class="line">    u = ++tot;</span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        tr[p].s[key &gt; tr[p].key] = u;</span><br><span class="line">    tr[u].<span class="built_in">init</span>(key, id, p);</span><br><span class="line">    <span class="built_in">splay</span>(u, <span class="number">0</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].s[<span class="number">0</span>]) <span class="built_in">dfs</span>(tr[u].s[<span class="number">0</span>], b);</span><br><span class="line">    <span class="keyword">if</span> (tr[u].s[<span class="number">1</span>]) <span class="built_in">dfs</span>(tr[u].s[<span class="number">1</span>], b);</span><br><span class="line">    <span class="built_in">insert</span>(tr[u].key, tr[u].id, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] != x)</span><br><span class="line">        fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        rt[i]=i;</span><br><span class="line">        fa[i]=i;</span><br><span class="line">        tr[i].<span class="built_in">init</span>(x,i,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tot=n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x==y) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (tr[rt[x]].size &gt; tr[rt[y]].size)</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="built_in">dfs</span>(rt[x], y);</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %d %d&quot;</span>, op, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x = <span class="built_in">find</span>(x);</span><br><span class="line">            <span class="keyword">if</span> (tr[rt[x]].size &lt; y)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get_k</span>(y, x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            x = <span class="built_in">find</span>(x);</span><br><span class="line">            y = <span class="built_in">find</span>(y);</span><br><span class="line">            <span class="keyword">if</span> (x == y)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (tr[rt[x]].size &gt; tr[rt[y]].size)</span><br><span class="line">                <span class="built_in">swap</span>(x, y);</span><br><span class="line">            <span class="built_in">dfs</span>(rt[x], y);</span><br><span class="line">            fa[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T4：-NOI2005-维护数列"><a href="#T4：-NOI2005-维护数列" class="headerlink" title="T4：[NOI2005] 维护数列"></a>T4：[NOI2005] 维护数列</h4><p><a href="https://www.luogu.com.cn/problem/P2042">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/957/">题目传送门 AcWing</a></p><p>很麻烦，我们可以一个一个的看。</p><p>（先咕着）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> val,fa,size;</span><br><span class="line">    <span class="keyword">bool</span> flag,sm;</span><br><span class="line">    <span class="keyword">int</span> ls,rs,tots,sum;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _val,<span class="keyword">int</span> _fa)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sum=val=_val;fa=_fa;s[<span class="number">0</span>]=s[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        flag=sm=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (val&gt;=<span class="number">0</span>) ls=rs=tots=val;</span><br><span class="line">        <span class="keyword">else</span> ls=rs=<span class="number">0</span>,tots=val;</span><br><span class="line">        size=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N],st,rt;</span><br><span class="line"><span class="keyword">int</span> tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node &amp;u=tr[x],&amp;l=tr[tr[x].s[<span class="number">0</span>]],&amp;r=tr[tr[x].s[<span class="number">1</span>]];</span><br><span class="line">    u.size=l.size+r.size+<span class="number">1</span>;</span><br><span class="line">    u.sum=l.sum+r.sum+u.val;</span><br><span class="line">    u.ls=<span class="built_in">max</span>(l.ls,l.sum+u.val+r.ls);</span><br><span class="line">    u.rs=<span class="built_in">max</span>(r.rs,r.sum+u.val+l.rs);</span><br><span class="line">    u.tots=<span class="built_in">max</span>(<span class="built_in">max</span>(l.tots,r.tots),l.rs+u.val+r.ls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node &amp;u=tr[x],&amp;l=tr[tr[x].s[<span class="number">0</span>]],&amp;r=tr[tr[x].s[<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">if</span> (u.sm)</span><br><span class="line">    &#123;</span><br><span class="line">        u.flag=<span class="number">0</span>;u.sm=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (u.s[<span class="number">0</span>]) l.sm=<span class="number">1</span>,l.val=u.val,l.sum=u.val*l.size;</span><br><span class="line">        <span class="keyword">if</span> (u.s[<span class="number">1</span>]) r.sm=<span class="number">1</span>,r.val=u.val,r.sum=u.val*r.size;</span><br><span class="line">        <span class="keyword">if</span> (u.s[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> (l.val&gt;=<span class="number">0</span>) l.ls=l.rs=l.tots=l.sum;</span><br><span class="line">            <span class="keyword">else</span> l.ls=l.rs=<span class="number">0</span>,l.tots=l.val;</span><br><span class="line">        <span class="keyword">if</span> (u.s[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> (r.val&gt;=<span class="number">0</span>) r.ls=r.rs=r.tots=r.sum;</span><br><span class="line">            <span class="keyword">else</span> r.ls=r.rs=<span class="number">0</span>,r.tots=r.val;</span><br><span class="line"><span class="comment">//         if (l==N-1||r==N-1) puts(&quot;Failed&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u.flag)</span><br><span class="line">    &#123;</span><br><span class="line">        u.flag=<span class="number">0</span>;</span><br><span class="line">        l.flag^=<span class="number">1</span>;r.flag^=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(l.ls,l.rs);<span class="built_in">swap</span>(l.s[<span class="number">0</span>],l.s[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">swap</span>(r.ls,r.rs);<span class="built_in">swap</span>(r.s[<span class="number">0</span>],r.s[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//if (l==N-1||r==N-1) puts(&quot;Failed&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushup(x);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    pushdown(x);</span></span><br><span class="line">    <span class="keyword">int</span> y=tr[x].fa,z=tr[y].fa;</span><br><span class="line">    <span class="keyword">int</span> k=x==tr[y].s[<span class="number">1</span>];</span><br><span class="line">    tr[z].s[y==tr[z].s[<span class="number">1</span>]]=x,tr[x].fa=z;</span><br><span class="line">    tr[tr[x].s[k^<span class="number">1</span>]].fa=y,tr[y].s[k]=tr[x].s[k^<span class="number">1</span>];</span><br><span class="line">    tr[y].fa=x,tr[x].s[k^<span class="number">1</span>]=y;</span><br><span class="line">    <span class="built_in">pushup</span>(y);<span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (tr[x].fa!=k)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        pushdown(x);</span></span><br><span class="line">        <span class="keyword">int</span> y=tr[x].fa,z=tr[y].fa;</span><br><span class="line"><span class="comment">//        pushdown(z);pushdown(y);</span></span><br><span class="line">        <span class="keyword">if</span> (z!=k)</span><br><span class="line">            <span class="keyword">if</span> ((x==tr[y].s[<span class="number">1</span>])^(y==tr[z].s[<span class="number">1</span>])) <span class="built_in">rotate</span>(x);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">rotate</span>(y);</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!k) rt=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;find:%d(%d,%d,%d) %d\n&quot;,x,tr[x].val,tr[x].size,tr[tr[x].s[0]].size,pos);</span></span><br><span class="line">    <span class="keyword">int</span> u=rt;</span><br><span class="line">    <span class="keyword">while</span> (u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="keyword">if</span> (tr[tr[u].s[<span class="number">0</span>]].size&gt;=k) u=tr[u].s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tr[tr[u].s[<span class="number">0</span>]].size+<span class="number">1</span>==k) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">else</span> k-=tr[tr[u].s[<span class="number">0</span>]].size+<span class="number">1</span>, u=tr[u].s[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q[st++]=x;</span><br><span class="line">    <span class="keyword">if</span> (tr[x].s[<span class="number">0</span>]) <span class="built_in">dfs</span>(tr[x].s[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (tr[x].s[<span class="number">1</span>]) <span class="built_in">dfs</span>(tr[x].s[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_tree</span><span class="params">(<span class="keyword">int</span> fa,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;make_tree %d %d %d\n&quot;,fa,l,r);</span></span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,u=q[--st];</span><br><span class="line">    tr[u].<span class="built_in">init</span>(tmp[mid],fa);</span><br><span class="line">    <span class="keyword">if</span> (l==r)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span> (tmp[mid]&gt;=<span class="number">0</span>) tr[u].tots=tr[u].ls=tr[u].rs=tmp[mid];</span><br><span class="line">    <span class="keyword">else</span> tr[u].tots=tmp[mid],tr[u].ls=tr[u].rs=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;mid) tr[u].s[<span class="number">0</span>]=<span class="built_in">make_tree</span>(u,l,mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (r&gt;mid) tr[u].s[<span class="number">1</span>]=<span class="built_in">make_tree</span>(u,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> tot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="built_in">find</span>(pos+<span class="number">1</span>),r=<span class="built_in">find</span>(pos+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">splay</span>(l,<span class="number">0</span>);<span class="built_in">splay</span>(r,l);</span><br><span class="line"><span class="comment">//    pushdown(r);pushdown(l);</span></span><br><span class="line">    tr[r].s[<span class="number">0</span>]=<span class="built_in">make_tree</span>(r,<span class="number">0</span>,tot<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">pushup</span>(r);<span class="built_in">pushup</span>(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> tot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="built_in">find</span>(pos),r=<span class="built_in">find</span>(pos+tot+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">splay</span>(l,<span class="number">0</span>);<span class="built_in">splay</span>(r,l);</span><br><span class="line"><span class="comment">//    pushdown(r);</span></span><br><span class="line"><span class="comment">//    printf(&quot;%d:%d %d:%d\n&quot;,l,tr[l].val,r,tr[r].val);</span></span><br><span class="line">    <span class="built_in">dfs</span>(tr[r].s[<span class="number">0</span>]);</span><br><span class="line">    tr[r].s[<span class="number">0</span>]=<span class="number">0</span>;<span class="built_in">pushup</span>(r);<span class="built_in">pushup</span>(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_same</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> tot,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="built_in">find</span>(pos),r=<span class="built_in">find</span>(pos+tot+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;%d:%d %d:%d\n&quot;,l,tr[l].val,r,tr[r].val);</span></span><br><span class="line">    <span class="built_in">splay</span>(l,<span class="number">0</span>);<span class="built_in">splay</span>(r,l);</span><br><span class="line">    Node &amp;now=tr[tr[r].s[<span class="number">0</span>]];</span><br><span class="line">    now.val=x;now.sm=<span class="number">1</span>;</span><br><span class="line">now.sum=x*now.size;</span><br><span class="line">    now.flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if (now==N-1) printf(&quot;Failed:::::%d %d %d %d\n&quot;,tr[now].ls,tr[now].rs,tr[now].sum,tr[now].tots);</span></span><br><span class="line">        now.ls=now.rs=now.tots=now.sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> now.ls=now.rs=<span class="number">0</span>,now.tots=x;</span><br><span class="line">    <span class="built_in">pushup</span>(r);<span class="built_in">pushup</span>(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> tot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="built_in">find</span>(pos),r=<span class="built_in">find</span>(pos+tot+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;%d:%d %d:%d\n&quot;,l,tr[l].val,r,tr[r].val);</span></span><br><span class="line">    <span class="built_in">splay</span>(l,<span class="number">0</span>);<span class="built_in">splay</span>(r,l);</span><br><span class="line">    Node &amp;now=tr[tr[r].s[<span class="number">0</span>]];</span><br><span class="line">now.flag^=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">swap</span>(now.s[<span class="number">0</span>],now.s[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">swap</span>(now.ls,now.rs);</span><br><span class="line">    <span class="built_in">pushup</span>(r);<span class="built_in">pushup</span>(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> tot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="built_in">find</span>(pos),r=<span class="built_in">find</span>(pos+tot+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;%d:%d %d:%d\n&quot;,l,tr[l].val,r,tr[r].val);</span></span><br><span class="line">    <span class="built_in">splay</span>(l,<span class="number">0</span>);<span class="built_in">splay</span>(r,l);</span><br><span class="line">    <span class="keyword">return</span> tr[tr[r].s[<span class="number">0</span>]].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line"><span class="keyword">if</span> (tr[x].s[<span class="number">0</span>]) <span class="built_in">output</span>(tr[x].s[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n&quot;</span>,x,tr[x].val,tr[x].sum,tr[x].ls,tr[x].rs,tr[x].tots,tr[x].s[<span class="number">0</span>],tr[x].s[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (tr[x].s[<span class="number">1</span>]) <span class="built_in">output</span>(tr[x].s[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// freopen(&quot;P2042_2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">// freopen(&quot;myans.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i) q[st++]=i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    tr[<span class="number">0</span>].tots=-INF;</span><br><span class="line">    tmp[<span class="number">0</span>]=tmp[n+<span class="number">1</span>]=-INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tmp[i]);</span><br><span class="line">    rt=<span class="built_in">make_tree</span>(<span class="number">0</span>,<span class="number">0</span>,n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> pos,tot,x;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op,<span class="string">&quot;INSERT&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;pos,&amp;tot);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tmp[i]);</span><br><span class="line">            <span class="built_in">Insert</span>(pos,tot);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op,<span class="string">&quot;DELETE&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;pos,&amp;tot);</span><br><span class="line">            <span class="built_in">remove</span>(pos,tot);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op,<span class="string">&quot;MAKE-SAME&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;pos,&amp;tot,&amp;x);</span><br><span class="line">            <span class="built_in">make_same</span>(pos,tot,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op,<span class="string">&quot;REVERSE&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;pos,&amp;tot);</span><br><span class="line">            <span class="built_in">reverse</span>(pos,tot);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op,<span class="string">&quot;GET-SUM&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;pos,&amp;tot);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">get_sum</span>(pos,tot));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op,<span class="string">&quot;MAX-SUM&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">// output(rt);</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tr[rt].tots);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 平衡树 </tag>
            
            <tag> Splay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态树</title>
      <link href="/2021/12/12/%E5%8A%A8%E6%80%81%E6%A0%91/"/>
      <url>/2021/12/12/%E5%8A%A8%E6%80%81%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>比较难写，也比较难理解。</p><span id="more"></span><h2 id="动态树"><a href="#动态树" class="headerlink" title="动态树"></a>动态树</h2><h3 id="0-前置知识"><a href="#0-前置知识" class="headerlink" title="0. 前置知识"></a>0. 前置知识</h3><p>Splay</p><p><a href="https://mydcwfy.github.io/2021/12/12/Splay/">我的 Splay 文章</a></p><h3 id="1-主要思想与用途"><a href="#1-主要思想与用途" class="headerlink" title="1. 主要思想与用途"></a>1. 主要思想与用途</h3><p>用于处理树上的联通及统计问题。</p><p>时间复杂度为 $O(m\log n)$。</p><h3 id="2-主要思想"><a href="#2-主要思想" class="headerlink" title="2. 主要思想"></a>2. 主要思想</h3><p><strong>首先声明：祖先和儿子是人为定义的，其实是一棵无根树！</strong></p><p>和树链剖分其实相似，我们也将树的边分为两种，为实边和虚边。</p><p>定义为每个点最多只有一条实边相连它的儿子，其他的我们称为虚边。</p><p>和重链类似，我们定义实边链为实边所连成的链。</p><p>但是，又和树链剖分不同，每一条链用 Splay 维护。所以树被拆成了若干个 Splay。单个点也可以有一个 Splay。</p><p>Splay 维护的就是从祖先到儿子的实边链，形状任意，用中序遍历维护。即我们如果中序遍历这一个 Splay，那么一定得到的是祖先到儿子的访问顺序。</p><p>但一般不称其为树套树（<del>主要是太重要</del>）。</p><p>回忆 Splay 的操作，我们发现：后继就是该点儿子，前驱就是该点父亲。</p><p>虚边不一定维护到真正的点，而是连到整个 Splay 的根节点来维护。具体的表现方式是指我们在儿子所在的 Splay 的根节点的父亲定义为这一个点。但是注意这个点的左右儿子都不是儿子所在 Splay 的根节点。</p><p><strong>一定分清 Splay 的根节点和 Splay 深度最小的点！</strong></p><p>将 Splay 的根节点连接至原树节点所代表的点。</p><p>下面有一个问题：</p><p>怎样区分实边和虚边？</p><p>仔细分析之后，我们发现，虚边只有儿子指向父亲，实边则还有父亲指向儿子。</p><p>所以，我们只要改变父亲所记录的儿子，就可以改变实边与虚边，而无需两边都进行维护。据此我们可以得出一个节点是不是所在 Splay 的根节点：直接判断它父亲有没有一个儿子是他自己。</p><p>画一个图。</p><img src="/2021/12/12/%E5%8A%A8%E6%80%81%E6%A0%91/%E5%8A%A8%E6%80%81%E6%A0%911.png" class=""><p>它建出一堆 Splay 后（有些点没管）：</p><img src="/2021/12/12/%E5%8A%A8%E6%80%81%E6%A0%91/%E5%8A%A8%E6%80%81%E6%A0%912.png" class=""><h3 id="3-主要操作"><a href="#3-主要操作" class="headerlink" title="3. 主要操作"></a>3. 主要操作</h3><h4 id="1）access"><a href="#1）access" class="headerlink" title="1）access"></a>1）access</h4><p>$\operatorname{access}(x)$ 是指将 x 到根节点的路径全部变为实边，把不合法的删去（因为可能有两个儿子的）。注意 $x$ 下面就没有实边了。</p><p>当遇到一个虚边时，假设我们当前的最高的点是 $y$，它的父亲是 $k$，我们将 $k$ 转到 Splay 的根，然后将 $k$ 的右儿子直接赋值为 $y$（可能原来也有值），但是我们要强制断掉，然后使得 $k-y$ 连上。</p><h4 id="2）make-root"><a href="#2）make-root" class="headerlink" title="2）make_root"></a>2）make_root</h4><p>$\operatorname{make_root}(x)$ 是指将 x 变为整颗原树的根节点。</p><p>先调用 $\operatorname{access}(x)$，再直接转上去，调用 reverse。</p><p>将整个树看做是无根树，那么将 x 转到根节点，并打上 reverse 的 flag。</p><p>请注意，现在的拓扑序其实并没有变化，而且只是当前的顺序是变了一下，但是打了一个标记，其实后来走到的时候也要转回去。</p><h4 id="3）find-root"><a href="#3）find-root" class="headerlink" title="3）find_root"></a>3）find_root</h4><p>$\operatorname{find_root}(x)$ 是指找到 x 所在树的深度最小的节点。</p><p>我们直接先 $\text{access}(x)$，然后一直向左儿子走。</p><h4 id="4）split"><a href="#4）split" class="headerlink" title="4）split"></a>4）split</h4><p>$\operatorname{split}(x,y)$ 是指将 x 到 y 的路径建为实边。</p><p>先 $\operatorname{make_root}(x)$，再 $\operatorname{access}(y)$。</p><h4 id="5）link"><a href="#5）link" class="headerlink" title="5）link"></a>5）link</h4><p>这里是指如果 x 和 y 不连通的话，就连起来。</p><p>将 x 转到根节点，判断 y 的根节点是不是 x 即可，如果不是，就直接连上即可。</p><h4 id="6）cut"><a href="#6）cut" class="headerlink" title="6）cut"></a>6）cut</h4><p>先将 x 转到整个树的根节点，再将 y 转至 x 的下面，最后判断 y 是不是 x 的后继。</p><p>注意我们前面说到 $y$ 下面没有实边。如果 x 为根，并且 $x-y$ 是 x 所在的 Splay 唯一的实边。如果是，直接删除。注意要双向删除，既不能作为一个简单的将实边变为虚边，而是儿子到父亲和父亲到儿子都要删。</p><h4 id="7）isroot"><a href="#7）isroot" class="headerlink" title="7）isroot"></a>7）isroot</h4><p>判断 x 是否是所在 Splay 的根节点。前面已经讲到了。</p><hr><p>以上就是 Link-Cut-Tree 的基本函数，也是核心函数。</p><p><strong>非常绕，请务必理解并画图！</strong></p><h3 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h3><p>其实还算简单，但是细节不少，也有些难理解。</p><p><a href="https://www.luogu.com.cn/problem/P3690">模板 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/2541/">模板 AcWing</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">2</span>], fa;</span><br><span class="line">    <span class="keyword">int</span> val, rev;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="keyword">int</span> n, m, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].val = tr[tr[x].s[<span class="number">0</span>]].val ^ tr[tr[x].s[<span class="number">1</span>]].val ^ a[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].rev ^= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">swap</span>(tr[x].s[<span class="number">0</span>], tr[x].s[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tr[x].rev) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(tr[x].s[<span class="number">0</span>]), <span class="built_in">reverse</span>(tr[x].s[<span class="number">1</span>]);<span class="comment">//注意 reverse 的方式</span></span><br><span class="line">    tr[x].rev = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x != tr[tr[x].fa].s[<span class="number">0</span>] &amp;&amp; x != tr[tr[x].fa].s[<span class="number">1</span>];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = tr[x].fa, z = tr[y].fa;</span><br><span class="line">    <span class="keyword">int</span> k = tr[y].s[<span class="number">1</span>] == x;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isroot</span>(y)) tr[z].s[y == tr[z].s[<span class="number">1</span>]] = x;</span><br><span class="line">    tr[x].fa = z;</span><br><span class="line">    tr[y].s[k] = tr[x].s[k ^ <span class="number">1</span>], tr[tr[x].s[k ^ <span class="number">1</span>]].fa = y;</span><br><span class="line">    tr[y].fa = x, tr[x].s[k ^ <span class="number">1</span>] = y;</span><br><span class="line">    <span class="built_in">pushup</span>(y), <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isroot</span>(x)) <span class="built_in">update</span>(tr[x].fa);</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">update</span>(x);<span class="comment">//先翻转回来</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isroot</span>(x))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = tr[x].fa, z = tr[y].fa;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isroot</span>(y))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((x == tr[y].s[<span class="number">1</span>]) ^ (y == tr[z].s[<span class="number">1</span>])) <span class="built_in">rotate</span>(x);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">rotate</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; x; y = x, x = tr[y].fa)<span class="comment">//最开始的 y 是 0，表示 x 开始没有向儿子的实边了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">splay</span>(x);</span><br><span class="line">        tr[x].s[<span class="number">1</span>] = y, <span class="built_in">pushup</span>(x);<span class="comment">//更改了信息就要 pushup</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(x), <span class="built_in">reverse</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(x);</span><br><span class="line">    <span class="keyword">while</span> (tr[x].s[<span class="number">0</span>]) <span class="built_in">pushdown</span>(x), x = tr[x].s[<span class="number">0</span>];<span class="comment">//注意要 pushup</span></span><br><span class="line">    <span class="built_in">splay</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">makeroot</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">findroot</span>(y) != x) tr[x].fa = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">makeroot</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">findroot</span>(y) == x &amp;&amp; tr[y].fa == x &amp;&amp; !tr[y].s[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].s[<span class="number">1</span>] = tr[y].fa = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) tr[i].val = a[i];</span><br><span class="line">    <span class="keyword">int</span> op, x, y;</span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">makeroot</span>(x), <span class="built_in">access</span>(y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tr[y].val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">link</span>(x, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) <span class="built_in">cut</span>(x, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">access</span>(x);</span><br><span class="line">            a[x] = y, <span class="built_in">pushup</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-例题"><a href="#5-例题" class="headerlink" title="5. 例题"></a>5. 例题</h3><h4 id="T1：魔法森林"><a href="#T1：魔法森林" class="headerlink" title="T1：魔法森林"></a>T1：魔法森林</h4><p><a href="https://www.luogu.com.cn/problem/P2387">题目传送门 Luogu</a></p><p><a href="https://www.acwing.com/problem/content/1001/">题目传送门 AcWing</a></p><p>看似是一个最短路，但是我们的最短路是处理单元的，并且两个没有联系，我们必须转换。</p><p>枚举 $a[i]$ 的取值，是 $\max(a[i])$ 答案为 $a[x]$，我们可以现在取不超过 $a[x]$ 的边，再求 $\max(b[i])$ 的值。</p><p>首先，我们考虑怎样维护整张图。</p><p>可以从小到大枚举 $a[i]$，使只加入边。</p><p>加入边，就是 <strong>Link-Cut-Tree</strong> 的模板。</p><p>但是，有一个问题：动态树只能维护树，而不能维护图，怎么办？</p><p>当加入一条边时，形成环时，我们去掉整个环的最大值，一定不会影响答案。</p><p>原因是如果取删掉的边，一定在删除这条边后可以找到比该解更优或者相同的解。</p><p>最后一个问题：怎样维护边上的权值？</p><p>我们可以使用 <strong>边化点</strong> 的技巧。</p><p>即在边中建一个点，使其的权值等于边的取值，即可。</p><p>（说实话很久前写的了，有些记不得了。而且码风还没改）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isroot(x) (tr[tr[x].p].s[0]!=x&amp;&amp;tr[tr[x].p].s[1]!=x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5e4</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,p[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">2</span>],p;</span><br><span class="line">    <span class="keyword">int</span> val,mx,flag;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _p,<span class="keyword">int</span> _val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p=_p;val=_val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,a,b;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Edge &amp;t) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&lt;t.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].mx=x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)</span><br><span class="line">        <span class="keyword">if</span> (tr[tr[tr[x].s[k]].mx].val&gt;tr[tr[x].mx].val) tr[x].mx=tr[tr[x].s[k]].mx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(tr[x].s[<span class="number">0</span>],tr[x].s[<span class="number">1</span>]);</span><br><span class="line">    tr[x].flag^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tr[x].flag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(tr[x].s[<span class="number">0</span>]);<span class="built_in">reverse</span>(tr[x].s[<span class="number">1</span>]);</span><br><span class="line">    tr[x].flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=tr[x].p,z=tr[y].p;</span><br><span class="line">    <span class="keyword">int</span> k=tr[y].s[<span class="number">1</span>]==x;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isroot</span>(y)) tr[z].s[tr[z].s[<span class="number">1</span>]==y]=x;</span><br><span class="line">    tr[x].p=z;</span><br><span class="line">    tr[y].s[k]=tr[x].s[k^<span class="number">1</span>],tr[tr[x].s[k^<span class="number">1</span>]].p=y;</span><br><span class="line">    tr[x].s[k^<span class="number">1</span>]=y,tr[y].p=x;</span><br><span class="line">    <span class="built_in">pushup</span>(y);<span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isroot</span>(x)) <span class="built_in">updata</span>(tr[x].p);</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">updata</span>(x);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isroot</span>(x))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=tr[x].p,z=tr[y].p;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isroot</span>(y))</span><br><span class="line">            <span class="keyword">if</span> ((tr[z].s[<span class="number">1</span>]==y)^(tr[y].s[<span class="number">1</span>]==x)) <span class="built_in">rotate</span>(x);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">rotate</span>(y);</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z=x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>;x;y=x,x=tr[y].p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">splay</span>(x);</span><br><span class="line">        tr[x].s[<span class="number">1</span>]=y;<span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(x);</span><br><span class="line">    <span class="built_in">reverse</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(x);</span><br><span class="line">    <span class="keyword">while</span> (tr[x].s[<span class="number">0</span>]) <span class="built_in">pushdown</span>(x),x=tr[x].s[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">splay</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">makeroot</span>(x);</span><br><span class="line">    <span class="built_in">access</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">makeroot</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">findroot</span>(y)!=x) tr[x].p=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">split</span>(x,y);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">findroot</span>(y)==x&amp;&amp;tr[y].p==x&amp;&amp;!tr[y].s[<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        tr[y].p=tr[x].s[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y,a,b;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,&amp;x,&amp;y,&amp;a,&amp;b);</span><br><span class="line">        e[i]=(Edge)&#123;x,y,a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(e+<span class="number">1</span>,e+m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i]=i;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;n) tr[i].val=e[i-n].b;</span><br><span class="line">        tr[i].mx=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res=INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y,t,a,b;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x=e[i].x,y=e[i].y,a=e[i].a,b=e[i].b;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">split</span>(x,y);</span><br><span class="line">            t=tr[y].mx;</span><br><span class="line">            <span class="keyword">if</span> (tr[t].val&gt;b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cut</span>(e[t-n].x,t);<span class="built_in">cut</span>(t,e[t-n].y);</span><br><span class="line">                <span class="built_in">link</span>(x,n+i);<span class="built_in">link</span>(n+i,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">            <span class="built_in">link</span>(x,n+i),<span class="built_in">link</span>(n+i,y);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(<span class="number">1</span>)==<span class="built_in">find</span>(n))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">split</span>(<span class="number">1</span>,n);</span><br><span class="line">            res=<span class="built_in">min</span>(res,a+tr[tr[n].mx].val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printf(&quot;%d\n&quot;,res);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res==INF) res=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Splay </tag>
            
            <tag> 动态树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式汇总</title>
      <link href="/2021/12/12/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%87%E6%80%BB/"/>
      <url>/2021/12/12/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>大杂烩。建议先学 FFT 和 NTT。</p><p>也可以来这里找代码。</p><p><strong>注意清空数组！</strong></p><p><strong>会不断更新。</strong></p><span id="more"></span><p>这里汇总了所有<del>我所学过的</del>多项式的板子。</p><p>既是存代码，也是简单的讲解。</p><p>首先甩一个 NTT 在这里。</p><p>前置知识：FFT。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * a % Mod;</span><br><span class="line">        a = a * a % Mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poly_rev</span><span class="params">(<span class="keyword">int</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; bit); ++ i)</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *a, <span class="keyword">int</span> bit, <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">poly_rev</span>(bit);</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (rev[i] &lt; i) <span class="built_in">swap</span>(a[rev[i]], a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ll ak = <span class="built_in">qpow</span>(<span class="number">3</span>, (Mod - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (inv == <span class="number">-1</span>) ak = <span class="built_in">qpow</span>(ak, Mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += (mid &lt;&lt; <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ll now = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++ j, now = now * ak % Mod)</span><br><span class="line">            &#123;</span><br><span class="line">                ll x = a[i + j], y = a[i + j + mid] * now % Mod;</span><br><span class="line">                a[i + j] = (x + y) % Mod, a[i + j + mid] = (x - y + Mod) % Mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inv == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    ll Inv = <span class="built_in">qpow</span>(tot, Mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = a[i] * Inv % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-多项式求逆"><a href="#1-多项式求逆" class="headerlink" title="1. 多项式求逆"></a>1. 多项式求逆</h2><p>可以考虑倍增。</p><p>默认 $\dfrac{n}{2}=\lfloor\dfrac{n+1}{2}\rfloor$</p><p>假设我们已经求出了 $h(x)\equiv f(x)^{-1}\pmod{x^{\frac{n}{2}}}$。</p><p>我们需要求 $g(x)\equiv f(x)^{-1}\pmod{x^n}$。</p><p>很明显，可以得到：$g(x)-h(x)\equiv 0\pmod {x^{\frac{n}{2} } }$。</p><p>平方一下，就是 $g^2(x)-2g(x)h(x)+h^2(x)\equiv 0\pmod {x^n}$。</p><p>有一个 $g^2(x)$，我们考虑搞掉一个，所以乘一个 $f(x)$，也就是 $g(x)-2h(x)+h^2(x)f(x)\equiv 0\pmod {x^n}$。</p><p>于是：$g(x)\equiv h(x)(2-h(x)f(x))\pmod {x^n}$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poly_inv</span><span class="params">(ll *a, ll *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        b[<span class="number">0</span>] = <span class="built_in">qpow</span>(a[<span class="number">0</span>], Mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (len &lt;&lt; <span class="number">1</span>)) bit ++;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">    <span class="built_in">poly_inv</span>(a, b, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> ll c[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; i &lt; tot; ++ i) b[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) c[i] = a[i];</span><br><span class="line">        <span class="keyword">else</span> c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NTT</span>(c, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line">        b[i] = (<span class="number">2</span> - b[i] * c[i] % Mod + Mod) % Mod * b[i] % Mod;</span><br><span class="line">    <span class="built_in">NTT</span>(b, bit, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; tot; ++ i) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-多项式-ln"><a href="#2-多项式-ln" class="headerlink" title="2. 多项式 ln"></a>2. 多项式 ln</h2><p>考虑：$g(x)=\ln f(x)$。</p><p>同时求导：$g’(x)=\ln f(x)$。</p><p>看做复合函数，$h(x)=\ln x$，那么 $\ln f(x) = h(f(x)) = \dfrac{1}{f(x)} \cdot f’(x)$。</p><p>然后又有求导和积分公式：<br>$$<br>\begin{aligned}<br>x^ {a’} &amp;= a x ^ {a - 1}\<br>\int x ^ a dx &amp;= \dfrac{1} {a + 1} x ^ {a + 1}<br>\end{aligned}<br>$$<br>顺便把求导的和积分的放进来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poly_dao</span><span class="params">(ll *a, ll *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++ i) b[i - <span class="number">1</span>] = a[i] * i % Mod;</span><br><span class="line">    b[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poly_ji</span><span class="params">(ll *a, ll *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++ i) b[i] = a[i - <span class="number">1</span>] * <span class="built_in">qpow</span>(i, Mod - <span class="number">2</span>) % Mod;</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poly_ln</span><span class="params">(ll *a, ll *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ll c[N], d[N];</span><br><span class="line">    <span class="built_in">poly_dao</span>(a, c, len), <span class="built_in">poly_inv</span>(a, d, len);</span><br><span class="line">    <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (len &lt;&lt; <span class="number">1</span>)) bit ++;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; tot; ++ i) c[i] = d[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NTT</span>(c, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(d, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = c[i] * d[i] % Mod;</span><br><span class="line">    <span class="built_in">NTT</span>(c, bit, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; tot; ++ i) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">poly_ji</span>(c, b, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; tot; ++ i) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-多项式-exp"><a href="#3-多项式-exp" class="headerlink" title="3. 多项式 exp"></a>3. 多项式 exp</h2><p>这个需要牛顿迭代。</p><p>假设我们要找到一个函数的零点，我们当前找到的值为 $x_0$，怎样才能逼近更优解呢？</p><p>画一个图。</p><img src="/2021/12/12/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%87%E6%80%BB/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E5%9B%BE.png" class=""><p>看到上面的函数图像，我们发现，可以直接对该点进行求导，然后交到 $x$ 轴的位置，会更靠近答案。</p><p>于是我们可以得到式子：<br>$$<br>x_1 = x_0 - \dfrac{y_0}{f’(x_0)}<br>$$<br>精度就可以不断提高。</p><p>回到本题，<del>经过我不会的证明</del>，可以得到，单次牛顿迭代后，答案可以由 $\pmod{x ^ { \frac{n} {2} } }$ 变为 $\pmod{ x^n }$。</p><p>那么，假设我们已经确定了 $h(x) = e ^ {f(x)} \pmod {x ^ {\frac {n}{2} } }$，要求 $g(x) = e ^{f(x)} \pmod {x ^ n}$。</p><p>我们考虑构造 $A(x) = \ln g(x) - f(x) = 0$，求 $g(x)$，现在我们已经找到了一个近似的 $h(x)$。</p><p>带入上面的式子，就是：<br>$$<br>\begin{aligned}<br>g(x) &amp;\equiv h(x) - \dfrac{A(h(x))} {A’(h(x))}<br>\\ &amp;\equiv h(x) - A(h(x))h(x)<br>\\ &amp;\equiv h(x) - (\ln h(x) - f(x))h(x)<br>\\ &amp;\equiv h(x)(1 - \ln h(x) + f(x))<br>\\ &amp;\pmod {x^n}<br>\end{aligned}<br>$$<br>直接 NTT 就可以了。注意保证 $f(0) = 0$，也就是常数项为 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poly_exp</span><span class="params">(ll *a, ll *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (len &lt;&lt; <span class="number">1</span>)) bit ++;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">    <span class="built_in">poly_exp</span>(a, b, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> ll d[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) d[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">poly_ln</span>(b, d, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) d[i] = (a[i] - d[i] + Mod) % Mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; tot; ++ i) d[i] = <span class="number">0</span>;</span><br><span class="line">    d[<span class="number">0</span>] ++;</span><br><span class="line">    <span class="built_in">NTT</span>(d, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line">        b[i] = b[i] * d[i] % Mod;</span><br><span class="line">    <span class="built_in">NTT</span>(b, bit, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; tot; ++ i) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-多项式快速幂"><a href="#4-多项式快速幂" class="headerlink" title="4. 多项式快速幂"></a>4. 多项式快速幂</h2><p>比较简单。</p><p>$$<br>B(x) = A(x) ^ k \Leftrightarrow B(x) = \exp(k \ln A(x))<br>$$<br>唯一需要注意的是如果 $[x^0]A(x) \not = 1$ 的时候，而 $\ln$ 的要求就是 $[x^0]A(x) = 1$，我们需要将最低非 0 项移到最低点。所以要注意移位的问题和全部是 0 的情况。</p><p>这是保证 $[x^0]A(x) = 1$ 的情况的写法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poly_qpow</span><span class="params">(LL *a, LL *b, <span class="keyword">int</span> len, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> LL c[N];</span><br><span class="line">    <span class="built_in">poly_ln</span>(a, c, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) c[i] = c[i] * k % Mod;</span><br><span class="line">    <span class="built_in">poly_exp</span>(c, b, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 Luogu 模板题<del>毒瘤</del>写法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poly_qpow</span><span class="params">(<span class="keyword">const</span> ll *a, ll *b, <span class="keyword">int</span> len, ll k1, ll k2)</span><span class="comment">//k1 = k % Mod, k2 = k % (Mod - 1), flag = (k &gt;= Mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!a[t] &amp;&amp; t &lt; len) t ++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1ll</span> * t * k1 &gt;= len || (t &amp;&amp; flag)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">static</span> ll c[N], d[N];</span><br><span class="line">    ll Inv = <span class="built_in">qpow</span>(a[t], Mod - <span class="number">2</span>), z = a[t];</span><br><span class="line">    len -= t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) d[i] = a[i + t] * Inv % Mod;</span><br><span class="line">    <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (len &lt;&lt; <span class="number">1</span>)) bit ++;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; tot; ++ i) d[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">poly_ln</span>(d, c, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) c[i] = c[i] * k1 % Mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; tot; ++ i) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">poly_exp</span>(c, b, len);</span><br><span class="line">    len += t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= t * k1; -- i) b[i] = b[i - t * k1] * <span class="built_in">qpow</span>(z, k2) % Mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = t * k1 - <span class="number">1</span>; ~i; -- i) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-多项式开根"><a href="#5-多项式开根" class="headerlink" title="5. 多项式开根"></a>5. 多项式开根</h2><p>是一个简单的推导：<br>$$<br>A(x) = B(x)^{\frac12} \Leftrightarrow A(x) = B(x) ^ {\frac{Mod + 1}{2}}<br>$$<br>一般 $[x^0]A(x) \not= 0$，所以我们直接找到 $\sqrt {[x^0]A(x)}$，然后 $pow$ 之前每一项都除以 $[x^0]A(x)$，然后 $pow$，最后将每一项都乘上 $\sqrt{[x^0]A(x)}$ 就是了。至于如何在模意义下求根号，我们使用 <a href="https://mydcwfy.github.io/2021/12/26/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%E4%B8%8E-Cipolla-%E7%AE%97%E6%B3%95/">Cipolla 算法</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Cipolla&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">        ll x, y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    <span class="function">Complex <span class="title">mul</span><span class="params">(Complex a, Complex b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;(a.x * b.x % Mod + a.y * b.y % Mod * w % Mod) % Mod, (a.x * b.y % Mod + b.x * a.y % Mod) % Mod&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Complex <span class="title">qpow_img</span><span class="params">(Complex a, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Complex res = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = <span class="built_in">mul</span>(res, a);</span><br><span class="line">            a = <span class="built_in">mul</span>(a, a);</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">get_sqrt</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ll a;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">qpow</span>(x, (Mod - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) == Mod - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="built_in">rand</span>() % Mod;</span><br><span class="line">            w = (a * a % Mod - x + Mod) % Mod;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">qpow</span>(w, (Mod - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) == Mod - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="built_in">qpow_img</span>(&#123;a, <span class="number">1</span>&#125;, (Mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>).x;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(ans, Mod - ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> Cipolla::get_sqrt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poly_sqrt</span><span class="params">(ll *f, ll *g, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll sq = <span class="built_in">get_sqrt</span>(f[<span class="number">0</span>]), inv = <span class="built_in">qpow</span>(f[<span class="number">0</span>], Mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) f[i] = f[i] * inv % Mod;</span><br><span class="line">    <span class="built_in">poly_qpow</span>(f, g, len, (Mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, (Mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) g[i] = g[i] * sq % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-多项式除法"><a href="#6-多项式除法" class="headerlink" title="6. 多项式除法"></a>6. 多项式除法</h2><p>我们假设这样一个函数：<br>$$<br>F(x) \Leftrightarrow F_R(x)<br>$$<br>表示将 $F(x)$ 的系数翻转过来。可以发现 $F(x) = x^n F(\dfrac 1x)$。</p><p>然后，我们对这个式子进行推导（假设是 $F(x) = D(x) * G(x) + R(x)$）：<br>$$<br>\begin{aligned}<br>F_R(x) = x^n F(\dfrac 1x) &amp;= (D(\dfrac 1x) * G(\dfrac 1x) + R(\dfrac 1x))x ^ n<br>\\ &amp;= D(\dfrac 1x) * x ^ {n - m} * G(\dfrac 1x) * x^m + R(\dfrac 1x) * x ^ m * x ^ {n - m}<br>\\ &amp;= D_R(x) * G_R(x) + R_R(x) * x^{n - m}<br>\end{aligned}<br>$$<br>然后，如果我们将这一个看做一个 $\bmod x^{n - m}$ 的话，那么 $R_R(x) * x ^{n - m}$ 就没有用了。</p><p>然后，$D_R(x)$ 又是 $n - m$ 次的，所以我们在 $\bmod x ^{n - m}$ 下用求逆求出 $D_R(x)$ 就可以了。至于要求出 $R(x)$，我们直接减就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poly_div</span><span class="params">(LL *a, LL *b, LL *c, LL *r, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> del = n - m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> LL d[N], e[N];</span><br><span class="line">    <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (n &lt;&lt; <span class="number">1</span>)) bit ++;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; m) e[i] = b[m - i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> e[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">poly_inv</span>(e, d, del);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) e[i] = a[n - i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> e[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NTT</span>(d, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(e, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line">        d[i] = d[i] * e[i] % Mod;</span><br><span class="line">    <span class="built_in">NTT</span>(d, bit, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; del; ++ i) c[i] = d[del - i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; del) d[i] = c[i];</span><br><span class="line">        <span class="keyword">else</span> d[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; m) e[i] = b[i];</span><br><span class="line">        <span class="keyword">else</span> e[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NTT</span>(d, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(e, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) d[i] = d[i] * e[i] % Mod;</span><br><span class="line">    <span class="built_in">NTT</span>(d, bit, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; tot; ++ i) d[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        r[i] = (a[i] - d[i] + Mod) % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-多项式三角函数"><a href="#7-多项式三角函数" class="headerlink" title="7. 多项式三角函数"></a>7. 多项式三角函数</h2><p>一个大名鼎鼎的公式：<br>$$<br>e^{ix} = \cos x + i\sin x<br>$$<br>带入 $-x$ 得：<br>$$<br>e^{-ix} = \cos x - i\sin x<br>$$<br>（不会有人连三角函数的诱导公式都不知道吧，$\cos(-x) = \cos x, \sin (-x) = -\sin x$）。</p><p>于是我们直接解出来：<br>$$<br>\begin{aligned}<br>&amp; \cos x = \dfrac{e^{ix} + e^{-ix}}2<br>\\&amp; \sin x = \dfrac{e^{ix} - e^{-ix}}{2i}<br>\end{aligned}<br>$$<br>至于 $i$ 在模 998244353 下的取值，我们有 $i^4 = 1 = g^{p - 1}$，所以 $i = g^{\frac{p - 1}{4}}$，在 998244353 下是 86583718。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> img = <span class="number">86583718</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poly_sin</span><span class="params">(ll *a, ll *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ll c[N], d[N], e[N];</span><br><span class="line">    <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (len &lt;&lt; <span class="number">1</span>)) bit ++;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) c[i] = a[i] * img % Mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; tot; ++ i) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">poly_exp</span>(c, d, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) c[i] = Mod - a[i] * img % Mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; tot; ++ i) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">poly_exp</span>(c, e, len);</span><br><span class="line">    ll invimg = <span class="built_in">qpow</span>(<span class="number">2ll</span> * img % Mod, Mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) b[i] = (d[i] - e[i] + Mod) % Mod * invimg % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poly_cos</span><span class="params">(ll *a, ll *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ll c[N], d[N], e[N];</span><br><span class="line">    <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (len &lt;&lt; <span class="number">1</span>)) bit ++;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) c[i] = a[i] * img % Mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; tot; ++ i) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">poly_exp</span>(c, d, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) c[i] = Mod - a[i] * img % Mod;</span><br><span class="line">    <span class="built_in">poly_exp</span>(c, e, len);</span><br><span class="line">    ll inv = (Mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) b[i] = (d[i] + e[i]) % Mod * inv % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-多项式反三角函数"><a href="#8-多项式反三角函数" class="headerlink" title="8. 多项式反三角函数"></a>8. 多项式反三角函数</h2><p>先扔一个公式（注意 $\text{asin}$ 和 $\arcsin$ 似乎是一个东西）：</p><p>$$<br>\begin{aligned}<br>\arcsin F(x) &amp;= \int \dfrac{F’(x)}{\sqrt {1 - F(x) ^ 2}} \pmod {x ^ n}<br>\\\arctan F(x) &amp;= \int \dfrac{F’(x)}{1 + F(x) ^ 2} \pmod {x ^ n}<br>\end{aligned}<br>$$</p><p>简单的证明一下（应该高数上有吧）：</p><p>$$<br>\begin{aligned}<br>&amp;y = \arcsin x<br>\\&amp; x = \sin y<br>\\&amp; \dfrac{x}{dx} = \dfrac{\sin y}{dx}<br>\\&amp; 1 = y’ \cos y<br>\\&amp; y’ = \dfrac{1}{\cos y} = \dfrac{1}{\sqrt{1 - \sin ^ 2 y}} = \dfrac{1}{\sqrt {1 - x ^ 2}}<br>\end{aligned}<br>$$</p><p>其中第四步是复合函数的求导：$y = g(t), t = f(x)\Rightarrow y’ = g’(t) * f’(x)$。$\arctan$ 的略去了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poly_asin</span><span class="params">(LL *a, LL *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> LL c[N], d[N], e[N];</span><br><span class="line">    <span class="built_in">poly_dao</span>(a, c, len);</span><br><span class="line">    <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (len &lt;&lt; <span class="number">1</span>)) bit ++;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) d[i] = a[i];</span><br><span class="line">        <span class="keyword">else</span> d[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NTT</span>(d, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) d[i] = d[i] * d[i] % Mod;</span><br><span class="line">    <span class="built_in">NTT</span>(d, bit, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) d[i] = (!i - d[i] + Mod) % Mod;</span><br><span class="line">        <span class="keyword">else</span> d[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">poly_sqrt</span>(d, e, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) d[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">poly_inv</span>(e, d, len);</span><br><span class="line">    <span class="built_in">NTT</span>(c, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(d, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = c[i] * d[i] % Mod;</span><br><span class="line">    <span class="built_in">NTT</span>(c, bit, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">poly_ji</span>(c, b, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poly_atan</span><span class="params">(LL *a, LL *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> LL c[N], d[N], e[N];</span><br><span class="line">    <span class="built_in">poly_dao</span>(a, c, len);</span><br><span class="line">    <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (len &lt;&lt; <span class="number">1</span>)) bit ++;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) d[i] = a[i];</span><br><span class="line">        <span class="keyword">else</span> d[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NTT</span>(d, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) d[i] = d[i] * d[i] % Mod;</span><br><span class="line">    <span class="built_in">NTT</span>(d, bit, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) d[i] = !i + d[i];</span><br><span class="line">        <span class="keyword">else</span> d[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">poly_inv</span>(d, e, len);</span><br><span class="line">    <span class="built_in">NTT</span>(c, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(e, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = c[i] * e[i] % Mod;</span><br><span class="line">    <span class="built_in">NTT</span>(c, bit, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">poly_ji</span>(c, b, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary>点击有惊喜</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// updated on 2022-03-18: used adj(x) to calculate mod, changed N&#x27;s value</span></span><br><span class="line"><span class="comment">/// It is written by mydcwfy on 2021-12-30.</span></span><br><span class="line"><span class="comment">/// This is the template of Polynomial, including NTT, Polyinverse, PolyDerivate, PolyIntegrate, PolyLn, PolyExp, PolyQpow, PolySqrt, Polysin..., Polyasin...</span></span><br><span class="line"><span class="comment">/// The caculation is under the mod of 998244353.</span></span><br><span class="line"><span class="comment">/// You can use the namespace under your version.</span></span><br><span class="line"><span class="keyword">namespace</span> Polynomial &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">21</span> | <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod = <span class="number">998244353</span>, Img = <span class="number">86583718</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rev[N], Inv[N];</span><br><span class="line"><span class="function">Cipolla <span class="title">cip</span><span class="params">(<span class="number">998244353</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Calculate the mod of x</span></span><br><span class="line"><span class="comment">/// please make sure that x is in [-Mod, Mod)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x += x &gt;&gt; <span class="number">31</span> &amp; Mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// This is the background fuction of the Polynomial.</span></span><br><span class="line"><span class="comment">/// It caculates the k-pow of a.</span></span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL a, LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * a % Mod;</span><br><span class="line">a = a * a % Mod;</span><br><span class="line">k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// This is the background fuction of the Polynomial.</span></span><br><span class="line"><span class="comment">/// It caculates the reverse of NTT.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poly_rev</span><span class="params">(<span class="keyword">int</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; bit); ++ i)</span><br><span class="line">rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// This is the background fuction of the Polynomial.</span></span><br><span class="line"><span class="comment">/// It caculates the mininum number bit qualifying (2 ^ bit &gt;= len * 2)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Poly_bit</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (len &lt;&lt; <span class="number">1</span>)) bit ++;</span><br><span class="line"><span class="keyword">return</span> bit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// This is the background fuction of the Polynomial.</span></span><br><span class="line"><span class="comment">/// It caculates the inverse of numbers ranging from [1, N).</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++ i) Inv[i] = (Mod - Mod / i) * (LL)Inv[Mod % i] % Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// This is the background fuction of the Polynomial.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(LL *a, <span class="keyword">int</span> bit, <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!Inv[<span class="number">1</span>]) <span class="built_in">init</span>();</span><br><span class="line"><span class="built_in">Poly_rev</span>(bit);</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &lt; rev[i]) <span class="built_in">swap</span>(a[rev[i]], a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>, bit = <span class="number">0</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>, bit ++) &#123;</span><br><span class="line">LL ak = <span class="built_in">qpow</span>(inv == <span class="number">1</span> ? <span class="number">3</span> : (Mod + <span class="number">1</span>) / <span class="number">3</span>, (Mod - <span class="number">1</span>) &gt;&gt; (bit + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, now = <span class="number">1</span>; j &lt; mid; ++ j, now = now * ak % Mod)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = a[i + j], y = a[i + j + mid] * now % Mod;</span><br><span class="line">a[i + j] = <span class="built_in">adj</span>(x + y - Mod), a[i + j + mid] = <span class="built_in">adj</span>(x - y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inv == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = a[i] * Inv[tot] % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Caculate the Polyinverse of a.</span></span><br><span class="line"><span class="comment">/// a is the original Polynomial.</span></span><br><span class="line"><span class="comment">/// b is the Polynomial to be caculated into.</span></span><br><span class="line"><span class="comment">/// len is the length of the Polynomial.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poly_Inv</span><span class="params">(LL *a, LL *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">b[<span class="number">0</span>] = <span class="built_in">qpow</span>(a[<span class="number">0</span>], Mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Poly_Inv</span>(a, b, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">static</span> LL c[N];</span><br><span class="line"><span class="keyword">int</span> bit = <span class="built_in">Poly_bit</span>(len), tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; i &lt; tot; ++ i) b[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &lt; len) c[i] = a[i];</span><br><span class="line"><span class="keyword">else</span> c[i] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NTT</span>(c, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b, bit, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line">b[i] = (<span class="number">2</span> - b[i] * c[i] % Mod + Mod) % Mod * b[i] % Mod;</span><br><span class="line"><span class="built_in">NTT</span>(b, bit, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; tot; ++ i) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Caculate the PolyDerivate of a.</span></span><br><span class="line"><span class="comment">/// a is the original Polynomial.</span></span><br><span class="line"><span class="comment">/// b is the Polynomial to be caculated into.</span></span><br><span class="line"><span class="comment">/// len is the length of the Polynomial.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poly_Dev</span><span class="params">(LL *a, LL *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++ i) b[i - <span class="number">1</span>] = a[i] * i % Mod;</span><br><span class="line">b[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Caculate the PolyIntegrate of a.</span></span><br><span class="line"><span class="comment">/// a is the original Polynomial.</span></span><br><span class="line"><span class="comment">/// b is the Polynomial to be caculated into.</span></span><br><span class="line"><span class="comment">/// len is the length of the Polynomial.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poly_Int</span><span class="params">(LL *a, LL *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!Inv[<span class="number">1</span>]) <span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++ i) b[i] = a[i - <span class="number">1</span>] * Inv[i] % Mod;</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Caculate the PolyLn of a.</span></span><br><span class="line"><span class="comment">/// a is the original Polynomial.</span></span><br><span class="line"><span class="comment">/// b is the Polynomial to be caculated into.</span></span><br><span class="line"><span class="comment">/// len is the length of the Polynomial.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poly_Ln</span><span class="params">(LL *a, LL *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> LL c[N], d[N];</span><br><span class="line"><span class="keyword">int</span> bit = <span class="built_in">Poly_bit</span>(len), tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = d[i] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Poly_Dev</span>(a, c, len), <span class="built_in">Poly_Inv</span>(a, d, len);</span><br><span class="line"><span class="built_in">NTT</span>(c, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(d, bit, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = c[i] * d[i] % Mod;</span><br><span class="line"><span class="built_in">NTT</span>(c, bit, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">Poly_Int</span>(c, b, len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; tot; ++ i) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Caculate the PolyExp of a.</span></span><br><span class="line"><span class="comment">/// a is the original Polynomial.</span></span><br><span class="line"><span class="comment">/// b is the Polynomial to be caculated into.</span></span><br><span class="line"><span class="comment">/// len is the length of the Polynomial.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poly_Exp</span><span class="params">(LL *a, LL *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Poly_Exp</span>(a, b, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> bit = <span class="built_in">Poly_bit</span>(len), tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">static</span> LL c[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Poly_Ln</span>(b, c, len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) c[i] = (!i + a[i] - c[i] + Mod) % Mod;</span><br><span class="line"><span class="built_in">NTT</span>(b, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(c, bit, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) b[i] = b[i] * c[i] % Mod;</span><br><span class="line"><span class="built_in">NTT</span>(b, bit, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; tot; ++ i) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Caculate the PolyQpow of a.</span></span><br><span class="line"><span class="comment">/// a is the original Polynomial.</span></span><br><span class="line"><span class="comment">/// b is the Polynomial to be caculated into.</span></span><br><span class="line"><span class="comment">/// len is the length of the Polynomial.</span></span><br><span class="line"><span class="comment">/// k is the pow number.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poly_Qpow</span><span class="params">(LL *a, LL *b, <span class="keyword">int</span> len, LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> LL c[N];</span><br><span class="line">LL x = a[<span class="number">0</span>], z = <span class="built_in">qpow</span>(x, Mod - <span class="number">2</span>), mul = <span class="built_in">qpow</span>(x, k % (Mod - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) a[i] = a[i] * z % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) c[i] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Poly_Ln</span>(a, c, len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) c[i] = c[i] * (k % Mod) % Mod;</span><br><span class="line"><span class="built_in">Poly_Exp</span>(c, b, len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) b[i] = b[i] * mul % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Caculate the PolySqrt of a.</span></span><br><span class="line"><span class="comment">/// a is the original Polynomial.</span></span><br><span class="line"><span class="comment">/// b is the Polynomial to be caculated into.</span></span><br><span class="line"><span class="comment">/// len is the length of the Polynomial.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poly_Sqrt</span><span class="params">(LL *a, LL *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL x = a[<span class="number">0</span>], z = cip.<span class="built_in">Mod_Sqrt</span>(x), cu = <span class="built_in">qpow</span>(x, Mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) a[i] = a[i] * cu % Mod;</span><br><span class="line"><span class="built_in">Poly_Qpow</span>(a, b, len, (Mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) a[i] = a[i] * z % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Caculate the PolySin of a.</span></span><br><span class="line"><span class="comment">/// a is the original Polynomial.</span></span><br><span class="line"><span class="comment">/// b is the Polynomial to be caculated into.</span></span><br><span class="line"><span class="comment">/// len is the length of the Polynomial.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poly_Sin</span><span class="params">(LL *a, LL *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> LL c[N], d[N], e[N];</span><br><span class="line"><span class="keyword">int</span> bit = <span class="built_in">Poly_bit</span>(len), tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = d[i] = e[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &lt; len) c[i] = a[i] * Img % Mod;</span><br><span class="line"><span class="keyword">else</span> c[i] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Poly_Exp</span>(c, d, len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &lt; len) c[i] = Mod - a[i] * Img % Mod;</span><br><span class="line"><span class="keyword">else</span> c[i] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Poly_Exp</span>(c, e, len);</span><br><span class="line">LL InvImg = <span class="built_in">qpow</span>(<span class="number">2LL</span> * Img % Mod, Mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) b[i] = (d[i] - e[i] + Mod) % Mod * InvImg % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Caculate the PolyCos of a.</span></span><br><span class="line"><span class="comment">/// a is the original Polynomial.</span></span><br><span class="line"><span class="comment">/// b is the Polynomial to be caculated into.</span></span><br><span class="line"><span class="comment">/// len is the length of the Polynomial.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poly_Cos</span><span class="params">(LL *a, LL *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> LL c[N], d[N], e[N];</span><br><span class="line"><span class="keyword">int</span> bit = <span class="built_in">Poly_bit</span>(len), tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = d[i] = e[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) c[i] = a[i] * Img % Mod;</span><br><span class="line"><span class="built_in">Poly_Exp</span>(c, d, len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &lt; len) c[i] = Mod - a[i] * Img % Mod;</span><br><span class="line"><span class="keyword">else</span> c[i] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Poly_Exp</span>(c, e, len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) b[i] = (d[i] + e[i]) % Mod * Inv[<span class="number">2</span>] % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Caculate the PolyTan of a.</span></span><br><span class="line"><span class="comment">/// a is the original Polynomial.</span></span><br><span class="line"><span class="comment">/// b is the Polynomial to be caculated into.</span></span><br><span class="line"><span class="comment">/// len is the length of the Polynomial.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poly_Tan</span><span class="params">(LL *a, LL *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> LL c[N], d[N];</span><br><span class="line"><span class="keyword">int</span> bit = <span class="built_in">Poly_bit</span>(len), tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = d[i] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Poly_Sin</span>(a, c, len), <span class="built_in">Poly_Cos</span>(a, d, len), <span class="built_in">Poly_Inv</span>(d, b, len);</span><br><span class="line"><span class="built_in">NTT</span>(c, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b, bit, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) b[i] = c[i] * b[i] % Mod;</span><br><span class="line"><span class="built_in">NTT</span>(b, bit, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; tot; ++ i) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Caculate the PolyCot of a.</span></span><br><span class="line"><span class="comment">/// a is the original Polynomial.</span></span><br><span class="line"><span class="comment">/// b is the Polynomial to be caculated into.</span></span><br><span class="line"><span class="comment">/// len is the length of the Polynomial.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poly_Cot</span><span class="params">(LL *a, LL *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> LL c[N], d[N];</span><br><span class="line"><span class="keyword">int</span> bit = <span class="built_in">Poly_bit</span>(len), tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = d[i] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Poly_Cos</span>(a, c, len), <span class="built_in">Poly_Sin</span>(a, d, len), <span class="built_in">Poly_Inv</span>(d, b, len);</span><br><span class="line"><span class="built_in">NTT</span>(c, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b, bit, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) b[i] = c[i] * b[i] % Mod;</span><br><span class="line"><span class="built_in">NTT</span>(b, bit, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; tot; ++ i) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Caculate the PolyAsin of a(Arcsin).</span></span><br><span class="line"><span class="comment">/// a is the original Polynomial.</span></span><br><span class="line"><span class="comment">/// b is the Polynomial to be caculated into.</span></span><br><span class="line"><span class="comment">/// len is the length of the Polynomial.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poly_Asin</span><span class="params">(LL *a, LL *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> LL c[N], d[N], e[N];</span><br><span class="line"><span class="keyword">int</span> bit = <span class="built_in">Poly_bit</span>(len), tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = d[i] = e[i] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Poly_Dev</span>(a, c, len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &lt; len) d[i] = a[i];</span><br><span class="line"><span class="keyword">else</span> d[i] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NTT</span>(d, bit, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) d[i] = d[i] * d[i] % Mod;</span><br><span class="line"><span class="built_in">NTT</span>(d, bit, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i &lt; len) d[i] = (!i - d[i] + Mod) % Mod;</span><br><span class="line"><span class="keyword">else</span> d[i] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Poly_Sqrt</span>(d, e, len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) d[i] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Poly_Inv</span>(e, d, len);</span><br><span class="line"><span class="built_in">NTT</span>(c, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(d, bit, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = c[i] * d[i] % Mod;</span><br><span class="line"><span class="built_in">NTT</span>(c, bit, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">Poly_Int</span>(c, b, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Caculate the PolyAtan of a(Arctan).</span></span><br><span class="line"><span class="comment">/// a is the original Polynomial.</span></span><br><span class="line"><span class="comment">/// b is the Polynomial to be caculated into.</span></span><br><span class="line"><span class="comment">/// len is the length of the Polynomial.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poly_Atan</span><span class="params">(LL *a, LL *b, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> LL c[N], d[N], e[N];</span><br><span class="line"><span class="keyword">int</span> bit = <span class="built_in">Poly_bit</span>(len), tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = d[i] = e[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) c[i] = a[i];</span><br><span class="line"><span class="built_in">NTT</span>(c, bit, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = c[i] * c[i] % Mod;</span><br><span class="line"><span class="built_in">NTT</span>(c, bit, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; tot; ++ i) c[i] = <span class="number">0</span>;</span><br><span class="line">c[<span class="number">0</span>] ++;</span><br><span class="line"><span class="built_in">Poly_Dev</span>(a, d, len), <span class="built_in">Poly_Inv</span>(c, e, len);</span><br><span class="line"><span class="built_in">NTT</span>(d, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(e, bit, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) d[i] = d[i] * e[i] % Mod;</span><br><span class="line"><span class="built_in">NTT</span>(d, bit, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">Poly_Int</span>(d, b, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace Polynomial</span></span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斯特林数</title>
      <link href="/2021/12/12/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
      <url>/2021/12/12/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>后面比较难理解，但是前面比较简单。</p><span id="more"></span><h2 id="1-第一类斯特林数"><a href="#1-第一类斯特林数" class="headerlink" title="1. 第一类斯特林数"></a>1. 第一类斯特林数</h2><h3 id="一）定义"><a href="#一）定义" class="headerlink" title="一）定义"></a>一）定义</h3><p>是指将 $n$ 个不同的数划分成 $k$ 个圆排列的方案数，记作 $s(n,k)$ 或者 $n\brack m$。</p><h3 id="二）求法"><a href="#二）求法" class="headerlink" title="二）求法"></a>二）求法</h3><p>使用递推的方法。</p><p>第一种情况是 $n$ 专门放入 1 个圆排列，剩下的 $n-1$ 放入剩下的 $k-1$ 的圆排列中，这一类答案的贡献是 $s(n-1,k-1)$。</p><p>第二种情况是 $n$ 放入已有的 $k$ 个圆排列中。因为每一个数是不同的，所以可以发现，在一个圆排列中，可以放的位置（且不重复）恰好等于当前圆排列的大小。前面放的 $n-1$ 个数，所以有 $n-1$ 种方法，贡献为 $(n-1)\times s(n-1,k)$。</p><p>那么，我们就可以得到递推公式：</p><p>$$<br>s(n,k)=s(n-1,k-1)+(n-1)\times s(n-1,k)<br>$$</p><h3 id="三）性质"><a href="#三）性质" class="headerlink" title="三）性质"></a>三）性质</h3><ol><li><p>$s(n,n)=1$：显然，每一个数放一个圆排列。</p></li><li><p>$s(n,1)=(n-1)!$：首先，不考虑旋转的话，就是 $n!$，但是每一种会对应 $n$ 种相同的，所以就是 $(n-1)!$。</p></li><li><p>$s(n, n-2) = 2\binom{n}{3}+3\binom{n}{4}$：其实都是一些简单的推导了。此处略去。</p></li><li><p>$\sum_{k=0}^ns(n,k)=n!$：这个需要用到第一类斯特林数的另一种表示方法，我们等一下再讲。</p></li></ol><p>首先，我们定义一个 $x^{\bar n}=x(x+1)…(x+n-1)$，也就是上升幂。</p><p><strong>定理</strong>：$x^{\bar{n}}=\sum_{k=0}^ns(n,k)x^k$。</p><p>证明：使用递推的方法，我们假设最后一个乘的是 $x$ 而不是 $n-1$，那么，对于 $x^k$ 的贡献就是剩下的 $x^{\overline{n-1}}$ 在 $x^{k-1}$ 的贡献。</p><p>如果最后乘的是 $n-1$，那么对于 $x^k$ 的贡献就是 $x^{\overline{n-1}}$ 在 $x^k$ 的贡献再乘上 $n-1$。</p><p>综上，我们发现和 $s(n,k)$ 的递推公式一模一样，所以定理得证。</p><p>接着，利用定理，我们令 $x=1$，那么可以化为：</p><p>$$<br>n!=\sum_{k=0}^ns(n,k)<br>$$</p><h2 id="2-第二类斯特林数"><a href="#2-第二类斯特林数" class="headerlink" title="2. 第二类斯特林数"></a>2. 第二类斯特林数</h2><h3 id="一）定义-1"><a href="#一）定义-1" class="headerlink" title="一）定义"></a>一）定义</h3><p>是指将 $n$ 个不同的数划分 $k$ 个子集的方案数，记为 $S(n,k)$ 或 $n\brace m$。</p><h3 id="二）求法-1"><a href="#二）求法-1" class="headerlink" title="二）求法"></a>二）求法</h3><p>如果我们单独将 $n$ 放入一个集合，就是 $S(n-1,k-1)$。</p><p>如果我们将 $n$ 归入前面的 $k$ 个集合，就是 $k\times S(n-1,k)$。</p><p>于是，递推式就是：</p><p>$$<br>S(n,k)=S(n-1,k-1)+k\times S(n-1,k)<br>$$</p><h2 id="3-例题"><a href="#3-例题" class="headerlink" title="3. 例题"></a>3. 例题</h2><h4 id="T1：-FJOI2016-建筑师"><a href="#T1：-FJOI2016-建筑师" class="headerlink" title="T1：[FJOI2016]建筑师"></a>T1：[FJOI2016]建筑师</h4><p><a href="https://www.luogu.com.cn/problem/P4609">题目传送门 Luogu</a></p><p>首先，一个显然的东西是：最高的肯定不会被挡住。</p><p>所以，我们可以将 $n$ 的位置枚举，然后左边可以看到 $A-1$ 个，右边可以看到 $B-1$ 个（均没有计算 $n$ 的贡献）。</p><p>然后，我们可以将这些可以看到的建筑以及它后面被挡住的分为一组。</p><p>可以在这一组中，因为最高的一定放在最前面。如果接在一起，可以看做一个圆排列，并且贡献就是 $1$。</p><p>这不就是第一类斯特林数吗！</p><p>我们就是将 $n-1$ 个放入 $A+B-2$ 个圆排列，贡献就是 ${n-1}\brack{A+B-2}$。</p><p>然后，我们要选择 $A-1$ 个放在前面，于是就是 ${A+B-2}\choose {A-1}$。</p><p>答案就是<br>$$<br>{ {n - 1} \brack {A + B - 2} } \times { { A + B - 2} \choose {A - 1} }<br>$$</p><p>直接递推，时间复杂度为 $O(nk)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">10</span>, K = <span class="number">205</span>, Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll s[N][K], C[K][K];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; K; ++ j)</span><br><span class="line">            s[i][j] = (s[i - <span class="number">1</span>][j - <span class="number">1</span>] + (i - <span class="number">1</span>) * s[i - <span class="number">1</span>][j]) % Mod;</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; K; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (!j) C[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="comment">// cout &lt;&lt; C[5][3] &lt;&lt; &#x27; &#x27; &lt;&lt; s[4][1] &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span> t, n, a, b;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, s[n - <span class="number">1</span>][a + b - <span class="number">2</span>] * C[a + b - <span class="number">2</span>][a - <span class="number">1</span>] % Mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有 Luogu 上的几道神仙题（一紫三黑），我们简单的讲一下。</p><h4 id="T1：第二类斯特林数-·-行"><a href="#T1：第二类斯特林数-·-行" class="headerlink" title="T1：第二类斯特林数 · 行"></a>T1：第二类斯特林数 · 行</h4><p><a href="https://www.luogu.com.cn/problem/P5395">题目传送门 Luogu</a></p><p>我们可以这样考虑：<br>$$<br>{n \brace m} = \sum_{i=0}^m\dfrac{(-1)^i}{i!}\cdot \dfrac{(m-i)^n}{(m-i)!}<br>$$<br>发现可以先构造左边的 $f(x)=\sum_{i=0}^n \dfrac{(-1)^i}{i!},g(x)=\sum_{i=0}^n \dfrac{i^n}{i!}$，直接 NTT 卷积即可，就可以得到每一项 $h_m$ 所对应的项。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">qpow</span>(i, n) * infact[i] % Mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) b[i] = (i &amp; <span class="number">1</span> ? Mod - infact[i] : infact[i]);</span><br><span class="line">    <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span> &lt;&lt; bit &lt; (n &lt;&lt; <span class="number">1</span>)) bit ++;</span><br><span class="line">    <span class="built_in">NTT</span>(a, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(b, bit, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; bit); ++ i) a[i] = a[i] * b[i] % Mod;</span><br><span class="line">    <span class="built_in">NTT</span>(a, bit, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2：第二类斯特林数-·-列"><a href="#T2：第二类斯特林数-·-列" class="headerlink" title="T2：第二类斯特林数 · 列"></a>T2：第二类斯特林数 · 列</h4><p><a href="https://www.luogu.com.cn/problem/P5396">题目传送门 Luogu</a></p><p>直接考虑指数型生成函数。</p><p>先看做 $n$ 个元素是相同的，$m$ 个盒子是不同的。</p><p>如果只有一个集合，用 $x^n$ 的系数表示方案数，那么就是：<br>$$<br>f(x)=\sum_{i=1}\dfrac{x^i}{i!}<br>$$<br>（注意指数型生成函数本身就要除以 $i!$，才能得到系数）</p><p>可以用 Taylor 展开式得到：$f(x)=e^x-1$（因为不是从 $i=0$ 开始的）。</p><p>那么，有 $m$ 个集合，就是 $g(x)=f(x)^k$，得到的系数再乘以一个 $i!$ 再除以 $m!$ 就可以得到答案了。</p><p>快速幂直接是 $g(x)=e^\left(k\ln f(x) \right)$。多项式 $\ln,\exp$ 结束了。注意第一项是 0，要整体向右平移 1 个单位，最后向左平移 $k$ 个单位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    n ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++ i) f[i] = infact[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> ll c[N];</span><br><span class="line">    <span class="built_in">get_ln</span>(a, c, len);</span><br><span class="line">    <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; (len &lt;&lt; <span class="number">1</span>)) bit ++;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = c[i] * k % Mod;</span><br><span class="line">    <span class="built_in">get_exp</span>(c, b, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= k; -- i) g[i] = g[i - k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i) g[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, g[i] * fact[i] % Mod * infact[k] % Mod);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3：第一类斯特林数-·-行"><a href="#T3：第一类斯特林数-·-行" class="headerlink" title="T3：第一类斯特林数 · 行"></a>T3：第一类斯特林数 · 行</h4><p><a href="https://www.luogu.com.cn/problem/P5408">题目传送门 Luogu</a></p><p>首先，<del>由题解</del>可以得到：<br>$$<br>x^{\overline n} = \sum_{i=0}^{n}{n \brack i}x^i<br>$$<br>题目转化为求 $x^{\overline n}$ 的系数。</p><p>考虑倍增的算法。</p><p>已经得到了 $f(x)$，求 $f(x+c)$。</p><p>二项式定理就可以了。<br>$$<br>\begin{aligned}<br>f(x+c)&amp;=\sum_{i=0}^n[x^i]f(x)\sum_{j=0}^i {i \choose j}x^j c^{i-j} \<br>&amp;=\sum_{i=0}^n[x^i]f(x)\sum_{j=0}^i \dfrac{i!}{j!\cdot (i-j)!} x^j c^{i-j}\<br>&amp;=\sum_{j=0}^n \dfrac{x^j}{j!}\cdot \sum_{i=j}^n\dfrac{c^{i-j}}{(i-j)!}[x^i]f(x) i!\<br>\end{aligned}<br>$$<br>很明显可以化为两个式子：$g(x)=\sum_{i=0}^n \dfrac{c^i}{i!}x^i,h(x)=[x^i]f(x)i!x^i$，发现就是次数相减。</p><p>将 $h(x)$ 翻转为 $[x^i]f(x)i! x^{n-i}$，那么就是次数相加了，变为 NTT 就可以了。</p><p>回归本题。<br>$$<br>x^{\overline {2n}} = x^{\overline n}\cdot (x+n)^{\overline{n}}<br>$$<br>先将 $x^\overline n$ 求出来，然后上面的式子（可以叫多项式平移）推出 $(x+n)^\overline n$，NTT 一下就是了。</p><p>注意 $n$ 为奇数的时候，可以直接暴力求 $x^\overline {n-1}\cdot (x+n)$ 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_sti</span><span class="params">(<span class="keyword">int</span> n, ll *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> ll c[N], d[N], t[N];</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">get_sti</span>(n - <span class="number">1</span>, a);</span><br><span class="line">c[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) c[i + <span class="number">1</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) c[i] = (c[i] + a[i] * (n - <span class="number">1</span>) % Mod) % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) a[i] = c[i];</span><br><span class="line"><span class="comment">// cout &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// for (int i = 0; i &lt;= n; ++ i) cout &lt;&lt; a[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"><span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">get_sti</span>(n &gt;&gt; <span class="number">1</span>, a);</span><br><span class="line"><span class="keyword">int</span> m = n &gt;&gt; <span class="number">1</span>, bit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; n + <span class="number">1</span>) bit ++;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">ll now = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i) c[m - i] = a[i] * fact[i] % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i, now = now * m % Mod) d[i] = now * infact[i] % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span>; i &lt; tot; ++ i) c[i] = d[i] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// for (int i = 0; i &lt;= m; ++ i) cout &lt;&lt; c[i] &lt;&lt; &quot; \n&quot;[i == m];</span></span><br><span class="line"><span class="comment">// for (int i = 0; i &lt;= m; ++ i) cout &lt;&lt; d[i] &lt;&lt; &quot; \n&quot;[i == m];</span></span><br><span class="line"><span class="built_in">NTT</span>(c, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(d, bit, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) c[i] = c[i] * d[i] % Mod;</span><br><span class="line"><span class="built_in">NTT</span>(c, bit, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i) t[i] = c[m - i] * infact[i] % Mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span>; i &lt; tot; ++ i) t[i] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// for (int i = 0; i &lt;= m; ++ i) cout &lt;&lt; t[i] &lt;&lt; &quot; \n&quot;[i == m];</span></span><br><span class="line"><span class="built_in">NTT</span>(a, bit, <span class="number">1</span>), <span class="built_in">NTT</span>(t, bit, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = a[i] * t[i] % Mod;</span><br><span class="line"><span class="built_in">NTT</span>(a, bit, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt; tot; ++ i) a[i] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// cout &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// for (int i = 0; i &lt;= n; ++ i) cout &lt;&lt; a[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"><span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T4：第一类斯特林数-·-列"><a href="#T4：第一类斯特林数-·-列" class="headerlink" title="T4：第一类斯特林数 · 列"></a>T4：第一类斯特林数 · 列</h4><p><a href="https://www.luogu.com.cn/problem/P5409">题目传送门 Luogu</a></p><p>和 T2 差不多。</p><p>考虑只有一个集合的时候，就是：<br>$$<br>f(x)=\sum_{i=1}(i-1)!\dfrac{x^i}{i!}<br>$$<br>那么答案就是 $g(x) = f(x)^m$，最后答案乘上 $\dfrac{i!}{m!}$ 就可以了。</p><p>仍然注意第一项为 $0$，所以要先右移一位，做完后，再左移 $m$ 位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    n ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++ i) a[i] = <span class="built_in">qpow</span>(i + <span class="number">1</span>, Mod - <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">get_qpow</span>(a, b, n - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= k; -- i) b[i] = b[i - k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i) b[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, b[i] * infact[k] % Mod * fact[i] % Mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFT 详解</title>
      <link href="/2021/12/11/FFT-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/12/11/FFT-%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><strong>前方高能！</strong></p><span id="more"></span><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>本节是数学之中算非常难的模板题了。</p><p>注意，如果有没学过的知识点，请记住结论即可，不必深挖使自己绕晕。</p><h2 id="1-解决问题"><a href="#1-解决问题" class="headerlink" title="1. 解决问题"></a>1. 解决问题</h2><p>求两个高次多项式的乘积。</p><p>设 $A(x)$ 多项式为 $n$ 次，$B(x)$ 多项式为 $m$ 次（$n\geq m$）。</p><p>朴素复杂度为 $O(nm)$，该算法可以在 $O(n\log n)$ 的时间求出。</p><h2 id="2-主要方法"><a href="#2-主要方法" class="headerlink" title="2. 主要方法"></a>2. 主要方法</h2><h3 id="1）前置知识"><a href="#1）前置知识" class="headerlink" title="1）前置知识"></a>1）前置知识</h3><h4 id="A-点值表示"><a href="#A-点值表示" class="headerlink" title="A. 点值表示"></a>A. 点值表示</h4><p>任意一个 $n$ 次多项式都可以用任意 $n+1$ 个点来表示，其中 $n+1$ 个点都在函数上。</p><p>证明不难，就是 $n+1$ 个 $n+1$ 元一次方程有唯一解。</p><p>经过“范德蒙矩阵”的行列式推导，当且仅当 $x_i\not=x_j(i\not=j)$ 时原方程有唯一解。</p><h4 id="B-复数的基本运算"><a href="#B-复数的基本运算" class="headerlink" title="B. 复数的基本运算"></a>B. 复数的基本运算</h4><p>首先，令 $i=\sqrt{-1}$。</p><p>所以，所有的复数都可以表示为 $a+bi$。</p><p>复数的加法：$(a+bi)+(c+di)=(a+c) +(b+d)i$。</p><p>用向量的角度看，就是两个向量的合成。</p><p>复数的乘法：$(a+bi)\times(c+di)$$=(ac-bd)+(ad+bc)i$。</p><p>从向量的角度看，乘积的模就为原来的向量的模的乘积。</p><p>乘积的角度为 $\theta=\theta_1+\theta_2$。$\theta$ 为向量与 x 轴正半轴的夹角。</p><h4 id="C-复数域上的单位根"><a href="#C-复数域上的单位根" class="headerlink" title="C. 复数域上的单位根"></a>C. 复数域上的单位根</h4><p>画一个单位圆。</p><p>将该圆划分为 $n$ 份，从 $x$ 轴正半轴逆时针取了 $k$ 份后，终边所表示的向量记为 $\omega_n^k$。</p><p>$n$ 次单位根为：$\omega_n^k(k\in [0,n-1])$。</p><p>它有几个性质：</p><ol><li>$\forall i\not=j,\omega_n^i \not=\omega_n^j$。</li><li>$\omega_n^k=\cos\dfrac{2k \pi}{n}+\sin\dfrac{2k\pi}{n}i$。</li><li>$\omega_n^0=\omega_n^n=1$。</li><li>$\omega_{2n}^{2k}=\omega_n^k$。</li><li>$\omega_n^{k+\frac{n}{2}}=-\omega_n^k$。</li></ol><p>同样，具有上述几个性质的点也是 $n$ 次单位根。</p><h3 id="2）核心：点值表示与系数表示的转换"><a href="#2）核心：点值表示与系数表示的转换" class="headerlink" title="2）核心：点值表示与系数表示的转换"></a>2）核心：点值表示与系数表示的转换</h3><p>在 FFT 中，我们一共取 $n+m+1$ 个点。</p><p>怎样求出 $C(x)$ 的表达式？</p><p>我们设定 $n+m+1$ 个点，然后求出每一个点的函数值，就求出了点值表示。</p><p>怎样转换为系数表示呢？</p><p>首先，我们考虑取哪些点。</p><p>对于 $A(x)$ 来说，我们取 $\omega_n^k (k\in[0,n-1])$ $n$ 个横坐标。</p><p>我们还是首先考虑怎样从系数表示转换为点值表示。</p><p>然后，我们按次数分类，分为奇数次和偶数次。</p><p>$A(x)=a_0+a_1x+a_2x^2+…+a_{n-1}z^{n-1}$。</p><p>假设 $n$ 为偶数。</p><p>$A_1(x)=a_0+a_2x+a_4x^2+…+a_{n-2}x^{\frac{n}{2}-1}$。</p><p>$A_2(x)=a_1+a_3x+a_5x^2+…+a_{n-1}x^{\frac{n}{2}-1}$。</p><p>所以，我们惊喜地发现：$A(x)=A_1( x^2)+xA_2(x^2)$！</p><p>然后我们将 $\omega_n^k$ 代入，得到：</p><p>如果 $k\in[0,\dfrac{n}{2}-1]$，原式可以写成：<br>$$<br>\begin{aligned}<br>A(\omega_n^k)=A_1(\omega_n^{2k})+\omega_n^kA_2(\omega_n^{2k})<br>\\=A_1(\omega_{\frac{n}{2}}^k)+\omega_n^kA_2(\omega_{\frac{n}{2}}^k)<br>\end{aligned}<br>$$<br>如果 $k\in[\dfrac{n}{2},n-1]$，原式可以写成：<br>$$<br>A(\omega_n^k)=A_1(\omega_n^{2k})+\omega_n^kA_2(\omega_n^{2k})\\=A_1(\omega_n^{2k-n})-\omega_n^{k-\frac{n}{2}}A_2(\omega_n^{2k-n})<br>$$</p><p>这样，我们就可以在 $O(n\log n)$ 的时间内从系数表示转换到点值表示。</p><p>下面，我们进行逆变化：从点值表示转换到系数表示。</p><p>假设最终的答案为 $A(x)=c_0+c_1x+…+ c_{n-1}x^{n-1}$。</p><p><strong>结论：</strong><br>$$<br>c_k=\dfrac{\sum_{i=0}^{n-1}y_i(\omega_n^{-k})^i}{n}<br>$$<br>其中，$y_i$ 表示最终得到的纵坐标。</p><p>首先，我们假设该结论成立。</p><p>再定义 $B(x)=y_0+y_1x+y_2x^2+…+y_{n-1}x^ {n-1}$。</p><p>不难发现 $c_i=B(\omega_n^{-i})$。</p><p>所以，我们相当于把 $B$ 从系数表示法转换为点值表示法，就在做一次前面的即可。</p><p>可以发现（？），有一个负号不影响答案。</p><p>好，下面我们来证明该结论。</p><p><strong>证明：（从结论反推）</strong><br>$$<br>n*c_k=\sum_{i=0}^{n-1}y_i(\omega_{n}^ {-k})^i\\=\sum_{i=0}^{n-1}(\sum_{j= 0}^{n-1}c_j(\omega_{n}^{i})^j)(\omega _{n}^{-k})^i<br>$$</p><p>$$<br>\begin{aligned}<br>=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}c_j (\omega_{n}^{i})^j(\omega_{n}^{-k})^i<br>\\=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1} c_j(\omega_{n}^{j-k})^i<br>\end{aligned}<br>$$</p><p>$$<br>=\sum_{j=0}^{n-1}c_j(\sum_{i=0}^{n-1} (\omega_{n}^{j-k})^i)<br>$$</p><p>在最里面的括号 $(\omega_{n}^{j-k})^i$，$j,k$ 都是常量，$i$ 是变量，所以我们可以再构造 $D(x)=\sum <em>{i=0}^{n-1}x^i$，原式就可以化成：<br>$$<br>=\sum</em>{j=0}^{n-1}c_j*D(\omega_{n}^{j-k})<br>$$<br>接着，我们讨论 $D(\omega_{n}^{x})$ 的取值：</p><p>$x\not=0$：，首先，$D(\omega_{n}^{x})= \omega_{n}^{0}+\omega_{n}^{x}+ \omega_{n}^{2x}+…+\omega_{n} ^{(n-1)x}$。</p><p>其次，$\omega_{n}^{x}D( \omega_{n}^{x})=\omega_{n}^{x}+ \omega_{n}^{2x}+…+\omega_{n} ^{(n-1)x}+(\omega_{n}^{nx}=0)$。</p><p>发现，这两项相等。</p><p>于是，$(\omega_{n}^{x}-1)D(\omega_{n}^{x})=0$，又 $x\not=0$，所以 $\omega_{n}^{x}\not=1$，于是 $D(\omega_{n}^{x})=0$。</p><p>$x=0$：$D(\omega_{n}^{x})=D(1)=n$。</p><p>所以，当 $j\not=k$ 时，原式为 $0$。</p><p>带入原式，便可以得到：<br>$$<br>=nc_k<br>$$<br><strong>证毕。</strong></p><p>现在，我们讨论的是怎样求出 $n$ 次单位根对应的点值。</p><p>首先，有前面推导的式子：<br>$$<br>A(\omega_{n}^{k})=A_1(\omega_{\frac{n}{2}}^{k})+\omega_{n}^{k}A_2(\omega <em>{\frac{n}{2}}^{k})\\A(\omega</em>{n}^{ k+\frac{n}{2}})=A_1(\omega_{\frac{n} {2}}^{k})-\omega_{n}^{k}A_2(\omega _{\frac{n}{2}}^{k})<br>$$<br>在实践中，递归的常数较大，我们使用迭代。</p><p>首先，我们发现，如果 $i\leq\dfrac{n}{2}$，就可以得到 $a_i=b_i+\omega_{n}^ic_i$，如果 $i&gt;\dfrac{n}{2}$，就可以得到 $a_i= b_i-\omega_{n}^{i-\frac{n}{2}}c_i$，其中 $b_i,c_i$ 分别表示左边和右边求出来的系数，分别对应偶数求出来的点值和奇数次方求出来的点值。</p><p>我们每一次求点值时，会递归并将偶数次项的放前面，将奇数次项的放后面，然后计算出前后的 $n$ 次方根的数值，然后将答案合并即可。</p><p>来看一张图。</p><p>（红色 $a$ 表示系数的长度，蓝色 $b$ 表示已经求出的点值的合并，黑色表示点值的转移）</p><img src="/2021/12/11/FFT-%E8%AF%A6%E8%A7%A3/FFT.png" class=""><p>首先，我们要预处理第一层，即 $b$ 的最上面一层。</p><p>我们找一下规律：第零个 $0$，第一个 $4$，……</p><p>可以发现，答案求出的就是二进制的翻转，这个例子中是指三位的异或。</p><p>我们考虑刚才的结论怎么证明。</p><p>其实很简单：如果最后一位为 $1$，则放在右边，也就是当前的最高位为 $1$，也就是翻转了。</p><p>假设 $bit$ 位的翻转，我们怎样求出翻转结果呢？</p><p>记要翻转的数为 $i$，结果为 $\text{rev}(i)$。</p><p>首先，我们将最后一位不看，即为 $i/2$，然后将剩下的翻转，为 $\text{rev}(i/2)$，然后在最前面补上前面的最后一位。</p><p>所以，我们可以得到一个递推公式：<code>rev[i] = (rev[i &gt;&gt; 1]) | (i &amp; 1) &lt;&lt; (bit - 1)</code>。</p><p>至此，所有的推导全部结束。</p><p><strong>大功告成！！！</strong></p><p>最后的最后，我们总结一下整体的思路。</p><p>首先，将两个式子分别从系数表示转换为点值表示，其中要使用到递归（或迭代）求点值，最后用两边合并为当前，时间复杂度为 $O(n\log n)$。</p><p>然后，用点值表示将两个式子乘起来，直接得到 $O(n)$。</p><p>然后，我们将得到的式子用一个证明，即为点值做系数，$\omega_{n}^{-k}$ 做自变量，就可以求出 $n*c_k$ 的值，这再做一次前面的正向即可。</p><p>最后，除以 $n$ 输出即可。</p><p>至此，上代码。可能还是有一些地方没有讲清楚，请读者看代码吧<del>（逃</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="keyword">const</span> Complex <span class="keyword">operator</span> +(<span class="keyword">const</span> Complex &amp;t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Complex)&#123;x + t.x, y + t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> Complex <span class="keyword">operator</span> -(<span class="keyword">const</span> Complex &amp;t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Complex)&#123;x - t.x, y - t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> Complex <span class="keyword">operator</span> *(<span class="keyword">const</span> Complex &amp;t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Complex)&#123;x * t.x - y * t.y, x * t.y + y * t.x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> tot, bit, rev[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex a[], <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (rev[i] &lt; i) <span class="built_in">swap</span>(a[rev[i]], a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Complex w1 = (Complex)&#123;<span class="built_in">cos</span>(PI / mid), <span class="built_in">sin</span>(inv * PI / mid)&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += mid * <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Complex now = (Complex)&#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j ++, now = now * w1)</span><br><span class="line">            &#123;</span><br><span class="line">                Complex x = a[i + j], y = now * a[i + j + mid];</span><br><span class="line">                a[i + j] = x + y, a[i + j + mid] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a[i].x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;b[i].x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; n + m + <span class="number">1</span>) bit ++;</span><br><span class="line">    tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; bit - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FFT</span>(a, <span class="number">1</span>);<span class="built_in">FFT</span>(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++ i) a[i] = a[i] * b[i];</span><br><span class="line">    <span class="built_in">FFT</span>(a, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + m; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in"><span class="keyword">int</span></span>((a[i].x / tot) + <span class="number">0.5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIp2021 游记</title>
      <link href="/2021/11/20/NOIp2021-%E6%B8%B8%E8%AE%B0/"/>
      <url>/2021/11/20/NOIp2021-%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>可还行吧。</p><span id="more"></span><p>以考试当天（2021-11-20）为 Day 0。</p><h2 id="Day"><a href="#Day" class="headerlink" title="Day -?"></a>Day -?</h2><p>记录两次机房的对话。</p><hr><p>我：”又在卷网络流！怎么可能考得到嘛。“</p><p>机房大佬：”CSP-S 才考了，肯定是在考纲范围内啊。已经是废物了，还不快复习网络流。”</p><p>我（表示不信）：“怎么可能？才考了，怎么可能还考得到？”</p><hr><p>我：“模拟退火都要学！啥分都骗不到，估计和暴力差不多。”</p><p>机房大佬：“骗分的东西，还是要多学的。”</p><p>我：“骗分的东西，考试的时候又用不到，还学这么高深的算法。这么久都没考了，不可能考啊”。</p><hr><p>事实证明，还是不能随便押题啊。模拟退火就考到了……</p><p>考前和省外的联测，天天被吊打，怎么办啊……</p><p>已经停了 whk 专心搞竞赛了，但是感觉没有很大的提升，倒是身旁的大佬多了起来。不知道更卷的地方是什么样呢，反正已经比我强多了。</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h2><p>本身根据机房习俗，应该是 <code>考前 generals 大赛</code>，但是由于之前机房发生过事故（具体什么就略去了），所以不敢参加。</p><p>倒是解决了一个遗留问题：（在 CSP-S 当天早上写的 Treap 60 pts 那个）在 NOIP 前一天解决了！简直是 rp ++！</p><p>又 A 了一个黑题（CF 的虚高黑题），考前心态还是挺不错的。</p><p>晚上同寝室的还比较照顾我，本身应该说话到 11:00 的，很早（10：30 之前）就都睡了。</p><p>我却翻来覆去，一直睡不着，不知道明天如果考挂了，自己的前途将会是如何。</p><p>但不管怎样，考试还是得来临，我迷迷糊糊之中还是睡着了。</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>早上 8:00 到考场，发现已经挤满了人（本身考点人就不多，基本都在外面）。</p><p>赶忙进去，开了虚拟机，开始敲模板，感觉键盘比较拙劣，平均 3 个字符就有一个吃掉了，只要集中在 <code>s,j,(</code> 这些字符，很难打。<code>(</code> 最烦，我又开了 <code>-Wall</code> 的，很容易打掉括号。</p><p>几分钟码完了模板，开始呆坐。只能看到标题，也就只是复制了几遍模板，放在那里，命好名，啥也不能干了。</p><p>8:22 发了密码，赶忙翻到 T1，但是刚翻到老师就说不准动键盘，于是只能盯着 T1 看。但是旁边的人一直在动鼠标，老师也没有管（大草</p><p>8:30：正式开始！</p><p>看了遍题，没什么思路（其实是没认真看）。</p><p>感觉第一题是一个签到的题目，虽然是 $10^7$，埃式筛法是 $O(n\ln n)$，但是不是每一个数都要筛一遍，所以赶忙码了一个，测速只需要 0.3s，所以 20 min 就做完了签到题。</p><p>8:50 左右开第二题。第二题似乎是一个神仙 DP，可以顺序枚举每一个数被取的次数，主要是进位十分烦人。考虑可以用一个状态存下来向前的进位，发现最多只是 $n$ 的级别。</p><p>中间算错了几次复杂度，一直算的都是 $O(n^3m)$（因为状态个数就是 $O(n^3m)$），码了一半，发现还需要一个 $n$ 枚举每一个数枚举的次数，复杂度升到 $O(n^4m)$，计算器一算，$3\times10^8$，但一想到有很多状态不存在，直接跳过就好，所以不太关心。</p><p>写了 25min 左右，差不多 9:40，调还算顺利，调了一会就出来了，给的样例又不是大样例（觉得是大样例的站出来！），没感觉到什么就对了。</p><p>9:55 左右看第三题，感觉是一个神仙题，虽然是方差知道怎么求，$=nS2-S1^2$，但是啥性质都推不出来了。第四题题面又臭又长，但是又不得不看，有些搞心态。</p><p>又回来推第三题，想了半个小时才发现可以差分，就是邻项交换。似乎可以暴力枚举的，手写了一个暴力观察性质。</p><p>发现了应该单谷，但是想了几个贪心都是错的，不知道怎么回事。后来才发现贪心就是错的。</p><p>这时已经 11:30 了，只好放弃 T3，马上去写 T4，发现只有直行的可以维护每一行列的覆盖情况，发现可以倒序变成加点的形式。</p><p>但是似乎极其难写，只写了个暴力，30 min 写完跑路。</p><p>又倒过来看 T3，已经 12:10 了，感觉可以区间 DP 的样子，但是方差的公式实在用差分的形式太难变形了，只好放弃。</p><p>12:30 的时候，突然灵光一闪：我的贪心答案和正确答案差不了多少，可不可以通过随机交换的方式来得到更优解呢？</p><p>于是我想到了模拟退火（大草</p><p>从来没写过模拟退火，这次在 NOIP 考场上算是第一次写。</p><p>我看过书上的解释，但是当时没有给代码，心里还是没底的。</p><p>不过模拟退火还好写，10 min 就写完了。</p><p>不过死活过不了大样例，答案比最开始的贪心答案还大一倍（这里说一说我的神奇模拟退火（赛后知晓）：我中间有判断，如果 <code>time&gt;0.9</code> 就直接退出；但是我有没有全局变量来维护走过的最佳答案），不免极慌。</p><p>一阵魔改之后，过掉了样例 3，但样例 4 实在是过不了了，此时已经 12:55 了。</p><p>我不知道应该怎样改才是合适的，但是最后时分，我将多次退火改为了一次退火，精度调的极高：<code>for (double t = 1e9; t &gt; 1e-7; t *= 0.9999997)</code>，没时间测样例的，我赶忙将文件看了一下，没有多余输出，都有 <code>freopen</code>。</p><p>检查完后，看到 12:59:30 了，本身想测 T3 大样例的，也只好罢休了。</p><blockquote><p>考试结束，不允许再动键盘鼠标了，迅速离开。</p></blockquote><p>寂寞的走出考场，交流了一下，发现许多人没有写出 T2，但是都写出了 T3 的模拟退火。</p><p>哎，要是我学了模拟退火该多好啊！</p><p>但是，过去的已经过去了。</p><p>机房大佬说，模拟退火应该有 $40\sim56pts$，但是我的假的模拟退火，差不多有个 $16pts$ 差不多了。</p><p>仔细算了一下：$100+100+[0\sim 20]+[32\sim48]=[232\sim268]$ 的成绩了吧。</p><p>看到去年的一等奖线都是 100+ 不少，想到万一 T2 挂了肯定就上不了一等奖线了。</p><p>但是估计在全省大概就是 $rk25\sim40$ 吧，可能又是省队三倍线上不了了吧。</p><p>不管了，休息了两天，又要回归 whk 了。</p><h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>还没时间写，不过已经有时间看别人的博客了。</p><p>发现大家似乎都是 $200pts$ 左右吧，心态稳了一些。</p><p>代码发下来了，但是不敢在 Luogu 上测，就连 xtl 都不敢看。</p><p>又浑浑噩噩过了一天。</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>还是看到了 xtl 的成绩，又到 Luogu 上测了一下。</p><p>发现 T2 挂了 $15 pts$，T4 由于多组询问全部都清空，直接导致只有 $24 pts$。</p><p>不过可喜可贺的是，我的模拟退火竟然写对了，再加上推出了差分单谷的性质，直接得到了 88 pts！</p><p>Luogu 评测：$100+85+88+24=297$，xtl $301$。据说可以进 $rk15$。</p><p>等 CCF 的成绩吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次考试，主要是策略相对正确，但是有很多细节地方应该注意，比如神仙挂分：T2 现在都不知道怎么挂的（求助，14-16 全 WA），T4 全部清空导致时间复杂度卡满了，只有 $24 pts$。</p><p>其实可以 $100+100+88+44=332$ 的，似乎轻松进 $rk10$ 了。</p><p>过去的已经过去了，还是向下一站进发吧！</p><p>2022 联合省选加油！</p><p><strong>upd on 2021-11-29：</strong> CCF T3 送了我 96 pts，看到了一些希望。</p><p>实际分数：$100+85+96+24=305$。</p><p>（另外，看到了 T2 的错误了，我在判断条件的时候，判断本位的时候写错了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随机蓝题100道</title>
      <link href="/2021/11/12/%E9%9A%8F%E6%9C%BA%E8%93%9D%E9%A2%98100%E9%81%93/"/>
      <url>/2021/11/12/%E9%9A%8F%E6%9C%BA%E8%93%9D%E9%A2%98100%E9%81%93/</url>
      
        <content type="html"><![CDATA[<p>这个是我在 CSP-S 复习前进行刷题目，采用随机跳题 100 道的方法。</p><p><strong>争取在 NOIP 之前做完啊！！</strong></p><span id="more"></span><h2 id="1-正文"><a href="#1-正文" class="headerlink" title="1. 正文"></a>1. 正文</h2><h4 id="T1：P4147-玉蟾宫"><a href="#T1：P4147-玉蟾宫" class="headerlink" title="T1：P4147 玉蟾宫"></a>T1：<a href="https://www.luogu.com.cn/problem/P4147">P4147 玉蟾宫</a></h4><p>这个是一个单调栈（或者叫悬线法）的模板题。</p><p>求 01 矩阵中只包含 1 的矩阵的面积最大值。</p><h4 id="T2：P4854-MloVtry的咸鱼树"><a href="#T2：P4854-MloVtry的咸鱼树" class="headerlink" title="T2：P4854 MloVtry的咸鱼树"></a>T2：<a href="https://www.luogu.com.cn/problem/P4854">P4854 MloVtry的咸鱼树</a></h4><p>状态压缩 + 最短路。</p><p>不太难想，看到 $n\leq15$ 的时候应该就有思路了。</p><h4 id="T3：UVA10881-Piotr’s-Ants"><a href="#T3：UVA10881-Piotr’s-Ants" class="headerlink" title="T3：UVA10881 Piotr’s Ants"></a>T3：<a href="https://www.luogu.com.cn/problem/UVA10881">UVA10881 Piotr’s Ants</a></h4><p>接下来的两个题都是以前校内考试考过的题目的变式，大概思路是人的相对位置（即左右的排名）和所有人都绝对位置（即坐标）分离处理。两个题虽然有些不同，但是大体思路是向东的。</p><h4 id="T4：P5835-USACO19DEC-Meetings-S"><a href="#T4：P5835-USACO19DEC-Meetings-S" class="headerlink" title="T4：P5835 [USACO19DEC]Meetings S"></a>T4：<a href="https://www.luogu.com.cn/problem/P5835">P5835 [USACO19DEC]Meetings S</a></h4><h4 id="T5：P5022-NOIP2018-提高组-旅行"><a href="#T5：P5022-NOIP2018-提高组-旅行" class="headerlink" title="T5：P5022 [NOIP2018 提高组] 旅行"></a>T5：<a href="https://www.luogu.com.cn/problem/P5022">P5022 [NOIP2018 提高组] 旅行</a></h4><p>CSP-S 前做的题目，主要是看一看以前的题目。</p><p>也归入了 CSP-S 的随机蓝题了 qwq。</p><h4 id="T6：P1127-词链"><a href="#T6：P1127-词链" class="headerlink" title="T6：P1127 词链"></a>T6：<a href="https://www.luogu.com.cn/problem/P1127">P1127 词链</a></h4><p>一个欧拉回路的好题。</p><h4 id="T7：P1961-最轻的天平"><a href="#T7：P1961-最轻的天平" class="headerlink" title="T7：P1961 最轻的天平"></a>T7：<a href="https://www.luogu.com.cn/problem/P1961">P1961 最轻的天平</a></h4><p>没有任何所谓的算法（最多一个 gcd），就是思想可鉴。</p><h4 id="T8：P5087-数学"><a href="#T8：P5087-数学" class="headerlink" title="T8：P5087 数学"></a>T8：<a href="https://www.luogu.com.cn/problem/P5087">P5087 数学</a></h4><p>没想到是 DP，看来看出 DP 还是有一定难度的。</p><p>主要是没有想到重复元素怎么搞。</p><h4 id="T9：P5994-PA2014-Kuglarz"><a href="#T9：P5994-PA2014-Kuglarz" class="headerlink" title="T9：P5994 [PA2014]Kuglarz"></a>T9：<a href="https://www.luogu.com.cn/problem/P5994">P5994 [PA2014]Kuglarz</a></h4><p>一个 Prim 的好题。</p><h4 id="T10：P6859-蝴蝶与花"><a href="#T10：P6859-蝴蝶与花" class="headerlink" title="T10：P6859 蝴蝶与花"></a>T10：<a href="https://www.luogu.com.cn/problem/P6859">P6859 蝴蝶与花</a></h4><p>校内考到原题了！（在我做了这个题之后）</p><p>还是有些毒瘤（卡到了最优解），但是还好。</p><p>首先数据结构内二分查找 $pre_i=tot/pre_i=tot+1$ 的 $i$，然后找下一个 1 就可以了。</p><h4 id="T11：P6327-区间加区间sin和"><a href="#T11：P6327-区间加区间sin和" class="headerlink" title="T11：P6327 区间加区间sin和"></a>T11：<a href="https://www.luogu.com.cn/problem/P6327">P6327 区间加区间sin和</a></h4><p>线段树的板子。不说了。</p><p>（但是得复习 $sin(\alpha+\beta)=\sin\alpha\cos\beta+\cos\alpha\sin\beta $）</p><h4 id="T12：P1783-海滩防御"><a href="#T12：P1783-海滩防御" class="headerlink" title="T12：P1783 海滩防御"></a>T12：<a href="https://www.luogu.com.cn/problem/P1783">P1783 海滩防御</a></h4><p>一个简单的二分题目。</p><h4 id="T13：P7878-「SWTR-07」My-rating-is-1064（hard-version）"><a href="#T13：P7878-「SWTR-07」My-rating-is-1064（hard-version）" class="headerlink" title="T13：P7878 「SWTR-07」My rating is 1064（hard version）"></a>T13：<a href="https://www.luogu.com.cn/problem/P7878">P7878 「SWTR-07」My rating is 1064（hard version）</a></h4><p>考场上做出来的。不说了。</p><h4 id="T14：P5184-COCI-2009-PASIJANS"><a href="#T14：P5184-COCI-2009-PASIJANS" class="headerlink" title="T14：P5184 [COCI 2009] PASIJANS"></a>T14：<a href="https://www.luogu.com.cn/problem/P5184">P5184 [COCI 2009] PASIJANS</a></h4><p>看似很简单，但是要处理前面相同的栈的处理。</p><h4 id="T15：P3917-异或序列"><a href="#T15：P3917-异或序列" class="headerlink" title="T15：P3917 异或序列"></a>T15：<a href="https://www.luogu.com.cn/problem/P3917">P3917 异或序列</a></h4><p>校内考过<br>$$<br>\sum_{i=1}^n\sum_{j=i}^n(a_i\ xor …xor\ a_j)^2<br>$$<br>所以就比较简单了。</p><h4 id="T16：P2512-HAOI2008-糖果传递"><a href="#T16：P2512-HAOI2008-糖果传递" class="headerlink" title="T16：P2512 [HAOI2008]糖果传递"></a>T16：<a href="https://www.luogu.com.cn/problem/P2512">P2512 [HAOI2008]糖果传递</a></h4><p>简单的贪心。</p><h4 id="T17：P1846-游戏"><a href="#T17：P1846-游戏" class="headerlink" title="T17：P1846 游戏"></a>T17：<a href="https://www.luogu.com.cn/problem/P1846">P1846 游戏</a></h4><p>很有意思，很难想到会用 DP。</p><h4 id="T18：P2148-SDOI2009-E-amp-D"><a href="#T18：P2148-SDOI2009-E-amp-D" class="headerlink" title="T18：P2148 [SDOI2009]E&amp;D"></a>T18：<a href="https://www.luogu.com.cn/problem/P2148">P2148 [SDOI2009]E&amp;D</a></h4><p>有结论。（自己翻题解吧 qwq</p><h4 id="T19：P4441-COCI2017-2018-3-Retro"><a href="#T19：P4441-COCI2017-2018-3-Retro" class="headerlink" title="T19：P4441 [COCI2017-2018#3] Retro"></a>T19：<a href="https://www.luogu.com.cn/problem/P4441">P4441 [COCI2017-2018#3] Retro</a></h4><h4 id="T20：P5689-CSP-S2019-江西-多叉堆"><a href="#T20：P5689-CSP-S2019-江西-多叉堆" class="headerlink" title="T20：P5689 [CSP-S2019 江西] 多叉堆"></a>T20：<a href="https://www.luogu.com.cn/problem/P5689">P5689 [CSP-S2019 江西] 多叉堆</a></h4><h4 id="T21：P5771-JSOI2016-反质数序列"><a href="#T21：P5771-JSOI2016-反质数序列" class="headerlink" title="T21：P5771 [JSOI2016]反质数序列"></a>T21：<a href="https://www.luogu.com.cn/problem/P5771">P5771 [JSOI2016]反质数序列</a></h4><h4 id="T22：P3946-ことりのおやつ（小鸟的点心）"><a href="#T22：P3946-ことりのおやつ（小鸟的点心）" class="headerlink" title="T22：P3946 ことりのおやつ（小鸟的点心）"></a>T22：<a href="https://www.luogu.com.cn/problem/P3946">P3946 ことりのおやつ（小鸟的点心）</a></h4><h4 id="T23：P6216-回文匹配"><a href="#T23：P6216-回文匹配" class="headerlink" title="T23：P6216 回文匹配"></a>T23：<a href="https://www.luogu.com.cn/problem/P6216">P6216 回文匹配</a></h4><h4 id="T24：P3743-kotori的设备"><a href="#T24：P3743-kotori的设备" class="headerlink" title="T24：P3743 kotori的设备"></a>T24：<a href="https://www.luogu.com.cn/problem/P3743">P3743 kotori的设备</a></h4><h4 id="T25：P3572-POI2014-PTA-Little-Bird"><a href="#T25：P3572-POI2014-PTA-Little-Bird" class="headerlink" title="T25：P3572 [POI2014]PTA-Little Bird"></a>T25：<a href="https://www.luogu.com.cn/problem/P3572">P3572 [POI2014]PTA-Little Bird</a></h4><h4 id="T26：P3601-签到题"><a href="#T26：P3601-签到题" class="headerlink" title="T26：P3601 签到题"></a>T26：<a href="https://www.luogu.com.cn/problem/P3601">P3601 签到题</a></h4><h4 id="T27：P2627-USACO11OPEN-Mowing-the-Lawn-G"><a href="#T27：P2627-USACO11OPEN-Mowing-the-Lawn-G" class="headerlink" title="T27：P2627 [USACO11OPEN]Mowing the Lawn G"></a>T27：<a href="https://www.luogu.com.cn/problem/P2627">P2627 [USACO11OPEN]Mowing the Lawn G</a></h4><h4 id="T28：P4503-CTSC2014-企鹅QQ"><a href="#T28：P4503-CTSC2014-企鹅QQ" class="headerlink" title="T28：P4503 [CTSC2014]企鹅QQ"></a>T28：<a href="https://www.luogu.com.cn/problem/P4503">P4503 [CTSC2014]企鹅QQ</a></h4><h4 id="T29：P1602-Sramoc问题"><a href="#T29：P1602-Sramoc问题" class="headerlink" title="T29：P1602 Sramoc问题"></a>T29：<a href="https://www.luogu.com.cn/problem/P1602">P1602 Sramoc问题</a></h4><h4 id="T30：P2267-琪琪的项链"><a href="#T30：P2267-琪琪的项链" class="headerlink" title="T30：P2267 琪琪的项链"></a>T30：<a href="https://www.luogu.com.cn/problem/P2267">P2267 琪琪的项链</a></h4><h4 id="T31：CF1082B-Vova-and-Trophies"><a href="#T31：CF1082B-Vova-and-Trophies" class="headerlink" title="T31：CF1082B Vova and Trophies"></a>T31：<a href="https://www.luogu.com.cn/problem/CF1082B">CF1082B Vova and Trophies</a></h4><h4 id="T32：P3029-USACO11NOV-Cow-Lineup-S"><a href="#T32：P3029-USACO11NOV-Cow-Lineup-S" class="headerlink" title="T32：P3029 [USACO11NOV]Cow Lineup S"></a>T32：<a href="https://www.luogu.com.cn/problem/P3029">P3029 [USACO11NOV]Cow Lineup S</a></h4><h4 id="T33：P2622-关灯问题II"><a href="#T33：P2622-关灯问题II" class="headerlink" title="T33：P2622 关灯问题II"></a>T33：<a href="https://www.luogu.com.cn/problem/P2622">P2622 关灯问题II</a></h4><h4 id="T34：P4092-HEOI2016-TJOI2016-树"><a href="#T34：P4092-HEOI2016-TJOI2016-树" class="headerlink" title="T34：P4092 [HEOI2016/TJOI2016]树"></a>T34：<a href="https://www.luogu.com.cn/problem/P4092">P4092 [HEOI2016/TJOI2016]树</a></h4><h4 id="T35：P4826-USACO15FEB-Superbull-S"><a href="#T35：P4826-USACO15FEB-Superbull-S" class="headerlink" title="T35：P4826 [USACO15FEB]Superbull S"></a>T35：<a href="https://www.luogu.com.cn/problem/P4826">P4826 [USACO15FEB]Superbull S</a></h4><h4 id="T36：P6218-USACO06NOV-Round-Numbers-S"><a href="#T36：P6218-USACO06NOV-Round-Numbers-S" class="headerlink" title="T36：P6218 [USACO06NOV] Round Numbers S"></a>T36：<a href="https://www.luogu.com.cn/problem/P6218">P6218 [USACO06NOV] Round Numbers S</a></h4><h4 id="T37：P3469-POI2008-BLO-Blockade"><a href="#T37：P3469-POI2008-BLO-Blockade" class="headerlink" title="T37：P3469 [POI2008]BLO-Blockade"></a>T37：<a href="https://www.luogu.com.cn/problem/P3469">P3469 [POI2008]BLO-Blockade</a></h4><h4 id="T38：P6016-CSGRound3-出游"><a href="#T38：P6016-CSGRound3-出游" class="headerlink" title="T38：P6016 [CSGRound3]出游"></a>T38：<a href="https://www.luogu.com.cn/problem/P6016">P6016 [CSGRound3]出游</a></h4><h4 id="T39：P2129-L国的战斗续之多路出击"><a href="#T39：P2129-L国的战斗续之多路出击" class="headerlink" title="T39：P2129 L国的战斗续之多路出击"></a>T39：<a href="https://www.luogu.com.cn/problem/P2129">P2129 L国的战斗续之多路出击</a></h4><h4 id="T40：P2915-USACO08NOV-Mixed-Up-Cows-G"><a href="#T40：P2915-USACO08NOV-Mixed-Up-Cows-G" class="headerlink" title="T40：P2915 [USACO08NOV]Mixed Up Cows G"></a>T40：<a href="https://www.luogu.com.cn/problem/P2915">P2915 [USACO08NOV]Mixed Up Cows G</a></h4><h4 id="T41：P2174-小Z的神奇数列"><a href="#T41：P2174-小Z的神奇数列" class="headerlink" title="T41：P2174 小Z的神奇数列"></a>T41：<a href="https://www.luogu.com.cn/problem/P2174">P2174 小Z的神奇数列</a></h4><h4 id="T42：P1262-间谍网络"><a href="#T42：P1262-间谍网络" class="headerlink" title="T42：P1262 间谍网络"></a>T42：<a href="https://www.luogu.com.cn/problem/P1262">P1262 间谍网络</a></h4><h4 id="T43：P1245-电话号码"><a href="#T43：P1245-电话号码" class="headerlink" title="T43：P1245 电话号码"></a>T43：<a href="https://www.luogu.com.cn/problem/P1245">P1245 电话号码</a></h4><h4 id="T44：P4231-三步必杀"><a href="#T44：P4231-三步必杀" class="headerlink" title="T44：P4231 三步必杀"></a>T44：<a href="https://www.luogu.com.cn/problem/P4231">P4231 三步必杀</a></h4><h4 id="T45：P2585-ZJOI2006-三色二叉树"><a href="#T45：P2585-ZJOI2006-三色二叉树" class="headerlink" title="T45：P2585 [ZJOI2006]三色二叉树"></a>T45：<a href="https://www.luogu.com.cn/problem/P2585">P2585 [ZJOI2006]三色二叉树</a></h4><h4 id="T46：P2700-逐个击破"><a href="#T46：P2700-逐个击破" class="headerlink" title="T46：P2700 逐个击破"></a>T46：<a href="https://www.luogu.com.cn/problem/P2700">P2700 逐个击破</a></h4><h4 id="T47：P6688-可重集"><a href="#T47：P6688-可重集" class="headerlink" title="T47：P6688 可重集"></a>T47：<a href="https://www.luogu.com.cn/problem/P6688">P6688 可重集</a></h4><h4 id="T48：P3177-HAOI2015-树上染色"><a href="#T48：P3177-HAOI2015-树上染色" class="headerlink" title="T48：P3177 [HAOI2015]树上染色"></a>T48：<a href="https://www.luogu.com.cn/problem/P3177">P3177 [HAOI2015]树上染色</a></h4><h4 id="T49：P2602-ZJOI2010-数字计数"><a href="#T49：P2602-ZJOI2010-数字计数" class="headerlink" title="T49：P2602 [ZJOI2010]数字计数"></a>T49：<a href="https://www.luogu.com.cn/problem/P2602">P2602 [ZJOI2010]数字计数</a></h4><h4 id="T50：P1836-数页码"><a href="#T50：P1836-数页码" class="headerlink" title="T50：P1836 数页码"></a>T50：<a href="https://www.luogu.com.cn/problem/P1836">P1836 数页码</a></h4><h4 id="T51：SP3928-MDIGITS-Counting-Digits"><a href="#T51：SP3928-MDIGITS-Counting-Digits" class="headerlink" title="T51：SP3928 MDIGITS - Counting Digits"></a>T51：<a href="https://www.luogu.com.cn/problem/SP3928">SP3928 MDIGITS - Counting Digits</a></h4><h4 id="T52：UVA1640-统计问题-The-Counting-Problem"><a href="#T52：UVA1640-统计问题-The-Counting-Problem" class="headerlink" title="T52：UVA1640 统计问题 The Counting Problem"></a>T52：<a href="https://www.luogu.com.cn/problem/UVA1640">UVA1640 统计问题 The Counting Problem</a></h4><h4 id="T53：P7244-章节划分"><a href="#T53：P7244-章节划分" class="headerlink" title="T53：P7244 章节划分"></a>T53：<a href="https://www.luogu.com.cn/problem/P7244">P7244 章节划分</a></h4><h4 id="T54：P5424-USACO19OPEN-Snakes-G"><a href="#T54：P5424-USACO19OPEN-Snakes-G" class="headerlink" title="T54：P5424 [USACO19OPEN]Snakes G"></a>T54：<a href="https://www.luogu.com.cn/problem/P5424">P5424 [USACO19OPEN]Snakes G</a></h4><h4 id="T55：P6026-餐馆"><a href="#T55：P6026-餐馆" class="headerlink" title="T55：P6026 餐馆"></a>T55：<a href="https://www.luogu.com.cn/problem/P6026">P6026 餐馆</a></h4><h4 id="T56：P2363-马农"><a href="#T56：P2363-马农" class="headerlink" title="T56：P2363 马农"></a>T56：<a href="https://www.luogu.com.cn/problem/P2363">P2363 马农</a></h4><h4 id="T57：P4539-SCOI2006-zh-tree"><a href="#T57：P4539-SCOI2006-zh-tree" class="headerlink" title="T57：P4539 [SCOI2006]zh_tree"></a>T57：<a href="https://www.luogu.com.cn/problem/P4539">P4539 [SCOI2006]zh_tree</a></h4><h4 id="T58：P1709-USACO5-5-隐藏口令Hidden-Password"><a href="#T58：P1709-USACO5-5-隐藏口令Hidden-Password" class="headerlink" title="T58：P1709 [USACO5.5]隐藏口令Hidden Password"></a>T58：<a href="https://www.luogu.com.cn/problem/P1709">P1709 [USACO5.5]隐藏口令Hidden Password</a></h4><h4 id="T59：P5088-矩形"><a href="#T59：P5088-矩形" class="headerlink" title="T59：P5088 矩形"></a>T59：<a href="https://www.luogu.com.cn/problem/P5088">P5088 矩形</a></h4><h4 id="T60：P2303-SDOI2012-Longge-的问题"><a href="#T60：P2303-SDOI2012-Longge-的问题" class="headerlink" title="T60：P2303 [SDOI2012] Longge 的问题"></a>T60：<a href="https://www.luogu.com.cn/problem/P2303">P2303 [SDOI2012] Longge 的问题</a></h4><h4 id="T61：P5557-旅行"><a href="#T61：P5557-旅行" class="headerlink" title="T61：P5557 旅行"></a>T61：<a href="https://www.luogu.com.cn/problem/P5557">P5557 旅行</a></h4><h4 id="T62：CF337C-Quiz"><a href="#T62：CF337C-Quiz" class="headerlink" title="T62：CF337C Quiz"></a>T62：<a href="https://www.luogu.com.cn/problem/CF337C">CF337C Quiz</a></h4><h4 id="T63：P2051-AHOI2009-中国象棋"><a href="#T63：P2051-AHOI2009-中国象棋" class="headerlink" title="T63：P2051 [AHOI2009]中国象棋"></a>T63：<a href="https://www.luogu.com.cn/problem/P2051">P2051 [AHOI2009]中国象棋</a></h4><h4 id="T64：P4918-信仰收集"><a href="#T64：P4918-信仰收集" class="headerlink" title="T64：P4918 信仰收集"></a>T64：<a href="https://www.luogu.com.cn/problem/P4918">P4918 信仰收集</a></h4><h4 id="T65：CF1394B-Boboniu-Walks-on-Graph"><a href="#T65：CF1394B-Boboniu-Walks-on-Graph" class="headerlink" title="T65：CF1394B Boboniu Walks on Graph"></a>T65：<a href="https://www.luogu.com.cn/problem/CF1394B">CF1394B Boboniu Walks on Graph</a></h4><h4 id="T66：CF1175B-Catch-Overflow"><a href="#T66：CF1175B-Catch-Overflow" class="headerlink" title="T66：CF1175B Catch Overflow!"></a>T66：<a href="https://www.luogu.com.cn/problem/CF1175B">CF1175B Catch Overflow!</a></h4><h4 id="T67：CF1526E-Oolimry-and-Suffix-Array"><a href="#T67：CF1526E-Oolimry-and-Suffix-Array" class="headerlink" title="T67：CF1526E Oolimry and Suffix Array"></a>T67：<a href="https://www.luogu.com.cn/problem/CF1526E">CF1526E Oolimry and Suffix Array</a></h4><h4 id="T68：CF1335F-Robots-on-a-Grid"><a href="#T68：CF1335F-Robots-on-a-Grid" class="headerlink" title="T68：CF1335F Robots on a Grid"></a>T68：<a href="https://www.luogu.com.cn/problem/CF1335F">CF1335F Robots on a Grid</a></h4><h4 id="T69：CF1228E-Another-Filling-the-Grid"><a href="#T69：CF1228E-Another-Filling-the-Grid" class="headerlink" title="T69：CF1228E Another Filling the Grid"></a>T69：<a href="https://www.luogu.com.cn/problem/CF1228E">CF1228E Another Filling the Grid</a></h4><h4 id="T70：CF884D-Boxes-And-Balls"><a href="#T70：CF884D-Boxes-And-Balls" class="headerlink" title="T70：CF884D Boxes And Balls"></a>T70：<a href="https://www.luogu.com.cn/problem/CF884D">CF884D Boxes And Balls</a></h4><h4 id="T71：P1654-OSU"><a href="#T71：P1654-OSU" class="headerlink" title="T71：P1654 OSU!"></a>T71：<a href="https://www.luogu.com.cn/problem/P1654">P1654 OSU!</a></h4><h4 id="T72：P1365-WJMZBMR打osu-Easy"><a href="#T72：P1365-WJMZBMR打osu-Easy" class="headerlink" title="T72：P1365 WJMZBMR打osu! / Easy"></a>T72：<a href="https://www.luogu.com.cn/problem/P1365">P1365 WJMZBMR打osu! / Easy</a></h4><h4 id="T73：CF235B-Let’s-Play-Osu"><a href="#T73：CF235B-Let’s-Play-Osu" class="headerlink" title="T73：CF235B Let’s Play Osu!"></a>T73：<a href="https://www.luogu.com.cn/problem/CF235B">CF235B Let’s Play Osu!</a></h4><h4 id="T74：P1659-国家集训队-拉拉队排练"><a href="#T74：P1659-国家集训队-拉拉队排练" class="headerlink" title="T74：P1659 [国家集训队]拉拉队排练"></a>T74：<a href="https://www.luogu.com.cn/problem/P1659">P1659 [国家集训队]拉拉队排练</a></h4><h4 id="T75：P2654-原核生物培养"><a href="#T75：P2654-原核生物培养" class="headerlink" title="T75：P2654 原核生物培养"></a>T75：<a href="https://www.luogu.com.cn/problem/P2654">P2654 原核生物培养</a></h4><h4 id="T76：P4881-hby与tkw的基情"><a href="#T76：P4881-hby与tkw的基情" class="headerlink" title="T76：P4881 hby与tkw的基情"></a>T76：<a href="https://www.luogu.com.cn/problem/P4881">P4881 hby与tkw的基情</a></h4><h4 id="T77：CF1131C-Birthday"><a href="#T77：CF1131C-Birthday" class="headerlink" title="T77：CF1131C Birthday"></a>T77：<a href="https://www.luogu.com.cn/problem/CF1131C">CF1131C Birthday</a></h4><h4 id="T78：CF1416B-Make-Them-Equal"><a href="#T78：CF1416B-Make-Them-Equal" class="headerlink" title="T78：CF1416B Make Them Equal"></a>T78：<a href="https://www.luogu.com.cn/problem/CF1416B">CF1416B Make Them Equal</a></h4><h4 id="T79：P1850-NOIP2016-提高组-换教室"><a href="#T79：P1850-NOIP2016-提高组-换教室" class="headerlink" title="T79：P1850 [NOIP2016 提高组] 换教室"></a>T79：<a href="https://www.luogu.com.cn/problem/P1850">P1850 [NOIP2016 提高组] 换教室</a></h4><h4 id="T80：P3802-小魔女帕琪"><a href="#T80：P3802-小魔女帕琪" class="headerlink" title="T80：P3802 小魔女帕琪"></a>T80：<a href="https://www.luogu.com.cn/problem/P3802">P3802 小魔女帕琪</a></h4><h4 id="T81：P3114-USACO15JAN-Stampede-S"><a href="#T81：P3114-USACO15JAN-Stampede-S" class="headerlink" title="T81：P3114 [USACO15JAN]Stampede S"></a>T81：<a href="https://www.luogu.com.cn/problem/P3114">P3114 [USACO15JAN]Stampede S</a></h4><h4 id="T82：P5160-WD与循环"><a href="#T82：P5160-WD与循环" class="headerlink" title="T82：P5160 WD与循环"></a>T82：<a href="https://www.luogu.com.cn/problem/P5160">P5160 WD与循环</a></h4><h4 id="T83：P5124-USACO18DEC-Teamwork-G"><a href="#T83：P5124-USACO18DEC-Teamwork-G" class="headerlink" title="T83：P5124 [USACO18DEC]Teamwork G"></a>T83：<a href="https://www.luogu.com.cn/problem/P5124">P5124 [USACO18DEC]Teamwork G</a></h4><h4 id="T84：P4753-River-Jumping"><a href="#T84：P4753-River-Jumping" class="headerlink" title="T84：P4753 River Jumping"></a>T84：<a href="https://www.luogu.com.cn/problem/P4753">P4753 River Jumping</a></h4><h4 id="T85：CF77B-Falling-Anvils"><a href="#T85：CF77B-Falling-Anvils" class="headerlink" title="T85：CF77B Falling Anvils"></a>T85：<a href="https://www.luogu.com.cn/problem/CF77B">CF77B Falling Anvils</a></h4><h4 id="T86：P1645-序列"><a href="#T86：P1645-序列" class="headerlink" title="T86：P1645 序列"></a>T86：<a href="https://www.luogu.com.cn/problem/P1645">P1645 序列</a></h4><h4 id="T87：P3868-TJOI2009-猜数字"><a href="#T87：P3868-TJOI2009-猜数字" class="headerlink" title="T87：P3868 [TJOI2009] 猜数字"></a>T87：<a href="https://www.luogu.com.cn/problem/P3868">P3868 [TJOI2009] 猜数字</a></h4><h4 id="T88：P5144-蜈蚣"><a href="#T88：P5144-蜈蚣" class="headerlink" title="T88：P5144 蜈蚣"></a>T88：<a href="https://www.luogu.com.cn/problem/P5144">P5144 蜈蚣</a></h4><h4 id="T89：CF306C-White-Black-and-White-Again"><a href="#T89：CF306C-White-Black-and-White-Again" class="headerlink" title="T89：CF306C White, Black and White Again"></a>T89：<a href="https://www.luogu.com.cn/problem/CF306C">CF306C White, Black and White Again</a></h4><h4 id="T90：CF919E-Congruence-Equation"><a href="#T90：CF919E-Congruence-Equation" class="headerlink" title="T90：CF919E Congruence Equation"></a>T90：<a href="https://www.luogu.com.cn/problem/CF919E">CF919E Congruence Equation</a></h4><h4 id="T91：CF598E-Chocolate-Bar"><a href="#T91：CF598E-Chocolate-Bar" class="headerlink" title="T91：CF598E Chocolate Bar"></a>T91：<a href="https://www.luogu.com.cn/problem/CF598E">CF598E Chocolate Bar</a></h4><h4 id="T92：P3932-浮游大陆的68号岛"><a href="#T92：P3932-浮游大陆的68号岛" class="headerlink" title="T92：P3932 浮游大陆的68号岛"></a>T92：<a href="https://www.luogu.com.cn/problem/P3932">P3932 浮游大陆的68号岛</a></h4><h4 id="T93：P6655-YsOI2020-制高"><a href="#T93：P6655-YsOI2020-制高" class="headerlink" title="T93：P6655 [YsOI2020]制高"></a>T93：<a href="https://www.luogu.com.cn/problem/P6655">P6655 [YsOI2020]制高</a></h4><h4 id="T94：CF822D-My-pretty-girl-Noora"><a href="#T94：CF822D-My-pretty-girl-Noora" class="headerlink" title="T94：CF822D My pretty girl Noora"></a>T94：<a href="https://www.luogu.com.cn/problem/CF822D">CF822D My pretty girl Noora</a></h4><h4 id="T95：CF1143B-Nirvana"><a href="#T95：CF1143B-Nirvana" class="headerlink" title="T95：CF1143B Nirvana"></a>T95：<a href="https://www.luogu.com.cn/problem/CF1143B">CF1143B Nirvana</a></h4><p>题目概述先鸽着 qwq</p>]]></content>
      
      
      
        <tags>
            
            <tag> 做题记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP-S2021 爆炸记</title>
      <link href="/2021/10/23/CSP-S2021-%E7%88%86%E7%82%B8%E8%AE%B0/"/>
      <url>/2021/10/23/CSP-S2021-%E7%88%86%E7%82%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>被大家吊起来锤。</p><span id="more"></span><h2 id="考前"><a href="#考前" class="headerlink" title="考前"></a>考前</h2><p><del>据老师说状态不错</del>，看了一下 CSP-S 2020 的题目，发现前面两个都是水（du）题（liu），还满不在意的。</p><p>但是一考试就显露原型了，都是只有 100 出头，被机房的 dalao 给吊打了，不过有次碰到了原题，倒是挺高兴的，也就那一次考得好罢了<del>（要是 CSP-S 考到原题就好了</del></p><p>成绩一直有些起伏，不过看到省选是看 NOIp 的成绩，心态要稳一些。</p><p>本校作为考点，还有许多特别强的学校学生要来，既有些高兴，又有些紧张。</p><p>一直以为考前的训练都是难到爆炸，肯定 CSP-S 要简单的多吧。</p><p>考前早上使劲复习模板，结果调了半早上的 Treap 还没调出来，感觉太菜了……</p><h2 id="考中"><a href="#考中" class="headerlink" title="考中"></a>考中</h2><p>本校考试，很早就来到了考场，本身还要开虚拟机的也忘记了，本身想要写个快读，结果被老师说不允许动键盘，也就罢休了。</p><p>2：20 密码下来，一看：<code>airport</code> 就是一个水题吧，<code>bracket</code> 感觉就是一个区间 DP，还没想。第三题似乎就是构造，因为 $\sum n\leq 5\times10^5$，似乎就是一个 $O(n)$，不能再多了。<code>traffic</code> 一看就是一个 Dinic，但一看，<del>我去，</del>$n,m\leq500$，怎么跑得出来？</p><p>感觉时间十分充足，慢慢悠悠地写了一个快读，在开始写第一题。</p><p>一看，是一个三分，感觉一个栈，但是似乎没法 $O(n)$ 求可以停栈桥的飞机。过了半个小时发现可以提前预处理，但是没想到可以线段树优化选择最小的，直接一个暴力 $O(n^2)$ 求后面最小的，（但是许多优化，手造随机数据在 <code>0.3s</code> 左右）</p><p>打完快 3：30 了，赶紧开第二题。按照它给的规则使劲码，结果 3:50 打完的时候，死活过不了第二个样例。经过了一个余小时的手调数据（已经不想写发生了什么了 qwq），终于发现了 <code>ASB</code> 的情况会重复，然后改了出来，$O(n^4)$ 的算法，65 pts 应该没问题了，但 $n=500$ 要刚好 <code>5s</code>，但希望数据水一点吧。</p><p>开第三题，已经 5:30 了。本身有点慌，但是想了几分钟就看出正解：一个简单的构造，将 <code>R</code> 的翻转过来，相当于是两个数列合并为一个回文数列，可以线性。考场上极慌，写到 6:10 分，还是没过大样例。监考老师使劲催：</p><blockquote><p>离考试结束还有 30 分钟。…离考试结束还有 20 分钟，同学们检查一下自己的头文件有没有写齐，有没有保存在 E:\CSP\ 目录下，Dev 会预加载头文件……</p></blockquote><p>虽然确实是善意的提醒，但我当时实在是有些烦躁，虽然坚持到了最后，但 6:27 时仍然败北，只好放弃。估计不超过 5 pts，还不如写暴力呢。</p><blockquote><p>考试结束了，同学们立即站立，不允许再动键盘，否则按违规处理。安静出场。</p></blockquote><p>唉！看着我同考室的同学，又想起 Dinic 连 60 pts 都没有拿到，叹了一口气，走出考场，似乎连饭都不想吃了。</p><h2 id="考后"><a href="#考后" class="headerlink" title="考后"></a>考后</h2><p>走出考场，发现大家都是一片哀嚎（至少我们学校是），心中稍微平衡了一点（话说我这是什么心态啊），仔细算了一下分，应该是 $(40\sim100)+(65\sim80)+(0\sim5)+0=105\sim185$，准确估分应该为 $140\sim160$ 之间。</p><p>和一个 dalao 交流了一下，猛地发现三分可能回锅掉！想起书上的一句话：</p><blockquote><p>特别需要注意的是，三分法并不能由于非严格单峰的函数（即有平台）。</p></blockquote><p>发现就连暴力枚举国内栈桥的个数，也不会增加复杂度。唉，实在是太菜了……</p><p>又讨论了第四题，同机房的竟说 Dinic 可以水过，Linux 加 O2 指令居然只需要 <code>2.7s</code>，实在是令我震惊。但是我也确实没有想好 Dinic 的建图方式，所以只好挂掉了。</p><p>赛后一直盯着 Luogu，看着 pj T4 才绿，感觉 tg 实在是太卷了。</p><p>第二天（还是第三天）发下来代码，跑了一下，发现第一题确实锅掉了，Luogu 只有 60pts，第三题也确实一分没有，总分 125 pts，大概全省 rk 80 的样子。</p><p>唉！不想再多说了。NOIP 加油！</p><p><strong>Update on 2021-11-01：</strong> 昨天（亦或是前天）知道公布了成绩，过去瞅了一眼，最后得到：$85+65+16+0=166$，竟然高出了预计。</p><p>可能是因为 <code>airport</code> 水了不少分吧……</p><p>同机房的 <code>dalao</code> 竟然 T4 Dinic 只有 60pts，叹息了一会，也就似乎什么都没有发生了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，这次考试还是策略没有调整好，因为计算了一下时间，如果我先开 T3，已经早有 200 pts+ 了。还有原因是代码水平不够，导致即使想出来了，也打不完或打不来。</p><p>按部就班吧，向 NOIP 进发！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
